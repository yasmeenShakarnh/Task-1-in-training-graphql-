class Input$AccountInput {
  factory Input$AccountInput({
    String? firstName,
    String? lastName,
    Enum$LanguageCodeEnum? languageCode,
    Input$AddressInput? defaultBillingAddress,
    Input$AddressInput? defaultShippingAddress,
    List<Input$MetadataInput>? metadata,
  }) =>
      Input$AccountInput._({
        if (firstName != null) r'firstName': firstName,
        if (lastName != null) r'lastName': lastName,
        if (languageCode != null) r'languageCode': languageCode,
        if (defaultBillingAddress != null)
          r'defaultBillingAddress': defaultBillingAddress,
        if (defaultShippingAddress != null)
          r'defaultShippingAddress': defaultShippingAddress,
        if (metadata != null) r'metadata': metadata,
      });

  Input$AccountInput._(this._$data);

  factory Input$AccountInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('firstName')) {
      final l$firstName = data['firstName'];
      result$data['firstName'] = (l$firstName as String?);
    }
    if (data.containsKey('lastName')) {
      final l$lastName = data['lastName'];
      result$data['lastName'] = (l$lastName as String?);
    }
    if (data.containsKey('languageCode')) {
      final l$languageCode = data['languageCode'];
      result$data['languageCode'] = l$languageCode == null
          ? null
          : fromJson$Enum$LanguageCodeEnum((l$languageCode as String));
    }
    if (data.containsKey('defaultBillingAddress')) {
      final l$defaultBillingAddress = data['defaultBillingAddress'];
      result$data['defaultBillingAddress'] = l$defaultBillingAddress == null
          ? null
          : Input$AddressInput.fromJson(
              (l$defaultBillingAddress as Map<String, dynamic>));
    }
    if (data.containsKey('defaultShippingAddress')) {
      final l$defaultShippingAddress = data['defaultShippingAddress'];
      result$data['defaultShippingAddress'] = l$defaultShippingAddress == null
          ? null
          : Input$AddressInput.fromJson(
              (l$defaultShippingAddress as Map<String, dynamic>));
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$AccountInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get firstName => (_$data['firstName'] as String?);

  String? get lastName => (_$data['lastName'] as String?);

  Enum$LanguageCodeEnum? get languageCode =>
      (_$data['languageCode'] as Enum$LanguageCodeEnum?);

  Input$AddressInput? get defaultBillingAddress =>
      (_$data['defaultBillingAddress'] as Input$AddressInput?);

  Input$AddressInput? get defaultShippingAddress =>
      (_$data['defaultShippingAddress'] as Input$AddressInput?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('firstName')) {
      final l$firstName = firstName;
      result$data['firstName'] = l$firstName;
    }
    if (_$data.containsKey('lastName')) {
      final l$lastName = lastName;
      result$data['lastName'] = l$lastName;
    }
    if (_$data.containsKey('languageCode')) {
      final l$languageCode = languageCode;
      result$data['languageCode'] = l$languageCode == null
          ? null
          : toJson$Enum$LanguageCodeEnum(l$languageCode);
    }
    if (_$data.containsKey('defaultBillingAddress')) {
      final l$defaultBillingAddress = defaultBillingAddress;
      result$data['defaultBillingAddress'] = l$defaultBillingAddress?.toJson();
    }
    if (_$data.containsKey('defaultShippingAddress')) {
      final l$defaultShippingAddress = defaultShippingAddress;
      result$data['defaultShippingAddress'] =
          l$defaultShippingAddress?.toJson();
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$AccountInput<Input$AccountInput> get copyWith =>
      CopyWith$Input$AccountInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AccountInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$firstName = firstName;
    final lOther$firstName = other.firstName;
    if (_$data.containsKey('firstName') !=
        other._$data.containsKey('firstName')) {
      return false;
    }
    if (l$firstName != lOther$firstName) {
      return false;
    }
    final l$lastName = lastName;
    final lOther$lastName = other.lastName;
    if (_$data.containsKey('lastName') !=
        other._$data.containsKey('lastName')) {
      return false;
    }
    if (l$lastName != lOther$lastName) {
      return false;
    }
    final l$languageCode = languageCode;
    final lOther$languageCode = other.languageCode;
    if (_$data.containsKey('languageCode') !=
        other._$data.containsKey('languageCode')) {
      return false;
    }
    if (l$languageCode != lOther$languageCode) {
      return false;
    }
    final l$defaultBillingAddress = defaultBillingAddress;
    final lOther$defaultBillingAddress = other.defaultBillingAddress;
    if (_$data.containsKey('defaultBillingAddress') !=
        other._$data.containsKey('defaultBillingAddress')) {
      return false;
    }
    if (l$defaultBillingAddress != lOther$defaultBillingAddress) {
      return false;
    }
    final l$defaultShippingAddress = defaultShippingAddress;
    final lOther$defaultShippingAddress = other.defaultShippingAddress;
    if (_$data.containsKey('defaultShippingAddress') !=
        other._$data.containsKey('defaultShippingAddress')) {
      return false;
    }
    if (l$defaultShippingAddress != lOther$defaultShippingAddress) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$firstName = firstName;
    final l$lastName = lastName;
    final l$languageCode = languageCode;
    final l$defaultBillingAddress = defaultBillingAddress;
    final l$defaultShippingAddress = defaultShippingAddress;
    final l$metadata = metadata;
    return Object.hashAll([
      _$data.containsKey('firstName') ? l$firstName : const {},
      _$data.containsKey('lastName') ? l$lastName : const {},
      _$data.containsKey('languageCode') ? l$languageCode : const {},
      _$data.containsKey('defaultBillingAddress')
          ? l$defaultBillingAddress
          : const {},
      _$data.containsKey('defaultShippingAddress')
          ? l$defaultShippingAddress
          : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AccountInput<TRes> {
  factory CopyWith$Input$AccountInput(
    Input$AccountInput instance,
    TRes Function(Input$AccountInput) then,
  ) = _CopyWithImpl$Input$AccountInput;

  factory CopyWith$Input$AccountInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AccountInput;

  TRes call({
    String? firstName,
    String? lastName,
    Enum$LanguageCodeEnum? languageCode,
    Input$AddressInput? defaultBillingAddress,
    Input$AddressInput? defaultShippingAddress,
    List<Input$MetadataInput>? metadata,
  });
  CopyWith$Input$AddressInput<TRes> get defaultBillingAddress;
  CopyWith$Input$AddressInput<TRes> get defaultShippingAddress;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$AccountInput<TRes>
    implements CopyWith$Input$AccountInput<TRes> {
  _CopyWithImpl$Input$AccountInput(
    this._instance,
    this._then,
  );

  final Input$AccountInput _instance;

  final TRes Function(Input$AccountInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? firstName = _undefined,
    Object? lastName = _undefined,
    Object? languageCode = _undefined,
    Object? defaultBillingAddress = _undefined,
    Object? defaultShippingAddress = _undefined,
    Object? metadata = _undefined,
  }) =>
      _then(Input$AccountInput._({
        ..._instance._$data,
        if (firstName != _undefined) 'firstName': (firstName as String?),
        if (lastName != _undefined) 'lastName': (lastName as String?),
        if (languageCode != _undefined)
          'languageCode': (languageCode as Enum$LanguageCodeEnum?),
        if (defaultBillingAddress != _undefined)
          'defaultBillingAddress':
              (defaultBillingAddress as Input$AddressInput?),
        if (defaultShippingAddress != _undefined)
          'defaultShippingAddress':
              (defaultShippingAddress as Input$AddressInput?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
      }));

  CopyWith$Input$AddressInput<TRes> get defaultBillingAddress {
    final local$defaultBillingAddress = _instance.defaultBillingAddress;
    return local$defaultBillingAddress == null
        ? CopyWith$Input$AddressInput.stub(_then(_instance))
        : CopyWith$Input$AddressInput(
            local$defaultBillingAddress, (e) => call(defaultBillingAddress: e));
  }

  CopyWith$Input$AddressInput<TRes> get defaultShippingAddress {
    final local$defaultShippingAddress = _instance.defaultShippingAddress;
    return local$defaultShippingAddress == null
        ? CopyWith$Input$AddressInput.stub(_then(_instance))
        : CopyWith$Input$AddressInput(local$defaultShippingAddress,
            (e) => call(defaultShippingAddress: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$AccountInput<TRes>
    implements CopyWith$Input$AccountInput<TRes> {
  _CopyWithStubImpl$Input$AccountInput(this._res);

  TRes _res;

  call({
    String? firstName,
    String? lastName,
    Enum$LanguageCodeEnum? languageCode,
    Input$AddressInput? defaultBillingAddress,
    Input$AddressInput? defaultShippingAddress,
    List<Input$MetadataInput>? metadata,
  }) =>
      _res;

  CopyWith$Input$AddressInput<TRes> get defaultBillingAddress =>
      CopyWith$Input$AddressInput.stub(_res);

  CopyWith$Input$AddressInput<TRes> get defaultShippingAddress =>
      CopyWith$Input$AddressInput.stub(_res);

  metadata(_fn) => _res;
}

class Input$AccountRegisterInput {
  factory Input$AccountRegisterInput({
    String? firstName,
    String? lastName,
    Enum$LanguageCodeEnum? languageCode,
    required String email,
    required String password,
    String? redirectUrl,
    List<Input$MetadataInput>? metadata,
    String? channel,
  }) =>
      Input$AccountRegisterInput._({
        if (firstName != null) r'firstName': firstName,
        if (lastName != null) r'lastName': lastName,
        if (languageCode != null) r'languageCode': languageCode,
        r'email': email,
        r'password': password,
        if (redirectUrl != null) r'redirectUrl': redirectUrl,
        if (metadata != null) r'metadata': metadata,
        if (channel != null) r'channel': channel,
      });

  Input$AccountRegisterInput._(this._$data);

  factory Input$AccountRegisterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('firstName')) {
      final l$firstName = data['firstName'];
      result$data['firstName'] = (l$firstName as String?);
    }
    if (data.containsKey('lastName')) {
      final l$lastName = data['lastName'];
      result$data['lastName'] = (l$lastName as String?);
    }
    if (data.containsKey('languageCode')) {
      final l$languageCode = data['languageCode'];
      result$data['languageCode'] = l$languageCode == null
          ? null
          : fromJson$Enum$LanguageCodeEnum((l$languageCode as String));
    }
    final l$email = data['email'];
    result$data['email'] = (l$email as String);
    final l$password = data['password'];
    result$data['password'] = (l$password as String);
    if (data.containsKey('redirectUrl')) {
      final l$redirectUrl = data['redirectUrl'];
      result$data['redirectUrl'] = (l$redirectUrl as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('channel')) {
      final l$channel = data['channel'];
      result$data['channel'] = (l$channel as String?);
    }
    return Input$AccountRegisterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get firstName => (_$data['firstName'] as String?);

  String? get lastName => (_$data['lastName'] as String?);

  Enum$LanguageCodeEnum? get languageCode =>
      (_$data['languageCode'] as Enum$LanguageCodeEnum?);

  String get email => (_$data['email'] as String);

  String get password => (_$data['password'] as String);

  String? get redirectUrl => (_$data['redirectUrl'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  String? get channel => (_$data['channel'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('firstName')) {
      final l$firstName = firstName;
      result$data['firstName'] = l$firstName;
    }
    if (_$data.containsKey('lastName')) {
      final l$lastName = lastName;
      result$data['lastName'] = l$lastName;
    }
    if (_$data.containsKey('languageCode')) {
      final l$languageCode = languageCode;
      result$data['languageCode'] = l$languageCode == null
          ? null
          : toJson$Enum$LanguageCodeEnum(l$languageCode);
    }
    final l$email = email;
    result$data['email'] = l$email;
    final l$password = password;
    result$data['password'] = l$password;
    if (_$data.containsKey('redirectUrl')) {
      final l$redirectUrl = redirectUrl;
      result$data['redirectUrl'] = l$redirectUrl;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('channel')) {
      final l$channel = channel;
      result$data['channel'] = l$channel;
    }
    return result$data;
  }

  CopyWith$Input$AccountRegisterInput<Input$AccountRegisterInput>
      get copyWith => CopyWith$Input$AccountRegisterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AccountRegisterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$firstName = firstName;
    final lOther$firstName = other.firstName;
    if (_$data.containsKey('firstName') !=
        other._$data.containsKey('firstName')) {
      return false;
    }
    if (l$firstName != lOther$firstName) {
      return false;
    }
    final l$lastName = lastName;
    final lOther$lastName = other.lastName;
    if (_$data.containsKey('lastName') !=
        other._$data.containsKey('lastName')) {
      return false;
    }
    if (l$lastName != lOther$lastName) {
      return false;
    }
    final l$languageCode = languageCode;
    final lOther$languageCode = other.languageCode;
    if (_$data.containsKey('languageCode') !=
        other._$data.containsKey('languageCode')) {
      return false;
    }
    if (l$languageCode != lOther$languageCode) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (l$password != lOther$password) {
      return false;
    }
    final l$redirectUrl = redirectUrl;
    final lOther$redirectUrl = other.redirectUrl;
    if (_$data.containsKey('redirectUrl') !=
        other._$data.containsKey('redirectUrl')) {
      return false;
    }
    if (l$redirectUrl != lOther$redirectUrl) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$channel = channel;
    final lOther$channel = other.channel;
    if (_$data.containsKey('channel') != other._$data.containsKey('channel')) {
      return false;
    }
    if (l$channel != lOther$channel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$firstName = firstName;
    final l$lastName = lastName;
    final l$languageCode = languageCode;
    final l$email = email;
    final l$password = password;
    final l$redirectUrl = redirectUrl;
    final l$metadata = metadata;
    final l$channel = channel;
    return Object.hashAll([
      _$data.containsKey('firstName') ? l$firstName : const {},
      _$data.containsKey('lastName') ? l$lastName : const {},
      _$data.containsKey('languageCode') ? l$languageCode : const {},
      l$email,
      l$password,
      _$data.containsKey('redirectUrl') ? l$redirectUrl : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('channel') ? l$channel : const {},
    ]);
  }
}

abstract class CopyWith$Input$AccountRegisterInput<TRes> {
  factory CopyWith$Input$AccountRegisterInput(
    Input$AccountRegisterInput instance,
    TRes Function(Input$AccountRegisterInput) then,
  ) = _CopyWithImpl$Input$AccountRegisterInput;

  factory CopyWith$Input$AccountRegisterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AccountRegisterInput;

  TRes call({
    String? firstName,
    String? lastName,
    Enum$LanguageCodeEnum? languageCode,
    String? email,
    String? password,
    String? redirectUrl,
    List<Input$MetadataInput>? metadata,
    String? channel,
  });
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$AccountRegisterInput<TRes>
    implements CopyWith$Input$AccountRegisterInput<TRes> {
  _CopyWithImpl$Input$AccountRegisterInput(
    this._instance,
    this._then,
  );

  final Input$AccountRegisterInput _instance;

  final TRes Function(Input$AccountRegisterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? firstName = _undefined,
    Object? lastName = _undefined,
    Object? languageCode = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? redirectUrl = _undefined,
    Object? metadata = _undefined,
    Object? channel = _undefined,
  }) =>
      _then(Input$AccountRegisterInput._({
        ..._instance._$data,
        if (firstName != _undefined) 'firstName': (firstName as String?),
        if (lastName != _undefined) 'lastName': (lastName as String?),
        if (languageCode != _undefined)
          'languageCode': (languageCode as Enum$LanguageCodeEnum?),
        if (email != _undefined && email != null) 'email': (email as String),
        if (password != _undefined && password != null)
          'password': (password as String),
        if (redirectUrl != _undefined) 'redirectUrl': (redirectUrl as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (channel != _undefined) 'channel': (channel as String?),
      }));

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$AccountRegisterInput<TRes>
    implements CopyWith$Input$AccountRegisterInput<TRes> {
  _CopyWithStubImpl$Input$AccountRegisterInput(this._res);

  TRes _res;

  call({
    String? firstName,
    String? lastName,
    Enum$LanguageCodeEnum? languageCode,
    String? email,
    String? password,
    String? redirectUrl,
    List<Input$MetadataInput>? metadata,
    String? channel,
  }) =>
      _res;

  metadata(_fn) => _res;
}

class Input$AddressInput {
  factory Input$AddressInput({
    String? firstName,
    String? lastName,
    String? companyName,
    String? streetAddress1,
    String? streetAddress2,
    String? city,
    String? cityArea,
    String? postalCode,
    Enum$CountryCode? country,
    String? countryArea,
    String? phone,
    List<Input$MetadataInput>? metadata,
    bool? skipValidation,
  }) =>
      Input$AddressInput._({
        if (firstName != null) r'firstName': firstName,
        if (lastName != null) r'lastName': lastName,
        if (companyName != null) r'companyName': companyName,
        if (streetAddress1 != null) r'streetAddress1': streetAddress1,
        if (streetAddress2 != null) r'streetAddress2': streetAddress2,
        if (city != null) r'city': city,
        if (cityArea != null) r'cityArea': cityArea,
        if (postalCode != null) r'postalCode': postalCode,
        if (country != null) r'country': country,
        if (countryArea != null) r'countryArea': countryArea,
        if (phone != null) r'phone': phone,
        if (metadata != null) r'metadata': metadata,
        if (skipValidation != null) r'skipValidation': skipValidation,
      });

  Input$AddressInput._(this._$data);

  factory Input$AddressInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('firstName')) {
      final l$firstName = data['firstName'];
      result$data['firstName'] = (l$firstName as String?);
    }
    if (data.containsKey('lastName')) {
      final l$lastName = data['lastName'];
      result$data['lastName'] = (l$lastName as String?);
    }
    if (data.containsKey('companyName')) {
      final l$companyName = data['companyName'];
      result$data['companyName'] = (l$companyName as String?);
    }
    if (data.containsKey('streetAddress1')) {
      final l$streetAddress1 = data['streetAddress1'];
      result$data['streetAddress1'] = (l$streetAddress1 as String?);
    }
    if (data.containsKey('streetAddress2')) {
      final l$streetAddress2 = data['streetAddress2'];
      result$data['streetAddress2'] = (l$streetAddress2 as String?);
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = (l$city as String?);
    }
    if (data.containsKey('cityArea')) {
      final l$cityArea = data['cityArea'];
      result$data['cityArea'] = (l$cityArea as String?);
    }
    if (data.containsKey('postalCode')) {
      final l$postalCode = data['postalCode'];
      result$data['postalCode'] = (l$postalCode as String?);
    }
    if (data.containsKey('country')) {
      final l$country = data['country'];
      result$data['country'] = l$country == null
          ? null
          : fromJson$Enum$CountryCode((l$country as String));
    }
    if (data.containsKey('countryArea')) {
      final l$countryArea = data['countryArea'];
      result$data['countryArea'] = (l$countryArea as String?);
    }
    if (data.containsKey('phone')) {
      final l$phone = data['phone'];
      result$data['phone'] = (l$phone as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('skipValidation')) {
      final l$skipValidation = data['skipValidation'];
      result$data['skipValidation'] = (l$skipValidation as bool?);
    }
    return Input$AddressInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get firstName => (_$data['firstName'] as String?);

  String? get lastName => (_$data['lastName'] as String?);

  String? get companyName => (_$data['companyName'] as String?);

  String? get streetAddress1 => (_$data['streetAddress1'] as String?);

  String? get streetAddress2 => (_$data['streetAddress2'] as String?);

  String? get city => (_$data['city'] as String?);

  String? get cityArea => (_$data['cityArea'] as String?);

  String? get postalCode => (_$data['postalCode'] as String?);

  Enum$CountryCode? get country => (_$data['country'] as Enum$CountryCode?);

  String? get countryArea => (_$data['countryArea'] as String?);

  String? get phone => (_$data['phone'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  bool? get skipValidation => (_$data['skipValidation'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('firstName')) {
      final l$firstName = firstName;
      result$data['firstName'] = l$firstName;
    }
    if (_$data.containsKey('lastName')) {
      final l$lastName = lastName;
      result$data['lastName'] = l$lastName;
    }
    if (_$data.containsKey('companyName')) {
      final l$companyName = companyName;
      result$data['companyName'] = l$companyName;
    }
    if (_$data.containsKey('streetAddress1')) {
      final l$streetAddress1 = streetAddress1;
      result$data['streetAddress1'] = l$streetAddress1;
    }
    if (_$data.containsKey('streetAddress2')) {
      final l$streetAddress2 = streetAddress2;
      result$data['streetAddress2'] = l$streetAddress2;
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city;
    }
    if (_$data.containsKey('cityArea')) {
      final l$cityArea = cityArea;
      result$data['cityArea'] = l$cityArea;
    }
    if (_$data.containsKey('postalCode')) {
      final l$postalCode = postalCode;
      result$data['postalCode'] = l$postalCode;
    }
    if (_$data.containsKey('country')) {
      final l$country = country;
      result$data['country'] =
          l$country == null ? null : toJson$Enum$CountryCode(l$country);
    }
    if (_$data.containsKey('countryArea')) {
      final l$countryArea = countryArea;
      result$data['countryArea'] = l$countryArea;
    }
    if (_$data.containsKey('phone')) {
      final l$phone = phone;
      result$data['phone'] = l$phone;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('skipValidation')) {
      final l$skipValidation = skipValidation;
      result$data['skipValidation'] = l$skipValidation;
    }
    return result$data;
  }

  CopyWith$Input$AddressInput<Input$AddressInput> get copyWith =>
      CopyWith$Input$AddressInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddressInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$firstName = firstName;
    final lOther$firstName = other.firstName;
    if (_$data.containsKey('firstName') !=
        other._$data.containsKey('firstName')) {
      return false;
    }
    if (l$firstName != lOther$firstName) {
      return false;
    }
    final l$lastName = lastName;
    final lOther$lastName = other.lastName;
    if (_$data.containsKey('lastName') !=
        other._$data.containsKey('lastName')) {
      return false;
    }
    if (l$lastName != lOther$lastName) {
      return false;
    }
    final l$companyName = companyName;
    final lOther$companyName = other.companyName;
    if (_$data.containsKey('companyName') !=
        other._$data.containsKey('companyName')) {
      return false;
    }
    if (l$companyName != lOther$companyName) {
      return false;
    }
    final l$streetAddress1 = streetAddress1;
    final lOther$streetAddress1 = other.streetAddress1;
    if (_$data.containsKey('streetAddress1') !=
        other._$data.containsKey('streetAddress1')) {
      return false;
    }
    if (l$streetAddress1 != lOther$streetAddress1) {
      return false;
    }
    final l$streetAddress2 = streetAddress2;
    final lOther$streetAddress2 = other.streetAddress2;
    if (_$data.containsKey('streetAddress2') !=
        other._$data.containsKey('streetAddress2')) {
      return false;
    }
    if (l$streetAddress2 != lOther$streetAddress2) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$cityArea = cityArea;
    final lOther$cityArea = other.cityArea;
    if (_$data.containsKey('cityArea') !=
        other._$data.containsKey('cityArea')) {
      return false;
    }
    if (l$cityArea != lOther$cityArea) {
      return false;
    }
    final l$postalCode = postalCode;
    final lOther$postalCode = other.postalCode;
    if (_$data.containsKey('postalCode') !=
        other._$data.containsKey('postalCode')) {
      return false;
    }
    if (l$postalCode != lOther$postalCode) {
      return false;
    }
    final l$country = country;
    final lOther$country = other.country;
    if (_$data.containsKey('country') != other._$data.containsKey('country')) {
      return false;
    }
    if (l$country != lOther$country) {
      return false;
    }
    final l$countryArea = countryArea;
    final lOther$countryArea = other.countryArea;
    if (_$data.containsKey('countryArea') !=
        other._$data.containsKey('countryArea')) {
      return false;
    }
    if (l$countryArea != lOther$countryArea) {
      return false;
    }
    final l$phone = phone;
    final lOther$phone = other.phone;
    if (_$data.containsKey('phone') != other._$data.containsKey('phone')) {
      return false;
    }
    if (l$phone != lOther$phone) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$skipValidation = skipValidation;
    final lOther$skipValidation = other.skipValidation;
    if (_$data.containsKey('skipValidation') !=
        other._$data.containsKey('skipValidation')) {
      return false;
    }
    if (l$skipValidation != lOther$skipValidation) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$firstName = firstName;
    final l$lastName = lastName;
    final l$companyName = companyName;
    final l$streetAddress1 = streetAddress1;
    final l$streetAddress2 = streetAddress2;
    final l$city = city;
    final l$cityArea = cityArea;
    final l$postalCode = postalCode;
    final l$country = country;
    final l$countryArea = countryArea;
    final l$phone = phone;
    final l$metadata = metadata;
    final l$skipValidation = skipValidation;
    return Object.hashAll([
      _$data.containsKey('firstName') ? l$firstName : const {},
      _$data.containsKey('lastName') ? l$lastName : const {},
      _$data.containsKey('companyName') ? l$companyName : const {},
      _$data.containsKey('streetAddress1') ? l$streetAddress1 : const {},
      _$data.containsKey('streetAddress2') ? l$streetAddress2 : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('cityArea') ? l$cityArea : const {},
      _$data.containsKey('postalCode') ? l$postalCode : const {},
      _$data.containsKey('country') ? l$country : const {},
      _$data.containsKey('countryArea') ? l$countryArea : const {},
      _$data.containsKey('phone') ? l$phone : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('skipValidation') ? l$skipValidation : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddressInput<TRes> {
  factory CopyWith$Input$AddressInput(
    Input$AddressInput instance,
    TRes Function(Input$AddressInput) then,
  ) = _CopyWithImpl$Input$AddressInput;

  factory CopyWith$Input$AddressInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddressInput;

  TRes call({
    String? firstName,
    String? lastName,
    String? companyName,
    String? streetAddress1,
    String? streetAddress2,
    String? city,
    String? cityArea,
    String? postalCode,
    Enum$CountryCode? country,
    String? countryArea,
    String? phone,
    List<Input$MetadataInput>? metadata,
    bool? skipValidation,
  });
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$AddressInput<TRes>
    implements CopyWith$Input$AddressInput<TRes> {
  _CopyWithImpl$Input$AddressInput(
    this._instance,
    this._then,
  );

  final Input$AddressInput _instance;

  final TRes Function(Input$AddressInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? firstName = _undefined,
    Object? lastName = _undefined,
    Object? companyName = _undefined,
    Object? streetAddress1 = _undefined,
    Object? streetAddress2 = _undefined,
    Object? city = _undefined,
    Object? cityArea = _undefined,
    Object? postalCode = _undefined,
    Object? country = _undefined,
    Object? countryArea = _undefined,
    Object? phone = _undefined,
    Object? metadata = _undefined,
    Object? skipValidation = _undefined,
  }) =>
      _then(Input$AddressInput._({
        ..._instance._$data,
        if (firstName != _undefined) 'firstName': (firstName as String?),
        if (lastName != _undefined) 'lastName': (lastName as String?),
        if (companyName != _undefined) 'companyName': (companyName as String?),
        if (streetAddress1 != _undefined)
          'streetAddress1': (streetAddress1 as String?),
        if (streetAddress2 != _undefined)
          'streetAddress2': (streetAddress2 as String?),
        if (city != _undefined) 'city': (city as String?),
        if (cityArea != _undefined) 'cityArea': (cityArea as String?),
        if (postalCode != _undefined) 'postalCode': (postalCode as String?),
        if (country != _undefined) 'country': (country as Enum$CountryCode?),
        if (countryArea != _undefined) 'countryArea': (countryArea as String?),
        if (phone != _undefined) 'phone': (phone as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (skipValidation != _undefined)
          'skipValidation': (skipValidation as bool?),
      }));

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$AddressInput<TRes>
    implements CopyWith$Input$AddressInput<TRes> {
  _CopyWithStubImpl$Input$AddressInput(this._res);

  TRes _res;

  call({
    String? firstName,
    String? lastName,
    String? companyName,
    String? streetAddress1,
    String? streetAddress2,
    String? city,
    String? cityArea,
    String? postalCode,
    Enum$CountryCode? country,
    String? countryArea,
    String? phone,
    List<Input$MetadataInput>? metadata,
    bool? skipValidation,
  }) =>
      _res;

  metadata(_fn) => _res;
}

class Input$AppExtensionFilterInput {
  factory Input$AppExtensionFilterInput({
    List<Enum$AppExtensionMountEnum>? mount,
    Enum$AppExtensionTargetEnum? target,
  }) =>
      Input$AppExtensionFilterInput._({
        if (mount != null) r'mount': mount,
        if (target != null) r'target': target,
      });

  Input$AppExtensionFilterInput._(this._$data);

  factory Input$AppExtensionFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('mount')) {
      final l$mount = data['mount'];
      result$data['mount'] = (l$mount as List<dynamic>?)
          ?.map((e) => fromJson$Enum$AppExtensionMountEnum((e as String)))
          .toList();
    }
    if (data.containsKey('target')) {
      final l$target = data['target'];
      result$data['target'] = l$target == null
          ? null
          : fromJson$Enum$AppExtensionTargetEnum((l$target as String));
    }
    return Input$AppExtensionFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$AppExtensionMountEnum>? get mount =>
      (_$data['mount'] as List<Enum$AppExtensionMountEnum>?);

  Enum$AppExtensionTargetEnum? get target =>
      (_$data['target'] as Enum$AppExtensionTargetEnum?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('mount')) {
      final l$mount = mount;
      result$data['mount'] =
          l$mount?.map((e) => toJson$Enum$AppExtensionMountEnum(e)).toList();
    }
    if (_$data.containsKey('target')) {
      final l$target = target;
      result$data['target'] = l$target == null
          ? null
          : toJson$Enum$AppExtensionTargetEnum(l$target);
    }
    return result$data;
  }

  CopyWith$Input$AppExtensionFilterInput<Input$AppExtensionFilterInput>
      get copyWith => CopyWith$Input$AppExtensionFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AppExtensionFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$mount = mount;
    final lOther$mount = other.mount;
    if (_$data.containsKey('mount') != other._$data.containsKey('mount')) {
      return false;
    }
    if (l$mount != null && lOther$mount != null) {
      if (l$mount.length != lOther$mount.length) {
        return false;
      }
      for (int i = 0; i < l$mount.length; i++) {
        final l$mount$entry = l$mount[i];
        final lOther$mount$entry = lOther$mount[i];
        if (l$mount$entry != lOther$mount$entry) {
          return false;
        }
      }
    } else if (l$mount != lOther$mount) {
      return false;
    }
    final l$target = target;
    final lOther$target = other.target;
    if (_$data.containsKey('target') != other._$data.containsKey('target')) {
      return false;
    }
    if (l$target != lOther$target) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$mount = mount;
    final l$target = target;
    return Object.hashAll([
      _$data.containsKey('mount')
          ? l$mount == null
              ? null
              : Object.hashAll(l$mount.map((v) => v))
          : const {},
      _$data.containsKey('target') ? l$target : const {},
    ]);
  }
}

abstract class CopyWith$Input$AppExtensionFilterInput<TRes> {
  factory CopyWith$Input$AppExtensionFilterInput(
    Input$AppExtensionFilterInput instance,
    TRes Function(Input$AppExtensionFilterInput) then,
  ) = _CopyWithImpl$Input$AppExtensionFilterInput;

  factory CopyWith$Input$AppExtensionFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AppExtensionFilterInput;

  TRes call({
    List<Enum$AppExtensionMountEnum>? mount,
    Enum$AppExtensionTargetEnum? target,
  });
}

class _CopyWithImpl$Input$AppExtensionFilterInput<TRes>
    implements CopyWith$Input$AppExtensionFilterInput<TRes> {
  _CopyWithImpl$Input$AppExtensionFilterInput(
    this._instance,
    this._then,
  );

  final Input$AppExtensionFilterInput _instance;

  final TRes Function(Input$AppExtensionFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? mount = _undefined,
    Object? target = _undefined,
  }) =>
      _then(Input$AppExtensionFilterInput._({
        ..._instance._$data,
        if (mount != _undefined)
          'mount': (mount as List<Enum$AppExtensionMountEnum>?),
        if (target != _undefined)
          'target': (target as Enum$AppExtensionTargetEnum?),
      }));
}

class _CopyWithStubImpl$Input$AppExtensionFilterInput<TRes>
    implements CopyWith$Input$AppExtensionFilterInput<TRes> {
  _CopyWithStubImpl$Input$AppExtensionFilterInput(this._res);

  TRes _res;

  call({
    List<Enum$AppExtensionMountEnum>? mount,
    Enum$AppExtensionTargetEnum? target,
  }) =>
      _res;
}

class Input$AppFilterInput {
  factory Input$AppFilterInput({
    String? search,
    bool? isActive,
    Enum$AppTypeEnum? type,
  }) =>
      Input$AppFilterInput._({
        if (search != null) r'search': search,
        if (isActive != null) r'isActive': isActive,
        if (type != null) r'type': type,
      });

  Input$AppFilterInput._(this._$data);

  factory Input$AppFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = (l$isActive as bool?);
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] =
          l$type == null ? null : fromJson$Enum$AppTypeEnum((l$type as String));
    }
    return Input$AppFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get search => (_$data['search'] as String?);

  bool? get isActive => (_$data['isActive'] as bool?);

  Enum$AppTypeEnum? get type => (_$data['type'] as Enum$AppTypeEnum?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive;
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] =
          l$type == null ? null : toJson$Enum$AppTypeEnum(l$type);
    }
    return result$data;
  }

  CopyWith$Input$AppFilterInput<Input$AppFilterInput> get copyWith =>
      CopyWith$Input$AppFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AppFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$search = search;
    final l$isActive = isActive;
    final l$type = type;
    return Object.hashAll([
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('type') ? l$type : const {},
    ]);
  }
}

abstract class CopyWith$Input$AppFilterInput<TRes> {
  factory CopyWith$Input$AppFilterInput(
    Input$AppFilterInput instance,
    TRes Function(Input$AppFilterInput) then,
  ) = _CopyWithImpl$Input$AppFilterInput;

  factory CopyWith$Input$AppFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AppFilterInput;

  TRes call({
    String? search,
    bool? isActive,
    Enum$AppTypeEnum? type,
  });
}

class _CopyWithImpl$Input$AppFilterInput<TRes>
    implements CopyWith$Input$AppFilterInput<TRes> {
  _CopyWithImpl$Input$AppFilterInput(
    this._instance,
    this._then,
  );

  final Input$AppFilterInput _instance;

  final TRes Function(Input$AppFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? search = _undefined,
    Object? isActive = _undefined,
    Object? type = _undefined,
  }) =>
      _then(Input$AppFilterInput._({
        ..._instance._$data,
        if (search != _undefined) 'search': (search as String?),
        if (isActive != _undefined) 'isActive': (isActive as bool?),
        if (type != _undefined) 'type': (type as Enum$AppTypeEnum?),
      }));
}

class _CopyWithStubImpl$Input$AppFilterInput<TRes>
    implements CopyWith$Input$AppFilterInput<TRes> {
  _CopyWithStubImpl$Input$AppFilterInput(this._res);

  TRes _res;

  call({
    String? search,
    bool? isActive,
    Enum$AppTypeEnum? type,
  }) =>
      _res;
}

class Input$AppInput {
  factory Input$AppInput({
    String? name,
    String? identifier,
    List<Enum$PermissionEnum>? permissions,
  }) =>
      Input$AppInput._({
        if (name != null) r'name': name,
        if (identifier != null) r'identifier': identifier,
        if (permissions != null) r'permissions': permissions,
      });

  Input$AppInput._(this._$data);

  factory Input$AppInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('identifier')) {
      final l$identifier = data['identifier'];
      result$data['identifier'] = (l$identifier as String?);
    }
    if (data.containsKey('permissions')) {
      final l$permissions = data['permissions'];
      result$data['permissions'] = (l$permissions as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PermissionEnum((e as String)))
          .toList();
    }
    return Input$AppInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get identifier => (_$data['identifier'] as String?);

  List<Enum$PermissionEnum>? get permissions =>
      (_$data['permissions'] as List<Enum$PermissionEnum>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('identifier')) {
      final l$identifier = identifier;
      result$data['identifier'] = l$identifier;
    }
    if (_$data.containsKey('permissions')) {
      final l$permissions = permissions;
      result$data['permissions'] =
          l$permissions?.map((e) => toJson$Enum$PermissionEnum(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$AppInput<Input$AppInput> get copyWith =>
      CopyWith$Input$AppInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AppInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$identifier = identifier;
    final lOther$identifier = other.identifier;
    if (_$data.containsKey('identifier') !=
        other._$data.containsKey('identifier')) {
      return false;
    }
    if (l$identifier != lOther$identifier) {
      return false;
    }
    final l$permissions = permissions;
    final lOther$permissions = other.permissions;
    if (_$data.containsKey('permissions') !=
        other._$data.containsKey('permissions')) {
      return false;
    }
    if (l$permissions != null && lOther$permissions != null) {
      if (l$permissions.length != lOther$permissions.length) {
        return false;
      }
      for (int i = 0; i < l$permissions.length; i++) {
        final l$permissions$entry = l$permissions[i];
        final lOther$permissions$entry = lOther$permissions[i];
        if (l$permissions$entry != lOther$permissions$entry) {
          return false;
        }
      }
    } else if (l$permissions != lOther$permissions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$identifier = identifier;
    final l$permissions = permissions;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('identifier') ? l$identifier : const {},
      _$data.containsKey('permissions')
          ? l$permissions == null
              ? null
              : Object.hashAll(l$permissions.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AppInput<TRes> {
  factory CopyWith$Input$AppInput(
    Input$AppInput instance,
    TRes Function(Input$AppInput) then,
  ) = _CopyWithImpl$Input$AppInput;

  factory CopyWith$Input$AppInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AppInput;

  TRes call({
    String? name,
    String? identifier,
    List<Enum$PermissionEnum>? permissions,
  });
}

class _CopyWithImpl$Input$AppInput<TRes>
    implements CopyWith$Input$AppInput<TRes> {
  _CopyWithImpl$Input$AppInput(
    this._instance,
    this._then,
  );

  final Input$AppInput _instance;

  final TRes Function(Input$AppInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? identifier = _undefined,
    Object? permissions = _undefined,
  }) =>
      _then(Input$AppInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (identifier != _undefined) 'identifier': (identifier as String?),
        if (permissions != _undefined)
          'permissions': (permissions as List<Enum$PermissionEnum>?),
      }));
}

class _CopyWithStubImpl$Input$AppInput<TRes>
    implements CopyWith$Input$AppInput<TRes> {
  _CopyWithStubImpl$Input$AppInput(this._res);

  TRes _res;

  call({
    String? name,
    String? identifier,
    List<Enum$PermissionEnum>? permissions,
  }) =>
      _res;
}

class Input$AppInstallInput {
  factory Input$AppInstallInput({
    String? appName,
    String? manifestUrl,
    bool? activateAfterInstallation,
    List<Enum$PermissionEnum>? permissions,
  }) =>
      Input$AppInstallInput._({
        if (appName != null) r'appName': appName,
        if (manifestUrl != null) r'manifestUrl': manifestUrl,
        if (activateAfterInstallation != null)
          r'activateAfterInstallation': activateAfterInstallation,
        if (permissions != null) r'permissions': permissions,
      });

  Input$AppInstallInput._(this._$data);

  factory Input$AppInstallInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('appName')) {
      final l$appName = data['appName'];
      result$data['appName'] = (l$appName as String?);
    }
    if (data.containsKey('manifestUrl')) {
      final l$manifestUrl = data['manifestUrl'];
      result$data['manifestUrl'] = (l$manifestUrl as String?);
    }
    if (data.containsKey('activateAfterInstallation')) {
      final l$activateAfterInstallation = data['activateAfterInstallation'];
      result$data['activateAfterInstallation'] =
          (l$activateAfterInstallation as bool?);
    }
    if (data.containsKey('permissions')) {
      final l$permissions = data['permissions'];
      result$data['permissions'] = (l$permissions as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PermissionEnum((e as String)))
          .toList();
    }
    return Input$AppInstallInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get appName => (_$data['appName'] as String?);

  String? get manifestUrl => (_$data['manifestUrl'] as String?);

  bool? get activateAfterInstallation =>
      (_$data['activateAfterInstallation'] as bool?);

  List<Enum$PermissionEnum>? get permissions =>
      (_$data['permissions'] as List<Enum$PermissionEnum>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('appName')) {
      final l$appName = appName;
      result$data['appName'] = l$appName;
    }
    if (_$data.containsKey('manifestUrl')) {
      final l$manifestUrl = manifestUrl;
      result$data['manifestUrl'] = l$manifestUrl;
    }
    if (_$data.containsKey('activateAfterInstallation')) {
      final l$activateAfterInstallation = activateAfterInstallation;
      result$data['activateAfterInstallation'] = l$activateAfterInstallation;
    }
    if (_$data.containsKey('permissions')) {
      final l$permissions = permissions;
      result$data['permissions'] =
          l$permissions?.map((e) => toJson$Enum$PermissionEnum(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$AppInstallInput<Input$AppInstallInput> get copyWith =>
      CopyWith$Input$AppInstallInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AppInstallInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$appName = appName;
    final lOther$appName = other.appName;
    if (_$data.containsKey('appName') != other._$data.containsKey('appName')) {
      return false;
    }
    if (l$appName != lOther$appName) {
      return false;
    }
    final l$manifestUrl = manifestUrl;
    final lOther$manifestUrl = other.manifestUrl;
    if (_$data.containsKey('manifestUrl') !=
        other._$data.containsKey('manifestUrl')) {
      return false;
    }
    if (l$manifestUrl != lOther$manifestUrl) {
      return false;
    }
    final l$activateAfterInstallation = activateAfterInstallation;
    final lOther$activateAfterInstallation = other.activateAfterInstallation;
    if (_$data.containsKey('activateAfterInstallation') !=
        other._$data.containsKey('activateAfterInstallation')) {
      return false;
    }
    if (l$activateAfterInstallation != lOther$activateAfterInstallation) {
      return false;
    }
    final l$permissions = permissions;
    final lOther$permissions = other.permissions;
    if (_$data.containsKey('permissions') !=
        other._$data.containsKey('permissions')) {
      return false;
    }
    if (l$permissions != null && lOther$permissions != null) {
      if (l$permissions.length != lOther$permissions.length) {
        return false;
      }
      for (int i = 0; i < l$permissions.length; i++) {
        final l$permissions$entry = l$permissions[i];
        final lOther$permissions$entry = lOther$permissions[i];
        if (l$permissions$entry != lOther$permissions$entry) {
          return false;
        }
      }
    } else if (l$permissions != lOther$permissions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$appName = appName;
    final l$manifestUrl = manifestUrl;
    final l$activateAfterInstallation = activateAfterInstallation;
    final l$permissions = permissions;
    return Object.hashAll([
      _$data.containsKey('appName') ? l$appName : const {},
      _$data.containsKey('manifestUrl') ? l$manifestUrl : const {},
      _$data.containsKey('activateAfterInstallation')
          ? l$activateAfterInstallation
          : const {},
      _$data.containsKey('permissions')
          ? l$permissions == null
              ? null
              : Object.hashAll(l$permissions.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AppInstallInput<TRes> {
  factory CopyWith$Input$AppInstallInput(
    Input$AppInstallInput instance,
    TRes Function(Input$AppInstallInput) then,
  ) = _CopyWithImpl$Input$AppInstallInput;

  factory CopyWith$Input$AppInstallInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AppInstallInput;

  TRes call({
    String? appName,
    String? manifestUrl,
    bool? activateAfterInstallation,
    List<Enum$PermissionEnum>? permissions,
  });
}

class _CopyWithImpl$Input$AppInstallInput<TRes>
    implements CopyWith$Input$AppInstallInput<TRes> {
  _CopyWithImpl$Input$AppInstallInput(
    this._instance,
    this._then,
  );

  final Input$AppInstallInput _instance;

  final TRes Function(Input$AppInstallInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? appName = _undefined,
    Object? manifestUrl = _undefined,
    Object? activateAfterInstallation = _undefined,
    Object? permissions = _undefined,
  }) =>
      _then(Input$AppInstallInput._({
        ..._instance._$data,
        if (appName != _undefined) 'appName': (appName as String?),
        if (manifestUrl != _undefined) 'manifestUrl': (manifestUrl as String?),
        if (activateAfterInstallation != _undefined)
          'activateAfterInstallation': (activateAfterInstallation as bool?),
        if (permissions != _undefined)
          'permissions': (permissions as List<Enum$PermissionEnum>?),
      }));
}

class _CopyWithStubImpl$Input$AppInstallInput<TRes>
    implements CopyWith$Input$AppInstallInput<TRes> {
  _CopyWithStubImpl$Input$AppInstallInput(this._res);

  TRes _res;

  call({
    String? appName,
    String? manifestUrl,
    bool? activateAfterInstallation,
    List<Enum$PermissionEnum>? permissions,
  }) =>
      _res;
}

class Input$AppSortingInput {
  factory Input$AppSortingInput({
    required Enum$OrderDirection direction,
    required Enum$AppSortField field,
  }) =>
      Input$AppSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$AppSortingInput._(this._$data);

  factory Input$AppSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$AppSortField((l$field as String));
    return Input$AppSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$AppSortField get field => (_$data['field'] as Enum$AppSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$AppSortField(l$field);
    return result$data;
  }

  CopyWith$Input$AppSortingInput<Input$AppSortingInput> get copyWith =>
      CopyWith$Input$AppSortingInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AppSortingInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$AppSortingInput<TRes> {
  factory CopyWith$Input$AppSortingInput(
    Input$AppSortingInput instance,
    TRes Function(Input$AppSortingInput) then,
  ) = _CopyWithImpl$Input$AppSortingInput;

  factory CopyWith$Input$AppSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AppSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$AppSortField? field,
  });
}

class _CopyWithImpl$Input$AppSortingInput<TRes>
    implements CopyWith$Input$AppSortingInput<TRes> {
  _CopyWithImpl$Input$AppSortingInput(
    this._instance,
    this._then,
  );

  final Input$AppSortingInput _instance;

  final TRes Function(Input$AppSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$AppSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$AppSortField),
      }));
}

class _CopyWithStubImpl$Input$AppSortingInput<TRes>
    implements CopyWith$Input$AppSortingInput<TRes> {
  _CopyWithStubImpl$Input$AppSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$AppSortField? field,
  }) =>
      _res;
}

class Input$AppTokenInput {
  factory Input$AppTokenInput({
    String? name,
    required String app,
  }) =>
      Input$AppTokenInput._({
        if (name != null) r'name': name,
        r'app': app,
      });

  Input$AppTokenInput._(this._$data);

  factory Input$AppTokenInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    final l$app = data['app'];
    result$data['app'] = (l$app as String);
    return Input$AppTokenInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String get app => (_$data['app'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    final l$app = app;
    result$data['app'] = l$app;
    return result$data;
  }

  CopyWith$Input$AppTokenInput<Input$AppTokenInput> get copyWith =>
      CopyWith$Input$AppTokenInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AppTokenInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$app = app;
    final lOther$app = other.app;
    if (l$app != lOther$app) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$app = app;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      l$app,
    ]);
  }
}

abstract class CopyWith$Input$AppTokenInput<TRes> {
  factory CopyWith$Input$AppTokenInput(
    Input$AppTokenInput instance,
    TRes Function(Input$AppTokenInput) then,
  ) = _CopyWithImpl$Input$AppTokenInput;

  factory CopyWith$Input$AppTokenInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AppTokenInput;

  TRes call({
    String? name,
    String? app,
  });
}

class _CopyWithImpl$Input$AppTokenInput<TRes>
    implements CopyWith$Input$AppTokenInput<TRes> {
  _CopyWithImpl$Input$AppTokenInput(
    this._instance,
    this._then,
  );

  final Input$AppTokenInput _instance;

  final TRes Function(Input$AppTokenInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? app = _undefined,
  }) =>
      _then(Input$AppTokenInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (app != _undefined && app != null) 'app': (app as String),
      }));
}

class _CopyWithStubImpl$Input$AppTokenInput<TRes>
    implements CopyWith$Input$AppTokenInput<TRes> {
  _CopyWithStubImpl$Input$AppTokenInput(this._res);

  TRes _res;

  call({
    String? name,
    String? app,
  }) =>
      _res;
}

class Input$AttributeBulkTranslateInput {
  factory Input$AttributeBulkTranslateInput({
    String? id,
    String? externalReference,
    required Enum$LanguageCodeEnum languageCode,
    required Input$NameTranslationInput translationFields,
  }) =>
      Input$AttributeBulkTranslateInput._({
        if (id != null) r'id': id,
        if (externalReference != null) r'externalReference': externalReference,
        r'languageCode': languageCode,
        r'translationFields': translationFields,
      });

  Input$AttributeBulkTranslateInput._(this._$data);

  factory Input$AttributeBulkTranslateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    final l$languageCode = data['languageCode'];
    result$data['languageCode'] =
        fromJson$Enum$LanguageCodeEnum((l$languageCode as String));
    final l$translationFields = data['translationFields'];
    result$data['translationFields'] = Input$NameTranslationInput.fromJson(
        (l$translationFields as Map<String, dynamic>));
    return Input$AttributeBulkTranslateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get externalReference => (_$data['externalReference'] as String?);

  Enum$LanguageCodeEnum get languageCode =>
      (_$data['languageCode'] as Enum$LanguageCodeEnum);

  Input$NameTranslationInput get translationFields =>
      (_$data['translationFields'] as Input$NameTranslationInput);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    final l$languageCode = languageCode;
    result$data['languageCode'] = toJson$Enum$LanguageCodeEnum(l$languageCode);
    final l$translationFields = translationFields;
    result$data['translationFields'] = l$translationFields.toJson();
    return result$data;
  }

  CopyWith$Input$AttributeBulkTranslateInput<Input$AttributeBulkTranslateInput>
      get copyWith => CopyWith$Input$AttributeBulkTranslateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeBulkTranslateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$languageCode = languageCode;
    final lOther$languageCode = other.languageCode;
    if (l$languageCode != lOther$languageCode) {
      return false;
    }
    final l$translationFields = translationFields;
    final lOther$translationFields = other.translationFields;
    if (l$translationFields != lOther$translationFields) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$externalReference = externalReference;
    final l$languageCode = languageCode;
    final l$translationFields = translationFields;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      l$languageCode,
      l$translationFields,
    ]);
  }
}

abstract class CopyWith$Input$AttributeBulkTranslateInput<TRes> {
  factory CopyWith$Input$AttributeBulkTranslateInput(
    Input$AttributeBulkTranslateInput instance,
    TRes Function(Input$AttributeBulkTranslateInput) then,
  ) = _CopyWithImpl$Input$AttributeBulkTranslateInput;

  factory CopyWith$Input$AttributeBulkTranslateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeBulkTranslateInput;

  TRes call({
    String? id,
    String? externalReference,
    Enum$LanguageCodeEnum? languageCode,
    Input$NameTranslationInput? translationFields,
  });
  CopyWith$Input$NameTranslationInput<TRes> get translationFields;
}

class _CopyWithImpl$Input$AttributeBulkTranslateInput<TRes>
    implements CopyWith$Input$AttributeBulkTranslateInput<TRes> {
  _CopyWithImpl$Input$AttributeBulkTranslateInput(
    this._instance,
    this._then,
  );

  final Input$AttributeBulkTranslateInput _instance;

  final TRes Function(Input$AttributeBulkTranslateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? externalReference = _undefined,
    Object? languageCode = _undefined,
    Object? translationFields = _undefined,
  }) =>
      _then(Input$AttributeBulkTranslateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (languageCode != _undefined && languageCode != null)
          'languageCode': (languageCode as Enum$LanguageCodeEnum),
        if (translationFields != _undefined && translationFields != null)
          'translationFields':
              (translationFields as Input$NameTranslationInput),
      }));

  CopyWith$Input$NameTranslationInput<TRes> get translationFields {
    final local$translationFields = _instance.translationFields;
    return CopyWith$Input$NameTranslationInput(
        local$translationFields, (e) => call(translationFields: e));
  }
}

class _CopyWithStubImpl$Input$AttributeBulkTranslateInput<TRes>
    implements CopyWith$Input$AttributeBulkTranslateInput<TRes> {
  _CopyWithStubImpl$Input$AttributeBulkTranslateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? externalReference,
    Enum$LanguageCodeEnum? languageCode,
    Input$NameTranslationInput? translationFields,
  }) =>
      _res;

  CopyWith$Input$NameTranslationInput<TRes> get translationFields =>
      CopyWith$Input$NameTranslationInput.stub(_res);
}

class Input$AttributeBulkUpdateInput {
  factory Input$AttributeBulkUpdateInput({
    String? id,
    String? externalReference,
    required Input$AttributeUpdateInput fields,
  }) =>
      Input$AttributeBulkUpdateInput._({
        if (id != null) r'id': id,
        if (externalReference != null) r'externalReference': externalReference,
        r'fields': fields,
      });

  Input$AttributeBulkUpdateInput._(this._$data);

  factory Input$AttributeBulkUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    final l$fields = data['fields'];
    result$data['fields'] =
        Input$AttributeUpdateInput.fromJson((l$fields as Map<String, dynamic>));
    return Input$AttributeBulkUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get externalReference => (_$data['externalReference'] as String?);

  Input$AttributeUpdateInput get fields =>
      (_$data['fields'] as Input$AttributeUpdateInput);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    final l$fields = fields;
    result$data['fields'] = l$fields.toJson();
    return result$data;
  }

  CopyWith$Input$AttributeBulkUpdateInput<Input$AttributeBulkUpdateInput>
      get copyWith => CopyWith$Input$AttributeBulkUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeBulkUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$fields = fields;
    final lOther$fields = other.fields;
    if (l$fields != lOther$fields) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$externalReference = externalReference;
    final l$fields = fields;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      l$fields,
    ]);
  }
}

abstract class CopyWith$Input$AttributeBulkUpdateInput<TRes> {
  factory CopyWith$Input$AttributeBulkUpdateInput(
    Input$AttributeBulkUpdateInput instance,
    TRes Function(Input$AttributeBulkUpdateInput) then,
  ) = _CopyWithImpl$Input$AttributeBulkUpdateInput;

  factory CopyWith$Input$AttributeBulkUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeBulkUpdateInput;

  TRes call({
    String? id,
    String? externalReference,
    Input$AttributeUpdateInput? fields,
  });
  CopyWith$Input$AttributeUpdateInput<TRes> get fields;
}

class _CopyWithImpl$Input$AttributeBulkUpdateInput<TRes>
    implements CopyWith$Input$AttributeBulkUpdateInput<TRes> {
  _CopyWithImpl$Input$AttributeBulkUpdateInput(
    this._instance,
    this._then,
  );

  final Input$AttributeBulkUpdateInput _instance;

  final TRes Function(Input$AttributeBulkUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? externalReference = _undefined,
    Object? fields = _undefined,
  }) =>
      _then(Input$AttributeBulkUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (fields != _undefined && fields != null)
          'fields': (fields as Input$AttributeUpdateInput),
      }));

  CopyWith$Input$AttributeUpdateInput<TRes> get fields {
    final local$fields = _instance.fields;
    return CopyWith$Input$AttributeUpdateInput(
        local$fields, (e) => call(fields: e));
  }
}

class _CopyWithStubImpl$Input$AttributeBulkUpdateInput<TRes>
    implements CopyWith$Input$AttributeBulkUpdateInput<TRes> {
  _CopyWithStubImpl$Input$AttributeBulkUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? externalReference,
    Input$AttributeUpdateInput? fields,
  }) =>
      _res;

  CopyWith$Input$AttributeUpdateInput<TRes> get fields =>
      CopyWith$Input$AttributeUpdateInput.stub(_res);
}

class Input$AttributeChoicesSortingInput {
  factory Input$AttributeChoicesSortingInput({
    required Enum$OrderDirection direction,
    required Enum$AttributeChoicesSortField field,
  }) =>
      Input$AttributeChoicesSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$AttributeChoicesSortingInput._(this._$data);

  factory Input$AttributeChoicesSortingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$AttributeChoicesSortField((l$field as String));
    return Input$AttributeChoicesSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$AttributeChoicesSortField get field =>
      (_$data['field'] as Enum$AttributeChoicesSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$AttributeChoicesSortField(l$field);
    return result$data;
  }

  CopyWith$Input$AttributeChoicesSortingInput<
          Input$AttributeChoicesSortingInput>
      get copyWith => CopyWith$Input$AttributeChoicesSortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeChoicesSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$AttributeChoicesSortingInput<TRes> {
  factory CopyWith$Input$AttributeChoicesSortingInput(
    Input$AttributeChoicesSortingInput instance,
    TRes Function(Input$AttributeChoicesSortingInput) then,
  ) = _CopyWithImpl$Input$AttributeChoicesSortingInput;

  factory CopyWith$Input$AttributeChoicesSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeChoicesSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$AttributeChoicesSortField? field,
  });
}

class _CopyWithImpl$Input$AttributeChoicesSortingInput<TRes>
    implements CopyWith$Input$AttributeChoicesSortingInput<TRes> {
  _CopyWithImpl$Input$AttributeChoicesSortingInput(
    this._instance,
    this._then,
  );

  final Input$AttributeChoicesSortingInput _instance;

  final TRes Function(Input$AttributeChoicesSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$AttributeChoicesSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$AttributeChoicesSortField),
      }));
}

class _CopyWithStubImpl$Input$AttributeChoicesSortingInput<TRes>
    implements CopyWith$Input$AttributeChoicesSortingInput<TRes> {
  _CopyWithStubImpl$Input$AttributeChoicesSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$AttributeChoicesSortField? field,
  }) =>
      _res;
}

class Input$AttributeCreateInput {
  factory Input$AttributeCreateInput({
    Enum$AttributeInputTypeEnum? inputType,
    Enum$AttributeEntityTypeEnum? entityType,
    required String name,
    String? slug,
    required Enum$AttributeTypeEnum type,
    Enum$MeasurementUnitsEnum? unit,
    List<Input$AttributeValueCreateInput>? values,
    bool? valueRequired,
    bool? isVariantOnly,
    bool? visibleInStorefront,
    bool? filterableInStorefront,
    bool? filterableInDashboard,
    int? storefrontSearchPosition,
    bool? availableInGrid,
    String? externalReference,
  }) =>
      Input$AttributeCreateInput._({
        if (inputType != null) r'inputType': inputType,
        if (entityType != null) r'entityType': entityType,
        r'name': name,
        if (slug != null) r'slug': slug,
        r'type': type,
        if (unit != null) r'unit': unit,
        if (values != null) r'values': values,
        if (valueRequired != null) r'valueRequired': valueRequired,
        if (isVariantOnly != null) r'isVariantOnly': isVariantOnly,
        if (visibleInStorefront != null)
          r'visibleInStorefront': visibleInStorefront,
        if (filterableInStorefront != null)
          r'filterableInStorefront': filterableInStorefront,
        if (filterableInDashboard != null)
          r'filterableInDashboard': filterableInDashboard,
        if (storefrontSearchPosition != null)
          r'storefrontSearchPosition': storefrontSearchPosition,
        if (availableInGrid != null) r'availableInGrid': availableInGrid,
        if (externalReference != null) r'externalReference': externalReference,
      });

  Input$AttributeCreateInput._(this._$data);

  factory Input$AttributeCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('inputType')) {
      final l$inputType = data['inputType'];
      result$data['inputType'] = l$inputType == null
          ? null
          : fromJson$Enum$AttributeInputTypeEnum((l$inputType as String));
    }
    if (data.containsKey('entityType')) {
      final l$entityType = data['entityType'];
      result$data['entityType'] = l$entityType == null
          ? null
          : fromJson$Enum$AttributeEntityTypeEnum((l$entityType as String));
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    final l$type = data['type'];
    result$data['type'] = fromJson$Enum$AttributeTypeEnum((l$type as String));
    if (data.containsKey('unit')) {
      final l$unit = data['unit'];
      result$data['unit'] = l$unit == null
          ? null
          : fromJson$Enum$MeasurementUnitsEnum((l$unit as String));
    }
    if (data.containsKey('values')) {
      final l$values = data['values'];
      result$data['values'] = (l$values as List<dynamic>?)
          ?.map((e) => Input$AttributeValueCreateInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('valueRequired')) {
      final l$valueRequired = data['valueRequired'];
      result$data['valueRequired'] = (l$valueRequired as bool?);
    }
    if (data.containsKey('isVariantOnly')) {
      final l$isVariantOnly = data['isVariantOnly'];
      result$data['isVariantOnly'] = (l$isVariantOnly as bool?);
    }
    if (data.containsKey('visibleInStorefront')) {
      final l$visibleInStorefront = data['visibleInStorefront'];
      result$data['visibleInStorefront'] = (l$visibleInStorefront as bool?);
    }
    if (data.containsKey('filterableInStorefront')) {
      final l$filterableInStorefront = data['filterableInStorefront'];
      result$data['filterableInStorefront'] =
          (l$filterableInStorefront as bool?);
    }
    if (data.containsKey('filterableInDashboard')) {
      final l$filterableInDashboard = data['filterableInDashboard'];
      result$data['filterableInDashboard'] = (l$filterableInDashboard as bool?);
    }
    if (data.containsKey('storefrontSearchPosition')) {
      final l$storefrontSearchPosition = data['storefrontSearchPosition'];
      result$data['storefrontSearchPosition'] =
          (l$storefrontSearchPosition as int?);
    }
    if (data.containsKey('availableInGrid')) {
      final l$availableInGrid = data['availableInGrid'];
      result$data['availableInGrid'] = (l$availableInGrid as bool?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    return Input$AttributeCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$AttributeInputTypeEnum? get inputType =>
      (_$data['inputType'] as Enum$AttributeInputTypeEnum?);

  Enum$AttributeEntityTypeEnum? get entityType =>
      (_$data['entityType'] as Enum$AttributeEntityTypeEnum?);

  String get name => (_$data['name'] as String);

  String? get slug => (_$data['slug'] as String?);

  Enum$AttributeTypeEnum get type => (_$data['type'] as Enum$AttributeTypeEnum);

  Enum$MeasurementUnitsEnum? get unit =>
      (_$data['unit'] as Enum$MeasurementUnitsEnum?);

  List<Input$AttributeValueCreateInput>? get values =>
      (_$data['values'] as List<Input$AttributeValueCreateInput>?);

  bool? get valueRequired => (_$data['valueRequired'] as bool?);

  bool? get isVariantOnly => (_$data['isVariantOnly'] as bool?);

  bool? get visibleInStorefront => (_$data['visibleInStorefront'] as bool?);

  bool? get filterableInStorefront =>
      (_$data['filterableInStorefront'] as bool?);

  bool? get filterableInDashboard => (_$data['filterableInDashboard'] as bool?);

  int? get storefrontSearchPosition =>
      (_$data['storefrontSearchPosition'] as int?);

  bool? get availableInGrid => (_$data['availableInGrid'] as bool?);

  String? get externalReference => (_$data['externalReference'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('inputType')) {
      final l$inputType = inputType;
      result$data['inputType'] = l$inputType == null
          ? null
          : toJson$Enum$AttributeInputTypeEnum(l$inputType);
    }
    if (_$data.containsKey('entityType')) {
      final l$entityType = entityType;
      result$data['entityType'] = l$entityType == null
          ? null
          : toJson$Enum$AttributeEntityTypeEnum(l$entityType);
    }
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    final l$type = type;
    result$data['type'] = toJson$Enum$AttributeTypeEnum(l$type);
    if (_$data.containsKey('unit')) {
      final l$unit = unit;
      result$data['unit'] =
          l$unit == null ? null : toJson$Enum$MeasurementUnitsEnum(l$unit);
    }
    if (_$data.containsKey('values')) {
      final l$values = values;
      result$data['values'] = l$values?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('valueRequired')) {
      final l$valueRequired = valueRequired;
      result$data['valueRequired'] = l$valueRequired;
    }
    if (_$data.containsKey('isVariantOnly')) {
      final l$isVariantOnly = isVariantOnly;
      result$data['isVariantOnly'] = l$isVariantOnly;
    }
    if (_$data.containsKey('visibleInStorefront')) {
      final l$visibleInStorefront = visibleInStorefront;
      result$data['visibleInStorefront'] = l$visibleInStorefront;
    }
    if (_$data.containsKey('filterableInStorefront')) {
      final l$filterableInStorefront = filterableInStorefront;
      result$data['filterableInStorefront'] = l$filterableInStorefront;
    }
    if (_$data.containsKey('filterableInDashboard')) {
      final l$filterableInDashboard = filterableInDashboard;
      result$data['filterableInDashboard'] = l$filterableInDashboard;
    }
    if (_$data.containsKey('storefrontSearchPosition')) {
      final l$storefrontSearchPosition = storefrontSearchPosition;
      result$data['storefrontSearchPosition'] = l$storefrontSearchPosition;
    }
    if (_$data.containsKey('availableInGrid')) {
      final l$availableInGrid = availableInGrid;
      result$data['availableInGrid'] = l$availableInGrid;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    return result$data;
  }

  CopyWith$Input$AttributeCreateInput<Input$AttributeCreateInput>
      get copyWith => CopyWith$Input$AttributeCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$inputType = inputType;
    final lOther$inputType = other.inputType;
    if (_$data.containsKey('inputType') !=
        other._$data.containsKey('inputType')) {
      return false;
    }
    if (l$inputType != lOther$inputType) {
      return false;
    }
    final l$entityType = entityType;
    final lOther$entityType = other.entityType;
    if (_$data.containsKey('entityType') !=
        other._$data.containsKey('entityType')) {
      return false;
    }
    if (l$entityType != lOther$entityType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) {
      return false;
    }
    final l$unit = unit;
    final lOther$unit = other.unit;
    if (_$data.containsKey('unit') != other._$data.containsKey('unit')) {
      return false;
    }
    if (l$unit != lOther$unit) {
      return false;
    }
    final l$values = values;
    final lOther$values = other.values;
    if (_$data.containsKey('values') != other._$data.containsKey('values')) {
      return false;
    }
    if (l$values != null && lOther$values != null) {
      if (l$values.length != lOther$values.length) {
        return false;
      }
      for (int i = 0; i < l$values.length; i++) {
        final l$values$entry = l$values[i];
        final lOther$values$entry = lOther$values[i];
        if (l$values$entry != lOther$values$entry) {
          return false;
        }
      }
    } else if (l$values != lOther$values) {
      return false;
    }
    final l$valueRequired = valueRequired;
    final lOther$valueRequired = other.valueRequired;
    if (_$data.containsKey('valueRequired') !=
        other._$data.containsKey('valueRequired')) {
      return false;
    }
    if (l$valueRequired != lOther$valueRequired) {
      return false;
    }
    final l$isVariantOnly = isVariantOnly;
    final lOther$isVariantOnly = other.isVariantOnly;
    if (_$data.containsKey('isVariantOnly') !=
        other._$data.containsKey('isVariantOnly')) {
      return false;
    }
    if (l$isVariantOnly != lOther$isVariantOnly) {
      return false;
    }
    final l$visibleInStorefront = visibleInStorefront;
    final lOther$visibleInStorefront = other.visibleInStorefront;
    if (_$data.containsKey('visibleInStorefront') !=
        other._$data.containsKey('visibleInStorefront')) {
      return false;
    }
    if (l$visibleInStorefront != lOther$visibleInStorefront) {
      return false;
    }
    final l$filterableInStorefront = filterableInStorefront;
    final lOther$filterableInStorefront = other.filterableInStorefront;
    if (_$data.containsKey('filterableInStorefront') !=
        other._$data.containsKey('filterableInStorefront')) {
      return false;
    }
    if (l$filterableInStorefront != lOther$filterableInStorefront) {
      return false;
    }
    final l$filterableInDashboard = filterableInDashboard;
    final lOther$filterableInDashboard = other.filterableInDashboard;
    if (_$data.containsKey('filterableInDashboard') !=
        other._$data.containsKey('filterableInDashboard')) {
      return false;
    }
    if (l$filterableInDashboard != lOther$filterableInDashboard) {
      return false;
    }
    final l$storefrontSearchPosition = storefrontSearchPosition;
    final lOther$storefrontSearchPosition = other.storefrontSearchPosition;
    if (_$data.containsKey('storefrontSearchPosition') !=
        other._$data.containsKey('storefrontSearchPosition')) {
      return false;
    }
    if (l$storefrontSearchPosition != lOther$storefrontSearchPosition) {
      return false;
    }
    final l$availableInGrid = availableInGrid;
    final lOther$availableInGrid = other.availableInGrid;
    if (_$data.containsKey('availableInGrid') !=
        other._$data.containsKey('availableInGrid')) {
      return false;
    }
    if (l$availableInGrid != lOther$availableInGrid) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$inputType = inputType;
    final l$entityType = entityType;
    final l$name = name;
    final l$slug = slug;
    final l$type = type;
    final l$unit = unit;
    final l$values = values;
    final l$valueRequired = valueRequired;
    final l$isVariantOnly = isVariantOnly;
    final l$visibleInStorefront = visibleInStorefront;
    final l$filterableInStorefront = filterableInStorefront;
    final l$filterableInDashboard = filterableInDashboard;
    final l$storefrontSearchPosition = storefrontSearchPosition;
    final l$availableInGrid = availableInGrid;
    final l$externalReference = externalReference;
    return Object.hashAll([
      _$data.containsKey('inputType') ? l$inputType : const {},
      _$data.containsKey('entityType') ? l$entityType : const {},
      l$name,
      _$data.containsKey('slug') ? l$slug : const {},
      l$type,
      _$data.containsKey('unit') ? l$unit : const {},
      _$data.containsKey('values')
          ? l$values == null
              ? null
              : Object.hashAll(l$values.map((v) => v))
          : const {},
      _$data.containsKey('valueRequired') ? l$valueRequired : const {},
      _$data.containsKey('isVariantOnly') ? l$isVariantOnly : const {},
      _$data.containsKey('visibleInStorefront')
          ? l$visibleInStorefront
          : const {},
      _$data.containsKey('filterableInStorefront')
          ? l$filterableInStorefront
          : const {},
      _$data.containsKey('filterableInDashboard')
          ? l$filterableInDashboard
          : const {},
      _$data.containsKey('storefrontSearchPosition')
          ? l$storefrontSearchPosition
          : const {},
      _$data.containsKey('availableInGrid') ? l$availableInGrid : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
    ]);
  }
}

abstract class CopyWith$Input$AttributeCreateInput<TRes> {
  factory CopyWith$Input$AttributeCreateInput(
    Input$AttributeCreateInput instance,
    TRes Function(Input$AttributeCreateInput) then,
  ) = _CopyWithImpl$Input$AttributeCreateInput;

  factory CopyWith$Input$AttributeCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeCreateInput;

  TRes call({
    Enum$AttributeInputTypeEnum? inputType,
    Enum$AttributeEntityTypeEnum? entityType,
    String? name,
    String? slug,
    Enum$AttributeTypeEnum? type,
    Enum$MeasurementUnitsEnum? unit,
    List<Input$AttributeValueCreateInput>? values,
    bool? valueRequired,
    bool? isVariantOnly,
    bool? visibleInStorefront,
    bool? filterableInStorefront,
    bool? filterableInDashboard,
    int? storefrontSearchPosition,
    bool? availableInGrid,
    String? externalReference,
  });
  TRes values(
      Iterable<Input$AttributeValueCreateInput>? Function(
              Iterable<
                  CopyWith$Input$AttributeValueCreateInput<
                      Input$AttributeValueCreateInput>>?)
          _fn);
}

class _CopyWithImpl$Input$AttributeCreateInput<TRes>
    implements CopyWith$Input$AttributeCreateInput<TRes> {
  _CopyWithImpl$Input$AttributeCreateInput(
    this._instance,
    this._then,
  );

  final Input$AttributeCreateInput _instance;

  final TRes Function(Input$AttributeCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? inputType = _undefined,
    Object? entityType = _undefined,
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? type = _undefined,
    Object? unit = _undefined,
    Object? values = _undefined,
    Object? valueRequired = _undefined,
    Object? isVariantOnly = _undefined,
    Object? visibleInStorefront = _undefined,
    Object? filterableInStorefront = _undefined,
    Object? filterableInDashboard = _undefined,
    Object? storefrontSearchPosition = _undefined,
    Object? availableInGrid = _undefined,
    Object? externalReference = _undefined,
  }) =>
      _then(Input$AttributeCreateInput._({
        ..._instance._$data,
        if (inputType != _undefined)
          'inputType': (inputType as Enum$AttributeInputTypeEnum?),
        if (entityType != _undefined)
          'entityType': (entityType as Enum$AttributeEntityTypeEnum?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (slug != _undefined) 'slug': (slug as String?),
        if (type != _undefined && type != null)
          'type': (type as Enum$AttributeTypeEnum),
        if (unit != _undefined) 'unit': (unit as Enum$MeasurementUnitsEnum?),
        if (values != _undefined)
          'values': (values as List<Input$AttributeValueCreateInput>?),
        if (valueRequired != _undefined)
          'valueRequired': (valueRequired as bool?),
        if (isVariantOnly != _undefined)
          'isVariantOnly': (isVariantOnly as bool?),
        if (visibleInStorefront != _undefined)
          'visibleInStorefront': (visibleInStorefront as bool?),
        if (filterableInStorefront != _undefined)
          'filterableInStorefront': (filterableInStorefront as bool?),
        if (filterableInDashboard != _undefined)
          'filterableInDashboard': (filterableInDashboard as bool?),
        if (storefrontSearchPosition != _undefined)
          'storefrontSearchPosition': (storefrontSearchPosition as int?),
        if (availableInGrid != _undefined)
          'availableInGrid': (availableInGrid as bool?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
      }));

  TRes values(
          Iterable<Input$AttributeValueCreateInput>? Function(
                  Iterable<
                      CopyWith$Input$AttributeValueCreateInput<
                          Input$AttributeValueCreateInput>>?)
              _fn) =>
      call(
          values: _fn(_instance.values
              ?.map((e) => CopyWith$Input$AttributeValueCreateInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$AttributeCreateInput<TRes>
    implements CopyWith$Input$AttributeCreateInput<TRes> {
  _CopyWithStubImpl$Input$AttributeCreateInput(this._res);

  TRes _res;

  call({
    Enum$AttributeInputTypeEnum? inputType,
    Enum$AttributeEntityTypeEnum? entityType,
    String? name,
    String? slug,
    Enum$AttributeTypeEnum? type,
    Enum$MeasurementUnitsEnum? unit,
    List<Input$AttributeValueCreateInput>? values,
    bool? valueRequired,
    bool? isVariantOnly,
    bool? visibleInStorefront,
    bool? filterableInStorefront,
    bool? filterableInDashboard,
    int? storefrontSearchPosition,
    bool? availableInGrid,
    String? externalReference,
  }) =>
      _res;

  values(_fn) => _res;
}

class Input$AttributeEntityTypeEnumFilterInput {
  factory Input$AttributeEntityTypeEnumFilterInput({
    Enum$AttributeEntityTypeEnum? eq,
    List<Enum$AttributeEntityTypeEnum>? oneOf,
  }) =>
      Input$AttributeEntityTypeEnumFilterInput._({
        if (eq != null) r'eq': eq,
        if (oneOf != null) r'oneOf': oneOf,
      });

  Input$AttributeEntityTypeEnumFilterInput._(this._$data);

  factory Input$AttributeEntityTypeEnumFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$AttributeEntityTypeEnum((l$eq as String));
    }
    if (data.containsKey('oneOf')) {
      final l$oneOf = data['oneOf'];
      result$data['oneOf'] = (l$oneOf as List<dynamic>?)
          ?.map((e) => fromJson$Enum$AttributeEntityTypeEnum((e as String)))
          .toList();
    }
    return Input$AttributeEntityTypeEnumFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$AttributeEntityTypeEnum? get eq =>
      (_$data['eq'] as Enum$AttributeEntityTypeEnum?);

  List<Enum$AttributeEntityTypeEnum>? get oneOf =>
      (_$data['oneOf'] as List<Enum$AttributeEntityTypeEnum>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] =
          l$eq == null ? null : toJson$Enum$AttributeEntityTypeEnum(l$eq);
    }
    if (_$data.containsKey('oneOf')) {
      final l$oneOf = oneOf;
      result$data['oneOf'] =
          l$oneOf?.map((e) => toJson$Enum$AttributeEntityTypeEnum(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$AttributeEntityTypeEnumFilterInput<
          Input$AttributeEntityTypeEnumFilterInput>
      get copyWith => CopyWith$Input$AttributeEntityTypeEnumFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeEntityTypeEnumFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$oneOf = oneOf;
    final lOther$oneOf = other.oneOf;
    if (_$data.containsKey('oneOf') != other._$data.containsKey('oneOf')) {
      return false;
    }
    if (l$oneOf != null && lOther$oneOf != null) {
      if (l$oneOf.length != lOther$oneOf.length) {
        return false;
      }
      for (int i = 0; i < l$oneOf.length; i++) {
        final l$oneOf$entry = l$oneOf[i];
        final lOther$oneOf$entry = lOther$oneOf[i];
        if (l$oneOf$entry != lOther$oneOf$entry) {
          return false;
        }
      }
    } else if (l$oneOf != lOther$oneOf) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$oneOf = oneOf;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('oneOf')
          ? l$oneOf == null
              ? null
              : Object.hashAll(l$oneOf.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AttributeEntityTypeEnumFilterInput<TRes> {
  factory CopyWith$Input$AttributeEntityTypeEnumFilterInput(
    Input$AttributeEntityTypeEnumFilterInput instance,
    TRes Function(Input$AttributeEntityTypeEnumFilterInput) then,
  ) = _CopyWithImpl$Input$AttributeEntityTypeEnumFilterInput;

  factory CopyWith$Input$AttributeEntityTypeEnumFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeEntityTypeEnumFilterInput;

  TRes call({
    Enum$AttributeEntityTypeEnum? eq,
    List<Enum$AttributeEntityTypeEnum>? oneOf,
  });
}

class _CopyWithImpl$Input$AttributeEntityTypeEnumFilterInput<TRes>
    implements CopyWith$Input$AttributeEntityTypeEnumFilterInput<TRes> {
  _CopyWithImpl$Input$AttributeEntityTypeEnumFilterInput(
    this._instance,
    this._then,
  );

  final Input$AttributeEntityTypeEnumFilterInput _instance;

  final TRes Function(Input$AttributeEntityTypeEnumFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? oneOf = _undefined,
  }) =>
      _then(Input$AttributeEntityTypeEnumFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as Enum$AttributeEntityTypeEnum?),
        if (oneOf != _undefined)
          'oneOf': (oneOf as List<Enum$AttributeEntityTypeEnum>?),
      }));
}

class _CopyWithStubImpl$Input$AttributeEntityTypeEnumFilterInput<TRes>
    implements CopyWith$Input$AttributeEntityTypeEnumFilterInput<TRes> {
  _CopyWithStubImpl$Input$AttributeEntityTypeEnumFilterInput(this._res);

  TRes _res;

  call({
    Enum$AttributeEntityTypeEnum? eq,
    List<Enum$AttributeEntityTypeEnum>? oneOf,
  }) =>
      _res;
}

class Input$AttributeFilterInput {
  factory Input$AttributeFilterInput({
    bool? valueRequired,
    bool? isVariantOnly,
    bool? visibleInStorefront,
    bool? filterableInStorefront,
    bool? filterableInDashboard,
    bool? availableInGrid,
    List<Input$MetadataFilter>? metadata,
    String? search,
    List<String>? ids,
    Enum$AttributeTypeEnum? type,
    String? inCollection,
    String? inCategory,
    List<String>? slugs,
    String? channel,
  }) =>
      Input$AttributeFilterInput._({
        if (valueRequired != null) r'valueRequired': valueRequired,
        if (isVariantOnly != null) r'isVariantOnly': isVariantOnly,
        if (visibleInStorefront != null)
          r'visibleInStorefront': visibleInStorefront,
        if (filterableInStorefront != null)
          r'filterableInStorefront': filterableInStorefront,
        if (filterableInDashboard != null)
          r'filterableInDashboard': filterableInDashboard,
        if (availableInGrid != null) r'availableInGrid': availableInGrid,
        if (metadata != null) r'metadata': metadata,
        if (search != null) r'search': search,
        if (ids != null) r'ids': ids,
        if (type != null) r'type': type,
        if (inCollection != null) r'inCollection': inCollection,
        if (inCategory != null) r'inCategory': inCategory,
        if (slugs != null) r'slugs': slugs,
        if (channel != null) r'channel': channel,
      });

  Input$AttributeFilterInput._(this._$data);

  factory Input$AttributeFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('valueRequired')) {
      final l$valueRequired = data['valueRequired'];
      result$data['valueRequired'] = (l$valueRequired as bool?);
    }
    if (data.containsKey('isVariantOnly')) {
      final l$isVariantOnly = data['isVariantOnly'];
      result$data['isVariantOnly'] = (l$isVariantOnly as bool?);
    }
    if (data.containsKey('visibleInStorefront')) {
      final l$visibleInStorefront = data['visibleInStorefront'];
      result$data['visibleInStorefront'] = (l$visibleInStorefront as bool?);
    }
    if (data.containsKey('filterableInStorefront')) {
      final l$filterableInStorefront = data['filterableInStorefront'];
      result$data['filterableInStorefront'] =
          (l$filterableInStorefront as bool?);
    }
    if (data.containsKey('filterableInDashboard')) {
      final l$filterableInDashboard = data['filterableInDashboard'];
      result$data['filterableInDashboard'] = (l$filterableInDashboard as bool?);
    }
    if (data.containsKey('availableInGrid')) {
      final l$availableInGrid = data['availableInGrid'];
      result$data['availableInGrid'] = (l$availableInGrid as bool?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : fromJson$Enum$AttributeTypeEnum((l$type as String));
    }
    if (data.containsKey('inCollection')) {
      final l$inCollection = data['inCollection'];
      result$data['inCollection'] = (l$inCollection as String?);
    }
    if (data.containsKey('inCategory')) {
      final l$inCategory = data['inCategory'];
      result$data['inCategory'] = (l$inCategory as String?);
    }
    if (data.containsKey('slugs')) {
      final l$slugs = data['slugs'];
      result$data['slugs'] =
          (l$slugs as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('channel')) {
      final l$channel = data['channel'];
      result$data['channel'] = (l$channel as String?);
    }
    return Input$AttributeFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get valueRequired => (_$data['valueRequired'] as bool?);

  bool? get isVariantOnly => (_$data['isVariantOnly'] as bool?);

  bool? get visibleInStorefront => (_$data['visibleInStorefront'] as bool?);

  bool? get filterableInStorefront =>
      (_$data['filterableInStorefront'] as bool?);

  bool? get filterableInDashboard => (_$data['filterableInDashboard'] as bool?);

  bool? get availableInGrid => (_$data['availableInGrid'] as bool?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  String? get search => (_$data['search'] as String?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  Enum$AttributeTypeEnum? get type =>
      (_$data['type'] as Enum$AttributeTypeEnum?);

  String? get inCollection => (_$data['inCollection'] as String?);

  String? get inCategory => (_$data['inCategory'] as String?);

  List<String>? get slugs => (_$data['slugs'] as List<String>?);

  String? get channel => (_$data['channel'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('valueRequired')) {
      final l$valueRequired = valueRequired;
      result$data['valueRequired'] = l$valueRequired;
    }
    if (_$data.containsKey('isVariantOnly')) {
      final l$isVariantOnly = isVariantOnly;
      result$data['isVariantOnly'] = l$isVariantOnly;
    }
    if (_$data.containsKey('visibleInStorefront')) {
      final l$visibleInStorefront = visibleInStorefront;
      result$data['visibleInStorefront'] = l$visibleInStorefront;
    }
    if (_$data.containsKey('filterableInStorefront')) {
      final l$filterableInStorefront = filterableInStorefront;
      result$data['filterableInStorefront'] = l$filterableInStorefront;
    }
    if (_$data.containsKey('filterableInDashboard')) {
      final l$filterableInDashboard = filterableInDashboard;
      result$data['filterableInDashboard'] = l$filterableInDashboard;
    }
    if (_$data.containsKey('availableInGrid')) {
      final l$availableInGrid = availableInGrid;
      result$data['availableInGrid'] = l$availableInGrid;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] =
          l$type == null ? null : toJson$Enum$AttributeTypeEnum(l$type);
    }
    if (_$data.containsKey('inCollection')) {
      final l$inCollection = inCollection;
      result$data['inCollection'] = l$inCollection;
    }
    if (_$data.containsKey('inCategory')) {
      final l$inCategory = inCategory;
      result$data['inCategory'] = l$inCategory;
    }
    if (_$data.containsKey('slugs')) {
      final l$slugs = slugs;
      result$data['slugs'] = l$slugs?.map((e) => e).toList();
    }
    if (_$data.containsKey('channel')) {
      final l$channel = channel;
      result$data['channel'] = l$channel;
    }
    return result$data;
  }

  CopyWith$Input$AttributeFilterInput<Input$AttributeFilterInput>
      get copyWith => CopyWith$Input$AttributeFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$valueRequired = valueRequired;
    final lOther$valueRequired = other.valueRequired;
    if (_$data.containsKey('valueRequired') !=
        other._$data.containsKey('valueRequired')) {
      return false;
    }
    if (l$valueRequired != lOther$valueRequired) {
      return false;
    }
    final l$isVariantOnly = isVariantOnly;
    final lOther$isVariantOnly = other.isVariantOnly;
    if (_$data.containsKey('isVariantOnly') !=
        other._$data.containsKey('isVariantOnly')) {
      return false;
    }
    if (l$isVariantOnly != lOther$isVariantOnly) {
      return false;
    }
    final l$visibleInStorefront = visibleInStorefront;
    final lOther$visibleInStorefront = other.visibleInStorefront;
    if (_$data.containsKey('visibleInStorefront') !=
        other._$data.containsKey('visibleInStorefront')) {
      return false;
    }
    if (l$visibleInStorefront != lOther$visibleInStorefront) {
      return false;
    }
    final l$filterableInStorefront = filterableInStorefront;
    final lOther$filterableInStorefront = other.filterableInStorefront;
    if (_$data.containsKey('filterableInStorefront') !=
        other._$data.containsKey('filterableInStorefront')) {
      return false;
    }
    if (l$filterableInStorefront != lOther$filterableInStorefront) {
      return false;
    }
    final l$filterableInDashboard = filterableInDashboard;
    final lOther$filterableInDashboard = other.filterableInDashboard;
    if (_$data.containsKey('filterableInDashboard') !=
        other._$data.containsKey('filterableInDashboard')) {
      return false;
    }
    if (l$filterableInDashboard != lOther$filterableInDashboard) {
      return false;
    }
    final l$availableInGrid = availableInGrid;
    final lOther$availableInGrid = other.availableInGrid;
    if (_$data.containsKey('availableInGrid') !=
        other._$data.containsKey('availableInGrid')) {
      return false;
    }
    if (l$availableInGrid != lOther$availableInGrid) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$inCollection = inCollection;
    final lOther$inCollection = other.inCollection;
    if (_$data.containsKey('inCollection') !=
        other._$data.containsKey('inCollection')) {
      return false;
    }
    if (l$inCollection != lOther$inCollection) {
      return false;
    }
    final l$inCategory = inCategory;
    final lOther$inCategory = other.inCategory;
    if (_$data.containsKey('inCategory') !=
        other._$data.containsKey('inCategory')) {
      return false;
    }
    if (l$inCategory != lOther$inCategory) {
      return false;
    }
    final l$slugs = slugs;
    final lOther$slugs = other.slugs;
    if (_$data.containsKey('slugs') != other._$data.containsKey('slugs')) {
      return false;
    }
    if (l$slugs != null && lOther$slugs != null) {
      if (l$slugs.length != lOther$slugs.length) {
        return false;
      }
      for (int i = 0; i < l$slugs.length; i++) {
        final l$slugs$entry = l$slugs[i];
        final lOther$slugs$entry = lOther$slugs[i];
        if (l$slugs$entry != lOther$slugs$entry) {
          return false;
        }
      }
    } else if (l$slugs != lOther$slugs) {
      return false;
    }
    final l$channel = channel;
    final lOther$channel = other.channel;
    if (_$data.containsKey('channel') != other._$data.containsKey('channel')) {
      return false;
    }
    if (l$channel != lOther$channel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$valueRequired = valueRequired;
    final l$isVariantOnly = isVariantOnly;
    final l$visibleInStorefront = visibleInStorefront;
    final l$filterableInStorefront = filterableInStorefront;
    final l$filterableInDashboard = filterableInDashboard;
    final l$availableInGrid = availableInGrid;
    final l$metadata = metadata;
    final l$search = search;
    final l$ids = ids;
    final l$type = type;
    final l$inCollection = inCollection;
    final l$inCategory = inCategory;
    final l$slugs = slugs;
    final l$channel = channel;
    return Object.hashAll([
      _$data.containsKey('valueRequired') ? l$valueRequired : const {},
      _$data.containsKey('isVariantOnly') ? l$isVariantOnly : const {},
      _$data.containsKey('visibleInStorefront')
          ? l$visibleInStorefront
          : const {},
      _$data.containsKey('filterableInStorefront')
          ? l$filterableInStorefront
          : const {},
      _$data.containsKey('filterableInDashboard')
          ? l$filterableInDashboard
          : const {},
      _$data.containsKey('availableInGrid') ? l$availableInGrid : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('inCollection') ? l$inCollection : const {},
      _$data.containsKey('inCategory') ? l$inCategory : const {},
      _$data.containsKey('slugs')
          ? l$slugs == null
              ? null
              : Object.hashAll(l$slugs.map((v) => v))
          : const {},
      _$data.containsKey('channel') ? l$channel : const {},
    ]);
  }
}

abstract class CopyWith$Input$AttributeFilterInput<TRes> {
  factory CopyWith$Input$AttributeFilterInput(
    Input$AttributeFilterInput instance,
    TRes Function(Input$AttributeFilterInput) then,
  ) = _CopyWithImpl$Input$AttributeFilterInput;

  factory CopyWith$Input$AttributeFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeFilterInput;

  TRes call({
    bool? valueRequired,
    bool? isVariantOnly,
    bool? visibleInStorefront,
    bool? filterableInStorefront,
    bool? filterableInDashboard,
    bool? availableInGrid,
    List<Input$MetadataFilter>? metadata,
    String? search,
    List<String>? ids,
    Enum$AttributeTypeEnum? type,
    String? inCollection,
    String? inCategory,
    List<String>? slugs,
    String? channel,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
}

class _CopyWithImpl$Input$AttributeFilterInput<TRes>
    implements CopyWith$Input$AttributeFilterInput<TRes> {
  _CopyWithImpl$Input$AttributeFilterInput(
    this._instance,
    this._then,
  );

  final Input$AttributeFilterInput _instance;

  final TRes Function(Input$AttributeFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? valueRequired = _undefined,
    Object? isVariantOnly = _undefined,
    Object? visibleInStorefront = _undefined,
    Object? filterableInStorefront = _undefined,
    Object? filterableInDashboard = _undefined,
    Object? availableInGrid = _undefined,
    Object? metadata = _undefined,
    Object? search = _undefined,
    Object? ids = _undefined,
    Object? type = _undefined,
    Object? inCollection = _undefined,
    Object? inCategory = _undefined,
    Object? slugs = _undefined,
    Object? channel = _undefined,
  }) =>
      _then(Input$AttributeFilterInput._({
        ..._instance._$data,
        if (valueRequired != _undefined)
          'valueRequired': (valueRequired as bool?),
        if (isVariantOnly != _undefined)
          'isVariantOnly': (isVariantOnly as bool?),
        if (visibleInStorefront != _undefined)
          'visibleInStorefront': (visibleInStorefront as bool?),
        if (filterableInStorefront != _undefined)
          'filterableInStorefront': (filterableInStorefront as bool?),
        if (filterableInDashboard != _undefined)
          'filterableInDashboard': (filterableInDashboard as bool?),
        if (availableInGrid != _undefined)
          'availableInGrid': (availableInGrid as bool?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (search != _undefined) 'search': (search as String?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (type != _undefined) 'type': (type as Enum$AttributeTypeEnum?),
        if (inCollection != _undefined)
          'inCollection': (inCollection as String?),
        if (inCategory != _undefined) 'inCategory': (inCategory as String?),
        if (slugs != _undefined) 'slugs': (slugs as List<String>?),
        if (channel != _undefined) 'channel': (channel as String?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$AttributeFilterInput<TRes>
    implements CopyWith$Input$AttributeFilterInput<TRes> {
  _CopyWithStubImpl$Input$AttributeFilterInput(this._res);

  TRes _res;

  call({
    bool? valueRequired,
    bool? isVariantOnly,
    bool? visibleInStorefront,
    bool? filterableInStorefront,
    bool? filterableInDashboard,
    bool? availableInGrid,
    List<Input$MetadataFilter>? metadata,
    String? search,
    List<String>? ids,
    Enum$AttributeTypeEnum? type,
    String? inCollection,
    String? inCategory,
    List<String>? slugs,
    String? channel,
  }) =>
      _res;

  metadata(_fn) => _res;
}

class Input$AttributeInput {
  factory Input$AttributeInput({
    required String slug,
    List<String>? valueNames,
    List<String>? values,
    Input$IntRangeInput? valuesRange,
    Input$DateTimeRangeInput? dateTime,
    Input$DateRangeInput? date,
    bool? boolean,
  }) =>
      Input$AttributeInput._({
        r'slug': slug,
        if (valueNames != null) r'valueNames': valueNames,
        if (values != null) r'values': values,
        if (valuesRange != null) r'valuesRange': valuesRange,
        if (dateTime != null) r'dateTime': dateTime,
        if (date != null) r'date': date,
        if (boolean != null) r'boolean': boolean,
      });

  Input$AttributeInput._(this._$data);

  factory Input$AttributeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$slug = data['slug'];
    result$data['slug'] = (l$slug as String);
    if (data.containsKey('valueNames')) {
      final l$valueNames = data['valueNames'];
      result$data['valueNames'] =
          (l$valueNames as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('values')) {
      final l$values = data['values'];
      result$data['values'] =
          (l$values as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('valuesRange')) {
      final l$valuesRange = data['valuesRange'];
      result$data['valuesRange'] = l$valuesRange == null
          ? null
          : Input$IntRangeInput.fromJson(
              (l$valuesRange as Map<String, dynamic>));
    }
    if (data.containsKey('dateTime')) {
      final l$dateTime = data['dateTime'];
      result$data['dateTime'] = l$dateTime == null
          ? null
          : Input$DateTimeRangeInput.fromJson(
              (l$dateTime as Map<String, dynamic>));
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = l$date == null
          ? null
          : Input$DateRangeInput.fromJson((l$date as Map<String, dynamic>));
    }
    if (data.containsKey('boolean')) {
      final l$boolean = data['boolean'];
      result$data['boolean'] = (l$boolean as bool?);
    }
    return Input$AttributeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get slug => (_$data['slug'] as String);

  List<String>? get valueNames => (_$data['valueNames'] as List<String>?);

  List<String>? get values => (_$data['values'] as List<String>?);

  Input$IntRangeInput? get valuesRange =>
      (_$data['valuesRange'] as Input$IntRangeInput?);

  Input$DateTimeRangeInput? get dateTime =>
      (_$data['dateTime'] as Input$DateTimeRangeInput?);

  Input$DateRangeInput? get date => (_$data['date'] as Input$DateRangeInput?);

  bool? get boolean => (_$data['boolean'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$slug = slug;
    result$data['slug'] = l$slug;
    if (_$data.containsKey('valueNames')) {
      final l$valueNames = valueNames;
      result$data['valueNames'] = l$valueNames?.map((e) => e).toList();
    }
    if (_$data.containsKey('values')) {
      final l$values = values;
      result$data['values'] = l$values?.map((e) => e).toList();
    }
    if (_$data.containsKey('valuesRange')) {
      final l$valuesRange = valuesRange;
      result$data['valuesRange'] = l$valuesRange?.toJson();
    }
    if (_$data.containsKey('dateTime')) {
      final l$dateTime = dateTime;
      result$data['dateTime'] = l$dateTime?.toJson();
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date?.toJson();
    }
    if (_$data.containsKey('boolean')) {
      final l$boolean = boolean;
      result$data['boolean'] = l$boolean;
    }
    return result$data;
  }

  CopyWith$Input$AttributeInput<Input$AttributeInput> get copyWith =>
      CopyWith$Input$AttributeInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$valueNames = valueNames;
    final lOther$valueNames = other.valueNames;
    if (_$data.containsKey('valueNames') !=
        other._$data.containsKey('valueNames')) {
      return false;
    }
    if (l$valueNames != null && lOther$valueNames != null) {
      if (l$valueNames.length != lOther$valueNames.length) {
        return false;
      }
      for (int i = 0; i < l$valueNames.length; i++) {
        final l$valueNames$entry = l$valueNames[i];
        final lOther$valueNames$entry = lOther$valueNames[i];
        if (l$valueNames$entry != lOther$valueNames$entry) {
          return false;
        }
      }
    } else if (l$valueNames != lOther$valueNames) {
      return false;
    }
    final l$values = values;
    final lOther$values = other.values;
    if (_$data.containsKey('values') != other._$data.containsKey('values')) {
      return false;
    }
    if (l$values != null && lOther$values != null) {
      if (l$values.length != lOther$values.length) {
        return false;
      }
      for (int i = 0; i < l$values.length; i++) {
        final l$values$entry = l$values[i];
        final lOther$values$entry = lOther$values[i];
        if (l$values$entry != lOther$values$entry) {
          return false;
        }
      }
    } else if (l$values != lOther$values) {
      return false;
    }
    final l$valuesRange = valuesRange;
    final lOther$valuesRange = other.valuesRange;
    if (_$data.containsKey('valuesRange') !=
        other._$data.containsKey('valuesRange')) {
      return false;
    }
    if (l$valuesRange != lOther$valuesRange) {
      return false;
    }
    final l$dateTime = dateTime;
    final lOther$dateTime = other.dateTime;
    if (_$data.containsKey('dateTime') !=
        other._$data.containsKey('dateTime')) {
      return false;
    }
    if (l$dateTime != lOther$dateTime) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$boolean = boolean;
    final lOther$boolean = other.boolean;
    if (_$data.containsKey('boolean') != other._$data.containsKey('boolean')) {
      return false;
    }
    if (l$boolean != lOther$boolean) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$slug = slug;
    final l$valueNames = valueNames;
    final l$values = values;
    final l$valuesRange = valuesRange;
    final l$dateTime = dateTime;
    final l$date = date;
    final l$boolean = boolean;
    return Object.hashAll([
      l$slug,
      _$data.containsKey('valueNames')
          ? l$valueNames == null
              ? null
              : Object.hashAll(l$valueNames.map((v) => v))
          : const {},
      _$data.containsKey('values')
          ? l$values == null
              ? null
              : Object.hashAll(l$values.map((v) => v))
          : const {},
      _$data.containsKey('valuesRange') ? l$valuesRange : const {},
      _$data.containsKey('dateTime') ? l$dateTime : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('boolean') ? l$boolean : const {},
    ]);
  }
}

abstract class CopyWith$Input$AttributeInput<TRes> {
  factory CopyWith$Input$AttributeInput(
    Input$AttributeInput instance,
    TRes Function(Input$AttributeInput) then,
  ) = _CopyWithImpl$Input$AttributeInput;

  factory CopyWith$Input$AttributeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeInput;

  TRes call({
    String? slug,
    List<String>? valueNames,
    List<String>? values,
    Input$IntRangeInput? valuesRange,
    Input$DateTimeRangeInput? dateTime,
    Input$DateRangeInput? date,
    bool? boolean,
  });
  CopyWith$Input$IntRangeInput<TRes> get valuesRange;
  CopyWith$Input$DateTimeRangeInput<TRes> get dateTime;
  CopyWith$Input$DateRangeInput<TRes> get date;
}

class _CopyWithImpl$Input$AttributeInput<TRes>
    implements CopyWith$Input$AttributeInput<TRes> {
  _CopyWithImpl$Input$AttributeInput(
    this._instance,
    this._then,
  );

  final Input$AttributeInput _instance;

  final TRes Function(Input$AttributeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? slug = _undefined,
    Object? valueNames = _undefined,
    Object? values = _undefined,
    Object? valuesRange = _undefined,
    Object? dateTime = _undefined,
    Object? date = _undefined,
    Object? boolean = _undefined,
  }) =>
      _then(Input$AttributeInput._({
        ..._instance._$data,
        if (slug != _undefined && slug != null) 'slug': (slug as String),
        if (valueNames != _undefined)
          'valueNames': (valueNames as List<String>?),
        if (values != _undefined) 'values': (values as List<String>?),
        if (valuesRange != _undefined)
          'valuesRange': (valuesRange as Input$IntRangeInput?),
        if (dateTime != _undefined)
          'dateTime': (dateTime as Input$DateTimeRangeInput?),
        if (date != _undefined) 'date': (date as Input$DateRangeInput?),
        if (boolean != _undefined) 'boolean': (boolean as bool?),
      }));

  CopyWith$Input$IntRangeInput<TRes> get valuesRange {
    final local$valuesRange = _instance.valuesRange;
    return local$valuesRange == null
        ? CopyWith$Input$IntRangeInput.stub(_then(_instance))
        : CopyWith$Input$IntRangeInput(
            local$valuesRange, (e) => call(valuesRange: e));
  }

  CopyWith$Input$DateTimeRangeInput<TRes> get dateTime {
    final local$dateTime = _instance.dateTime;
    return local$dateTime == null
        ? CopyWith$Input$DateTimeRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeRangeInput(
            local$dateTime, (e) => call(dateTime: e));
  }

  CopyWith$Input$DateRangeInput<TRes> get date {
    final local$date = _instance.date;
    return local$date == null
        ? CopyWith$Input$DateRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateRangeInput(local$date, (e) => call(date: e));
  }
}

class _CopyWithStubImpl$Input$AttributeInput<TRes>
    implements CopyWith$Input$AttributeInput<TRes> {
  _CopyWithStubImpl$Input$AttributeInput(this._res);

  TRes _res;

  call({
    String? slug,
    List<String>? valueNames,
    List<String>? values,
    Input$IntRangeInput? valuesRange,
    Input$DateTimeRangeInput? dateTime,
    Input$DateRangeInput? date,
    bool? boolean,
  }) =>
      _res;

  CopyWith$Input$IntRangeInput<TRes> get valuesRange =>
      CopyWith$Input$IntRangeInput.stub(_res);

  CopyWith$Input$DateTimeRangeInput<TRes> get dateTime =>
      CopyWith$Input$DateTimeRangeInput.stub(_res);

  CopyWith$Input$DateRangeInput<TRes> get date =>
      CopyWith$Input$DateRangeInput.stub(_res);
}

class Input$AttributeInputTypeEnumFilterInput {
  factory Input$AttributeInputTypeEnumFilterInput({
    Enum$AttributeInputTypeEnum? eq,
    List<Enum$AttributeInputTypeEnum>? oneOf,
  }) =>
      Input$AttributeInputTypeEnumFilterInput._({
        if (eq != null) r'eq': eq,
        if (oneOf != null) r'oneOf': oneOf,
      });

  Input$AttributeInputTypeEnumFilterInput._(this._$data);

  factory Input$AttributeInputTypeEnumFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$AttributeInputTypeEnum((l$eq as String));
    }
    if (data.containsKey('oneOf')) {
      final l$oneOf = data['oneOf'];
      result$data['oneOf'] = (l$oneOf as List<dynamic>?)
          ?.map((e) => fromJson$Enum$AttributeInputTypeEnum((e as String)))
          .toList();
    }
    return Input$AttributeInputTypeEnumFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$AttributeInputTypeEnum? get eq =>
      (_$data['eq'] as Enum$AttributeInputTypeEnum?);

  List<Enum$AttributeInputTypeEnum>? get oneOf =>
      (_$data['oneOf'] as List<Enum$AttributeInputTypeEnum>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] =
          l$eq == null ? null : toJson$Enum$AttributeInputTypeEnum(l$eq);
    }
    if (_$data.containsKey('oneOf')) {
      final l$oneOf = oneOf;
      result$data['oneOf'] =
          l$oneOf?.map((e) => toJson$Enum$AttributeInputTypeEnum(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$AttributeInputTypeEnumFilterInput<
          Input$AttributeInputTypeEnumFilterInput>
      get copyWith => CopyWith$Input$AttributeInputTypeEnumFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeInputTypeEnumFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$oneOf = oneOf;
    final lOther$oneOf = other.oneOf;
    if (_$data.containsKey('oneOf') != other._$data.containsKey('oneOf')) {
      return false;
    }
    if (l$oneOf != null && lOther$oneOf != null) {
      if (l$oneOf.length != lOther$oneOf.length) {
        return false;
      }
      for (int i = 0; i < l$oneOf.length; i++) {
        final l$oneOf$entry = l$oneOf[i];
        final lOther$oneOf$entry = lOther$oneOf[i];
        if (l$oneOf$entry != lOther$oneOf$entry) {
          return false;
        }
      }
    } else if (l$oneOf != lOther$oneOf) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$oneOf = oneOf;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('oneOf')
          ? l$oneOf == null
              ? null
              : Object.hashAll(l$oneOf.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AttributeInputTypeEnumFilterInput<TRes> {
  factory CopyWith$Input$AttributeInputTypeEnumFilterInput(
    Input$AttributeInputTypeEnumFilterInput instance,
    TRes Function(Input$AttributeInputTypeEnumFilterInput) then,
  ) = _CopyWithImpl$Input$AttributeInputTypeEnumFilterInput;

  factory CopyWith$Input$AttributeInputTypeEnumFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeInputTypeEnumFilterInput;

  TRes call({
    Enum$AttributeInputTypeEnum? eq,
    List<Enum$AttributeInputTypeEnum>? oneOf,
  });
}

class _CopyWithImpl$Input$AttributeInputTypeEnumFilterInput<TRes>
    implements CopyWith$Input$AttributeInputTypeEnumFilterInput<TRes> {
  _CopyWithImpl$Input$AttributeInputTypeEnumFilterInput(
    this._instance,
    this._then,
  );

  final Input$AttributeInputTypeEnumFilterInput _instance;

  final TRes Function(Input$AttributeInputTypeEnumFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? oneOf = _undefined,
  }) =>
      _then(Input$AttributeInputTypeEnumFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as Enum$AttributeInputTypeEnum?),
        if (oneOf != _undefined)
          'oneOf': (oneOf as List<Enum$AttributeInputTypeEnum>?),
      }));
}

class _CopyWithStubImpl$Input$AttributeInputTypeEnumFilterInput<TRes>
    implements CopyWith$Input$AttributeInputTypeEnumFilterInput<TRes> {
  _CopyWithStubImpl$Input$AttributeInputTypeEnumFilterInput(this._res);

  TRes _res;

  call({
    Enum$AttributeInputTypeEnum? eq,
    List<Enum$AttributeInputTypeEnum>? oneOf,
  }) =>
      _res;
}

class Input$AttributeSortingInput {
  factory Input$AttributeSortingInput({
    required Enum$OrderDirection direction,
    required Enum$AttributeSortField field,
  }) =>
      Input$AttributeSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$AttributeSortingInput._(this._$data);

  factory Input$AttributeSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$AttributeSortField((l$field as String));
    return Input$AttributeSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$AttributeSortField get field =>
      (_$data['field'] as Enum$AttributeSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$AttributeSortField(l$field);
    return result$data;
  }

  CopyWith$Input$AttributeSortingInput<Input$AttributeSortingInput>
      get copyWith => CopyWith$Input$AttributeSortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$AttributeSortingInput<TRes> {
  factory CopyWith$Input$AttributeSortingInput(
    Input$AttributeSortingInput instance,
    TRes Function(Input$AttributeSortingInput) then,
  ) = _CopyWithImpl$Input$AttributeSortingInput;

  factory CopyWith$Input$AttributeSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$AttributeSortField? field,
  });
}

class _CopyWithImpl$Input$AttributeSortingInput<TRes>
    implements CopyWith$Input$AttributeSortingInput<TRes> {
  _CopyWithImpl$Input$AttributeSortingInput(
    this._instance,
    this._then,
  );

  final Input$AttributeSortingInput _instance;

  final TRes Function(Input$AttributeSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$AttributeSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$AttributeSortField),
      }));
}

class _CopyWithStubImpl$Input$AttributeSortingInput<TRes>
    implements CopyWith$Input$AttributeSortingInput<TRes> {
  _CopyWithStubImpl$Input$AttributeSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$AttributeSortField? field,
  }) =>
      _res;
}

class Input$AttributeTypeEnumFilterInput {
  factory Input$AttributeTypeEnumFilterInput({
    Enum$AttributeTypeEnum? eq,
    List<Enum$AttributeTypeEnum>? oneOf,
  }) =>
      Input$AttributeTypeEnumFilterInput._({
        if (eq != null) r'eq': eq,
        if (oneOf != null) r'oneOf': oneOf,
      });

  Input$AttributeTypeEnumFilterInput._(this._$data);

  factory Input$AttributeTypeEnumFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$AttributeTypeEnum((l$eq as String));
    }
    if (data.containsKey('oneOf')) {
      final l$oneOf = data['oneOf'];
      result$data['oneOf'] = (l$oneOf as List<dynamic>?)
          ?.map((e) => fromJson$Enum$AttributeTypeEnum((e as String)))
          .toList();
    }
    return Input$AttributeTypeEnumFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$AttributeTypeEnum? get eq => (_$data['eq'] as Enum$AttributeTypeEnum?);

  List<Enum$AttributeTypeEnum>? get oneOf =>
      (_$data['oneOf'] as List<Enum$AttributeTypeEnum>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] =
          l$eq == null ? null : toJson$Enum$AttributeTypeEnum(l$eq);
    }
    if (_$data.containsKey('oneOf')) {
      final l$oneOf = oneOf;
      result$data['oneOf'] =
          l$oneOf?.map((e) => toJson$Enum$AttributeTypeEnum(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$AttributeTypeEnumFilterInput<
          Input$AttributeTypeEnumFilterInput>
      get copyWith => CopyWith$Input$AttributeTypeEnumFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeTypeEnumFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$oneOf = oneOf;
    final lOther$oneOf = other.oneOf;
    if (_$data.containsKey('oneOf') != other._$data.containsKey('oneOf')) {
      return false;
    }
    if (l$oneOf != null && lOther$oneOf != null) {
      if (l$oneOf.length != lOther$oneOf.length) {
        return false;
      }
      for (int i = 0; i < l$oneOf.length; i++) {
        final l$oneOf$entry = l$oneOf[i];
        final lOther$oneOf$entry = lOther$oneOf[i];
        if (l$oneOf$entry != lOther$oneOf$entry) {
          return false;
        }
      }
    } else if (l$oneOf != lOther$oneOf) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$oneOf = oneOf;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('oneOf')
          ? l$oneOf == null
              ? null
              : Object.hashAll(l$oneOf.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AttributeTypeEnumFilterInput<TRes> {
  factory CopyWith$Input$AttributeTypeEnumFilterInput(
    Input$AttributeTypeEnumFilterInput instance,
    TRes Function(Input$AttributeTypeEnumFilterInput) then,
  ) = _CopyWithImpl$Input$AttributeTypeEnumFilterInput;

  factory CopyWith$Input$AttributeTypeEnumFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeTypeEnumFilterInput;

  TRes call({
    Enum$AttributeTypeEnum? eq,
    List<Enum$AttributeTypeEnum>? oneOf,
  });
}

class _CopyWithImpl$Input$AttributeTypeEnumFilterInput<TRes>
    implements CopyWith$Input$AttributeTypeEnumFilterInput<TRes> {
  _CopyWithImpl$Input$AttributeTypeEnumFilterInput(
    this._instance,
    this._then,
  );

  final Input$AttributeTypeEnumFilterInput _instance;

  final TRes Function(Input$AttributeTypeEnumFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? oneOf = _undefined,
  }) =>
      _then(Input$AttributeTypeEnumFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as Enum$AttributeTypeEnum?),
        if (oneOf != _undefined)
          'oneOf': (oneOf as List<Enum$AttributeTypeEnum>?),
      }));
}

class _CopyWithStubImpl$Input$AttributeTypeEnumFilterInput<TRes>
    implements CopyWith$Input$AttributeTypeEnumFilterInput<TRes> {
  _CopyWithStubImpl$Input$AttributeTypeEnumFilterInput(this._res);

  TRes _res;

  call({
    Enum$AttributeTypeEnum? eq,
    List<Enum$AttributeTypeEnum>? oneOf,
  }) =>
      _res;
}

class Input$AttributeUpdateInput {
  factory Input$AttributeUpdateInput({
    String? name,
    String? slug,
    Enum$MeasurementUnitsEnum? unit,
    List<String>? removeValues,
    List<Input$AttributeValueUpdateInput>? addValues,
    bool? valueRequired,
    bool? isVariantOnly,
    bool? visibleInStorefront,
    bool? filterableInStorefront,
    bool? filterableInDashboard,
    int? storefrontSearchPosition,
    bool? availableInGrid,
    String? externalReference,
  }) =>
      Input$AttributeUpdateInput._({
        if (name != null) r'name': name,
        if (slug != null) r'slug': slug,
        if (unit != null) r'unit': unit,
        if (removeValues != null) r'removeValues': removeValues,
        if (addValues != null) r'addValues': addValues,
        if (valueRequired != null) r'valueRequired': valueRequired,
        if (isVariantOnly != null) r'isVariantOnly': isVariantOnly,
        if (visibleInStorefront != null)
          r'visibleInStorefront': visibleInStorefront,
        if (filterableInStorefront != null)
          r'filterableInStorefront': filterableInStorefront,
        if (filterableInDashboard != null)
          r'filterableInDashboard': filterableInDashboard,
        if (storefrontSearchPosition != null)
          r'storefrontSearchPosition': storefrontSearchPosition,
        if (availableInGrid != null) r'availableInGrid': availableInGrid,
        if (externalReference != null) r'externalReference': externalReference,
      });

  Input$AttributeUpdateInput._(this._$data);

  factory Input$AttributeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('unit')) {
      final l$unit = data['unit'];
      result$data['unit'] = l$unit == null
          ? null
          : fromJson$Enum$MeasurementUnitsEnum((l$unit as String));
    }
    if (data.containsKey('removeValues')) {
      final l$removeValues = data['removeValues'];
      result$data['removeValues'] = (l$removeValues as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('addValues')) {
      final l$addValues = data['addValues'];
      result$data['addValues'] = (l$addValues as List<dynamic>?)
          ?.map((e) => Input$AttributeValueUpdateInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('valueRequired')) {
      final l$valueRequired = data['valueRequired'];
      result$data['valueRequired'] = (l$valueRequired as bool?);
    }
    if (data.containsKey('isVariantOnly')) {
      final l$isVariantOnly = data['isVariantOnly'];
      result$data['isVariantOnly'] = (l$isVariantOnly as bool?);
    }
    if (data.containsKey('visibleInStorefront')) {
      final l$visibleInStorefront = data['visibleInStorefront'];
      result$data['visibleInStorefront'] = (l$visibleInStorefront as bool?);
    }
    if (data.containsKey('filterableInStorefront')) {
      final l$filterableInStorefront = data['filterableInStorefront'];
      result$data['filterableInStorefront'] =
          (l$filterableInStorefront as bool?);
    }
    if (data.containsKey('filterableInDashboard')) {
      final l$filterableInDashboard = data['filterableInDashboard'];
      result$data['filterableInDashboard'] = (l$filterableInDashboard as bool?);
    }
    if (data.containsKey('storefrontSearchPosition')) {
      final l$storefrontSearchPosition = data['storefrontSearchPosition'];
      result$data['storefrontSearchPosition'] =
          (l$storefrontSearchPosition as int?);
    }
    if (data.containsKey('availableInGrid')) {
      final l$availableInGrid = data['availableInGrid'];
      result$data['availableInGrid'] = (l$availableInGrid as bool?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    return Input$AttributeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get slug => (_$data['slug'] as String?);

  Enum$MeasurementUnitsEnum? get unit =>
      (_$data['unit'] as Enum$MeasurementUnitsEnum?);

  List<String>? get removeValues => (_$data['removeValues'] as List<String>?);

  List<Input$AttributeValueUpdateInput>? get addValues =>
      (_$data['addValues'] as List<Input$AttributeValueUpdateInput>?);

  bool? get valueRequired => (_$data['valueRequired'] as bool?);

  bool? get isVariantOnly => (_$data['isVariantOnly'] as bool?);

  bool? get visibleInStorefront => (_$data['visibleInStorefront'] as bool?);

  bool? get filterableInStorefront =>
      (_$data['filterableInStorefront'] as bool?);

  bool? get filterableInDashboard => (_$data['filterableInDashboard'] as bool?);

  int? get storefrontSearchPosition =>
      (_$data['storefrontSearchPosition'] as int?);

  bool? get availableInGrid => (_$data['availableInGrid'] as bool?);

  String? get externalReference => (_$data['externalReference'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('unit')) {
      final l$unit = unit;
      result$data['unit'] =
          l$unit == null ? null : toJson$Enum$MeasurementUnitsEnum(l$unit);
    }
    if (_$data.containsKey('removeValues')) {
      final l$removeValues = removeValues;
      result$data['removeValues'] = l$removeValues?.map((e) => e).toList();
    }
    if (_$data.containsKey('addValues')) {
      final l$addValues = addValues;
      result$data['addValues'] = l$addValues?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('valueRequired')) {
      final l$valueRequired = valueRequired;
      result$data['valueRequired'] = l$valueRequired;
    }
    if (_$data.containsKey('isVariantOnly')) {
      final l$isVariantOnly = isVariantOnly;
      result$data['isVariantOnly'] = l$isVariantOnly;
    }
    if (_$data.containsKey('visibleInStorefront')) {
      final l$visibleInStorefront = visibleInStorefront;
      result$data['visibleInStorefront'] = l$visibleInStorefront;
    }
    if (_$data.containsKey('filterableInStorefront')) {
      final l$filterableInStorefront = filterableInStorefront;
      result$data['filterableInStorefront'] = l$filterableInStorefront;
    }
    if (_$data.containsKey('filterableInDashboard')) {
      final l$filterableInDashboard = filterableInDashboard;
      result$data['filterableInDashboard'] = l$filterableInDashboard;
    }
    if (_$data.containsKey('storefrontSearchPosition')) {
      final l$storefrontSearchPosition = storefrontSearchPosition;
      result$data['storefrontSearchPosition'] = l$storefrontSearchPosition;
    }
    if (_$data.containsKey('availableInGrid')) {
      final l$availableInGrid = availableInGrid;
      result$data['availableInGrid'] = l$availableInGrid;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    return result$data;
  }

  CopyWith$Input$AttributeUpdateInput<Input$AttributeUpdateInput>
      get copyWith => CopyWith$Input$AttributeUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$unit = unit;
    final lOther$unit = other.unit;
    if (_$data.containsKey('unit') != other._$data.containsKey('unit')) {
      return false;
    }
    if (l$unit != lOther$unit) {
      return false;
    }
    final l$removeValues = removeValues;
    final lOther$removeValues = other.removeValues;
    if (_$data.containsKey('removeValues') !=
        other._$data.containsKey('removeValues')) {
      return false;
    }
    if (l$removeValues != null && lOther$removeValues != null) {
      if (l$removeValues.length != lOther$removeValues.length) {
        return false;
      }
      for (int i = 0; i < l$removeValues.length; i++) {
        final l$removeValues$entry = l$removeValues[i];
        final lOther$removeValues$entry = lOther$removeValues[i];
        if (l$removeValues$entry != lOther$removeValues$entry) {
          return false;
        }
      }
    } else if (l$removeValues != lOther$removeValues) {
      return false;
    }
    final l$addValues = addValues;
    final lOther$addValues = other.addValues;
    if (_$data.containsKey('addValues') !=
        other._$data.containsKey('addValues')) {
      return false;
    }
    if (l$addValues != null && lOther$addValues != null) {
      if (l$addValues.length != lOther$addValues.length) {
        return false;
      }
      for (int i = 0; i < l$addValues.length; i++) {
        final l$addValues$entry = l$addValues[i];
        final lOther$addValues$entry = lOther$addValues[i];
        if (l$addValues$entry != lOther$addValues$entry) {
          return false;
        }
      }
    } else if (l$addValues != lOther$addValues) {
      return false;
    }
    final l$valueRequired = valueRequired;
    final lOther$valueRequired = other.valueRequired;
    if (_$data.containsKey('valueRequired') !=
        other._$data.containsKey('valueRequired')) {
      return false;
    }
    if (l$valueRequired != lOther$valueRequired) {
      return false;
    }
    final l$isVariantOnly = isVariantOnly;
    final lOther$isVariantOnly = other.isVariantOnly;
    if (_$data.containsKey('isVariantOnly') !=
        other._$data.containsKey('isVariantOnly')) {
      return false;
    }
    if (l$isVariantOnly != lOther$isVariantOnly) {
      return false;
    }
    final l$visibleInStorefront = visibleInStorefront;
    final lOther$visibleInStorefront = other.visibleInStorefront;
    if (_$data.containsKey('visibleInStorefront') !=
        other._$data.containsKey('visibleInStorefront')) {
      return false;
    }
    if (l$visibleInStorefront != lOther$visibleInStorefront) {
      return false;
    }
    final l$filterableInStorefront = filterableInStorefront;
    final lOther$filterableInStorefront = other.filterableInStorefront;
    if (_$data.containsKey('filterableInStorefront') !=
        other._$data.containsKey('filterableInStorefront')) {
      return false;
    }
    if (l$filterableInStorefront != lOther$filterableInStorefront) {
      return false;
    }
    final l$filterableInDashboard = filterableInDashboard;
    final lOther$filterableInDashboard = other.filterableInDashboard;
    if (_$data.containsKey('filterableInDashboard') !=
        other._$data.containsKey('filterableInDashboard')) {
      return false;
    }
    if (l$filterableInDashboard != lOther$filterableInDashboard) {
      return false;
    }
    final l$storefrontSearchPosition = storefrontSearchPosition;
    final lOther$storefrontSearchPosition = other.storefrontSearchPosition;
    if (_$data.containsKey('storefrontSearchPosition') !=
        other._$data.containsKey('storefrontSearchPosition')) {
      return false;
    }
    if (l$storefrontSearchPosition != lOther$storefrontSearchPosition) {
      return false;
    }
    final l$availableInGrid = availableInGrid;
    final lOther$availableInGrid = other.availableInGrid;
    if (_$data.containsKey('availableInGrid') !=
        other._$data.containsKey('availableInGrid')) {
      return false;
    }
    if (l$availableInGrid != lOther$availableInGrid) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$unit = unit;
    final l$removeValues = removeValues;
    final l$addValues = addValues;
    final l$valueRequired = valueRequired;
    final l$isVariantOnly = isVariantOnly;
    final l$visibleInStorefront = visibleInStorefront;
    final l$filterableInStorefront = filterableInStorefront;
    final l$filterableInDashboard = filterableInDashboard;
    final l$storefrontSearchPosition = storefrontSearchPosition;
    final l$availableInGrid = availableInGrid;
    final l$externalReference = externalReference;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('unit') ? l$unit : const {},
      _$data.containsKey('removeValues')
          ? l$removeValues == null
              ? null
              : Object.hashAll(l$removeValues.map((v) => v))
          : const {},
      _$data.containsKey('addValues')
          ? l$addValues == null
              ? null
              : Object.hashAll(l$addValues.map((v) => v))
          : const {},
      _$data.containsKey('valueRequired') ? l$valueRequired : const {},
      _$data.containsKey('isVariantOnly') ? l$isVariantOnly : const {},
      _$data.containsKey('visibleInStorefront')
          ? l$visibleInStorefront
          : const {},
      _$data.containsKey('filterableInStorefront')
          ? l$filterableInStorefront
          : const {},
      _$data.containsKey('filterableInDashboard')
          ? l$filterableInDashboard
          : const {},
      _$data.containsKey('storefrontSearchPosition')
          ? l$storefrontSearchPosition
          : const {},
      _$data.containsKey('availableInGrid') ? l$availableInGrid : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
    ]);
  }
}

abstract class CopyWith$Input$AttributeUpdateInput<TRes> {
  factory CopyWith$Input$AttributeUpdateInput(
    Input$AttributeUpdateInput instance,
    TRes Function(Input$AttributeUpdateInput) then,
  ) = _CopyWithImpl$Input$AttributeUpdateInput;

  factory CopyWith$Input$AttributeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeUpdateInput;

  TRes call({
    String? name,
    String? slug,
    Enum$MeasurementUnitsEnum? unit,
    List<String>? removeValues,
    List<Input$AttributeValueUpdateInput>? addValues,
    bool? valueRequired,
    bool? isVariantOnly,
    bool? visibleInStorefront,
    bool? filterableInStorefront,
    bool? filterableInDashboard,
    int? storefrontSearchPosition,
    bool? availableInGrid,
    String? externalReference,
  });
  TRes addValues(
      Iterable<Input$AttributeValueUpdateInput>? Function(
              Iterable<
                  CopyWith$Input$AttributeValueUpdateInput<
                      Input$AttributeValueUpdateInput>>?)
          _fn);
}

class _CopyWithImpl$Input$AttributeUpdateInput<TRes>
    implements CopyWith$Input$AttributeUpdateInput<TRes> {
  _CopyWithImpl$Input$AttributeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$AttributeUpdateInput _instance;

  final TRes Function(Input$AttributeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? unit = _undefined,
    Object? removeValues = _undefined,
    Object? addValues = _undefined,
    Object? valueRequired = _undefined,
    Object? isVariantOnly = _undefined,
    Object? visibleInStorefront = _undefined,
    Object? filterableInStorefront = _undefined,
    Object? filterableInDashboard = _undefined,
    Object? storefrontSearchPosition = _undefined,
    Object? availableInGrid = _undefined,
    Object? externalReference = _undefined,
  }) =>
      _then(Input$AttributeUpdateInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (slug != _undefined) 'slug': (slug as String?),
        if (unit != _undefined) 'unit': (unit as Enum$MeasurementUnitsEnum?),
        if (removeValues != _undefined)
          'removeValues': (removeValues as List<String>?),
        if (addValues != _undefined)
          'addValues': (addValues as List<Input$AttributeValueUpdateInput>?),
        if (valueRequired != _undefined)
          'valueRequired': (valueRequired as bool?),
        if (isVariantOnly != _undefined)
          'isVariantOnly': (isVariantOnly as bool?),
        if (visibleInStorefront != _undefined)
          'visibleInStorefront': (visibleInStorefront as bool?),
        if (filterableInStorefront != _undefined)
          'filterableInStorefront': (filterableInStorefront as bool?),
        if (filterableInDashboard != _undefined)
          'filterableInDashboard': (filterableInDashboard as bool?),
        if (storefrontSearchPosition != _undefined)
          'storefrontSearchPosition': (storefrontSearchPosition as int?),
        if (availableInGrid != _undefined)
          'availableInGrid': (availableInGrid as bool?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
      }));

  TRes addValues(
          Iterable<Input$AttributeValueUpdateInput>? Function(
                  Iterable<
                      CopyWith$Input$AttributeValueUpdateInput<
                          Input$AttributeValueUpdateInput>>?)
              _fn) =>
      call(
          addValues: _fn(_instance.addValues
              ?.map((e) => CopyWith$Input$AttributeValueUpdateInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$AttributeUpdateInput<TRes>
    implements CopyWith$Input$AttributeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$AttributeUpdateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? slug,
    Enum$MeasurementUnitsEnum? unit,
    List<String>? removeValues,
    List<Input$AttributeValueUpdateInput>? addValues,
    bool? valueRequired,
    bool? isVariantOnly,
    bool? visibleInStorefront,
    bool? filterableInStorefront,
    bool? filterableInDashboard,
    int? storefrontSearchPosition,
    bool? availableInGrid,
    String? externalReference,
  }) =>
      _res;

  addValues(_fn) => _res;
}

class Input$AttributeValueBulkTranslateInput {
  factory Input$AttributeValueBulkTranslateInput({
    String? id,
    String? externalReference,
    required Enum$LanguageCodeEnum languageCode,
    required Input$AttributeValueTranslationInput translationFields,
  }) =>
      Input$AttributeValueBulkTranslateInput._({
        if (id != null) r'id': id,
        if (externalReference != null) r'externalReference': externalReference,
        r'languageCode': languageCode,
        r'translationFields': translationFields,
      });

  Input$AttributeValueBulkTranslateInput._(this._$data);

  factory Input$AttributeValueBulkTranslateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    final l$languageCode = data['languageCode'];
    result$data['languageCode'] =
        fromJson$Enum$LanguageCodeEnum((l$languageCode as String));
    final l$translationFields = data['translationFields'];
    result$data['translationFields'] =
        Input$AttributeValueTranslationInput.fromJson(
            (l$translationFields as Map<String, dynamic>));
    return Input$AttributeValueBulkTranslateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get externalReference => (_$data['externalReference'] as String?);

  Enum$LanguageCodeEnum get languageCode =>
      (_$data['languageCode'] as Enum$LanguageCodeEnum);

  Input$AttributeValueTranslationInput get translationFields =>
      (_$data['translationFields'] as Input$AttributeValueTranslationInput);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    final l$languageCode = languageCode;
    result$data['languageCode'] = toJson$Enum$LanguageCodeEnum(l$languageCode);
    final l$translationFields = translationFields;
    result$data['translationFields'] = l$translationFields.toJson();
    return result$data;
  }

  CopyWith$Input$AttributeValueBulkTranslateInput<
          Input$AttributeValueBulkTranslateInput>
      get copyWith => CopyWith$Input$AttributeValueBulkTranslateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeValueBulkTranslateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$languageCode = languageCode;
    final lOther$languageCode = other.languageCode;
    if (l$languageCode != lOther$languageCode) {
      return false;
    }
    final l$translationFields = translationFields;
    final lOther$translationFields = other.translationFields;
    if (l$translationFields != lOther$translationFields) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$externalReference = externalReference;
    final l$languageCode = languageCode;
    final l$translationFields = translationFields;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      l$languageCode,
      l$translationFields,
    ]);
  }
}

abstract class CopyWith$Input$AttributeValueBulkTranslateInput<TRes> {
  factory CopyWith$Input$AttributeValueBulkTranslateInput(
    Input$AttributeValueBulkTranslateInput instance,
    TRes Function(Input$AttributeValueBulkTranslateInput) then,
  ) = _CopyWithImpl$Input$AttributeValueBulkTranslateInput;

  factory CopyWith$Input$AttributeValueBulkTranslateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeValueBulkTranslateInput;

  TRes call({
    String? id,
    String? externalReference,
    Enum$LanguageCodeEnum? languageCode,
    Input$AttributeValueTranslationInput? translationFields,
  });
  CopyWith$Input$AttributeValueTranslationInput<TRes> get translationFields;
}

class _CopyWithImpl$Input$AttributeValueBulkTranslateInput<TRes>
    implements CopyWith$Input$AttributeValueBulkTranslateInput<TRes> {
  _CopyWithImpl$Input$AttributeValueBulkTranslateInput(
    this._instance,
    this._then,
  );

  final Input$AttributeValueBulkTranslateInput _instance;

  final TRes Function(Input$AttributeValueBulkTranslateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? externalReference = _undefined,
    Object? languageCode = _undefined,
    Object? translationFields = _undefined,
  }) =>
      _then(Input$AttributeValueBulkTranslateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (languageCode != _undefined && languageCode != null)
          'languageCode': (languageCode as Enum$LanguageCodeEnum),
        if (translationFields != _undefined && translationFields != null)
          'translationFields':
              (translationFields as Input$AttributeValueTranslationInput),
      }));

  CopyWith$Input$AttributeValueTranslationInput<TRes> get translationFields {
    final local$translationFields = _instance.translationFields;
    return CopyWith$Input$AttributeValueTranslationInput(
        local$translationFields, (e) => call(translationFields: e));
  }
}

class _CopyWithStubImpl$Input$AttributeValueBulkTranslateInput<TRes>
    implements CopyWith$Input$AttributeValueBulkTranslateInput<TRes> {
  _CopyWithStubImpl$Input$AttributeValueBulkTranslateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? externalReference,
    Enum$LanguageCodeEnum? languageCode,
    Input$AttributeValueTranslationInput? translationFields,
  }) =>
      _res;

  CopyWith$Input$AttributeValueTranslationInput<TRes> get translationFields =>
      CopyWith$Input$AttributeValueTranslationInput.stub(_res);
}

class Input$AttributeValueCreateInput {
  factory Input$AttributeValueCreateInput({
    String? value,
    String? richText,
    String? plainText,
    String? fileUrl,
    String? contentType,
    String? externalReference,
    required String name,
  }) =>
      Input$AttributeValueCreateInput._({
        if (value != null) r'value': value,
        if (richText != null) r'richText': richText,
        if (plainText != null) r'plainText': plainText,
        if (fileUrl != null) r'fileUrl': fileUrl,
        if (contentType != null) r'contentType': contentType,
        if (externalReference != null) r'externalReference': externalReference,
        r'name': name,
      });

  Input$AttributeValueCreateInput._(this._$data);

  factory Input$AttributeValueCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('value')) {
      final l$value = data['value'];
      result$data['value'] = (l$value as String?);
    }
    if (data.containsKey('richText')) {
      final l$richText = data['richText'];
      result$data['richText'] = (l$richText as String?);
    }
    if (data.containsKey('plainText')) {
      final l$plainText = data['plainText'];
      result$data['plainText'] = (l$plainText as String?);
    }
    if (data.containsKey('fileUrl')) {
      final l$fileUrl = data['fileUrl'];
      result$data['fileUrl'] = (l$fileUrl as String?);
    }
    if (data.containsKey('contentType')) {
      final l$contentType = data['contentType'];
      result$data['contentType'] = (l$contentType as String?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    return Input$AttributeValueCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get value => (_$data['value'] as String?);

  String? get richText => (_$data['richText'] as String?);

  String? get plainText => (_$data['plainText'] as String?);

  String? get fileUrl => (_$data['fileUrl'] as String?);

  String? get contentType => (_$data['contentType'] as String?);

  String? get externalReference => (_$data['externalReference'] as String?);

  String get name => (_$data['name'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('value')) {
      final l$value = value;
      result$data['value'] = l$value;
    }
    if (_$data.containsKey('richText')) {
      final l$richText = richText;
      result$data['richText'] = l$richText;
    }
    if (_$data.containsKey('plainText')) {
      final l$plainText = plainText;
      result$data['plainText'] = l$plainText;
    }
    if (_$data.containsKey('fileUrl')) {
      final l$fileUrl = fileUrl;
      result$data['fileUrl'] = l$fileUrl;
    }
    if (_$data.containsKey('contentType')) {
      final l$contentType = contentType;
      result$data['contentType'] = l$contentType;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    final l$name = name;
    result$data['name'] = l$name;
    return result$data;
  }

  CopyWith$Input$AttributeValueCreateInput<Input$AttributeValueCreateInput>
      get copyWith => CopyWith$Input$AttributeValueCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeValueCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (_$data.containsKey('value') != other._$data.containsKey('value')) {
      return false;
    }
    if (l$value != lOther$value) {
      return false;
    }
    final l$richText = richText;
    final lOther$richText = other.richText;
    if (_$data.containsKey('richText') !=
        other._$data.containsKey('richText')) {
      return false;
    }
    if (l$richText != lOther$richText) {
      return false;
    }
    final l$plainText = plainText;
    final lOther$plainText = other.plainText;
    if (_$data.containsKey('plainText') !=
        other._$data.containsKey('plainText')) {
      return false;
    }
    if (l$plainText != lOther$plainText) {
      return false;
    }
    final l$fileUrl = fileUrl;
    final lOther$fileUrl = other.fileUrl;
    if (_$data.containsKey('fileUrl') != other._$data.containsKey('fileUrl')) {
      return false;
    }
    if (l$fileUrl != lOther$fileUrl) {
      return false;
    }
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (_$data.containsKey('contentType') !=
        other._$data.containsKey('contentType')) {
      return false;
    }
    if (l$contentType != lOther$contentType) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$value = value;
    final l$richText = richText;
    final l$plainText = plainText;
    final l$fileUrl = fileUrl;
    final l$contentType = contentType;
    final l$externalReference = externalReference;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('value') ? l$value : const {},
      _$data.containsKey('richText') ? l$richText : const {},
      _$data.containsKey('plainText') ? l$plainText : const {},
      _$data.containsKey('fileUrl') ? l$fileUrl : const {},
      _$data.containsKey('contentType') ? l$contentType : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      l$name,
    ]);
  }
}

abstract class CopyWith$Input$AttributeValueCreateInput<TRes> {
  factory CopyWith$Input$AttributeValueCreateInput(
    Input$AttributeValueCreateInput instance,
    TRes Function(Input$AttributeValueCreateInput) then,
  ) = _CopyWithImpl$Input$AttributeValueCreateInput;

  factory CopyWith$Input$AttributeValueCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeValueCreateInput;

  TRes call({
    String? value,
    String? richText,
    String? plainText,
    String? fileUrl,
    String? contentType,
    String? externalReference,
    String? name,
  });
}

class _CopyWithImpl$Input$AttributeValueCreateInput<TRes>
    implements CopyWith$Input$AttributeValueCreateInput<TRes> {
  _CopyWithImpl$Input$AttributeValueCreateInput(
    this._instance,
    this._then,
  );

  final Input$AttributeValueCreateInput _instance;

  final TRes Function(Input$AttributeValueCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? value = _undefined,
    Object? richText = _undefined,
    Object? plainText = _undefined,
    Object? fileUrl = _undefined,
    Object? contentType = _undefined,
    Object? externalReference = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$AttributeValueCreateInput._({
        ..._instance._$data,
        if (value != _undefined) 'value': (value as String?),
        if (richText != _undefined) 'richText': (richText as String?),
        if (plainText != _undefined) 'plainText': (plainText as String?),
        if (fileUrl != _undefined) 'fileUrl': (fileUrl as String?),
        if (contentType != _undefined) 'contentType': (contentType as String?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (name != _undefined && name != null) 'name': (name as String),
      }));
}

class _CopyWithStubImpl$Input$AttributeValueCreateInput<TRes>
    implements CopyWith$Input$AttributeValueCreateInput<TRes> {
  _CopyWithStubImpl$Input$AttributeValueCreateInput(this._res);

  TRes _res;

  call({
    String? value,
    String? richText,
    String? plainText,
    String? fileUrl,
    String? contentType,
    String? externalReference,
    String? name,
  }) =>
      _res;
}

class Input$AttributeValueFilterInput {
  factory Input$AttributeValueFilterInput({
    String? search,
    List<String>? ids,
    List<String>? slugs,
  }) =>
      Input$AttributeValueFilterInput._({
        if (search != null) r'search': search,
        if (ids != null) r'ids': ids,
        if (slugs != null) r'slugs': slugs,
      });

  Input$AttributeValueFilterInput._(this._$data);

  factory Input$AttributeValueFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('slugs')) {
      final l$slugs = data['slugs'];
      result$data['slugs'] =
          (l$slugs as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$AttributeValueFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get search => (_$data['search'] as String?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  List<String>? get slugs => (_$data['slugs'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('slugs')) {
      final l$slugs = slugs;
      result$data['slugs'] = l$slugs?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$AttributeValueFilterInput<Input$AttributeValueFilterInput>
      get copyWith => CopyWith$Input$AttributeValueFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeValueFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$slugs = slugs;
    final lOther$slugs = other.slugs;
    if (_$data.containsKey('slugs') != other._$data.containsKey('slugs')) {
      return false;
    }
    if (l$slugs != null && lOther$slugs != null) {
      if (l$slugs.length != lOther$slugs.length) {
        return false;
      }
      for (int i = 0; i < l$slugs.length; i++) {
        final l$slugs$entry = l$slugs[i];
        final lOther$slugs$entry = lOther$slugs[i];
        if (l$slugs$entry != lOther$slugs$entry) {
          return false;
        }
      }
    } else if (l$slugs != lOther$slugs) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$search = search;
    final l$ids = ids;
    final l$slugs = slugs;
    return Object.hashAll([
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('slugs')
          ? l$slugs == null
              ? null
              : Object.hashAll(l$slugs.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AttributeValueFilterInput<TRes> {
  factory CopyWith$Input$AttributeValueFilterInput(
    Input$AttributeValueFilterInput instance,
    TRes Function(Input$AttributeValueFilterInput) then,
  ) = _CopyWithImpl$Input$AttributeValueFilterInput;

  factory CopyWith$Input$AttributeValueFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeValueFilterInput;

  TRes call({
    String? search,
    List<String>? ids,
    List<String>? slugs,
  });
}

class _CopyWithImpl$Input$AttributeValueFilterInput<TRes>
    implements CopyWith$Input$AttributeValueFilterInput<TRes> {
  _CopyWithImpl$Input$AttributeValueFilterInput(
    this._instance,
    this._then,
  );

  final Input$AttributeValueFilterInput _instance;

  final TRes Function(Input$AttributeValueFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? search = _undefined,
    Object? ids = _undefined,
    Object? slugs = _undefined,
  }) =>
      _then(Input$AttributeValueFilterInput._({
        ..._instance._$data,
        if (search != _undefined) 'search': (search as String?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (slugs != _undefined) 'slugs': (slugs as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$AttributeValueFilterInput<TRes>
    implements CopyWith$Input$AttributeValueFilterInput<TRes> {
  _CopyWithStubImpl$Input$AttributeValueFilterInput(this._res);

  TRes _res;

  call({
    String? search,
    List<String>? ids,
    List<String>? slugs,
  }) =>
      _res;
}

class Input$AttributeValueInput {
  factory Input$AttributeValueInput({
    String? id,
    String? externalReference,
    List<String>? values,
    Input$AttributeValueSelectableTypeInput? dropdown,
    Input$AttributeValueSelectableTypeInput? swatch,
    List<Input$AttributeValueSelectableTypeInput>? multiselect,
    String? numeric,
    String? file,
    String? contentType,
    List<String>? references,
    String? richText,
    String? plainText,
    bool? boolean,
    String? date,
    String? dateTime,
  }) =>
      Input$AttributeValueInput._({
        if (id != null) r'id': id,
        if (externalReference != null) r'externalReference': externalReference,
        if (values != null) r'values': values,
        if (dropdown != null) r'dropdown': dropdown,
        if (swatch != null) r'swatch': swatch,
        if (multiselect != null) r'multiselect': multiselect,
        if (numeric != null) r'numeric': numeric,
        if (file != null) r'file': file,
        if (contentType != null) r'contentType': contentType,
        if (references != null) r'references': references,
        if (richText != null) r'richText': richText,
        if (plainText != null) r'plainText': plainText,
        if (boolean != null) r'boolean': boolean,
        if (date != null) r'date': date,
        if (dateTime != null) r'dateTime': dateTime,
      });

  Input$AttributeValueInput._(this._$data);

  factory Input$AttributeValueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    if (data.containsKey('values')) {
      final l$values = data['values'];
      result$data['values'] =
          (l$values as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('dropdown')) {
      final l$dropdown = data['dropdown'];
      result$data['dropdown'] = l$dropdown == null
          ? null
          : Input$AttributeValueSelectableTypeInput.fromJson(
              (l$dropdown as Map<String, dynamic>));
    }
    if (data.containsKey('swatch')) {
      final l$swatch = data['swatch'];
      result$data['swatch'] = l$swatch == null
          ? null
          : Input$AttributeValueSelectableTypeInput.fromJson(
              (l$swatch as Map<String, dynamic>));
    }
    if (data.containsKey('multiselect')) {
      final l$multiselect = data['multiselect'];
      result$data['multiselect'] = (l$multiselect as List<dynamic>?)
          ?.map((e) => Input$AttributeValueSelectableTypeInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('numeric')) {
      final l$numeric = data['numeric'];
      result$data['numeric'] = (l$numeric as String?);
    }
    if (data.containsKey('file')) {
      final l$file = data['file'];
      result$data['file'] = (l$file as String?);
    }
    if (data.containsKey('contentType')) {
      final l$contentType = data['contentType'];
      result$data['contentType'] = (l$contentType as String?);
    }
    if (data.containsKey('references')) {
      final l$references = data['references'];
      result$data['references'] =
          (l$references as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('richText')) {
      final l$richText = data['richText'];
      result$data['richText'] = (l$richText as String?);
    }
    if (data.containsKey('plainText')) {
      final l$plainText = data['plainText'];
      result$data['plainText'] = (l$plainText as String?);
    }
    if (data.containsKey('boolean')) {
      final l$boolean = data['boolean'];
      result$data['boolean'] = (l$boolean as bool?);
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = (l$date as String?);
    }
    if (data.containsKey('dateTime')) {
      final l$dateTime = data['dateTime'];
      result$data['dateTime'] = (l$dateTime as String?);
    }
    return Input$AttributeValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get externalReference => (_$data['externalReference'] as String?);

  List<String>? get values => (_$data['values'] as List<String>?);

  Input$AttributeValueSelectableTypeInput? get dropdown =>
      (_$data['dropdown'] as Input$AttributeValueSelectableTypeInput?);

  Input$AttributeValueSelectableTypeInput? get swatch =>
      (_$data['swatch'] as Input$AttributeValueSelectableTypeInput?);

  List<Input$AttributeValueSelectableTypeInput>? get multiselect =>
      (_$data['multiselect'] as List<Input$AttributeValueSelectableTypeInput>?);

  String? get numeric => (_$data['numeric'] as String?);

  String? get file => (_$data['file'] as String?);

  String? get contentType => (_$data['contentType'] as String?);

  List<String>? get references => (_$data['references'] as List<String>?);

  String? get richText => (_$data['richText'] as String?);

  String? get plainText => (_$data['plainText'] as String?);

  bool? get boolean => (_$data['boolean'] as bool?);

  String? get date => (_$data['date'] as String?);

  String? get dateTime => (_$data['dateTime'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    if (_$data.containsKey('values')) {
      final l$values = values;
      result$data['values'] = l$values?.map((e) => e).toList();
    }
    if (_$data.containsKey('dropdown')) {
      final l$dropdown = dropdown;
      result$data['dropdown'] = l$dropdown?.toJson();
    }
    if (_$data.containsKey('swatch')) {
      final l$swatch = swatch;
      result$data['swatch'] = l$swatch?.toJson();
    }
    if (_$data.containsKey('multiselect')) {
      final l$multiselect = multiselect;
      result$data['multiselect'] =
          l$multiselect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('numeric')) {
      final l$numeric = numeric;
      result$data['numeric'] = l$numeric;
    }
    if (_$data.containsKey('file')) {
      final l$file = file;
      result$data['file'] = l$file;
    }
    if (_$data.containsKey('contentType')) {
      final l$contentType = contentType;
      result$data['contentType'] = l$contentType;
    }
    if (_$data.containsKey('references')) {
      final l$references = references;
      result$data['references'] = l$references?.map((e) => e).toList();
    }
    if (_$data.containsKey('richText')) {
      final l$richText = richText;
      result$data['richText'] = l$richText;
    }
    if (_$data.containsKey('plainText')) {
      final l$plainText = plainText;
      result$data['plainText'] = l$plainText;
    }
    if (_$data.containsKey('boolean')) {
      final l$boolean = boolean;
      result$data['boolean'] = l$boolean;
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date;
    }
    if (_$data.containsKey('dateTime')) {
      final l$dateTime = dateTime;
      result$data['dateTime'] = l$dateTime;
    }
    return result$data;
  }

  CopyWith$Input$AttributeValueInput<Input$AttributeValueInput> get copyWith =>
      CopyWith$Input$AttributeValueInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeValueInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$values = values;
    final lOther$values = other.values;
    if (_$data.containsKey('values') != other._$data.containsKey('values')) {
      return false;
    }
    if (l$values != null && lOther$values != null) {
      if (l$values.length != lOther$values.length) {
        return false;
      }
      for (int i = 0; i < l$values.length; i++) {
        final l$values$entry = l$values[i];
        final lOther$values$entry = lOther$values[i];
        if (l$values$entry != lOther$values$entry) {
          return false;
        }
      }
    } else if (l$values != lOther$values) {
      return false;
    }
    final l$dropdown = dropdown;
    final lOther$dropdown = other.dropdown;
    if (_$data.containsKey('dropdown') !=
        other._$data.containsKey('dropdown')) {
      return false;
    }
    if (l$dropdown != lOther$dropdown) {
      return false;
    }
    final l$swatch = swatch;
    final lOther$swatch = other.swatch;
    if (_$data.containsKey('swatch') != other._$data.containsKey('swatch')) {
      return false;
    }
    if (l$swatch != lOther$swatch) {
      return false;
    }
    final l$multiselect = multiselect;
    final lOther$multiselect = other.multiselect;
    if (_$data.containsKey('multiselect') !=
        other._$data.containsKey('multiselect')) {
      return false;
    }
    if (l$multiselect != null && lOther$multiselect != null) {
      if (l$multiselect.length != lOther$multiselect.length) {
        return false;
      }
      for (int i = 0; i < l$multiselect.length; i++) {
        final l$multiselect$entry = l$multiselect[i];
        final lOther$multiselect$entry = lOther$multiselect[i];
        if (l$multiselect$entry != lOther$multiselect$entry) {
          return false;
        }
      }
    } else if (l$multiselect != lOther$multiselect) {
      return false;
    }
    final l$numeric = numeric;
    final lOther$numeric = other.numeric;
    if (_$data.containsKey('numeric') != other._$data.containsKey('numeric')) {
      return false;
    }
    if (l$numeric != lOther$numeric) {
      return false;
    }
    final l$file = file;
    final lOther$file = other.file;
    if (_$data.containsKey('file') != other._$data.containsKey('file')) {
      return false;
    }
    if (l$file != lOther$file) {
      return false;
    }
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (_$data.containsKey('contentType') !=
        other._$data.containsKey('contentType')) {
      return false;
    }
    if (l$contentType != lOther$contentType) {
      return false;
    }
    final l$references = references;
    final lOther$references = other.references;
    if (_$data.containsKey('references') !=
        other._$data.containsKey('references')) {
      return false;
    }
    if (l$references != null && lOther$references != null) {
      if (l$references.length != lOther$references.length) {
        return false;
      }
      for (int i = 0; i < l$references.length; i++) {
        final l$references$entry = l$references[i];
        final lOther$references$entry = lOther$references[i];
        if (l$references$entry != lOther$references$entry) {
          return false;
        }
      }
    } else if (l$references != lOther$references) {
      return false;
    }
    final l$richText = richText;
    final lOther$richText = other.richText;
    if (_$data.containsKey('richText') !=
        other._$data.containsKey('richText')) {
      return false;
    }
    if (l$richText != lOther$richText) {
      return false;
    }
    final l$plainText = plainText;
    final lOther$plainText = other.plainText;
    if (_$data.containsKey('plainText') !=
        other._$data.containsKey('plainText')) {
      return false;
    }
    if (l$plainText != lOther$plainText) {
      return false;
    }
    final l$boolean = boolean;
    final lOther$boolean = other.boolean;
    if (_$data.containsKey('boolean') != other._$data.containsKey('boolean')) {
      return false;
    }
    if (l$boolean != lOther$boolean) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$dateTime = dateTime;
    final lOther$dateTime = other.dateTime;
    if (_$data.containsKey('dateTime') !=
        other._$data.containsKey('dateTime')) {
      return false;
    }
    if (l$dateTime != lOther$dateTime) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$externalReference = externalReference;
    final l$values = values;
    final l$dropdown = dropdown;
    final l$swatch = swatch;
    final l$multiselect = multiselect;
    final l$numeric = numeric;
    final l$file = file;
    final l$contentType = contentType;
    final l$references = references;
    final l$richText = richText;
    final l$plainText = plainText;
    final l$boolean = boolean;
    final l$date = date;
    final l$dateTime = dateTime;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      _$data.containsKey('values')
          ? l$values == null
              ? null
              : Object.hashAll(l$values.map((v) => v))
          : const {},
      _$data.containsKey('dropdown') ? l$dropdown : const {},
      _$data.containsKey('swatch') ? l$swatch : const {},
      _$data.containsKey('multiselect')
          ? l$multiselect == null
              ? null
              : Object.hashAll(l$multiselect.map((v) => v))
          : const {},
      _$data.containsKey('numeric') ? l$numeric : const {},
      _$data.containsKey('file') ? l$file : const {},
      _$data.containsKey('contentType') ? l$contentType : const {},
      _$data.containsKey('references')
          ? l$references == null
              ? null
              : Object.hashAll(l$references.map((v) => v))
          : const {},
      _$data.containsKey('richText') ? l$richText : const {},
      _$data.containsKey('plainText') ? l$plainText : const {},
      _$data.containsKey('boolean') ? l$boolean : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('dateTime') ? l$dateTime : const {},
    ]);
  }
}

abstract class CopyWith$Input$AttributeValueInput<TRes> {
  factory CopyWith$Input$AttributeValueInput(
    Input$AttributeValueInput instance,
    TRes Function(Input$AttributeValueInput) then,
  ) = _CopyWithImpl$Input$AttributeValueInput;

  factory CopyWith$Input$AttributeValueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeValueInput;

  TRes call({
    String? id,
    String? externalReference,
    List<String>? values,
    Input$AttributeValueSelectableTypeInput? dropdown,
    Input$AttributeValueSelectableTypeInput? swatch,
    List<Input$AttributeValueSelectableTypeInput>? multiselect,
    String? numeric,
    String? file,
    String? contentType,
    List<String>? references,
    String? richText,
    String? plainText,
    bool? boolean,
    String? date,
    String? dateTime,
  });
  CopyWith$Input$AttributeValueSelectableTypeInput<TRes> get dropdown;
  CopyWith$Input$AttributeValueSelectableTypeInput<TRes> get swatch;
  TRes multiselect(
      Iterable<Input$AttributeValueSelectableTypeInput>? Function(
              Iterable<
                  CopyWith$Input$AttributeValueSelectableTypeInput<
                      Input$AttributeValueSelectableTypeInput>>?)
          _fn);
}

class _CopyWithImpl$Input$AttributeValueInput<TRes>
    implements CopyWith$Input$AttributeValueInput<TRes> {
  _CopyWithImpl$Input$AttributeValueInput(
    this._instance,
    this._then,
  );

  final Input$AttributeValueInput _instance;

  final TRes Function(Input$AttributeValueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? externalReference = _undefined,
    Object? values = _undefined,
    Object? dropdown = _undefined,
    Object? swatch = _undefined,
    Object? multiselect = _undefined,
    Object? numeric = _undefined,
    Object? file = _undefined,
    Object? contentType = _undefined,
    Object? references = _undefined,
    Object? richText = _undefined,
    Object? plainText = _undefined,
    Object? boolean = _undefined,
    Object? date = _undefined,
    Object? dateTime = _undefined,
  }) =>
      _then(Input$AttributeValueInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (values != _undefined) 'values': (values as List<String>?),
        if (dropdown != _undefined)
          'dropdown': (dropdown as Input$AttributeValueSelectableTypeInput?),
        if (swatch != _undefined)
          'swatch': (swatch as Input$AttributeValueSelectableTypeInput?),
        if (multiselect != _undefined)
          'multiselect':
              (multiselect as List<Input$AttributeValueSelectableTypeInput>?),
        if (numeric != _undefined) 'numeric': (numeric as String?),
        if (file != _undefined) 'file': (file as String?),
        if (contentType != _undefined) 'contentType': (contentType as String?),
        if (references != _undefined)
          'references': (references as List<String>?),
        if (richText != _undefined) 'richText': (richText as String?),
        if (plainText != _undefined) 'plainText': (plainText as String?),
        if (boolean != _undefined) 'boolean': (boolean as bool?),
        if (date != _undefined) 'date': (date as String?),
        if (dateTime != _undefined) 'dateTime': (dateTime as String?),
      }));

  CopyWith$Input$AttributeValueSelectableTypeInput<TRes> get dropdown {
    final local$dropdown = _instance.dropdown;
    return local$dropdown == null
        ? CopyWith$Input$AttributeValueSelectableTypeInput.stub(
            _then(_instance))
        : CopyWith$Input$AttributeValueSelectableTypeInput(
            local$dropdown, (e) => call(dropdown: e));
  }

  CopyWith$Input$AttributeValueSelectableTypeInput<TRes> get swatch {
    final local$swatch = _instance.swatch;
    return local$swatch == null
        ? CopyWith$Input$AttributeValueSelectableTypeInput.stub(
            _then(_instance))
        : CopyWith$Input$AttributeValueSelectableTypeInput(
            local$swatch, (e) => call(swatch: e));
  }

  TRes multiselect(
          Iterable<Input$AttributeValueSelectableTypeInput>? Function(
                  Iterable<
                      CopyWith$Input$AttributeValueSelectableTypeInput<
                          Input$AttributeValueSelectableTypeInput>>?)
              _fn) =>
      call(
          multiselect: _fn(_instance.multiselect
              ?.map((e) => CopyWith$Input$AttributeValueSelectableTypeInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$AttributeValueInput<TRes>
    implements CopyWith$Input$AttributeValueInput<TRes> {
  _CopyWithStubImpl$Input$AttributeValueInput(this._res);

  TRes _res;

  call({
    String? id,
    String? externalReference,
    List<String>? values,
    Input$AttributeValueSelectableTypeInput? dropdown,
    Input$AttributeValueSelectableTypeInput? swatch,
    List<Input$AttributeValueSelectableTypeInput>? multiselect,
    String? numeric,
    String? file,
    String? contentType,
    List<String>? references,
    String? richText,
    String? plainText,
    bool? boolean,
    String? date,
    String? dateTime,
  }) =>
      _res;

  CopyWith$Input$AttributeValueSelectableTypeInput<TRes> get dropdown =>
      CopyWith$Input$AttributeValueSelectableTypeInput.stub(_res);

  CopyWith$Input$AttributeValueSelectableTypeInput<TRes> get swatch =>
      CopyWith$Input$AttributeValueSelectableTypeInput.stub(_res);

  multiselect(_fn) => _res;
}

class Input$AttributeValueSelectableTypeInput {
  factory Input$AttributeValueSelectableTypeInput({
    String? id,
    String? externalReference,
    String? value,
  }) =>
      Input$AttributeValueSelectableTypeInput._({
        if (id != null) r'id': id,
        if (externalReference != null) r'externalReference': externalReference,
        if (value != null) r'value': value,
      });

  Input$AttributeValueSelectableTypeInput._(this._$data);

  factory Input$AttributeValueSelectableTypeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    if (data.containsKey('value')) {
      final l$value = data['value'];
      result$data['value'] = (l$value as String?);
    }
    return Input$AttributeValueSelectableTypeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get externalReference => (_$data['externalReference'] as String?);

  String? get value => (_$data['value'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    if (_$data.containsKey('value')) {
      final l$value = value;
      result$data['value'] = l$value;
    }
    return result$data;
  }

  CopyWith$Input$AttributeValueSelectableTypeInput<
          Input$AttributeValueSelectableTypeInput>
      get copyWith => CopyWith$Input$AttributeValueSelectableTypeInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeValueSelectableTypeInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (_$data.containsKey('value') != other._$data.containsKey('value')) {
      return false;
    }
    if (l$value != lOther$value) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$externalReference = externalReference;
    final l$value = value;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      _$data.containsKey('value') ? l$value : const {},
    ]);
  }
}

abstract class CopyWith$Input$AttributeValueSelectableTypeInput<TRes> {
  factory CopyWith$Input$AttributeValueSelectableTypeInput(
    Input$AttributeValueSelectableTypeInput instance,
    TRes Function(Input$AttributeValueSelectableTypeInput) then,
  ) = _CopyWithImpl$Input$AttributeValueSelectableTypeInput;

  factory CopyWith$Input$AttributeValueSelectableTypeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeValueSelectableTypeInput;

  TRes call({
    String? id,
    String? externalReference,
    String? value,
  });
}

class _CopyWithImpl$Input$AttributeValueSelectableTypeInput<TRes>
    implements CopyWith$Input$AttributeValueSelectableTypeInput<TRes> {
  _CopyWithImpl$Input$AttributeValueSelectableTypeInput(
    this._instance,
    this._then,
  );

  final Input$AttributeValueSelectableTypeInput _instance;

  final TRes Function(Input$AttributeValueSelectableTypeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? externalReference = _undefined,
    Object? value = _undefined,
  }) =>
      _then(Input$AttributeValueSelectableTypeInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (value != _undefined) 'value': (value as String?),
      }));
}

class _CopyWithStubImpl$Input$AttributeValueSelectableTypeInput<TRes>
    implements CopyWith$Input$AttributeValueSelectableTypeInput<TRes> {
  _CopyWithStubImpl$Input$AttributeValueSelectableTypeInput(this._res);

  TRes _res;

  call({
    String? id,
    String? externalReference,
    String? value,
  }) =>
      _res;
}

class Input$AttributeValueTranslationInput {
  factory Input$AttributeValueTranslationInput({
    String? name,
    String? richText,
    String? plainText,
  }) =>
      Input$AttributeValueTranslationInput._({
        if (name != null) r'name': name,
        if (richText != null) r'richText': richText,
        if (plainText != null) r'plainText': plainText,
      });

  Input$AttributeValueTranslationInput._(this._$data);

  factory Input$AttributeValueTranslationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('richText')) {
      final l$richText = data['richText'];
      result$data['richText'] = (l$richText as String?);
    }
    if (data.containsKey('plainText')) {
      final l$plainText = data['plainText'];
      result$data['plainText'] = (l$plainText as String?);
    }
    return Input$AttributeValueTranslationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get richText => (_$data['richText'] as String?);

  String? get plainText => (_$data['plainText'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('richText')) {
      final l$richText = richText;
      result$data['richText'] = l$richText;
    }
    if (_$data.containsKey('plainText')) {
      final l$plainText = plainText;
      result$data['plainText'] = l$plainText;
    }
    return result$data;
  }

  CopyWith$Input$AttributeValueTranslationInput<
          Input$AttributeValueTranslationInput>
      get copyWith => CopyWith$Input$AttributeValueTranslationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeValueTranslationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$richText = richText;
    final lOther$richText = other.richText;
    if (_$data.containsKey('richText') !=
        other._$data.containsKey('richText')) {
      return false;
    }
    if (l$richText != lOther$richText) {
      return false;
    }
    final l$plainText = plainText;
    final lOther$plainText = other.plainText;
    if (_$data.containsKey('plainText') !=
        other._$data.containsKey('plainText')) {
      return false;
    }
    if (l$plainText != lOther$plainText) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$richText = richText;
    final l$plainText = plainText;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('richText') ? l$richText : const {},
      _$data.containsKey('plainText') ? l$plainText : const {},
    ]);
  }
}

abstract class CopyWith$Input$AttributeValueTranslationInput<TRes> {
  factory CopyWith$Input$AttributeValueTranslationInput(
    Input$AttributeValueTranslationInput instance,
    TRes Function(Input$AttributeValueTranslationInput) then,
  ) = _CopyWithImpl$Input$AttributeValueTranslationInput;

  factory CopyWith$Input$AttributeValueTranslationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeValueTranslationInput;

  TRes call({
    String? name,
    String? richText,
    String? plainText,
  });
}

class _CopyWithImpl$Input$AttributeValueTranslationInput<TRes>
    implements CopyWith$Input$AttributeValueTranslationInput<TRes> {
  _CopyWithImpl$Input$AttributeValueTranslationInput(
    this._instance,
    this._then,
  );

  final Input$AttributeValueTranslationInput _instance;

  final TRes Function(Input$AttributeValueTranslationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? richText = _undefined,
    Object? plainText = _undefined,
  }) =>
      _then(Input$AttributeValueTranslationInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (richText != _undefined) 'richText': (richText as String?),
        if (plainText != _undefined) 'plainText': (plainText as String?),
      }));
}

class _CopyWithStubImpl$Input$AttributeValueTranslationInput<TRes>
    implements CopyWith$Input$AttributeValueTranslationInput<TRes> {
  _CopyWithStubImpl$Input$AttributeValueTranslationInput(this._res);

  TRes _res;

  call({
    String? name,
    String? richText,
    String? plainText,
  }) =>
      _res;
}

class Input$AttributeValueUpdateInput {
  factory Input$AttributeValueUpdateInput({
    String? value,
    String? richText,
    String? plainText,
    String? fileUrl,
    String? contentType,
    String? externalReference,
    String? name,
  }) =>
      Input$AttributeValueUpdateInput._({
        if (value != null) r'value': value,
        if (richText != null) r'richText': richText,
        if (plainText != null) r'plainText': plainText,
        if (fileUrl != null) r'fileUrl': fileUrl,
        if (contentType != null) r'contentType': contentType,
        if (externalReference != null) r'externalReference': externalReference,
        if (name != null) r'name': name,
      });

  Input$AttributeValueUpdateInput._(this._$data);

  factory Input$AttributeValueUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('value')) {
      final l$value = data['value'];
      result$data['value'] = (l$value as String?);
    }
    if (data.containsKey('richText')) {
      final l$richText = data['richText'];
      result$data['richText'] = (l$richText as String?);
    }
    if (data.containsKey('plainText')) {
      final l$plainText = data['plainText'];
      result$data['plainText'] = (l$plainText as String?);
    }
    if (data.containsKey('fileUrl')) {
      final l$fileUrl = data['fileUrl'];
      result$data['fileUrl'] = (l$fileUrl as String?);
    }
    if (data.containsKey('contentType')) {
      final l$contentType = data['contentType'];
      result$data['contentType'] = (l$contentType as String?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    return Input$AttributeValueUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get value => (_$data['value'] as String?);

  String? get richText => (_$data['richText'] as String?);

  String? get plainText => (_$data['plainText'] as String?);

  String? get fileUrl => (_$data['fileUrl'] as String?);

  String? get contentType => (_$data['contentType'] as String?);

  String? get externalReference => (_$data['externalReference'] as String?);

  String? get name => (_$data['name'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('value')) {
      final l$value = value;
      result$data['value'] = l$value;
    }
    if (_$data.containsKey('richText')) {
      final l$richText = richText;
      result$data['richText'] = l$richText;
    }
    if (_$data.containsKey('plainText')) {
      final l$plainText = plainText;
      result$data['plainText'] = l$plainText;
    }
    if (_$data.containsKey('fileUrl')) {
      final l$fileUrl = fileUrl;
      result$data['fileUrl'] = l$fileUrl;
    }
    if (_$data.containsKey('contentType')) {
      final l$contentType = contentType;
      result$data['contentType'] = l$contentType;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    return result$data;
  }

  CopyWith$Input$AttributeValueUpdateInput<Input$AttributeValueUpdateInput>
      get copyWith => CopyWith$Input$AttributeValueUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeValueUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (_$data.containsKey('value') != other._$data.containsKey('value')) {
      return false;
    }
    if (l$value != lOther$value) {
      return false;
    }
    final l$richText = richText;
    final lOther$richText = other.richText;
    if (_$data.containsKey('richText') !=
        other._$data.containsKey('richText')) {
      return false;
    }
    if (l$richText != lOther$richText) {
      return false;
    }
    final l$plainText = plainText;
    final lOther$plainText = other.plainText;
    if (_$data.containsKey('plainText') !=
        other._$data.containsKey('plainText')) {
      return false;
    }
    if (l$plainText != lOther$plainText) {
      return false;
    }
    final l$fileUrl = fileUrl;
    final lOther$fileUrl = other.fileUrl;
    if (_$data.containsKey('fileUrl') != other._$data.containsKey('fileUrl')) {
      return false;
    }
    if (l$fileUrl != lOther$fileUrl) {
      return false;
    }
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (_$data.containsKey('contentType') !=
        other._$data.containsKey('contentType')) {
      return false;
    }
    if (l$contentType != lOther$contentType) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$value = value;
    final l$richText = richText;
    final l$plainText = plainText;
    final l$fileUrl = fileUrl;
    final l$contentType = contentType;
    final l$externalReference = externalReference;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('value') ? l$value : const {},
      _$data.containsKey('richText') ? l$richText : const {},
      _$data.containsKey('plainText') ? l$plainText : const {},
      _$data.containsKey('fileUrl') ? l$fileUrl : const {},
      _$data.containsKey('contentType') ? l$contentType : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$AttributeValueUpdateInput<TRes> {
  factory CopyWith$Input$AttributeValueUpdateInput(
    Input$AttributeValueUpdateInput instance,
    TRes Function(Input$AttributeValueUpdateInput) then,
  ) = _CopyWithImpl$Input$AttributeValueUpdateInput;

  factory CopyWith$Input$AttributeValueUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeValueUpdateInput;

  TRes call({
    String? value,
    String? richText,
    String? plainText,
    String? fileUrl,
    String? contentType,
    String? externalReference,
    String? name,
  });
}

class _CopyWithImpl$Input$AttributeValueUpdateInput<TRes>
    implements CopyWith$Input$AttributeValueUpdateInput<TRes> {
  _CopyWithImpl$Input$AttributeValueUpdateInput(
    this._instance,
    this._then,
  );

  final Input$AttributeValueUpdateInput _instance;

  final TRes Function(Input$AttributeValueUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? value = _undefined,
    Object? richText = _undefined,
    Object? plainText = _undefined,
    Object? fileUrl = _undefined,
    Object? contentType = _undefined,
    Object? externalReference = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$AttributeValueUpdateInput._({
        ..._instance._$data,
        if (value != _undefined) 'value': (value as String?),
        if (richText != _undefined) 'richText': (richText as String?),
        if (plainText != _undefined) 'plainText': (plainText as String?),
        if (fileUrl != _undefined) 'fileUrl': (fileUrl as String?),
        if (contentType != _undefined) 'contentType': (contentType as String?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (name != _undefined) 'name': (name as String?),
      }));
}

class _CopyWithStubImpl$Input$AttributeValueUpdateInput<TRes>
    implements CopyWith$Input$AttributeValueUpdateInput<TRes> {
  _CopyWithStubImpl$Input$AttributeValueUpdateInput(this._res);

  TRes _res;

  call({
    String? value,
    String? richText,
    String? plainText,
    String? fileUrl,
    String? contentType,
    String? externalReference,
    String? name,
  }) =>
      _res;
}

class Input$AttributeWhereInput {
  factory Input$AttributeWhereInput({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    Input$StringFilterInput? name,
    Input$StringFilterInput? slug,
    bool? withChoices,
    Input$AttributeInputTypeEnumFilterInput? inputType,
    Input$AttributeEntityTypeEnumFilterInput? entityType,
    Input$AttributeTypeEnumFilterInput? type,
    Input$MeasurementUnitsEnumFilterInput? unit,
    String? inCollection,
    String? inCategory,
    bool? valueRequired,
    bool? visibleInStorefront,
    bool? filterableInDashboard,
    List<Input$AttributeWhereInput>? AND,
    List<Input$AttributeWhereInput>? OR,
  }) =>
      Input$AttributeWhereInput._({
        if (metadata != null) r'metadata': metadata,
        if (ids != null) r'ids': ids,
        if (name != null) r'name': name,
        if (slug != null) r'slug': slug,
        if (withChoices != null) r'withChoices': withChoices,
        if (inputType != null) r'inputType': inputType,
        if (entityType != null) r'entityType': entityType,
        if (type != null) r'type': type,
        if (unit != null) r'unit': unit,
        if (inCollection != null) r'inCollection': inCollection,
        if (inCategory != null) r'inCategory': inCategory,
        if (valueRequired != null) r'valueRequired': valueRequired,
        if (visibleInStorefront != null)
          r'visibleInStorefront': visibleInStorefront,
        if (filterableInDashboard != null)
          r'filterableInDashboard': filterableInDashboard,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
      });

  Input$AttributeWhereInput._(this._$data);

  factory Input$AttributeWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilterInput.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = l$slug == null
          ? null
          : Input$StringFilterInput.fromJson((l$slug as Map<String, dynamic>));
    }
    if (data.containsKey('withChoices')) {
      final l$withChoices = data['withChoices'];
      result$data['withChoices'] = (l$withChoices as bool?);
    }
    if (data.containsKey('inputType')) {
      final l$inputType = data['inputType'];
      result$data['inputType'] = l$inputType == null
          ? null
          : Input$AttributeInputTypeEnumFilterInput.fromJson(
              (l$inputType as Map<String, dynamic>));
    }
    if (data.containsKey('entityType')) {
      final l$entityType = data['entityType'];
      result$data['entityType'] = l$entityType == null
          ? null
          : Input$AttributeEntityTypeEnumFilterInput.fromJson(
              (l$entityType as Map<String, dynamic>));
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : Input$AttributeTypeEnumFilterInput.fromJson(
              (l$type as Map<String, dynamic>));
    }
    if (data.containsKey('unit')) {
      final l$unit = data['unit'];
      result$data['unit'] = l$unit == null
          ? null
          : Input$MeasurementUnitsEnumFilterInput.fromJson(
              (l$unit as Map<String, dynamic>));
    }
    if (data.containsKey('inCollection')) {
      final l$inCollection = data['inCollection'];
      result$data['inCollection'] = (l$inCollection as String?);
    }
    if (data.containsKey('inCategory')) {
      final l$inCategory = data['inCategory'];
      result$data['inCategory'] = (l$inCategory as String?);
    }
    if (data.containsKey('valueRequired')) {
      final l$valueRequired = data['valueRequired'];
      result$data['valueRequired'] = (l$valueRequired as bool?);
    }
    if (data.containsKey('visibleInStorefront')) {
      final l$visibleInStorefront = data['visibleInStorefront'];
      result$data['visibleInStorefront'] = (l$visibleInStorefront as bool?);
    }
    if (data.containsKey('filterableInDashboard')) {
      final l$filterableInDashboard = data['filterableInDashboard'];
      result$data['filterableInDashboard'] = (l$filterableInDashboard as bool?);
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$AttributeWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$AttributeWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$AttributeWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  Input$StringFilterInput? get name =>
      (_$data['name'] as Input$StringFilterInput?);

  Input$StringFilterInput? get slug =>
      (_$data['slug'] as Input$StringFilterInput?);

  bool? get withChoices => (_$data['withChoices'] as bool?);

  Input$AttributeInputTypeEnumFilterInput? get inputType =>
      (_$data['inputType'] as Input$AttributeInputTypeEnumFilterInput?);

  Input$AttributeEntityTypeEnumFilterInput? get entityType =>
      (_$data['entityType'] as Input$AttributeEntityTypeEnumFilterInput?);

  Input$AttributeTypeEnumFilterInput? get type =>
      (_$data['type'] as Input$AttributeTypeEnumFilterInput?);

  Input$MeasurementUnitsEnumFilterInput? get unit =>
      (_$data['unit'] as Input$MeasurementUnitsEnumFilterInput?);

  String? get inCollection => (_$data['inCollection'] as String?);

  String? get inCategory => (_$data['inCategory'] as String?);

  bool? get valueRequired => (_$data['valueRequired'] as bool?);

  bool? get visibleInStorefront => (_$data['visibleInStorefront'] as bool?);

  bool? get filterableInDashboard => (_$data['filterableInDashboard'] as bool?);

  List<Input$AttributeWhereInput>? get AND =>
      (_$data['AND'] as List<Input$AttributeWhereInput>?);

  List<Input$AttributeWhereInput>? get OR =>
      (_$data['OR'] as List<Input$AttributeWhereInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug?.toJson();
    }
    if (_$data.containsKey('withChoices')) {
      final l$withChoices = withChoices;
      result$data['withChoices'] = l$withChoices;
    }
    if (_$data.containsKey('inputType')) {
      final l$inputType = inputType;
      result$data['inputType'] = l$inputType?.toJson();
    }
    if (_$data.containsKey('entityType')) {
      final l$entityType = entityType;
      result$data['entityType'] = l$entityType?.toJson();
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type?.toJson();
    }
    if (_$data.containsKey('unit')) {
      final l$unit = unit;
      result$data['unit'] = l$unit?.toJson();
    }
    if (_$data.containsKey('inCollection')) {
      final l$inCollection = inCollection;
      result$data['inCollection'] = l$inCollection;
    }
    if (_$data.containsKey('inCategory')) {
      final l$inCategory = inCategory;
      result$data['inCategory'] = l$inCategory;
    }
    if (_$data.containsKey('valueRequired')) {
      final l$valueRequired = valueRequired;
      result$data['valueRequired'] = l$valueRequired;
    }
    if (_$data.containsKey('visibleInStorefront')) {
      final l$visibleInStorefront = visibleInStorefront;
      result$data['visibleInStorefront'] = l$visibleInStorefront;
    }
    if (_$data.containsKey('filterableInDashboard')) {
      final l$filterableInDashboard = filterableInDashboard;
      result$data['filterableInDashboard'] = l$filterableInDashboard;
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$AttributeWhereInput<Input$AttributeWhereInput> get copyWith =>
      CopyWith$Input$AttributeWhereInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AttributeWhereInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$withChoices = withChoices;
    final lOther$withChoices = other.withChoices;
    if (_$data.containsKey('withChoices') !=
        other._$data.containsKey('withChoices')) {
      return false;
    }
    if (l$withChoices != lOther$withChoices) {
      return false;
    }
    final l$inputType = inputType;
    final lOther$inputType = other.inputType;
    if (_$data.containsKey('inputType') !=
        other._$data.containsKey('inputType')) {
      return false;
    }
    if (l$inputType != lOther$inputType) {
      return false;
    }
    final l$entityType = entityType;
    final lOther$entityType = other.entityType;
    if (_$data.containsKey('entityType') !=
        other._$data.containsKey('entityType')) {
      return false;
    }
    if (l$entityType != lOther$entityType) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$unit = unit;
    final lOther$unit = other.unit;
    if (_$data.containsKey('unit') != other._$data.containsKey('unit')) {
      return false;
    }
    if (l$unit != lOther$unit) {
      return false;
    }
    final l$inCollection = inCollection;
    final lOther$inCollection = other.inCollection;
    if (_$data.containsKey('inCollection') !=
        other._$data.containsKey('inCollection')) {
      return false;
    }
    if (l$inCollection != lOther$inCollection) {
      return false;
    }
    final l$inCategory = inCategory;
    final lOther$inCategory = other.inCategory;
    if (_$data.containsKey('inCategory') !=
        other._$data.containsKey('inCategory')) {
      return false;
    }
    if (l$inCategory != lOther$inCategory) {
      return false;
    }
    final l$valueRequired = valueRequired;
    final lOther$valueRequired = other.valueRequired;
    if (_$data.containsKey('valueRequired') !=
        other._$data.containsKey('valueRequired')) {
      return false;
    }
    if (l$valueRequired != lOther$valueRequired) {
      return false;
    }
    final l$visibleInStorefront = visibleInStorefront;
    final lOther$visibleInStorefront = other.visibleInStorefront;
    if (_$data.containsKey('visibleInStorefront') !=
        other._$data.containsKey('visibleInStorefront')) {
      return false;
    }
    if (l$visibleInStorefront != lOther$visibleInStorefront) {
      return false;
    }
    final l$filterableInDashboard = filterableInDashboard;
    final lOther$filterableInDashboard = other.filterableInDashboard;
    if (_$data.containsKey('filterableInDashboard') !=
        other._$data.containsKey('filterableInDashboard')) {
      return false;
    }
    if (l$filterableInDashboard != lOther$filterableInDashboard) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$metadata = metadata;
    final l$ids = ids;
    final l$name = name;
    final l$slug = slug;
    final l$withChoices = withChoices;
    final l$inputType = inputType;
    final l$entityType = entityType;
    final l$type = type;
    final l$unit = unit;
    final l$inCollection = inCollection;
    final l$inCategory = inCategory;
    final l$valueRequired = valueRequired;
    final l$visibleInStorefront = visibleInStorefront;
    final l$filterableInDashboard = filterableInDashboard;
    final l$AND = AND;
    final l$OR = OR;
    return Object.hashAll([
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('withChoices') ? l$withChoices : const {},
      _$data.containsKey('inputType') ? l$inputType : const {},
      _$data.containsKey('entityType') ? l$entityType : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('unit') ? l$unit : const {},
      _$data.containsKey('inCollection') ? l$inCollection : const {},
      _$data.containsKey('inCategory') ? l$inCategory : const {},
      _$data.containsKey('valueRequired') ? l$valueRequired : const {},
      _$data.containsKey('visibleInStorefront')
          ? l$visibleInStorefront
          : const {},
      _$data.containsKey('filterableInDashboard')
          ? l$filterableInDashboard
          : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AttributeWhereInput<TRes> {
  factory CopyWith$Input$AttributeWhereInput(
    Input$AttributeWhereInput instance,
    TRes Function(Input$AttributeWhereInput) then,
  ) = _CopyWithImpl$Input$AttributeWhereInput;

  factory CopyWith$Input$AttributeWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AttributeWhereInput;

  TRes call({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    Input$StringFilterInput? name,
    Input$StringFilterInput? slug,
    bool? withChoices,
    Input$AttributeInputTypeEnumFilterInput? inputType,
    Input$AttributeEntityTypeEnumFilterInput? entityType,
    Input$AttributeTypeEnumFilterInput? type,
    Input$MeasurementUnitsEnumFilterInput? unit,
    String? inCollection,
    String? inCategory,
    bool? valueRequired,
    bool? visibleInStorefront,
    bool? filterableInDashboard,
    List<Input$AttributeWhereInput>? AND,
    List<Input$AttributeWhereInput>? OR,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
  CopyWith$Input$StringFilterInput<TRes> get name;
  CopyWith$Input$StringFilterInput<TRes> get slug;
  CopyWith$Input$AttributeInputTypeEnumFilterInput<TRes> get inputType;
  CopyWith$Input$AttributeEntityTypeEnumFilterInput<TRes> get entityType;
  CopyWith$Input$AttributeTypeEnumFilterInput<TRes> get type;
  CopyWith$Input$MeasurementUnitsEnumFilterInput<TRes> get unit;
  TRes AND(
      Iterable<Input$AttributeWhereInput>? Function(
              Iterable<
                  CopyWith$Input$AttributeWhereInput<
                      Input$AttributeWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$AttributeWhereInput>? Function(
              Iterable<
                  CopyWith$Input$AttributeWhereInput<
                      Input$AttributeWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$AttributeWhereInput<TRes>
    implements CopyWith$Input$AttributeWhereInput<TRes> {
  _CopyWithImpl$Input$AttributeWhereInput(
    this._instance,
    this._then,
  );

  final Input$AttributeWhereInput _instance;

  final TRes Function(Input$AttributeWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? metadata = _undefined,
    Object? ids = _undefined,
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? withChoices = _undefined,
    Object? inputType = _undefined,
    Object? entityType = _undefined,
    Object? type = _undefined,
    Object? unit = _undefined,
    Object? inCollection = _undefined,
    Object? inCategory = _undefined,
    Object? valueRequired = _undefined,
    Object? visibleInStorefront = _undefined,
    Object? filterableInDashboard = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
  }) =>
      _then(Input$AttributeWhereInput._({
        ..._instance._$data,
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (name != _undefined) 'name': (name as Input$StringFilterInput?),
        if (slug != _undefined) 'slug': (slug as Input$StringFilterInput?),
        if (withChoices != _undefined) 'withChoices': (withChoices as bool?),
        if (inputType != _undefined)
          'inputType': (inputType as Input$AttributeInputTypeEnumFilterInput?),
        if (entityType != _undefined)
          'entityType':
              (entityType as Input$AttributeEntityTypeEnumFilterInput?),
        if (type != _undefined)
          'type': (type as Input$AttributeTypeEnumFilterInput?),
        if (unit != _undefined)
          'unit': (unit as Input$MeasurementUnitsEnumFilterInput?),
        if (inCollection != _undefined)
          'inCollection': (inCollection as String?),
        if (inCategory != _undefined) 'inCategory': (inCategory as String?),
        if (valueRequired != _undefined)
          'valueRequired': (valueRequired as bool?),
        if (visibleInStorefront != _undefined)
          'visibleInStorefront': (visibleInStorefront as bool?),
        if (filterableInDashboard != _undefined)
          'filterableInDashboard': (filterableInDashboard as bool?),
        if (AND != _undefined) 'AND': (AND as List<Input$AttributeWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$AttributeWhereInput>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$StringFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringFilterInput(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilterInput<TRes> get slug {
    final local$slug = _instance.slug;
    return local$slug == null
        ? CopyWith$Input$StringFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringFilterInput(local$slug, (e) => call(slug: e));
  }

  CopyWith$Input$AttributeInputTypeEnumFilterInput<TRes> get inputType {
    final local$inputType = _instance.inputType;
    return local$inputType == null
        ? CopyWith$Input$AttributeInputTypeEnumFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$AttributeInputTypeEnumFilterInput(
            local$inputType, (e) => call(inputType: e));
  }

  CopyWith$Input$AttributeEntityTypeEnumFilterInput<TRes> get entityType {
    final local$entityType = _instance.entityType;
    return local$entityType == null
        ? CopyWith$Input$AttributeEntityTypeEnumFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$AttributeEntityTypeEnumFilterInput(
            local$entityType, (e) => call(entityType: e));
  }

  CopyWith$Input$AttributeTypeEnumFilterInput<TRes> get type {
    final local$type = _instance.type;
    return local$type == null
        ? CopyWith$Input$AttributeTypeEnumFilterInput.stub(_then(_instance))
        : CopyWith$Input$AttributeTypeEnumFilterInput(
            local$type, (e) => call(type: e));
  }

  CopyWith$Input$MeasurementUnitsEnumFilterInput<TRes> get unit {
    final local$unit = _instance.unit;
    return local$unit == null
        ? CopyWith$Input$MeasurementUnitsEnumFilterInput.stub(_then(_instance))
        : CopyWith$Input$MeasurementUnitsEnumFilterInput(
            local$unit, (e) => call(unit: e));
  }

  TRes AND(
          Iterable<Input$AttributeWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$AttributeWhereInput<
                          Input$AttributeWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$AttributeWhereInput(
                e,
                (i) => i,
              )))?.toList());

  TRes OR(
          Iterable<Input$AttributeWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$AttributeWhereInput<
                          Input$AttributeWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$AttributeWhereInput(
                e,
                (i) => i,
              )))?.toList());
}

class _CopyWithStubImpl$Input$AttributeWhereInput<TRes>
    implements CopyWith$Input$AttributeWhereInput<TRes> {
  _CopyWithStubImpl$Input$AttributeWhereInput(this._res);

  TRes _res;

  call({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    Input$StringFilterInput? name,
    Input$StringFilterInput? slug,
    bool? withChoices,
    Input$AttributeInputTypeEnumFilterInput? inputType,
    Input$AttributeEntityTypeEnumFilterInput? entityType,
    Input$AttributeTypeEnumFilterInput? type,
    Input$MeasurementUnitsEnumFilterInput? unit,
    String? inCollection,
    String? inCategory,
    bool? valueRequired,
    bool? visibleInStorefront,
    bool? filterableInDashboard,
    List<Input$AttributeWhereInput>? AND,
    List<Input$AttributeWhereInput>? OR,
  }) =>
      _res;

  metadata(_fn) => _res;

  CopyWith$Input$StringFilterInput<TRes> get name =>
      CopyWith$Input$StringFilterInput.stub(_res);

  CopyWith$Input$StringFilterInput<TRes> get slug =>
      CopyWith$Input$StringFilterInput.stub(_res);

  CopyWith$Input$AttributeInputTypeEnumFilterInput<TRes> get inputType =>
      CopyWith$Input$AttributeInputTypeEnumFilterInput.stub(_res);

  CopyWith$Input$AttributeEntityTypeEnumFilterInput<TRes> get entityType =>
      CopyWith$Input$AttributeEntityTypeEnumFilterInput.stub(_res);

  CopyWith$Input$AttributeTypeEnumFilterInput<TRes> get type =>
      CopyWith$Input$AttributeTypeEnumFilterInput.stub(_res);

  CopyWith$Input$MeasurementUnitsEnumFilterInput<TRes> get unit =>
      CopyWith$Input$MeasurementUnitsEnumFilterInput.stub(_res);

  AND(_fn) => _res;

  OR(_fn) => _res;
}

class Input$BulkAttributeValueInput {
  factory Input$BulkAttributeValueInput({
    String? id,
    String? externalReference,
    List<String>? values,
    Input$AttributeValueSelectableTypeInput? dropdown,
    Input$AttributeValueSelectableTypeInput? swatch,
    List<Input$AttributeValueSelectableTypeInput>? multiselect,
    String? numeric,
    String? file,
    String? contentType,
    List<String>? references,
    String? richText,
    String? plainText,
    bool? boolean,
    String? date,
    String? dateTime,
  }) =>
      Input$BulkAttributeValueInput._({
        if (id != null) r'id': id,
        if (externalReference != null) r'externalReference': externalReference,
        if (values != null) r'values': values,
        if (dropdown != null) r'dropdown': dropdown,
        if (swatch != null) r'swatch': swatch,
        if (multiselect != null) r'multiselect': multiselect,
        if (numeric != null) r'numeric': numeric,
        if (file != null) r'file': file,
        if (contentType != null) r'contentType': contentType,
        if (references != null) r'references': references,
        if (richText != null) r'richText': richText,
        if (plainText != null) r'plainText': plainText,
        if (boolean != null) r'boolean': boolean,
        if (date != null) r'date': date,
        if (dateTime != null) r'dateTime': dateTime,
      });

  Input$BulkAttributeValueInput._(this._$data);

  factory Input$BulkAttributeValueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    if (data.containsKey('values')) {
      final l$values = data['values'];
      result$data['values'] =
          (l$values as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('dropdown')) {
      final l$dropdown = data['dropdown'];
      result$data['dropdown'] = l$dropdown == null
          ? null
          : Input$AttributeValueSelectableTypeInput.fromJson(
              (l$dropdown as Map<String, dynamic>));
    }
    if (data.containsKey('swatch')) {
      final l$swatch = data['swatch'];
      result$data['swatch'] = l$swatch == null
          ? null
          : Input$AttributeValueSelectableTypeInput.fromJson(
              (l$swatch as Map<String, dynamic>));
    }
    if (data.containsKey('multiselect')) {
      final l$multiselect = data['multiselect'];
      result$data['multiselect'] = (l$multiselect as List<dynamic>?)
          ?.map((e) => Input$AttributeValueSelectableTypeInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('numeric')) {
      final l$numeric = data['numeric'];
      result$data['numeric'] = (l$numeric as String?);
    }
    if (data.containsKey('file')) {
      final l$file = data['file'];
      result$data['file'] = (l$file as String?);
    }
    if (data.containsKey('contentType')) {
      final l$contentType = data['contentType'];
      result$data['contentType'] = (l$contentType as String?);
    }
    if (data.containsKey('references')) {
      final l$references = data['references'];
      result$data['references'] =
          (l$references as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('richText')) {
      final l$richText = data['richText'];
      result$data['richText'] = (l$richText as String?);
    }
    if (data.containsKey('plainText')) {
      final l$plainText = data['plainText'];
      result$data['plainText'] = (l$plainText as String?);
    }
    if (data.containsKey('boolean')) {
      final l$boolean = data['boolean'];
      result$data['boolean'] = (l$boolean as bool?);
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = (l$date as String?);
    }
    if (data.containsKey('dateTime')) {
      final l$dateTime = data['dateTime'];
      result$data['dateTime'] = (l$dateTime as String?);
    }
    return Input$BulkAttributeValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get externalReference => (_$data['externalReference'] as String?);

  List<String>? get values => (_$data['values'] as List<String>?);

  Input$AttributeValueSelectableTypeInput? get dropdown =>
      (_$data['dropdown'] as Input$AttributeValueSelectableTypeInput?);

  Input$AttributeValueSelectableTypeInput? get swatch =>
      (_$data['swatch'] as Input$AttributeValueSelectableTypeInput?);

  List<Input$AttributeValueSelectableTypeInput>? get multiselect =>
      (_$data['multiselect'] as List<Input$AttributeValueSelectableTypeInput>?);

  String? get numeric => (_$data['numeric'] as String?);

  String? get file => (_$data['file'] as String?);

  String? get contentType => (_$data['contentType'] as String?);

  List<String>? get references => (_$data['references'] as List<String>?);

  String? get richText => (_$data['richText'] as String?);

  String? get plainText => (_$data['plainText'] as String?);

  bool? get boolean => (_$data['boolean'] as bool?);

  String? get date => (_$data['date'] as String?);

  String? get dateTime => (_$data['dateTime'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    if (_$data.containsKey('values')) {
      final l$values = values;
      result$data['values'] = l$values?.map((e) => e).toList();
    }
    if (_$data.containsKey('dropdown')) {
      final l$dropdown = dropdown;
      result$data['dropdown'] = l$dropdown?.toJson();
    }
    if (_$data.containsKey('swatch')) {
      final l$swatch = swatch;
      result$data['swatch'] = l$swatch?.toJson();
    }
    if (_$data.containsKey('multiselect')) {
      final l$multiselect = multiselect;
      result$data['multiselect'] =
          l$multiselect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('numeric')) {
      final l$numeric = numeric;
      result$data['numeric'] = l$numeric;
    }
    if (_$data.containsKey('file')) {
      final l$file = file;
      result$data['file'] = l$file;
    }
    if (_$data.containsKey('contentType')) {
      final l$contentType = contentType;
      result$data['contentType'] = l$contentType;
    }
    if (_$data.containsKey('references')) {
      final l$references = references;
      result$data['references'] = l$references?.map((e) => e).toList();
    }
    if (_$data.containsKey('richText')) {
      final l$richText = richText;
      result$data['richText'] = l$richText;
    }
    if (_$data.containsKey('plainText')) {
      final l$plainText = plainText;
      result$data['plainText'] = l$plainText;
    }
    if (_$data.containsKey('boolean')) {
      final l$boolean = boolean;
      result$data['boolean'] = l$boolean;
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date;
    }
    if (_$data.containsKey('dateTime')) {
      final l$dateTime = dateTime;
      result$data['dateTime'] = l$dateTime;
    }
    return result$data;
  }

  CopyWith$Input$BulkAttributeValueInput<Input$BulkAttributeValueInput>
      get copyWith => CopyWith$Input$BulkAttributeValueInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$BulkAttributeValueInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$values = values;
    final lOther$values = other.values;
    if (_$data.containsKey('values') != other._$data.containsKey('values')) {
      return false;
    }
    if (l$values != null && lOther$values != null) {
      if (l$values.length != lOther$values.length) {
        return false;
      }
      for (int i = 0; i < l$values.length; i++) {
        final l$values$entry = l$values[i];
        final lOther$values$entry = lOther$values[i];
        if (l$values$entry != lOther$values$entry) {
          return false;
        }
      }
    } else if (l$values != lOther$values) {
      return false;
    }
    final l$dropdown = dropdown;
    final lOther$dropdown = other.dropdown;
    if (_$data.containsKey('dropdown') !=
        other._$data.containsKey('dropdown')) {
      return false;
    }
    if (l$dropdown != lOther$dropdown) {
      return false;
    }
    final l$swatch = swatch;
    final lOther$swatch = other.swatch;
    if (_$data.containsKey('swatch') != other._$data.containsKey('swatch')) {
      return false;
    }
    if (l$swatch != lOther$swatch) {
      return false;
    }
    final l$multiselect = multiselect;
    final lOther$multiselect = other.multiselect;
    if (_$data.containsKey('multiselect') !=
        other._$data.containsKey('multiselect')) {
      return false;
    }
    if (l$multiselect != null && lOther$multiselect != null) {
      if (l$multiselect.length != lOther$multiselect.length) {
        return false;
      }
      for (int i = 0; i < l$multiselect.length; i++) {
        final l$multiselect$entry = l$multiselect[i];
        final lOther$multiselect$entry = lOther$multiselect[i];
        if (l$multiselect$entry != lOther$multiselect$entry) {
          return false;
        }
      }
    } else if (l$multiselect != lOther$multiselect) {
      return false;
    }
    final l$numeric = numeric;
    final lOther$numeric = other.numeric;
    if (_$data.containsKey('numeric') != other._$data.containsKey('numeric')) {
      return false;
    }
    if (l$numeric != lOther$numeric) {
      return false;
    }
    final l$file = file;
    final lOther$file = other.file;
    if (_$data.containsKey('file') != other._$data.containsKey('file')) {
      return false;
    }
    if (l$file != lOther$file) {
      return false;
    }
    final l$contentType = contentType;
    final lOther$contentType = other.contentType;
    if (_$data.containsKey('contentType') !=
        other._$data.containsKey('contentType')) {
      return false;
    }
    if (l$contentType != lOther$contentType) {
      return false;
    }
    final l$references = references;
    final lOther$references = other.references;
    if (_$data.containsKey('references') !=
        other._$data.containsKey('references')) {
      return false;
    }
    if (l$references != null && lOther$references != null) {
      if (l$references.length != lOther$references.length) {
        return false;
      }
      for (int i = 0; i < l$references.length; i++) {
        final l$references$entry = l$references[i];
        final lOther$references$entry = lOther$references[i];
        if (l$references$entry != lOther$references$entry) {
          return false;
        }
      }
    } else if (l$references != lOther$references) {
      return false;
    }
    final l$richText = richText;
    final lOther$richText = other.richText;
    if (_$data.containsKey('richText') !=
        other._$data.containsKey('richText')) {
      return false;
    }
    if (l$richText != lOther$richText) {
      return false;
    }
    final l$plainText = plainText;
    final lOther$plainText = other.plainText;
    if (_$data.containsKey('plainText') !=
        other._$data.containsKey('plainText')) {
      return false;
    }
    if (l$plainText != lOther$plainText) {
      return false;
    }
    final l$boolean = boolean;
    final lOther$boolean = other.boolean;
    if (_$data.containsKey('boolean') != other._$data.containsKey('boolean')) {
      return false;
    }
    if (l$boolean != lOther$boolean) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$dateTime = dateTime;
    final lOther$dateTime = other.dateTime;
    if (_$data.containsKey('dateTime') !=
        other._$data.containsKey('dateTime')) {
      return false;
    }
    if (l$dateTime != lOther$dateTime) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$externalReference = externalReference;
    final l$values = values;
    final l$dropdown = dropdown;
    final l$swatch = swatch;
    final l$multiselect = multiselect;
    final l$numeric = numeric;
    final l$file = file;
    final l$contentType = contentType;
    final l$references = references;
    final l$richText = richText;
    final l$plainText = plainText;
    final l$boolean = boolean;
    final l$date = date;
    final l$dateTime = dateTime;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      _$data.containsKey('values')
          ? l$values == null
              ? null
              : Object.hashAll(l$values.map((v) => v))
          : const {},
      _$data.containsKey('dropdown') ? l$dropdown : const {},
      _$data.containsKey('swatch') ? l$swatch : const {},
      _$data.containsKey('multiselect')
          ? l$multiselect == null
              ? null
              : Object.hashAll(l$multiselect.map((v) => v))
          : const {},
      _$data.containsKey('numeric') ? l$numeric : const {},
      _$data.containsKey('file') ? l$file : const {},
      _$data.containsKey('contentType') ? l$contentType : const {},
      _$data.containsKey('references')
          ? l$references == null
              ? null
              : Object.hashAll(l$references.map((v) => v))
          : const {},
      _$data.containsKey('richText') ? l$richText : const {},
      _$data.containsKey('plainText') ? l$plainText : const {},
      _$data.containsKey('boolean') ? l$boolean : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('dateTime') ? l$dateTime : const {},
    ]);
  }
}

abstract class CopyWith$Input$BulkAttributeValueInput<TRes> {
  factory CopyWith$Input$BulkAttributeValueInput(
    Input$BulkAttributeValueInput instance,
    TRes Function(Input$BulkAttributeValueInput) then,
  ) = _CopyWithImpl$Input$BulkAttributeValueInput;

  factory CopyWith$Input$BulkAttributeValueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BulkAttributeValueInput;

  TRes call({
    String? id,
    String? externalReference,
    List<String>? values,
    Input$AttributeValueSelectableTypeInput? dropdown,
    Input$AttributeValueSelectableTypeInput? swatch,
    List<Input$AttributeValueSelectableTypeInput>? multiselect,
    String? numeric,
    String? file,
    String? contentType,
    List<String>? references,
    String? richText,
    String? plainText,
    bool? boolean,
    String? date,
    String? dateTime,
  });
  CopyWith$Input$AttributeValueSelectableTypeInput<TRes> get dropdown;
  CopyWith$Input$AttributeValueSelectableTypeInput<TRes> get swatch;
  TRes multiselect(
      Iterable<Input$AttributeValueSelectableTypeInput>? Function(
              Iterable<
                  CopyWith$Input$AttributeValueSelectableTypeInput<
                      Input$AttributeValueSelectableTypeInput>>?)
          _fn);
}

class _CopyWithImpl$Input$BulkAttributeValueInput<TRes>
    implements CopyWith$Input$BulkAttributeValueInput<TRes> {
  _CopyWithImpl$Input$BulkAttributeValueInput(
    this._instance,
    this._then,
  );

  final Input$BulkAttributeValueInput _instance;

  final TRes Function(Input$BulkAttributeValueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? externalReference = _undefined,
    Object? values = _undefined,
    Object? dropdown = _undefined,
    Object? swatch = _undefined,
    Object? multiselect = _undefined,
    Object? numeric = _undefined,
    Object? file = _undefined,
    Object? contentType = _undefined,
    Object? references = _undefined,
    Object? richText = _undefined,
    Object? plainText = _undefined,
    Object? boolean = _undefined,
    Object? date = _undefined,
    Object? dateTime = _undefined,
  }) =>
      _then(Input$BulkAttributeValueInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (values != _undefined) 'values': (values as List<String>?),
        if (dropdown != _undefined)
          'dropdown': (dropdown as Input$AttributeValueSelectableTypeInput?),
        if (swatch != _undefined)
          'swatch': (swatch as Input$AttributeValueSelectableTypeInput?),
        if (multiselect != _undefined)
          'multiselect':
              (multiselect as List<Input$AttributeValueSelectableTypeInput>?),
        if (numeric != _undefined) 'numeric': (numeric as String?),
        if (file != _undefined) 'file': (file as String?),
        if (contentType != _undefined) 'contentType': (contentType as String?),
        if (references != _undefined)
          'references': (references as List<String>?),
        if (richText != _undefined) 'richText': (richText as String?),
        if (plainText != _undefined) 'plainText': (plainText as String?),
        if (boolean != _undefined) 'boolean': (boolean as bool?),
        if (date != _undefined) 'date': (date as String?),
        if (dateTime != _undefined) 'dateTime': (dateTime as String?),
      }));

  CopyWith$Input$AttributeValueSelectableTypeInput<TRes> get dropdown {
    final local$dropdown = _instance.dropdown;
    return local$dropdown == null
        ? CopyWith$Input$AttributeValueSelectableTypeInput.stub(
            _then(_instance))
        : CopyWith$Input$AttributeValueSelectableTypeInput(
            local$dropdown, (e) => call(dropdown: e));
  }

  CopyWith$Input$AttributeValueSelectableTypeInput<TRes> get swatch {
    final local$swatch = _instance.swatch;
    return local$swatch == null
        ? CopyWith$Input$AttributeValueSelectableTypeInput.stub(
            _then(_instance))
        : CopyWith$Input$AttributeValueSelectableTypeInput(
            local$swatch, (e) => call(swatch: e));
  }

  TRes multiselect(
          Iterable<Input$AttributeValueSelectableTypeInput>? Function(
                  Iterable<
                      CopyWith$Input$AttributeValueSelectableTypeInput<
                          Input$AttributeValueSelectableTypeInput>>?)
              _fn) =>
      call(
          multiselect: _fn(_instance.multiselect
              ?.map((e) => CopyWith$Input$AttributeValueSelectableTypeInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$BulkAttributeValueInput<TRes>
    implements CopyWith$Input$BulkAttributeValueInput<TRes> {
  _CopyWithStubImpl$Input$BulkAttributeValueInput(this._res);

  TRes _res;

  call({
    String? id,
    String? externalReference,
    List<String>? values,
    Input$AttributeValueSelectableTypeInput? dropdown,
    Input$AttributeValueSelectableTypeInput? swatch,
    List<Input$AttributeValueSelectableTypeInput>? multiselect,
    String? numeric,
    String? file,
    String? contentType,
    List<String>? references,
    String? richText,
    String? plainText,
    bool? boolean,
    String? date,
    String? dateTime,
  }) =>
      _res;

  CopyWith$Input$AttributeValueSelectableTypeInput<TRes> get dropdown =>
      CopyWith$Input$AttributeValueSelectableTypeInput.stub(_res);

  CopyWith$Input$AttributeValueSelectableTypeInput<TRes> get swatch =>
      CopyWith$Input$AttributeValueSelectableTypeInput.stub(_res);

  multiselect(_fn) => _res;
}

class Input$CardInput {
  factory Input$CardInput({
    required String code,
    String? cvc,
    required Input$MoneyInput money,
  }) =>
      Input$CardInput._({
        r'code': code,
        if (cvc != null) r'cvc': cvc,
        r'money': money,
      });

  Input$CardInput._(this._$data);

  factory Input$CardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$code = data['code'];
    result$data['code'] = (l$code as String);
    if (data.containsKey('cvc')) {
      final l$cvc = data['cvc'];
      result$data['cvc'] = (l$cvc as String?);
    }
    final l$money = data['money'];
    result$data['money'] =
        Input$MoneyInput.fromJson((l$money as Map<String, dynamic>));
    return Input$CardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get code => (_$data['code'] as String);

  String? get cvc => (_$data['cvc'] as String?);

  Input$MoneyInput get money => (_$data['money'] as Input$MoneyInput);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$code = code;
    result$data['code'] = l$code;
    if (_$data.containsKey('cvc')) {
      final l$cvc = cvc;
      result$data['cvc'] = l$cvc;
    }
    final l$money = money;
    result$data['money'] = l$money.toJson();
    return result$data;
  }

  CopyWith$Input$CardInput<Input$CardInput> get copyWith =>
      CopyWith$Input$CardInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CardInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$code = code;
    final lOther$code = other.code;
    if (l$code != lOther$code) {
      return false;
    }
    final l$cvc = cvc;
    final lOther$cvc = other.cvc;
    if (_$data.containsKey('cvc') != other._$data.containsKey('cvc')) {
      return false;
    }
    if (l$cvc != lOther$cvc) {
      return false;
    }
    final l$money = money;
    final lOther$money = other.money;
    if (l$money != lOther$money) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$code = code;
    final l$cvc = cvc;
    final l$money = money;
    return Object.hashAll([
      l$code,
      _$data.containsKey('cvc') ? l$cvc : const {},
      l$money,
    ]);
  }
}

abstract class CopyWith$Input$CardInput<TRes> {
  factory CopyWith$Input$CardInput(
    Input$CardInput instance,
    TRes Function(Input$CardInput) then,
  ) = _CopyWithImpl$Input$CardInput;

  factory CopyWith$Input$CardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CardInput;

  TRes call({
    String? code,
    String? cvc,
    Input$MoneyInput? money,
  });
  CopyWith$Input$MoneyInput<TRes> get money;
}

class _CopyWithImpl$Input$CardInput<TRes>
    implements CopyWith$Input$CardInput<TRes> {
  _CopyWithImpl$Input$CardInput(
    this._instance,
    this._then,
  );

  final Input$CardInput _instance;

  final TRes Function(Input$CardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? code = _undefined,
    Object? cvc = _undefined,
    Object? money = _undefined,
  }) =>
      _then(Input$CardInput._({
        ..._instance._$data,
        if (code != _undefined && code != null) 'code': (code as String),
        if (cvc != _undefined) 'cvc': (cvc as String?),
        if (money != _undefined && money != null)
          'money': (money as Input$MoneyInput),
      }));

  CopyWith$Input$MoneyInput<TRes> get money {
    final local$money = _instance.money;
    return CopyWith$Input$MoneyInput(local$money, (e) => call(money: e));
  }
}

class _CopyWithStubImpl$Input$CardInput<TRes>
    implements CopyWith$Input$CardInput<TRes> {
  _CopyWithStubImpl$Input$CardInput(this._res);

  TRes _res;

  call({
    String? code,
    String? cvc,
    Input$MoneyInput? money,
  }) =>
      _res;

  CopyWith$Input$MoneyInput<TRes> get money =>
      CopyWith$Input$MoneyInput.stub(_res);
}

class Input$CatalogueInput {
  factory Input$CatalogueInput({
    List<String>? products,
    List<String>? categories,
    List<String>? collections,
    List<String>? variants,
  }) =>
      Input$CatalogueInput._({
        if (products != null) r'products': products,
        if (categories != null) r'categories': categories,
        if (collections != null) r'collections': collections,
        if (variants != null) r'variants': variants,
      });

  Input$CatalogueInput._(this._$data);

  factory Input$CatalogueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('products')) {
      final l$products = data['products'];
      result$data['products'] =
          (l$products as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('categories')) {
      final l$categories = data['categories'];
      result$data['categories'] =
          (l$categories as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('collections')) {
      final l$collections = data['collections'];
      result$data['collections'] =
          (l$collections as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('variants')) {
      final l$variants = data['variants'];
      result$data['variants'] =
          (l$variants as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$CatalogueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get products => (_$data['products'] as List<String>?);

  List<String>? get categories => (_$data['categories'] as List<String>?);

  List<String>? get collections => (_$data['collections'] as List<String>?);

  List<String>? get variants => (_$data['variants'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('products')) {
      final l$products = products;
      result$data['products'] = l$products?.map((e) => e).toList();
    }
    if (_$data.containsKey('categories')) {
      final l$categories = categories;
      result$data['categories'] = l$categories?.map((e) => e).toList();
    }
    if (_$data.containsKey('collections')) {
      final l$collections = collections;
      result$data['collections'] = l$collections?.map((e) => e).toList();
    }
    if (_$data.containsKey('variants')) {
      final l$variants = variants;
      result$data['variants'] = l$variants?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$CatalogueInput<Input$CatalogueInput> get copyWith =>
      CopyWith$Input$CatalogueInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CatalogueInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$products = products;
    final lOther$products = other.products;
    if (_$data.containsKey('products') !=
        other._$data.containsKey('products')) {
      return false;
    }
    if (l$products != null && lOther$products != null) {
      if (l$products.length != lOther$products.length) {
        return false;
      }
      for (int i = 0; i < l$products.length; i++) {
        final l$products$entry = l$products[i];
        final lOther$products$entry = lOther$products[i];
        if (l$products$entry != lOther$products$entry) {
          return false;
        }
      }
    } else if (l$products != lOther$products) {
      return false;
    }
    final l$categories = categories;
    final lOther$categories = other.categories;
    if (_$data.containsKey('categories') !=
        other._$data.containsKey('categories')) {
      return false;
    }
    if (l$categories != null && lOther$categories != null) {
      if (l$categories.length != lOther$categories.length) {
        return false;
      }
      for (int i = 0; i < l$categories.length; i++) {
        final l$categories$entry = l$categories[i];
        final lOther$categories$entry = lOther$categories[i];
        if (l$categories$entry != lOther$categories$entry) {
          return false;
        }
      }
    } else if (l$categories != lOther$categories) {
      return false;
    }
    final l$collections = collections;
    final lOther$collections = other.collections;
    if (_$data.containsKey('collections') !=
        other._$data.containsKey('collections')) {
      return false;
    }
    if (l$collections != null && lOther$collections != null) {
      if (l$collections.length != lOther$collections.length) {
        return false;
      }
      for (int i = 0; i < l$collections.length; i++) {
        final l$collections$entry = l$collections[i];
        final lOther$collections$entry = lOther$collections[i];
        if (l$collections$entry != lOther$collections$entry) {
          return false;
        }
      }
    } else if (l$collections != lOther$collections) {
      return false;
    }
    final l$variants = variants;
    final lOther$variants = other.variants;
    if (_$data.containsKey('variants') !=
        other._$data.containsKey('variants')) {
      return false;
    }
    if (l$variants != null && lOther$variants != null) {
      if (l$variants.length != lOther$variants.length) {
        return false;
      }
      for (int i = 0; i < l$variants.length; i++) {
        final l$variants$entry = l$variants[i];
        final lOther$variants$entry = lOther$variants[i];
        if (l$variants$entry != lOther$variants$entry) {
          return false;
        }
      }
    } else if (l$variants != lOther$variants) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$products = products;
    final l$categories = categories;
    final l$collections = collections;
    final l$variants = variants;
    return Object.hashAll([
      _$data.containsKey('products')
          ? l$products == null
              ? null
              : Object.hashAll(l$products.map((v) => v))
          : const {},
      _$data.containsKey('categories')
          ? l$categories == null
              ? null
              : Object.hashAll(l$categories.map((v) => v))
          : const {},
      _$data.containsKey('collections')
          ? l$collections == null
              ? null
              : Object.hashAll(l$collections.map((v) => v))
          : const {},
      _$data.containsKey('variants')
          ? l$variants == null
              ? null
              : Object.hashAll(l$variants.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CatalogueInput<TRes> {
  factory CopyWith$Input$CatalogueInput(
    Input$CatalogueInput instance,
    TRes Function(Input$CatalogueInput) then,
  ) = _CopyWithImpl$Input$CatalogueInput;

  factory CopyWith$Input$CatalogueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CatalogueInput;

  TRes call({
    List<String>? products,
    List<String>? categories,
    List<String>? collections,
    List<String>? variants,
  });
}

class _CopyWithImpl$Input$CatalogueInput<TRes>
    implements CopyWith$Input$CatalogueInput<TRes> {
  _CopyWithImpl$Input$CatalogueInput(
    this._instance,
    this._then,
  );

  final Input$CatalogueInput _instance;

  final TRes Function(Input$CatalogueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? products = _undefined,
    Object? categories = _undefined,
    Object? collections = _undefined,
    Object? variants = _undefined,
  }) =>
      _then(Input$CatalogueInput._({
        ..._instance._$data,
        if (products != _undefined) 'products': (products as List<String>?),
        if (categories != _undefined)
          'categories': (categories as List<String>?),
        if (collections != _undefined)
          'collections': (collections as List<String>?),
        if (variants != _undefined) 'variants': (variants as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$CatalogueInput<TRes>
    implements CopyWith$Input$CatalogueInput<TRes> {
  _CopyWithStubImpl$Input$CatalogueInput(this._res);

  TRes _res;

  call({
    List<String>? products,
    List<String>? categories,
    List<String>? collections,
    List<String>? variants,
  }) =>
      _res;
}

class Input$CataloguePredicateInput {
  factory Input$CataloguePredicateInput({
    Input$ProductVariantWhereInput? variantPredicate,
    Input$ProductWhereInput? productPredicate,
    Input$CategoryWhereInput? categoryPredicate,
    Input$CollectionWhereInput? collectionPredicate,
    List<Input$CataloguePredicateInput>? AND,
    List<Input$CataloguePredicateInput>? OR,
  }) =>
      Input$CataloguePredicateInput._({
        if (variantPredicate != null) r'variantPredicate': variantPredicate,
        if (productPredicate != null) r'productPredicate': productPredicate,
        if (categoryPredicate != null) r'categoryPredicate': categoryPredicate,
        if (collectionPredicate != null)
          r'collectionPredicate': collectionPredicate,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
      });

  Input$CataloguePredicateInput._(this._$data);

  factory Input$CataloguePredicateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('variantPredicate')) {
      final l$variantPredicate = data['variantPredicate'];
      result$data['variantPredicate'] = l$variantPredicate == null
          ? null
          : Input$ProductVariantWhereInput.fromJson(
              (l$variantPredicate as Map<String, dynamic>));
    }
    if (data.containsKey('productPredicate')) {
      final l$productPredicate = data['productPredicate'];
      result$data['productPredicate'] = l$productPredicate == null
          ? null
          : Input$ProductWhereInput.fromJson(
              (l$productPredicate as Map<String, dynamic>));
    }
    if (data.containsKey('categoryPredicate')) {
      final l$categoryPredicate = data['categoryPredicate'];
      result$data['categoryPredicate'] = l$categoryPredicate == null
          ? null
          : Input$CategoryWhereInput.fromJson(
              (l$categoryPredicate as Map<String, dynamic>));
    }
    if (data.containsKey('collectionPredicate')) {
      final l$collectionPredicate = data['collectionPredicate'];
      result$data['collectionPredicate'] = l$collectionPredicate == null
          ? null
          : Input$CollectionWhereInput.fromJson(
              (l$collectionPredicate as Map<String, dynamic>));
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$CataloguePredicateInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$CataloguePredicateInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$CataloguePredicateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductVariantWhereInput? get variantPredicate =>
      (_$data['variantPredicate'] as Input$ProductVariantWhereInput?);

  Input$ProductWhereInput? get productPredicate =>
      (_$data['productPredicate'] as Input$ProductWhereInput?);

  Input$CategoryWhereInput? get categoryPredicate =>
      (_$data['categoryPredicate'] as Input$CategoryWhereInput?);

  Input$CollectionWhereInput? get collectionPredicate =>
      (_$data['collectionPredicate'] as Input$CollectionWhereInput?);

  List<Input$CataloguePredicateInput>? get AND =>
      (_$data['AND'] as List<Input$CataloguePredicateInput>?);

  List<Input$CataloguePredicateInput>? get OR =>
      (_$data['OR'] as List<Input$CataloguePredicateInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('variantPredicate')) {
      final l$variantPredicate = variantPredicate;
      result$data['variantPredicate'] = l$variantPredicate?.toJson();
    }
    if (_$data.containsKey('productPredicate')) {
      final l$productPredicate = productPredicate;
      result$data['productPredicate'] = l$productPredicate?.toJson();
    }
    if (_$data.containsKey('categoryPredicate')) {
      final l$categoryPredicate = categoryPredicate;
      result$data['categoryPredicate'] = l$categoryPredicate?.toJson();
    }
    if (_$data.containsKey('collectionPredicate')) {
      final l$collectionPredicate = collectionPredicate;
      result$data['collectionPredicate'] = l$collectionPredicate?.toJson();
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$CataloguePredicateInput<Input$CataloguePredicateInput>
      get copyWith => CopyWith$Input$CataloguePredicateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CataloguePredicateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$variantPredicate = variantPredicate;
    final lOther$variantPredicate = other.variantPredicate;
    if (_$data.containsKey('variantPredicate') !=
        other._$data.containsKey('variantPredicate')) {
      return false;
    }
    if (l$variantPredicate != lOther$variantPredicate) {
      return false;
    }
    final l$productPredicate = productPredicate;
    final lOther$productPredicate = other.productPredicate;
    if (_$data.containsKey('productPredicate') !=
        other._$data.containsKey('productPredicate')) {
      return false;
    }
    if (l$productPredicate != lOther$productPredicate) {
      return false;
    }
    final l$categoryPredicate = categoryPredicate;
    final lOther$categoryPredicate = other.categoryPredicate;
    if (_$data.containsKey('categoryPredicate') !=
        other._$data.containsKey('categoryPredicate')) {
      return false;
    }
    if (l$categoryPredicate != lOther$categoryPredicate) {
      return false;
    }
    final l$collectionPredicate = collectionPredicate;
    final lOther$collectionPredicate = other.collectionPredicate;
    if (_$data.containsKey('collectionPredicate') !=
        other._$data.containsKey('collectionPredicate')) {
      return false;
    }
    if (l$collectionPredicate != lOther$collectionPredicate) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$variantPredicate = variantPredicate;
    final l$productPredicate = productPredicate;
    final l$categoryPredicate = categoryPredicate;
    final l$collectionPredicate = collectionPredicate;
    final l$AND = AND;
    final l$OR = OR;
    return Object.hashAll([
      _$data.containsKey('variantPredicate') ? l$variantPredicate : const {},
      _$data.containsKey('productPredicate') ? l$productPredicate : const {},
      _$data.containsKey('categoryPredicate') ? l$categoryPredicate : const {},
      _$data.containsKey('collectionPredicate')
          ? l$collectionPredicate
          : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CataloguePredicateInput<TRes> {
  factory CopyWith$Input$CataloguePredicateInput(
    Input$CataloguePredicateInput instance,
    TRes Function(Input$CataloguePredicateInput) then,
  ) = _CopyWithImpl$Input$CataloguePredicateInput;

  factory CopyWith$Input$CataloguePredicateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CataloguePredicateInput;

  TRes call({
    Input$ProductVariantWhereInput? variantPredicate,
    Input$ProductWhereInput? productPredicate,
    Input$CategoryWhereInput? categoryPredicate,
    Input$CollectionWhereInput? collectionPredicate,
    List<Input$CataloguePredicateInput>? AND,
    List<Input$CataloguePredicateInput>? OR,
  });
  CopyWith$Input$ProductVariantWhereInput<TRes> get variantPredicate;
  CopyWith$Input$ProductWhereInput<TRes> get productPredicate;
  CopyWith$Input$CategoryWhereInput<TRes> get categoryPredicate;
  CopyWith$Input$CollectionWhereInput<TRes> get collectionPredicate;
  TRes AND(
      Iterable<Input$CataloguePredicateInput>? Function(
              Iterable<
                  CopyWith$Input$CataloguePredicateInput<
                      Input$CataloguePredicateInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$CataloguePredicateInput>? Function(
              Iterable<
                  CopyWith$Input$CataloguePredicateInput<
                      Input$CataloguePredicateInput>>?)
          _fn);
}

class _CopyWithImpl$Input$CataloguePredicateInput<TRes>
    implements CopyWith$Input$CataloguePredicateInput<TRes> {
  _CopyWithImpl$Input$CataloguePredicateInput(
    this._instance,
    this._then,
  );

  final Input$CataloguePredicateInput _instance;

  final TRes Function(Input$CataloguePredicateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? variantPredicate = _undefined,
    Object? productPredicate = _undefined,
    Object? categoryPredicate = _undefined,
    Object? collectionPredicate = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
  }) =>
      _then(Input$CataloguePredicateInput._({
        ..._instance._$data,
        if (variantPredicate != _undefined)
          'variantPredicate':
              (variantPredicate as Input$ProductVariantWhereInput?),
        if (productPredicate != _undefined)
          'productPredicate': (productPredicate as Input$ProductWhereInput?),
        if (categoryPredicate != _undefined)
          'categoryPredicate': (categoryPredicate as Input$CategoryWhereInput?),
        if (collectionPredicate != _undefined)
          'collectionPredicate':
              (collectionPredicate as Input$CollectionWhereInput?),
        if (AND != _undefined)
          'AND': (AND as List<Input$CataloguePredicateInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$CataloguePredicateInput>?),
      }));

  CopyWith$Input$ProductVariantWhereInput<TRes> get variantPredicate {
    final local$variantPredicate = _instance.variantPredicate;
    return local$variantPredicate == null
        ? CopyWith$Input$ProductVariantWhereInput.stub(_then(_instance))
        : CopyWith$Input$ProductVariantWhereInput(
            local$variantPredicate, (e) => call(variantPredicate: e));
  }

  CopyWith$Input$ProductWhereInput<TRes> get productPredicate {
    final local$productPredicate = _instance.productPredicate;
    return local$productPredicate == null
        ? CopyWith$Input$ProductWhereInput.stub(_then(_instance))
        : CopyWith$Input$ProductWhereInput(
            local$productPredicate, (e) => call(productPredicate: e));
  }

  CopyWith$Input$CategoryWhereInput<TRes> get categoryPredicate {
    final local$categoryPredicate = _instance.categoryPredicate;
    return local$categoryPredicate == null
        ? CopyWith$Input$CategoryWhereInput.stub(_then(_instance))
        : CopyWith$Input$CategoryWhereInput(
            local$categoryPredicate, (e) => call(categoryPredicate: e));
  }

  CopyWith$Input$CollectionWhereInput<TRes> get collectionPredicate {
    final local$collectionPredicate = _instance.collectionPredicate;
    return local$collectionPredicate == null
        ? CopyWith$Input$CollectionWhereInput.stub(_then(_instance))
        : CopyWith$Input$CollectionWhereInput(
            local$collectionPredicate, (e) => call(collectionPredicate: e));
  }

  TRes AND(
          Iterable<Input$CataloguePredicateInput>? Function(
                  Iterable<
                      CopyWith$Input$CataloguePredicateInput<
                          Input$CataloguePredicateInput>>?)
              _fn) =>
      call(
          AND: _fn(
              _instance.AND?.map((e) => CopyWith$Input$CataloguePredicateInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes OR(
          Iterable<Input$CataloguePredicateInput>? Function(
                  Iterable<
                      CopyWith$Input$CataloguePredicateInput<
                          Input$CataloguePredicateInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$CataloguePredicateInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CataloguePredicateInput<TRes>
    implements CopyWith$Input$CataloguePredicateInput<TRes> {
  _CopyWithStubImpl$Input$CataloguePredicateInput(this._res);

  TRes _res;

  call({
    Input$ProductVariantWhereInput? variantPredicate,
    Input$ProductWhereInput? productPredicate,
    Input$CategoryWhereInput? categoryPredicate,
    Input$CollectionWhereInput? collectionPredicate,
    List<Input$CataloguePredicateInput>? AND,
    List<Input$CataloguePredicateInput>? OR,
  }) =>
      _res;

  CopyWith$Input$ProductVariantWhereInput<TRes> get variantPredicate =>
      CopyWith$Input$ProductVariantWhereInput.stub(_res);

  CopyWith$Input$ProductWhereInput<TRes> get productPredicate =>
      CopyWith$Input$ProductWhereInput.stub(_res);

  CopyWith$Input$CategoryWhereInput<TRes> get categoryPredicate =>
      CopyWith$Input$CategoryWhereInput.stub(_res);

  CopyWith$Input$CollectionWhereInput<TRes> get collectionPredicate =>
      CopyWith$Input$CollectionWhereInput.stub(_res);

  AND(_fn) => _res;

  OR(_fn) => _res;
}

class Input$CategoryFilterInput {
  factory Input$CategoryFilterInput({
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<String>? slugs,
    Input$DateTimeRangeInput? updatedAt,
  }) =>
      Input$CategoryFilterInput._({
        if (search != null) r'search': search,
        if (metadata != null) r'metadata': metadata,
        if (ids != null) r'ids': ids,
        if (slugs != null) r'slugs': slugs,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$CategoryFilterInput._(this._$data);

  factory Input$CategoryFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('slugs')) {
      final l$slugs = data['slugs'];
      result$data['slugs'] =
          (l$slugs as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeRangeInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    return Input$CategoryFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get search => (_$data['search'] as String?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  List<String>? get slugs => (_$data['slugs'] as List<String>?);

  Input$DateTimeRangeInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeRangeInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('slugs')) {
      final l$slugs = slugs;
      result$data['slugs'] = l$slugs?.map((e) => e).toList();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CategoryFilterInput<Input$CategoryFilterInput> get copyWith =>
      CopyWith$Input$CategoryFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CategoryFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$slugs = slugs;
    final lOther$slugs = other.slugs;
    if (_$data.containsKey('slugs') != other._$data.containsKey('slugs')) {
      return false;
    }
    if (l$slugs != null && lOther$slugs != null) {
      if (l$slugs.length != lOther$slugs.length) {
        return false;
      }
      for (int i = 0; i < l$slugs.length; i++) {
        final l$slugs$entry = l$slugs[i];
        final lOther$slugs$entry = lOther$slugs[i];
        if (l$slugs$entry != lOther$slugs$entry) {
          return false;
        }
      }
    } else if (l$slugs != lOther$slugs) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$search = search;
    final l$metadata = metadata;
    final l$ids = ids;
    final l$slugs = slugs;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('slugs')
          ? l$slugs == null
              ? null
              : Object.hashAll(l$slugs.map((v) => v))
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$CategoryFilterInput<TRes> {
  factory CopyWith$Input$CategoryFilterInput(
    Input$CategoryFilterInput instance,
    TRes Function(Input$CategoryFilterInput) then,
  ) = _CopyWithImpl$Input$CategoryFilterInput;

  factory CopyWith$Input$CategoryFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CategoryFilterInput;

  TRes call({
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<String>? slugs,
    Input$DateTimeRangeInput? updatedAt,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$CategoryFilterInput<TRes>
    implements CopyWith$Input$CategoryFilterInput<TRes> {
  _CopyWithImpl$Input$CategoryFilterInput(
    this._instance,
    this._then,
  );

  final Input$CategoryFilterInput _instance;

  final TRes Function(Input$CategoryFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? search = _undefined,
    Object? metadata = _undefined,
    Object? ids = _undefined,
    Object? slugs = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$CategoryFilterInput._({
        ..._instance._$data,
        if (search != _undefined) 'search': (search as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (slugs != _undefined) 'slugs': (slugs as List<String>?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeRangeInput?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeRangeInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }
}

class _CopyWithStubImpl$Input$CategoryFilterInput<TRes>
    implements CopyWith$Input$CategoryFilterInput<TRes> {
  _CopyWithStubImpl$Input$CategoryFilterInput(this._res);

  TRes _res;

  call({
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<String>? slugs,
    Input$DateTimeRangeInput? updatedAt,
  }) =>
      _res;

  metadata(_fn) => _res;

  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeRangeInput.stub(_res);
}

class Input$CategoryInput {
  factory Input$CategoryInput({
    String? description,
    String? name,
    String? slug,
    Input$SeoInput? seo,
    String? backgroundImage,
    String? backgroundImageAlt,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  }) =>
      Input$CategoryInput._({
        if (description != null) r'description': description,
        if (name != null) r'name': name,
        if (slug != null) r'slug': slug,
        if (seo != null) r'seo': seo,
        if (backgroundImage != null) r'backgroundImage': backgroundImage,
        if (backgroundImageAlt != null)
          r'backgroundImageAlt': backgroundImageAlt,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
      });

  Input$CategoryInput._(this._$data);

  factory Input$CategoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('seo')) {
      final l$seo = data['seo'];
      result$data['seo'] = l$seo == null
          ? null
          : Input$SeoInput.fromJson((l$seo as Map<String, dynamic>));
    }
    if (data.containsKey('backgroundImage')) {
      final l$backgroundImage = data['backgroundImage'];
      result$data['backgroundImage'] = (l$backgroundImage as String?);
    }
    if (data.containsKey('backgroundImageAlt')) {
      final l$backgroundImageAlt = data['backgroundImageAlt'];
      result$data['backgroundImageAlt'] = (l$backgroundImageAlt as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$CategoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get description => (_$data['description'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get slug => (_$data['slug'] as String?);

  Input$SeoInput? get seo => (_$data['seo'] as Input$SeoInput?);

  String? get backgroundImage => (_$data['backgroundImage'] as String?);

  String? get backgroundImageAlt => (_$data['backgroundImageAlt'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('seo')) {
      final l$seo = seo;
      result$data['seo'] = l$seo?.toJson();
    }
    if (_$data.containsKey('backgroundImage')) {
      final l$backgroundImage = backgroundImage;
      result$data['backgroundImage'] = l$backgroundImage;
    }
    if (_$data.containsKey('backgroundImageAlt')) {
      final l$backgroundImageAlt = backgroundImageAlt;
      result$data['backgroundImageAlt'] = l$backgroundImageAlt;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$CategoryInput<Input$CategoryInput> get copyWith =>
      CopyWith$Input$CategoryInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CategoryInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$seo = seo;
    final lOther$seo = other.seo;
    if (_$data.containsKey('seo') != other._$data.containsKey('seo')) {
      return false;
    }
    if (l$seo != lOther$seo) {
      return false;
    }
    final l$backgroundImage = backgroundImage;
    final lOther$backgroundImage = other.backgroundImage;
    if (_$data.containsKey('backgroundImage') !=
        other._$data.containsKey('backgroundImage')) {
      return false;
    }
    if (l$backgroundImage != lOther$backgroundImage) {
      return false;
    }
    final l$backgroundImageAlt = backgroundImageAlt;
    final lOther$backgroundImageAlt = other.backgroundImageAlt;
    if (_$data.containsKey('backgroundImageAlt') !=
        other._$data.containsKey('backgroundImageAlt')) {
      return false;
    }
    if (l$backgroundImageAlt != lOther$backgroundImageAlt) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$description = description;
    final l$name = name;
    final l$slug = slug;
    final l$seo = seo;
    final l$backgroundImage = backgroundImage;
    final l$backgroundImageAlt = backgroundImageAlt;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    return Object.hashAll([
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('seo') ? l$seo : const {},
      _$data.containsKey('backgroundImage') ? l$backgroundImage : const {},
      _$data.containsKey('backgroundImageAlt')
          ? l$backgroundImageAlt
          : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CategoryInput<TRes> {
  factory CopyWith$Input$CategoryInput(
    Input$CategoryInput instance,
    TRes Function(Input$CategoryInput) then,
  ) = _CopyWithImpl$Input$CategoryInput;

  factory CopyWith$Input$CategoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CategoryInput;

  TRes call({
    String? description,
    String? name,
    String? slug,
    Input$SeoInput? seo,
    String? backgroundImage,
    String? backgroundImageAlt,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  });
  CopyWith$Input$SeoInput<TRes> get seo;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$CategoryInput<TRes>
    implements CopyWith$Input$CategoryInput<TRes> {
  _CopyWithImpl$Input$CategoryInput(
    this._instance,
    this._then,
  );

  final Input$CategoryInput _instance;

  final TRes Function(Input$CategoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? description = _undefined,
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? seo = _undefined,
    Object? backgroundImage = _undefined,
    Object? backgroundImageAlt = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
  }) =>
      _then(Input$CategoryInput._({
        ..._instance._$data,
        if (description != _undefined) 'description': (description as String?),
        if (name != _undefined) 'name': (name as String?),
        if (slug != _undefined) 'slug': (slug as String?),
        if (seo != _undefined) 'seo': (seo as Input$SeoInput?),
        if (backgroundImage != _undefined)
          'backgroundImage': (backgroundImage as String?),
        if (backgroundImageAlt != _undefined)
          'backgroundImageAlt': (backgroundImageAlt as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
      }));

  CopyWith$Input$SeoInput<TRes> get seo {
    final local$seo = _instance.seo;
    return local$seo == null
        ? CopyWith$Input$SeoInput.stub(_then(_instance))
        : CopyWith$Input$SeoInput(local$seo, (e) => call(seo: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CategoryInput<TRes>
    implements CopyWith$Input$CategoryInput<TRes> {
  _CopyWithStubImpl$Input$CategoryInput(this._res);

  TRes _res;

  call({
    String? description,
    String? name,
    String? slug,
    Input$SeoInput? seo,
    String? backgroundImage,
    String? backgroundImageAlt,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  }) =>
      _res;

  CopyWith$Input$SeoInput<TRes> get seo => CopyWith$Input$SeoInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$CategorySortingInput {
  factory Input$CategorySortingInput({
    required Enum$OrderDirection direction,
    String? channel,
    required Enum$CategorySortField field,
  }) =>
      Input$CategorySortingInput._({
        r'direction': direction,
        if (channel != null) r'channel': channel,
        r'field': field,
      });

  Input$CategorySortingInput._(this._$data);

  factory Input$CategorySortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    if (data.containsKey('channel')) {
      final l$channel = data['channel'];
      result$data['channel'] = (l$channel as String?);
    }
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$CategorySortField((l$field as String));
    return Input$CategorySortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  String? get channel => (_$data['channel'] as String?);

  Enum$CategorySortField get field =>
      (_$data['field'] as Enum$CategorySortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    if (_$data.containsKey('channel')) {
      final l$channel = channel;
      result$data['channel'] = l$channel;
    }
    final l$field = field;
    result$data['field'] = toJson$Enum$CategorySortField(l$field);
    return result$data;
  }

  CopyWith$Input$CategorySortingInput<Input$CategorySortingInput>
      get copyWith => CopyWith$Input$CategorySortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CategorySortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$channel = channel;
    final lOther$channel = other.channel;
    if (_$data.containsKey('channel') != other._$data.containsKey('channel')) {
      return false;
    }
    if (l$channel != lOther$channel) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$channel = channel;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      _$data.containsKey('channel') ? l$channel : const {},
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$CategorySortingInput<TRes> {
  factory CopyWith$Input$CategorySortingInput(
    Input$CategorySortingInput instance,
    TRes Function(Input$CategorySortingInput) then,
  ) = _CopyWithImpl$Input$CategorySortingInput;

  factory CopyWith$Input$CategorySortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CategorySortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    String? channel,
    Enum$CategorySortField? field,
  });
}

class _CopyWithImpl$Input$CategorySortingInput<TRes>
    implements CopyWith$Input$CategorySortingInput<TRes> {
  _CopyWithImpl$Input$CategorySortingInput(
    this._instance,
    this._then,
  );

  final Input$CategorySortingInput _instance;

  final TRes Function(Input$CategorySortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? channel = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$CategorySortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (channel != _undefined) 'channel': (channel as String?),
        if (field != _undefined && field != null)
          'field': (field as Enum$CategorySortField),
      }));
}

class _CopyWithStubImpl$Input$CategorySortingInput<TRes>
    implements CopyWith$Input$CategorySortingInput<TRes> {
  _CopyWithStubImpl$Input$CategorySortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    String? channel,
    Enum$CategorySortField? field,
  }) =>
      _res;
}

class Input$CategoryWhereInput {
  factory Input$CategoryWhereInput({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<Input$CategoryWhereInput>? AND,
    List<Input$CategoryWhereInput>? OR,
  }) =>
      Input$CategoryWhereInput._({
        if (metadata != null) r'metadata': metadata,
        if (ids != null) r'ids': ids,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
      });

  Input$CategoryWhereInput._(this._$data);

  factory Input$CategoryWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$CategoryWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$CategoryWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$CategoryWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  List<Input$CategoryWhereInput>? get AND =>
      (_$data['AND'] as List<Input$CategoryWhereInput>?);

  List<Input$CategoryWhereInput>? get OR =>
      (_$data['OR'] as List<Input$CategoryWhereInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$CategoryWhereInput<Input$CategoryWhereInput> get copyWith =>
      CopyWith$Input$CategoryWhereInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CategoryWhereInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$metadata = metadata;
    final l$ids = ids;
    final l$AND = AND;
    final l$OR = OR;
    return Object.hashAll([
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CategoryWhereInput<TRes> {
  factory CopyWith$Input$CategoryWhereInput(
    Input$CategoryWhereInput instance,
    TRes Function(Input$CategoryWhereInput) then,
  ) = _CopyWithImpl$Input$CategoryWhereInput;

  factory CopyWith$Input$CategoryWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CategoryWhereInput;

  TRes call({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<Input$CategoryWhereInput>? AND,
    List<Input$CategoryWhereInput>? OR,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
  TRes AND(
      Iterable<Input$CategoryWhereInput>? Function(
              Iterable<
                  CopyWith$Input$CategoryWhereInput<Input$CategoryWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$CategoryWhereInput>? Function(
              Iterable<
                  CopyWith$Input$CategoryWhereInput<Input$CategoryWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$CategoryWhereInput<TRes>
    implements CopyWith$Input$CategoryWhereInput<TRes> {
  _CopyWithImpl$Input$CategoryWhereInput(
    this._instance,
    this._then,
  );

  final Input$CategoryWhereInput _instance;

  final TRes Function(Input$CategoryWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? metadata = _undefined,
    Object? ids = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
  }) =>
      _then(Input$CategoryWhereInput._({
        ..._instance._$data,
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (AND != _undefined) 'AND': (AND as List<Input$CategoryWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$CategoryWhereInput>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes AND(
          Iterable<Input$CategoryWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$CategoryWhereInput<
                          Input$CategoryWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$CategoryWhereInput(
                e,
                (i) => i,
              )))?.toList());

  TRes OR(
          Iterable<Input$CategoryWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$CategoryWhereInput<
                          Input$CategoryWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$CategoryWhereInput(
                e,
                (i) => i,
              )))?.toList());
}

class _CopyWithStubImpl$Input$CategoryWhereInput<TRes>
    implements CopyWith$Input$CategoryWhereInput<TRes> {
  _CopyWithStubImpl$Input$CategoryWhereInput(this._res);

  TRes _res;

  call({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<Input$CategoryWhereInput>? AND,
    List<Input$CategoryWhereInput>? OR,
  }) =>
      _res;

  metadata(_fn) => _res;

  AND(_fn) => _res;

  OR(_fn) => _res;
}

class Input$ChannelCreateInput {
  factory Input$ChannelCreateInput({
    bool? isActive,
    Input$StockSettingsInput? stockSettings,
    List<String>? addShippingZones,
    List<String>? addWarehouses,
    Input$OrderSettingsInput? orderSettings,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Input$CheckoutSettingsInput? checkoutSettings,
    Input$PaymentSettingsInput? paymentSettings,
    required String name,
    required String slug,
    required String currencyCode,
    required Enum$CountryCode defaultCountry,
  }) =>
      Input$ChannelCreateInput._({
        if (isActive != null) r'isActive': isActive,
        if (stockSettings != null) r'stockSettings': stockSettings,
        if (addShippingZones != null) r'addShippingZones': addShippingZones,
        if (addWarehouses != null) r'addWarehouses': addWarehouses,
        if (orderSettings != null) r'orderSettings': orderSettings,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (checkoutSettings != null) r'checkoutSettings': checkoutSettings,
        if (paymentSettings != null) r'paymentSettings': paymentSettings,
        r'name': name,
        r'slug': slug,
        r'currencyCode': currencyCode,
        r'defaultCountry': defaultCountry,
      });

  Input$ChannelCreateInput._(this._$data);

  factory Input$ChannelCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = (l$isActive as bool?);
    }
    if (data.containsKey('stockSettings')) {
      final l$stockSettings = data['stockSettings'];
      result$data['stockSettings'] = l$stockSettings == null
          ? null
          : Input$StockSettingsInput.fromJson(
              (l$stockSettings as Map<String, dynamic>));
    }
    if (data.containsKey('addShippingZones')) {
      final l$addShippingZones = data['addShippingZones'];
      result$data['addShippingZones'] = (l$addShippingZones as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('addWarehouses')) {
      final l$addWarehouses = data['addWarehouses'];
      result$data['addWarehouses'] = (l$addWarehouses as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('orderSettings')) {
      final l$orderSettings = data['orderSettings'];
      result$data['orderSettings'] = l$orderSettings == null
          ? null
          : Input$OrderSettingsInput.fromJson(
              (l$orderSettings as Map<String, dynamic>));
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('checkoutSettings')) {
      final l$checkoutSettings = data['checkoutSettings'];
      result$data['checkoutSettings'] = l$checkoutSettings == null
          ? null
          : Input$CheckoutSettingsInput.fromJson(
              (l$checkoutSettings as Map<String, dynamic>));
    }
    if (data.containsKey('paymentSettings')) {
      final l$paymentSettings = data['paymentSettings'];
      result$data['paymentSettings'] = l$paymentSettings == null
          ? null
          : Input$PaymentSettingsInput.fromJson(
              (l$paymentSettings as Map<String, dynamic>));
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$slug = data['slug'];
    result$data['slug'] = (l$slug as String);
    final l$currencyCode = data['currencyCode'];
    result$data['currencyCode'] = (l$currencyCode as String);
    final l$defaultCountry = data['defaultCountry'];
    result$data['defaultCountry'] =
        fromJson$Enum$CountryCode((l$defaultCountry as String));
    return Input$ChannelCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get isActive => (_$data['isActive'] as bool?);

  Input$StockSettingsInput? get stockSettings =>
      (_$data['stockSettings'] as Input$StockSettingsInput?);

  List<String>? get addShippingZones =>
      (_$data['addShippingZones'] as List<String>?);

  List<String>? get addWarehouses => (_$data['addWarehouses'] as List<String>?);

  Input$OrderSettingsInput? get orderSettings =>
      (_$data['orderSettings'] as Input$OrderSettingsInput?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  Input$CheckoutSettingsInput? get checkoutSettings =>
      (_$data['checkoutSettings'] as Input$CheckoutSettingsInput?);

  Input$PaymentSettingsInput? get paymentSettings =>
      (_$data['paymentSettings'] as Input$PaymentSettingsInput?);

  String get name => (_$data['name'] as String);

  String get slug => (_$data['slug'] as String);

  String get currencyCode => (_$data['currencyCode'] as String);

  Enum$CountryCode get defaultCountry =>
      (_$data['defaultCountry'] as Enum$CountryCode);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive;
    }
    if (_$data.containsKey('stockSettings')) {
      final l$stockSettings = stockSettings;
      result$data['stockSettings'] = l$stockSettings?.toJson();
    }
    if (_$data.containsKey('addShippingZones')) {
      final l$addShippingZones = addShippingZones;
      result$data['addShippingZones'] =
          l$addShippingZones?.map((e) => e).toList();
    }
    if (_$data.containsKey('addWarehouses')) {
      final l$addWarehouses = addWarehouses;
      result$data['addWarehouses'] = l$addWarehouses?.map((e) => e).toList();
    }
    if (_$data.containsKey('orderSettings')) {
      final l$orderSettings = orderSettings;
      result$data['orderSettings'] = l$orderSettings?.toJson();
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('checkoutSettings')) {
      final l$checkoutSettings = checkoutSettings;
      result$data['checkoutSettings'] = l$checkoutSettings?.toJson();
    }
    if (_$data.containsKey('paymentSettings')) {
      final l$paymentSettings = paymentSettings;
      result$data['paymentSettings'] = l$paymentSettings?.toJson();
    }
    final l$name = name;
    result$data['name'] = l$name;
    final l$slug = slug;
    result$data['slug'] = l$slug;
    final l$currencyCode = currencyCode;
    result$data['currencyCode'] = l$currencyCode;
    final l$defaultCountry = defaultCountry;
    result$data['defaultCountry'] = toJson$Enum$CountryCode(l$defaultCountry);
    return result$data;
  }

  CopyWith$Input$ChannelCreateInput<Input$ChannelCreateInput> get copyWith =>
      CopyWith$Input$ChannelCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ChannelCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$stockSettings = stockSettings;
    final lOther$stockSettings = other.stockSettings;
    if (_$data.containsKey('stockSettings') !=
        other._$data.containsKey('stockSettings')) {
      return false;
    }
    if (l$stockSettings != lOther$stockSettings) {
      return false;
    }
    final l$addShippingZones = addShippingZones;
    final lOther$addShippingZones = other.addShippingZones;
    if (_$data.containsKey('addShippingZones') !=
        other._$data.containsKey('addShippingZones')) {
      return false;
    }
    if (l$addShippingZones != null && lOther$addShippingZones != null) {
      if (l$addShippingZones.length != lOther$addShippingZones.length) {
        return false;
      }
      for (int i = 0; i < l$addShippingZones.length; i++) {
        final l$addShippingZones$entry = l$addShippingZones[i];
        final lOther$addShippingZones$entry = lOther$addShippingZones[i];
        if (l$addShippingZones$entry != lOther$addShippingZones$entry) {
          return false;
        }
      }
    } else if (l$addShippingZones != lOther$addShippingZones) {
      return false;
    }
    final l$addWarehouses = addWarehouses;
    final lOther$addWarehouses = other.addWarehouses;
    if (_$data.containsKey('addWarehouses') !=
        other._$data.containsKey('addWarehouses')) {
      return false;
    }
    if (l$addWarehouses != null && lOther$addWarehouses != null) {
      if (l$addWarehouses.length != lOther$addWarehouses.length) {
        return false;
      }
      for (int i = 0; i < l$addWarehouses.length; i++) {
        final l$addWarehouses$entry = l$addWarehouses[i];
        final lOther$addWarehouses$entry = lOther$addWarehouses[i];
        if (l$addWarehouses$entry != lOther$addWarehouses$entry) {
          return false;
        }
      }
    } else if (l$addWarehouses != lOther$addWarehouses) {
      return false;
    }
    final l$orderSettings = orderSettings;
    final lOther$orderSettings = other.orderSettings;
    if (_$data.containsKey('orderSettings') !=
        other._$data.containsKey('orderSettings')) {
      return false;
    }
    if (l$orderSettings != lOther$orderSettings) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$checkoutSettings = checkoutSettings;
    final lOther$checkoutSettings = other.checkoutSettings;
    if (_$data.containsKey('checkoutSettings') !=
        other._$data.containsKey('checkoutSettings')) {
      return false;
    }
    if (l$checkoutSettings != lOther$checkoutSettings) {
      return false;
    }
    final l$paymentSettings = paymentSettings;
    final lOther$paymentSettings = other.paymentSettings;
    if (_$data.containsKey('paymentSettings') !=
        other._$data.containsKey('paymentSettings')) {
      return false;
    }
    if (l$paymentSettings != lOther$paymentSettings) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$currencyCode = currencyCode;
    final lOther$currencyCode = other.currencyCode;
    if (l$currencyCode != lOther$currencyCode) {
      return false;
    }
    final l$defaultCountry = defaultCountry;
    final lOther$defaultCountry = other.defaultCountry;
    if (l$defaultCountry != lOther$defaultCountry) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$isActive = isActive;
    final l$stockSettings = stockSettings;
    final l$addShippingZones = addShippingZones;
    final l$addWarehouses = addWarehouses;
    final l$orderSettings = orderSettings;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$checkoutSettings = checkoutSettings;
    final l$paymentSettings = paymentSettings;
    final l$name = name;
    final l$slug = slug;
    final l$currencyCode = currencyCode;
    final l$defaultCountry = defaultCountry;
    return Object.hashAll([
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('stockSettings') ? l$stockSettings : const {},
      _$data.containsKey('addShippingZones')
          ? l$addShippingZones == null
              ? null
              : Object.hashAll(l$addShippingZones.map((v) => v))
          : const {},
      _$data.containsKey('addWarehouses')
          ? l$addWarehouses == null
              ? null
              : Object.hashAll(l$addWarehouses.map((v) => v))
          : const {},
      _$data.containsKey('orderSettings') ? l$orderSettings : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('checkoutSettings') ? l$checkoutSettings : const {},
      _$data.containsKey('paymentSettings') ? l$paymentSettings : const {},
      l$name,
      l$slug,
      l$currencyCode,
      l$defaultCountry,
    ]);
  }
}

abstract class CopyWith$Input$ChannelCreateInput<TRes> {
  factory CopyWith$Input$ChannelCreateInput(
    Input$ChannelCreateInput instance,
    TRes Function(Input$ChannelCreateInput) then,
  ) = _CopyWithImpl$Input$ChannelCreateInput;

  factory CopyWith$Input$ChannelCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ChannelCreateInput;

  TRes call({
    bool? isActive,
    Input$StockSettingsInput? stockSettings,
    List<String>? addShippingZones,
    List<String>? addWarehouses,
    Input$OrderSettingsInput? orderSettings,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Input$CheckoutSettingsInput? checkoutSettings,
    Input$PaymentSettingsInput? paymentSettings,
    String? name,
    String? slug,
    String? currencyCode,
    Enum$CountryCode? defaultCountry,
  });
  CopyWith$Input$StockSettingsInput<TRes> get stockSettings;
  CopyWith$Input$OrderSettingsInput<TRes> get orderSettings;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  CopyWith$Input$CheckoutSettingsInput<TRes> get checkoutSettings;
  CopyWith$Input$PaymentSettingsInput<TRes> get paymentSettings;
}

class _CopyWithImpl$Input$ChannelCreateInput<TRes>
    implements CopyWith$Input$ChannelCreateInput<TRes> {
  _CopyWithImpl$Input$ChannelCreateInput(
    this._instance,
    this._then,
  );

  final Input$ChannelCreateInput _instance;

  final TRes Function(Input$ChannelCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? isActive = _undefined,
    Object? stockSettings = _undefined,
    Object? addShippingZones = _undefined,
    Object? addWarehouses = _undefined,
    Object? orderSettings = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? checkoutSettings = _undefined,
    Object? paymentSettings = _undefined,
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? currencyCode = _undefined,
    Object? defaultCountry = _undefined,
  }) =>
      _then(Input$ChannelCreateInput._({
        ..._instance._$data,
        if (isActive != _undefined) 'isActive': (isActive as bool?),
        if (stockSettings != _undefined)
          'stockSettings': (stockSettings as Input$StockSettingsInput?),
        if (addShippingZones != _undefined)
          'addShippingZones': (addShippingZones as List<String>?),
        if (addWarehouses != _undefined)
          'addWarehouses': (addWarehouses as List<String>?),
        if (orderSettings != _undefined)
          'orderSettings': (orderSettings as Input$OrderSettingsInput?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (checkoutSettings != _undefined)
          'checkoutSettings':
              (checkoutSettings as Input$CheckoutSettingsInput?),
        if (paymentSettings != _undefined)
          'paymentSettings': (paymentSettings as Input$PaymentSettingsInput?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (slug != _undefined && slug != null) 'slug': (slug as String),
        if (currencyCode != _undefined && currencyCode != null)
          'currencyCode': (currencyCode as String),
        if (defaultCountry != _undefined && defaultCountry != null)
          'defaultCountry': (defaultCountry as Enum$CountryCode),
      }));

  CopyWith$Input$StockSettingsInput<TRes> get stockSettings {
    final local$stockSettings = _instance.stockSettings;
    return local$stockSettings == null
        ? CopyWith$Input$StockSettingsInput.stub(_then(_instance))
        : CopyWith$Input$StockSettingsInput(
            local$stockSettings, (e) => call(stockSettings: e));
  }

  CopyWith$Input$OrderSettingsInput<TRes> get orderSettings {
    final local$orderSettings = _instance.orderSettings;
    return local$orderSettings == null
        ? CopyWith$Input$OrderSettingsInput.stub(_then(_instance))
        : CopyWith$Input$OrderSettingsInput(
            local$orderSettings, (e) => call(orderSettings: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$CheckoutSettingsInput<TRes> get checkoutSettings {
    final local$checkoutSettings = _instance.checkoutSettings;
    return local$checkoutSettings == null
        ? CopyWith$Input$CheckoutSettingsInput.stub(_then(_instance))
        : CopyWith$Input$CheckoutSettingsInput(
            local$checkoutSettings, (e) => call(checkoutSettings: e));
  }

  CopyWith$Input$PaymentSettingsInput<TRes> get paymentSettings {
    final local$paymentSettings = _instance.paymentSettings;
    return local$paymentSettings == null
        ? CopyWith$Input$PaymentSettingsInput.stub(_then(_instance))
        : CopyWith$Input$PaymentSettingsInput(
            local$paymentSettings, (e) => call(paymentSettings: e));
  }
}

class _CopyWithStubImpl$Input$ChannelCreateInput<TRes>
    implements CopyWith$Input$ChannelCreateInput<TRes> {
  _CopyWithStubImpl$Input$ChannelCreateInput(this._res);

  TRes _res;

  call({
    bool? isActive,
    Input$StockSettingsInput? stockSettings,
    List<String>? addShippingZones,
    List<String>? addWarehouses,
    Input$OrderSettingsInput? orderSettings,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Input$CheckoutSettingsInput? checkoutSettings,
    Input$PaymentSettingsInput? paymentSettings,
    String? name,
    String? slug,
    String? currencyCode,
    Enum$CountryCode? defaultCountry,
  }) =>
      _res;

  CopyWith$Input$StockSettingsInput<TRes> get stockSettings =>
      CopyWith$Input$StockSettingsInput.stub(_res);

  CopyWith$Input$OrderSettingsInput<TRes> get orderSettings =>
      CopyWith$Input$OrderSettingsInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;

  CopyWith$Input$CheckoutSettingsInput<TRes> get checkoutSettings =>
      CopyWith$Input$CheckoutSettingsInput.stub(_res);

  CopyWith$Input$PaymentSettingsInput<TRes> get paymentSettings =>
      CopyWith$Input$PaymentSettingsInput.stub(_res);
}

class Input$ChannelDeleteInput {
  factory Input$ChannelDeleteInput({required String channelId}) =>
      Input$ChannelDeleteInput._({
        r'channelId': channelId,
      });

  Input$ChannelDeleteInput._(this._$data);

  factory Input$ChannelDeleteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$channelId = data['channelId'];
    result$data['channelId'] = (l$channelId as String);
    return Input$ChannelDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get channelId => (_$data['channelId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$channelId = channelId;
    result$data['channelId'] = l$channelId;
    return result$data;
  }

  CopyWith$Input$ChannelDeleteInput<Input$ChannelDeleteInput> get copyWith =>
      CopyWith$Input$ChannelDeleteInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ChannelDeleteInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$channelId = channelId;
    final lOther$channelId = other.channelId;
    if (l$channelId != lOther$channelId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$channelId = channelId;
    return Object.hashAll([l$channelId]);
  }
}

abstract class CopyWith$Input$ChannelDeleteInput<TRes> {
  factory CopyWith$Input$ChannelDeleteInput(
    Input$ChannelDeleteInput instance,
    TRes Function(Input$ChannelDeleteInput) then,
  ) = _CopyWithImpl$Input$ChannelDeleteInput;

  factory CopyWith$Input$ChannelDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ChannelDeleteInput;

  TRes call({String? channelId});
}

class _CopyWithImpl$Input$ChannelDeleteInput<TRes>
    implements CopyWith$Input$ChannelDeleteInput<TRes> {
  _CopyWithImpl$Input$ChannelDeleteInput(
    this._instance,
    this._then,
  );

  final Input$ChannelDeleteInput _instance;

  final TRes Function(Input$ChannelDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? channelId = _undefined}) =>
      _then(Input$ChannelDeleteInput._({
        ..._instance._$data,
        if (channelId != _undefined && channelId != null)
          'channelId': (channelId as String),
      }));
}

class _CopyWithStubImpl$Input$ChannelDeleteInput<TRes>
    implements CopyWith$Input$ChannelDeleteInput<TRes> {
  _CopyWithStubImpl$Input$ChannelDeleteInput(this._res);

  TRes _res;

  call({String? channelId}) => _res;
}

class Input$ChannelListingUpdateInput {
  factory Input$ChannelListingUpdateInput({
    required String channelListing,
    String? price,
    String? costPrice,
    String? priorPrice,
    int? preorderThreshold,
  }) =>
      Input$ChannelListingUpdateInput._({
        r'channelListing': channelListing,
        if (price != null) r'price': price,
        if (costPrice != null) r'costPrice': costPrice,
        if (priorPrice != null) r'priorPrice': priorPrice,
        if (preorderThreshold != null) r'preorderThreshold': preorderThreshold,
      });

  Input$ChannelListingUpdateInput._(this._$data);

  factory Input$ChannelListingUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$channelListing = data['channelListing'];
    result$data['channelListing'] = (l$channelListing as String);
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] = (l$price as String?);
    }
    if (data.containsKey('costPrice')) {
      final l$costPrice = data['costPrice'];
      result$data['costPrice'] = (l$costPrice as String?);
    }
    if (data.containsKey('priorPrice')) {
      final l$priorPrice = data['priorPrice'];
      result$data['priorPrice'] = (l$priorPrice as String?);
    }
    if (data.containsKey('preorderThreshold')) {
      final l$preorderThreshold = data['preorderThreshold'];
      result$data['preorderThreshold'] = (l$preorderThreshold as int?);
    }
    return Input$ChannelListingUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get channelListing => (_$data['channelListing'] as String);

  String? get price => (_$data['price'] as String?);

  String? get costPrice => (_$data['costPrice'] as String?);

  String? get priorPrice => (_$data['priorPrice'] as String?);

  int? get preorderThreshold => (_$data['preorderThreshold'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$channelListing = channelListing;
    result$data['channelListing'] = l$channelListing;
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] = l$price;
    }
    if (_$data.containsKey('costPrice')) {
      final l$costPrice = costPrice;
      result$data['costPrice'] = l$costPrice;
    }
    if (_$data.containsKey('priorPrice')) {
      final l$priorPrice = priorPrice;
      result$data['priorPrice'] = l$priorPrice;
    }
    if (_$data.containsKey('preorderThreshold')) {
      final l$preorderThreshold = preorderThreshold;
      result$data['preorderThreshold'] = l$preorderThreshold;
    }
    return result$data;
  }

  CopyWith$Input$ChannelListingUpdateInput<Input$ChannelListingUpdateInput>
      get copyWith => CopyWith$Input$ChannelListingUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ChannelListingUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$channelListing = channelListing;
    final lOther$channelListing = other.channelListing;
    if (l$channelListing != lOther$channelListing) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$costPrice = costPrice;
    final lOther$costPrice = other.costPrice;
    if (_$data.containsKey('costPrice') !=
        other._$data.containsKey('costPrice')) {
      return false;
    }
    if (l$costPrice != lOther$costPrice) {
      return false;
    }
    final l$priorPrice = priorPrice;
    final lOther$priorPrice = other.priorPrice;
    if (_$data.containsKey('priorPrice') !=
        other._$data.containsKey('priorPrice')) {
      return false;
    }
    if (l$priorPrice != lOther$priorPrice) {
      return false;
    }
    final l$preorderThreshold = preorderThreshold;
    final lOther$preorderThreshold = other.preorderThreshold;
    if (_$data.containsKey('preorderThreshold') !=
        other._$data.containsKey('preorderThreshold')) {
      return false;
    }
    if (l$preorderThreshold != lOther$preorderThreshold) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$channelListing = channelListing;
    final l$price = price;
    final l$costPrice = costPrice;
    final l$priorPrice = priorPrice;
    final l$preorderThreshold = preorderThreshold;
    return Object.hashAll([
      l$channelListing,
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('costPrice') ? l$costPrice : const {},
      _$data.containsKey('priorPrice') ? l$priorPrice : const {},
      _$data.containsKey('preorderThreshold') ? l$preorderThreshold : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChannelListingUpdateInput<TRes> {
  factory CopyWith$Input$ChannelListingUpdateInput(
    Input$ChannelListingUpdateInput instance,
    TRes Function(Input$ChannelListingUpdateInput) then,
  ) = _CopyWithImpl$Input$ChannelListingUpdateInput;

  factory CopyWith$Input$ChannelListingUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ChannelListingUpdateInput;

  TRes call({
    String? channelListing,
    String? price,
    String? costPrice,
    String? priorPrice,
    int? preorderThreshold,
  });
}

class _CopyWithImpl$Input$ChannelListingUpdateInput<TRes>
    implements CopyWith$Input$ChannelListingUpdateInput<TRes> {
  _CopyWithImpl$Input$ChannelListingUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ChannelListingUpdateInput _instance;

  final TRes Function(Input$ChannelListingUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? channelListing = _undefined,
    Object? price = _undefined,
    Object? costPrice = _undefined,
    Object? priorPrice = _undefined,
    Object? preorderThreshold = _undefined,
  }) =>
      _then(Input$ChannelListingUpdateInput._({
        ..._instance._$data,
        if (channelListing != _undefined && channelListing != null)
          'channelListing': (channelListing as String),
        if (price != _undefined) 'price': (price as String?),
        if (costPrice != _undefined) 'costPrice': (costPrice as String?),
        if (priorPrice != _undefined) 'priorPrice': (priorPrice as String?),
        if (preorderThreshold != _undefined)
          'preorderThreshold': (preorderThreshold as int?),
      }));
}

class _CopyWithStubImpl$Input$ChannelListingUpdateInput<TRes>
    implements CopyWith$Input$ChannelListingUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ChannelListingUpdateInput(this._res);

  TRes _res;

  call({
    String? channelListing,
    String? price,
    String? costPrice,
    String? priorPrice,
    int? preorderThreshold,
  }) =>
      _res;
}

class Input$ChannelUpdateInput {
  factory Input$ChannelUpdateInput({
    bool? isActive,
    Input$StockSettingsInput? stockSettings,
    List<String>? addShippingZones,
    List<String>? addWarehouses,
    Input$OrderSettingsInput? orderSettings,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Input$CheckoutSettingsInput? checkoutSettings,
    Input$PaymentSettingsInput? paymentSettings,
    String? name,
    String? slug,
    Enum$CountryCode? defaultCountry,
    List<String>? removeShippingZones,
    List<String>? removeWarehouses,
  }) =>
      Input$ChannelUpdateInput._({
        if (isActive != null) r'isActive': isActive,
        if (stockSettings != null) r'stockSettings': stockSettings,
        if (addShippingZones != null) r'addShippingZones': addShippingZones,
        if (addWarehouses != null) r'addWarehouses': addWarehouses,
        if (orderSettings != null) r'orderSettings': orderSettings,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (checkoutSettings != null) r'checkoutSettings': checkoutSettings,
        if (paymentSettings != null) r'paymentSettings': paymentSettings,
        if (name != null) r'name': name,
        if (slug != null) r'slug': slug,
        if (defaultCountry != null) r'defaultCountry': defaultCountry,
        if (removeShippingZones != null)
          r'removeShippingZones': removeShippingZones,
        if (removeWarehouses != null) r'removeWarehouses': removeWarehouses,
      });

  Input$ChannelUpdateInput._(this._$data);

  factory Input$ChannelUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = (l$isActive as bool?);
    }
    if (data.containsKey('stockSettings')) {
      final l$stockSettings = data['stockSettings'];
      result$data['stockSettings'] = l$stockSettings == null
          ? null
          : Input$StockSettingsInput.fromJson(
              (l$stockSettings as Map<String, dynamic>));
    }
    if (data.containsKey('addShippingZones')) {
      final l$addShippingZones = data['addShippingZones'];
      result$data['addShippingZones'] = (l$addShippingZones as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('addWarehouses')) {
      final l$addWarehouses = data['addWarehouses'];
      result$data['addWarehouses'] = (l$addWarehouses as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('orderSettings')) {
      final l$orderSettings = data['orderSettings'];
      result$data['orderSettings'] = l$orderSettings == null
          ? null
          : Input$OrderSettingsInput.fromJson(
              (l$orderSettings as Map<String, dynamic>));
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('checkoutSettings')) {
      final l$checkoutSettings = data['checkoutSettings'];
      result$data['checkoutSettings'] = l$checkoutSettings == null
          ? null
          : Input$CheckoutSettingsInput.fromJson(
              (l$checkoutSettings as Map<String, dynamic>));
    }
    if (data.containsKey('paymentSettings')) {
      final l$paymentSettings = data['paymentSettings'];
      result$data['paymentSettings'] = l$paymentSettings == null
          ? null
          : Input$PaymentSettingsInput.fromJson(
              (l$paymentSettings as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('defaultCountry')) {
      final l$defaultCountry = data['defaultCountry'];
      result$data['defaultCountry'] = l$defaultCountry == null
          ? null
          : fromJson$Enum$CountryCode((l$defaultCountry as String));
    }
    if (data.containsKey('removeShippingZones')) {
      final l$removeShippingZones = data['removeShippingZones'];
      result$data['removeShippingZones'] =
          (l$removeShippingZones as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('removeWarehouses')) {
      final l$removeWarehouses = data['removeWarehouses'];
      result$data['removeWarehouses'] = (l$removeWarehouses as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$ChannelUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get isActive => (_$data['isActive'] as bool?);

  Input$StockSettingsInput? get stockSettings =>
      (_$data['stockSettings'] as Input$StockSettingsInput?);

  List<String>? get addShippingZones =>
      (_$data['addShippingZones'] as List<String>?);

  List<String>? get addWarehouses => (_$data['addWarehouses'] as List<String>?);

  Input$OrderSettingsInput? get orderSettings =>
      (_$data['orderSettings'] as Input$OrderSettingsInput?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  Input$CheckoutSettingsInput? get checkoutSettings =>
      (_$data['checkoutSettings'] as Input$CheckoutSettingsInput?);

  Input$PaymentSettingsInput? get paymentSettings =>
      (_$data['paymentSettings'] as Input$PaymentSettingsInput?);

  String? get name => (_$data['name'] as String?);

  String? get slug => (_$data['slug'] as String?);

  Enum$CountryCode? get defaultCountry =>
      (_$data['defaultCountry'] as Enum$CountryCode?);

  List<String>? get removeShippingZones =>
      (_$data['removeShippingZones'] as List<String>?);

  List<String>? get removeWarehouses =>
      (_$data['removeWarehouses'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive;
    }
    if (_$data.containsKey('stockSettings')) {
      final l$stockSettings = stockSettings;
      result$data['stockSettings'] = l$stockSettings?.toJson();
    }
    if (_$data.containsKey('addShippingZones')) {
      final l$addShippingZones = addShippingZones;
      result$data['addShippingZones'] =
          l$addShippingZones?.map((e) => e).toList();
    }
    if (_$data.containsKey('addWarehouses')) {
      final l$addWarehouses = addWarehouses;
      result$data['addWarehouses'] = l$addWarehouses?.map((e) => e).toList();
    }
    if (_$data.containsKey('orderSettings')) {
      final l$orderSettings = orderSettings;
      result$data['orderSettings'] = l$orderSettings?.toJson();
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('checkoutSettings')) {
      final l$checkoutSettings = checkoutSettings;
      result$data['checkoutSettings'] = l$checkoutSettings?.toJson();
    }
    if (_$data.containsKey('paymentSettings')) {
      final l$paymentSettings = paymentSettings;
      result$data['paymentSettings'] = l$paymentSettings?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('defaultCountry')) {
      final l$defaultCountry = defaultCountry;
      result$data['defaultCountry'] = l$defaultCountry == null
          ? null
          : toJson$Enum$CountryCode(l$defaultCountry);
    }
    if (_$data.containsKey('removeShippingZones')) {
      final l$removeShippingZones = removeShippingZones;
      result$data['removeShippingZones'] =
          l$removeShippingZones?.map((e) => e).toList();
    }
    if (_$data.containsKey('removeWarehouses')) {
      final l$removeWarehouses = removeWarehouses;
      result$data['removeWarehouses'] =
          l$removeWarehouses?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$ChannelUpdateInput<Input$ChannelUpdateInput> get copyWith =>
      CopyWith$Input$ChannelUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ChannelUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$stockSettings = stockSettings;
    final lOther$stockSettings = other.stockSettings;
    if (_$data.containsKey('stockSettings') !=
        other._$data.containsKey('stockSettings')) {
      return false;
    }
    if (l$stockSettings != lOther$stockSettings) {
      return false;
    }
    final l$addShippingZones = addShippingZones;
    final lOther$addShippingZones = other.addShippingZones;
    if (_$data.containsKey('addShippingZones') !=
        other._$data.containsKey('addShippingZones')) {
      return false;
    }
    if (l$addShippingZones != null && lOther$addShippingZones != null) {
      if (l$addShippingZones.length != lOther$addShippingZones.length) {
        return false;
      }
      for (int i = 0; i < l$addShippingZones.length; i++) {
        final l$addShippingZones$entry = l$addShippingZones[i];
        final lOther$addShippingZones$entry = lOther$addShippingZones[i];
        if (l$addShippingZones$entry != lOther$addShippingZones$entry) {
          return false;
        }
      }
    } else if (l$addShippingZones != lOther$addShippingZones) {
      return false;
    }
    final l$addWarehouses = addWarehouses;
    final lOther$addWarehouses = other.addWarehouses;
    if (_$data.containsKey('addWarehouses') !=
        other._$data.containsKey('addWarehouses')) {
      return false;
    }
    if (l$addWarehouses != null && lOther$addWarehouses != null) {
      if (l$addWarehouses.length != lOther$addWarehouses.length) {
        return false;
      }
      for (int i = 0; i < l$addWarehouses.length; i++) {
        final l$addWarehouses$entry = l$addWarehouses[i];
        final lOther$addWarehouses$entry = lOther$addWarehouses[i];
        if (l$addWarehouses$entry != lOther$addWarehouses$entry) {
          return false;
        }
      }
    } else if (l$addWarehouses != lOther$addWarehouses) {
      return false;
    }
    final l$orderSettings = orderSettings;
    final lOther$orderSettings = other.orderSettings;
    if (_$data.containsKey('orderSettings') !=
        other._$data.containsKey('orderSettings')) {
      return false;
    }
    if (l$orderSettings != lOther$orderSettings) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$checkoutSettings = checkoutSettings;
    final lOther$checkoutSettings = other.checkoutSettings;
    if (_$data.containsKey('checkoutSettings') !=
        other._$data.containsKey('checkoutSettings')) {
      return false;
    }
    if (l$checkoutSettings != lOther$checkoutSettings) {
      return false;
    }
    final l$paymentSettings = paymentSettings;
    final lOther$paymentSettings = other.paymentSettings;
    if (_$data.containsKey('paymentSettings') !=
        other._$data.containsKey('paymentSettings')) {
      return false;
    }
    if (l$paymentSettings != lOther$paymentSettings) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$defaultCountry = defaultCountry;
    final lOther$defaultCountry = other.defaultCountry;
    if (_$data.containsKey('defaultCountry') !=
        other._$data.containsKey('defaultCountry')) {
      return false;
    }
    if (l$defaultCountry != lOther$defaultCountry) {
      return false;
    }
    final l$removeShippingZones = removeShippingZones;
    final lOther$removeShippingZones = other.removeShippingZones;
    if (_$data.containsKey('removeShippingZones') !=
        other._$data.containsKey('removeShippingZones')) {
      return false;
    }
    if (l$removeShippingZones != null && lOther$removeShippingZones != null) {
      if (l$removeShippingZones.length != lOther$removeShippingZones.length) {
        return false;
      }
      for (int i = 0; i < l$removeShippingZones.length; i++) {
        final l$removeShippingZones$entry = l$removeShippingZones[i];
        final lOther$removeShippingZones$entry = lOther$removeShippingZones[i];
        if (l$removeShippingZones$entry != lOther$removeShippingZones$entry) {
          return false;
        }
      }
    } else if (l$removeShippingZones != lOther$removeShippingZones) {
      return false;
    }
    final l$removeWarehouses = removeWarehouses;
    final lOther$removeWarehouses = other.removeWarehouses;
    if (_$data.containsKey('removeWarehouses') !=
        other._$data.containsKey('removeWarehouses')) {
      return false;
    }
    if (l$removeWarehouses != null && lOther$removeWarehouses != null) {
      if (l$removeWarehouses.length != lOther$removeWarehouses.length) {
        return false;
      }
      for (int i = 0; i < l$removeWarehouses.length; i++) {
        final l$removeWarehouses$entry = l$removeWarehouses[i];
        final lOther$removeWarehouses$entry = lOther$removeWarehouses[i];
        if (l$removeWarehouses$entry != lOther$removeWarehouses$entry) {
          return false;
        }
      }
    } else if (l$removeWarehouses != lOther$removeWarehouses) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$isActive = isActive;
    final l$stockSettings = stockSettings;
    final l$addShippingZones = addShippingZones;
    final l$addWarehouses = addWarehouses;
    final l$orderSettings = orderSettings;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$checkoutSettings = checkoutSettings;
    final l$paymentSettings = paymentSettings;
    final l$name = name;
    final l$slug = slug;
    final l$defaultCountry = defaultCountry;
    final l$removeShippingZones = removeShippingZones;
    final l$removeWarehouses = removeWarehouses;
    return Object.hashAll([
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('stockSettings') ? l$stockSettings : const {},
      _$data.containsKey('addShippingZones')
          ? l$addShippingZones == null
              ? null
              : Object.hashAll(l$addShippingZones.map((v) => v))
          : const {},
      _$data.containsKey('addWarehouses')
          ? l$addWarehouses == null
              ? null
              : Object.hashAll(l$addWarehouses.map((v) => v))
          : const {},
      _$data.containsKey('orderSettings') ? l$orderSettings : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('checkoutSettings') ? l$checkoutSettings : const {},
      _$data.containsKey('paymentSettings') ? l$paymentSettings : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('defaultCountry') ? l$defaultCountry : const {},
      _$data.containsKey('removeShippingZones')
          ? l$removeShippingZones == null
              ? null
              : Object.hashAll(l$removeShippingZones.map((v) => v))
          : const {},
      _$data.containsKey('removeWarehouses')
          ? l$removeWarehouses == null
              ? null
              : Object.hashAll(l$removeWarehouses.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChannelUpdateInput<TRes> {
  factory CopyWith$Input$ChannelUpdateInput(
    Input$ChannelUpdateInput instance,
    TRes Function(Input$ChannelUpdateInput) then,
  ) = _CopyWithImpl$Input$ChannelUpdateInput;

  factory CopyWith$Input$ChannelUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ChannelUpdateInput;

  TRes call({
    bool? isActive,
    Input$StockSettingsInput? stockSettings,
    List<String>? addShippingZones,
    List<String>? addWarehouses,
    Input$OrderSettingsInput? orderSettings,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Input$CheckoutSettingsInput? checkoutSettings,
    Input$PaymentSettingsInput? paymentSettings,
    String? name,
    String? slug,
    Enum$CountryCode? defaultCountry,
    List<String>? removeShippingZones,
    List<String>? removeWarehouses,
  });
  CopyWith$Input$StockSettingsInput<TRes> get stockSettings;
  CopyWith$Input$OrderSettingsInput<TRes> get orderSettings;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  CopyWith$Input$CheckoutSettingsInput<TRes> get checkoutSettings;
  CopyWith$Input$PaymentSettingsInput<TRes> get paymentSettings;
}

class _CopyWithImpl$Input$ChannelUpdateInput<TRes>
    implements CopyWith$Input$ChannelUpdateInput<TRes> {
  _CopyWithImpl$Input$ChannelUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ChannelUpdateInput _instance;

  final TRes Function(Input$ChannelUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? isActive = _undefined,
    Object? stockSettings = _undefined,
    Object? addShippingZones = _undefined,
    Object? addWarehouses = _undefined,
    Object? orderSettings = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? checkoutSettings = _undefined,
    Object? paymentSettings = _undefined,
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? defaultCountry = _undefined,
    Object? removeShippingZones = _undefined,
    Object? removeWarehouses = _undefined,
  }) =>
      _then(Input$ChannelUpdateInput._({
        ..._instance._$data,
        if (isActive != _undefined) 'isActive': (isActive as bool?),
        if (stockSettings != _undefined)
          'stockSettings': (stockSettings as Input$StockSettingsInput?),
        if (addShippingZones != _undefined)
          'addShippingZones': (addShippingZones as List<String>?),
        if (addWarehouses != _undefined)
          'addWarehouses': (addWarehouses as List<String>?),
        if (orderSettings != _undefined)
          'orderSettings': (orderSettings as Input$OrderSettingsInput?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (checkoutSettings != _undefined)
          'checkoutSettings':
              (checkoutSettings as Input$CheckoutSettingsInput?),
        if (paymentSettings != _undefined)
          'paymentSettings': (paymentSettings as Input$PaymentSettingsInput?),
        if (name != _undefined) 'name': (name as String?),
        if (slug != _undefined) 'slug': (slug as String?),
        if (defaultCountry != _undefined)
          'defaultCountry': (defaultCountry as Enum$CountryCode?),
        if (removeShippingZones != _undefined)
          'removeShippingZones': (removeShippingZones as List<String>?),
        if (removeWarehouses != _undefined)
          'removeWarehouses': (removeWarehouses as List<String>?),
      }));

  CopyWith$Input$StockSettingsInput<TRes> get stockSettings {
    final local$stockSettings = _instance.stockSettings;
    return local$stockSettings == null
        ? CopyWith$Input$StockSettingsInput.stub(_then(_instance))
        : CopyWith$Input$StockSettingsInput(
            local$stockSettings, (e) => call(stockSettings: e));
  }

  CopyWith$Input$OrderSettingsInput<TRes> get orderSettings {
    final local$orderSettings = _instance.orderSettings;
    return local$orderSettings == null
        ? CopyWith$Input$OrderSettingsInput.stub(_then(_instance))
        : CopyWith$Input$OrderSettingsInput(
            local$orderSettings, (e) => call(orderSettings: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$CheckoutSettingsInput<TRes> get checkoutSettings {
    final local$checkoutSettings = _instance.checkoutSettings;
    return local$checkoutSettings == null
        ? CopyWith$Input$CheckoutSettingsInput.stub(_then(_instance))
        : CopyWith$Input$CheckoutSettingsInput(
            local$checkoutSettings, (e) => call(checkoutSettings: e));
  }

  CopyWith$Input$PaymentSettingsInput<TRes> get paymentSettings {
    final local$paymentSettings = _instance.paymentSettings;
    return local$paymentSettings == null
        ? CopyWith$Input$PaymentSettingsInput.stub(_then(_instance))
        : CopyWith$Input$PaymentSettingsInput(
            local$paymentSettings, (e) => call(paymentSettings: e));
  }
}

class _CopyWithStubImpl$Input$ChannelUpdateInput<TRes>
    implements CopyWith$Input$ChannelUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ChannelUpdateInput(this._res);

  TRes _res;

  call({
    bool? isActive,
    Input$StockSettingsInput? stockSettings,
    List<String>? addShippingZones,
    List<String>? addWarehouses,
    Input$OrderSettingsInput? orderSettings,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Input$CheckoutSettingsInput? checkoutSettings,
    Input$PaymentSettingsInput? paymentSettings,
    String? name,
    String? slug,
    Enum$CountryCode? defaultCountry,
    List<String>? removeShippingZones,
    List<String>? removeWarehouses,
  }) =>
      _res;

  CopyWith$Input$StockSettingsInput<TRes> get stockSettings =>
      CopyWith$Input$StockSettingsInput.stub(_res);

  CopyWith$Input$OrderSettingsInput<TRes> get orderSettings =>
      CopyWith$Input$OrderSettingsInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;

  CopyWith$Input$CheckoutSettingsInput<TRes> get checkoutSettings =>
      CopyWith$Input$CheckoutSettingsInput.stub(_res);

  CopyWith$Input$PaymentSettingsInput<TRes> get paymentSettings =>
      CopyWith$Input$PaymentSettingsInput.stub(_res);
}

class Input$CheckoutAddressValidationRules {
  factory Input$CheckoutAddressValidationRules({
    bool? checkRequiredFields,
    bool? checkFieldsFormat,
    bool? enableFieldsNormalization,
  }) =>
      Input$CheckoutAddressValidationRules._({
        if (checkRequiredFields != null)
          r'checkRequiredFields': checkRequiredFields,
        if (checkFieldsFormat != null) r'checkFieldsFormat': checkFieldsFormat,
        if (enableFieldsNormalization != null)
          r'enableFieldsNormalization': enableFieldsNormalization,
      });

  Input$CheckoutAddressValidationRules._(this._$data);

  factory Input$CheckoutAddressValidationRules.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('checkRequiredFields')) {
      final l$checkRequiredFields = data['checkRequiredFields'];
      result$data['checkRequiredFields'] = (l$checkRequiredFields as bool?);
    }
    if (data.containsKey('checkFieldsFormat')) {
      final l$checkFieldsFormat = data['checkFieldsFormat'];
      result$data['checkFieldsFormat'] = (l$checkFieldsFormat as bool?);
    }
    if (data.containsKey('enableFieldsNormalization')) {
      final l$enableFieldsNormalization = data['enableFieldsNormalization'];
      result$data['enableFieldsNormalization'] =
          (l$enableFieldsNormalization as bool?);
    }
    return Input$CheckoutAddressValidationRules._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get checkRequiredFields => (_$data['checkRequiredFields'] as bool?);

  bool? get checkFieldsFormat => (_$data['checkFieldsFormat'] as bool?);

  bool? get enableFieldsNormalization =>
      (_$data['enableFieldsNormalization'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('checkRequiredFields')) {
      final l$checkRequiredFields = checkRequiredFields;
      result$data['checkRequiredFields'] = l$checkRequiredFields;
    }
    if (_$data.containsKey('checkFieldsFormat')) {
      final l$checkFieldsFormat = checkFieldsFormat;
      result$data['checkFieldsFormat'] = l$checkFieldsFormat;
    }
    if (_$data.containsKey('enableFieldsNormalization')) {
      final l$enableFieldsNormalization = enableFieldsNormalization;
      result$data['enableFieldsNormalization'] = l$enableFieldsNormalization;
    }
    return result$data;
  }

  CopyWith$Input$CheckoutAddressValidationRules<
          Input$CheckoutAddressValidationRules>
      get copyWith => CopyWith$Input$CheckoutAddressValidationRules(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CheckoutAddressValidationRules ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$checkRequiredFields = checkRequiredFields;
    final lOther$checkRequiredFields = other.checkRequiredFields;
    if (_$data.containsKey('checkRequiredFields') !=
        other._$data.containsKey('checkRequiredFields')) {
      return false;
    }
    if (l$checkRequiredFields != lOther$checkRequiredFields) {
      return false;
    }
    final l$checkFieldsFormat = checkFieldsFormat;
    final lOther$checkFieldsFormat = other.checkFieldsFormat;
    if (_$data.containsKey('checkFieldsFormat') !=
        other._$data.containsKey('checkFieldsFormat')) {
      return false;
    }
    if (l$checkFieldsFormat != lOther$checkFieldsFormat) {
      return false;
    }
    final l$enableFieldsNormalization = enableFieldsNormalization;
    final lOther$enableFieldsNormalization = other.enableFieldsNormalization;
    if (_$data.containsKey('enableFieldsNormalization') !=
        other._$data.containsKey('enableFieldsNormalization')) {
      return false;
    }
    if (l$enableFieldsNormalization != lOther$enableFieldsNormalization) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$checkRequiredFields = checkRequiredFields;
    final l$checkFieldsFormat = checkFieldsFormat;
    final l$enableFieldsNormalization = enableFieldsNormalization;
    return Object.hashAll([
      _$data.containsKey('checkRequiredFields')
          ? l$checkRequiredFields
          : const {},
      _$data.containsKey('checkFieldsFormat') ? l$checkFieldsFormat : const {},
      _$data.containsKey('enableFieldsNormalization')
          ? l$enableFieldsNormalization
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckoutAddressValidationRules<TRes> {
  factory CopyWith$Input$CheckoutAddressValidationRules(
    Input$CheckoutAddressValidationRules instance,
    TRes Function(Input$CheckoutAddressValidationRules) then,
  ) = _CopyWithImpl$Input$CheckoutAddressValidationRules;

  factory CopyWith$Input$CheckoutAddressValidationRules.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckoutAddressValidationRules;

  TRes call({
    bool? checkRequiredFields,
    bool? checkFieldsFormat,
    bool? enableFieldsNormalization,
  });
}

class _CopyWithImpl$Input$CheckoutAddressValidationRules<TRes>
    implements CopyWith$Input$CheckoutAddressValidationRules<TRes> {
  _CopyWithImpl$Input$CheckoutAddressValidationRules(
    this._instance,
    this._then,
  );

  final Input$CheckoutAddressValidationRules _instance;

  final TRes Function(Input$CheckoutAddressValidationRules) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? checkRequiredFields = _undefined,
    Object? checkFieldsFormat = _undefined,
    Object? enableFieldsNormalization = _undefined,
  }) =>
      _then(Input$CheckoutAddressValidationRules._({
        ..._instance._$data,
        if (checkRequiredFields != _undefined)
          'checkRequiredFields': (checkRequiredFields as bool?),
        if (checkFieldsFormat != _undefined)
          'checkFieldsFormat': (checkFieldsFormat as bool?),
        if (enableFieldsNormalization != _undefined)
          'enableFieldsNormalization': (enableFieldsNormalization as bool?),
      }));
}

class _CopyWithStubImpl$Input$CheckoutAddressValidationRules<TRes>
    implements CopyWith$Input$CheckoutAddressValidationRules<TRes> {
  _CopyWithStubImpl$Input$CheckoutAddressValidationRules(this._res);

  TRes _res;

  call({
    bool? checkRequiredFields,
    bool? checkFieldsFormat,
    bool? enableFieldsNormalization,
  }) =>
      _res;
}

class Input$CheckoutCreateInput {
  factory Input$CheckoutCreateInput({
    String? channel,
    required List<Input$CheckoutLineInput> lines,
    String? email,
    bool? saveShippingAddress,
    Input$AddressInput? shippingAddress,
    bool? saveBillingAddress,
    Input$AddressInput? billingAddress,
    Enum$LanguageCodeEnum? languageCode,
    Input$CheckoutValidationRules? validationRules,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  }) =>
      Input$CheckoutCreateInput._({
        if (channel != null) r'channel': channel,
        r'lines': lines,
        if (email != null) r'email': email,
        if (saveShippingAddress != null)
          r'saveShippingAddress': saveShippingAddress,
        if (shippingAddress != null) r'shippingAddress': shippingAddress,
        if (saveBillingAddress != null)
          r'saveBillingAddress': saveBillingAddress,
        if (billingAddress != null) r'billingAddress': billingAddress,
        if (languageCode != null) r'languageCode': languageCode,
        if (validationRules != null) r'validationRules': validationRules,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
      });

  Input$CheckoutCreateInput._(this._$data);

  factory Input$CheckoutCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('channel')) {
      final l$channel = data['channel'];
      result$data['channel'] = (l$channel as String?);
    }
    final l$lines = data['lines'];
    result$data['lines'] = (l$lines as List<dynamic>)
        .map((e) =>
            Input$CheckoutLineInput.fromJson((e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('saveShippingAddress')) {
      final l$saveShippingAddress = data['saveShippingAddress'];
      result$data['saveShippingAddress'] = (l$saveShippingAddress as bool?);
    }
    if (data.containsKey('shippingAddress')) {
      final l$shippingAddress = data['shippingAddress'];
      result$data['shippingAddress'] = l$shippingAddress == null
          ? null
          : Input$AddressInput.fromJson(
              (l$shippingAddress as Map<String, dynamic>));
    }
    if (data.containsKey('saveBillingAddress')) {
      final l$saveBillingAddress = data['saveBillingAddress'];
      result$data['saveBillingAddress'] = (l$saveBillingAddress as bool?);
    }
    if (data.containsKey('billingAddress')) {
      final l$billingAddress = data['billingAddress'];
      result$data['billingAddress'] = l$billingAddress == null
          ? null
          : Input$AddressInput.fromJson(
              (l$billingAddress as Map<String, dynamic>));
    }
    if (data.containsKey('languageCode')) {
      final l$languageCode = data['languageCode'];
      result$data['languageCode'] = l$languageCode == null
          ? null
          : fromJson$Enum$LanguageCodeEnum((l$languageCode as String));
    }
    if (data.containsKey('validationRules')) {
      final l$validationRules = data['validationRules'];
      result$data['validationRules'] = l$validationRules == null
          ? null
          : Input$CheckoutValidationRules.fromJson(
              (l$validationRules as Map<String, dynamic>));
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$CheckoutCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get channel => (_$data['channel'] as String?);

  List<Input$CheckoutLineInput> get lines =>
      (_$data['lines'] as List<Input$CheckoutLineInput>);

  String? get email => (_$data['email'] as String?);

  bool? get saveShippingAddress => (_$data['saveShippingAddress'] as bool?);

  Input$AddressInput? get shippingAddress =>
      (_$data['shippingAddress'] as Input$AddressInput?);

  bool? get saveBillingAddress => (_$data['saveBillingAddress'] as bool?);

  Input$AddressInput? get billingAddress =>
      (_$data['billingAddress'] as Input$AddressInput?);

  Enum$LanguageCodeEnum? get languageCode =>
      (_$data['languageCode'] as Enum$LanguageCodeEnum?);

  Input$CheckoutValidationRules? get validationRules =>
      (_$data['validationRules'] as Input$CheckoutValidationRules?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('channel')) {
      final l$channel = channel;
      result$data['channel'] = l$channel;
    }
    final l$lines = lines;
    result$data['lines'] = l$lines.map((e) => e.toJson()).toList();
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('saveShippingAddress')) {
      final l$saveShippingAddress = saveShippingAddress;
      result$data['saveShippingAddress'] = l$saveShippingAddress;
    }
    if (_$data.containsKey('shippingAddress')) {
      final l$shippingAddress = shippingAddress;
      result$data['shippingAddress'] = l$shippingAddress?.toJson();
    }
    if (_$data.containsKey('saveBillingAddress')) {
      final l$saveBillingAddress = saveBillingAddress;
      result$data['saveBillingAddress'] = l$saveBillingAddress;
    }
    if (_$data.containsKey('billingAddress')) {
      final l$billingAddress = billingAddress;
      result$data['billingAddress'] = l$billingAddress?.toJson();
    }
    if (_$data.containsKey('languageCode')) {
      final l$languageCode = languageCode;
      result$data['languageCode'] = l$languageCode == null
          ? null
          : toJson$Enum$LanguageCodeEnum(l$languageCode);
    }
    if (_$data.containsKey('validationRules')) {
      final l$validationRules = validationRules;
      result$data['validationRules'] = l$validationRules?.toJson();
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$CheckoutCreateInput<Input$CheckoutCreateInput> get copyWith =>
      CopyWith$Input$CheckoutCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CheckoutCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$channel = channel;
    final lOther$channel = other.channel;
    if (_$data.containsKey('channel') != other._$data.containsKey('channel')) {
      return false;
    }
    if (l$channel != lOther$channel) {
      return false;
    }
    final l$lines = lines;
    final lOther$lines = other.lines;
    if (l$lines.length != lOther$lines.length) {
      return false;
    }
    for (int i = 0; i < l$lines.length; i++) {
      final l$lines$entry = l$lines[i];
      final lOther$lines$entry = lOther$lines[i];
      if (l$lines$entry != lOther$lines$entry) {
        return false;
      }
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$saveShippingAddress = saveShippingAddress;
    final lOther$saveShippingAddress = other.saveShippingAddress;
    if (_$data.containsKey('saveShippingAddress') !=
        other._$data.containsKey('saveShippingAddress')) {
      return false;
    }
    if (l$saveShippingAddress != lOther$saveShippingAddress) {
      return false;
    }
    final l$shippingAddress = shippingAddress;
    final lOther$shippingAddress = other.shippingAddress;
    if (_$data.containsKey('shippingAddress') !=
        other._$data.containsKey('shippingAddress')) {
      return false;
    }
    if (l$shippingAddress != lOther$shippingAddress) {
      return false;
    }
    final l$saveBillingAddress = saveBillingAddress;
    final lOther$saveBillingAddress = other.saveBillingAddress;
    if (_$data.containsKey('saveBillingAddress') !=
        other._$data.containsKey('saveBillingAddress')) {
      return false;
    }
    if (l$saveBillingAddress != lOther$saveBillingAddress) {
      return false;
    }
    final l$billingAddress = billingAddress;
    final lOther$billingAddress = other.billingAddress;
    if (_$data.containsKey('billingAddress') !=
        other._$data.containsKey('billingAddress')) {
      return false;
    }
    if (l$billingAddress != lOther$billingAddress) {
      return false;
    }
    final l$languageCode = languageCode;
    final lOther$languageCode = other.languageCode;
    if (_$data.containsKey('languageCode') !=
        other._$data.containsKey('languageCode')) {
      return false;
    }
    if (l$languageCode != lOther$languageCode) {
      return false;
    }
    final l$validationRules = validationRules;
    final lOther$validationRules = other.validationRules;
    if (_$data.containsKey('validationRules') !=
        other._$data.containsKey('validationRules')) {
      return false;
    }
    if (l$validationRules != lOther$validationRules) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$channel = channel;
    final l$lines = lines;
    final l$email = email;
    final l$saveShippingAddress = saveShippingAddress;
    final l$shippingAddress = shippingAddress;
    final l$saveBillingAddress = saveBillingAddress;
    final l$billingAddress = billingAddress;
    final l$languageCode = languageCode;
    final l$validationRules = validationRules;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    return Object.hashAll([
      _$data.containsKey('channel') ? l$channel : const {},
      Object.hashAll(l$lines.map((v) => v)),
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('saveShippingAddress')
          ? l$saveShippingAddress
          : const {},
      _$data.containsKey('shippingAddress') ? l$shippingAddress : const {},
      _$data.containsKey('saveBillingAddress')
          ? l$saveBillingAddress
          : const {},
      _$data.containsKey('billingAddress') ? l$billingAddress : const {},
      _$data.containsKey('languageCode') ? l$languageCode : const {},
      _$data.containsKey('validationRules') ? l$validationRules : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckoutCreateInput<TRes> {
  factory CopyWith$Input$CheckoutCreateInput(
    Input$CheckoutCreateInput instance,
    TRes Function(Input$CheckoutCreateInput) then,
  ) = _CopyWithImpl$Input$CheckoutCreateInput;

  factory CopyWith$Input$CheckoutCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckoutCreateInput;

  TRes call({
    String? channel,
    List<Input$CheckoutLineInput>? lines,
    String? email,
    bool? saveShippingAddress,
    Input$AddressInput? shippingAddress,
    bool? saveBillingAddress,
    Input$AddressInput? billingAddress,
    Enum$LanguageCodeEnum? languageCode,
    Input$CheckoutValidationRules? validationRules,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  });
  TRes lines(
      Iterable<Input$CheckoutLineInput> Function(
              Iterable<
                  CopyWith$Input$CheckoutLineInput<Input$CheckoutLineInput>>)
          _fn);
  CopyWith$Input$AddressInput<TRes> get shippingAddress;
  CopyWith$Input$AddressInput<TRes> get billingAddress;
  CopyWith$Input$CheckoutValidationRules<TRes> get validationRules;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$CheckoutCreateInput<TRes>
    implements CopyWith$Input$CheckoutCreateInput<TRes> {
  _CopyWithImpl$Input$CheckoutCreateInput(
    this._instance,
    this._then,
  );

  final Input$CheckoutCreateInput _instance;

  final TRes Function(Input$CheckoutCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? channel = _undefined,
    Object? lines = _undefined,
    Object? email = _undefined,
    Object? saveShippingAddress = _undefined,
    Object? shippingAddress = _undefined,
    Object? saveBillingAddress = _undefined,
    Object? billingAddress = _undefined,
    Object? languageCode = _undefined,
    Object? validationRules = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
  }) =>
      _then(Input$CheckoutCreateInput._({
        ..._instance._$data,
        if (channel != _undefined) 'channel': (channel as String?),
        if (lines != _undefined && lines != null)
          'lines': (lines as List<Input$CheckoutLineInput>),
        if (email != _undefined) 'email': (email as String?),
        if (saveShippingAddress != _undefined)
          'saveShippingAddress': (saveShippingAddress as bool?),
        if (shippingAddress != _undefined)
          'shippingAddress': (shippingAddress as Input$AddressInput?),
        if (saveBillingAddress != _undefined)
          'saveBillingAddress': (saveBillingAddress as bool?),
        if (billingAddress != _undefined)
          'billingAddress': (billingAddress as Input$AddressInput?),
        if (languageCode != _undefined)
          'languageCode': (languageCode as Enum$LanguageCodeEnum?),
        if (validationRules != _undefined)
          'validationRules':
              (validationRules as Input$CheckoutValidationRules?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
      }));

  TRes lines(
          Iterable<Input$CheckoutLineInput> Function(
                  Iterable<
                      CopyWith$Input$CheckoutLineInput<
                          Input$CheckoutLineInput>>)
              _fn) =>
      call(
          lines:
              _fn(_instance.lines.map((e) => CopyWith$Input$CheckoutLineInput(
                    e,
                    (i) => i,
                  ))).toList());

  CopyWith$Input$AddressInput<TRes> get shippingAddress {
    final local$shippingAddress = _instance.shippingAddress;
    return local$shippingAddress == null
        ? CopyWith$Input$AddressInput.stub(_then(_instance))
        : CopyWith$Input$AddressInput(
            local$shippingAddress, (e) => call(shippingAddress: e));
  }

  CopyWith$Input$AddressInput<TRes> get billingAddress {
    final local$billingAddress = _instance.billingAddress;
    return local$billingAddress == null
        ? CopyWith$Input$AddressInput.stub(_then(_instance))
        : CopyWith$Input$AddressInput(
            local$billingAddress, (e) => call(billingAddress: e));
  }

  CopyWith$Input$CheckoutValidationRules<TRes> get validationRules {
    final local$validationRules = _instance.validationRules;
    return local$validationRules == null
        ? CopyWith$Input$CheckoutValidationRules.stub(_then(_instance))
        : CopyWith$Input$CheckoutValidationRules(
            local$validationRules, (e) => call(validationRules: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CheckoutCreateInput<TRes>
    implements CopyWith$Input$CheckoutCreateInput<TRes> {
  _CopyWithStubImpl$Input$CheckoutCreateInput(this._res);

  TRes _res;

  call({
    String? channel,
    List<Input$CheckoutLineInput>? lines,
    String? email,
    bool? saveShippingAddress,
    Input$AddressInput? shippingAddress,
    bool? saveBillingAddress,
    Input$AddressInput? billingAddress,
    Enum$LanguageCodeEnum? languageCode,
    Input$CheckoutValidationRules? validationRules,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  }) =>
      _res;

  lines(_fn) => _res;

  CopyWith$Input$AddressInput<TRes> get shippingAddress =>
      CopyWith$Input$AddressInput.stub(_res);

  CopyWith$Input$AddressInput<TRes> get billingAddress =>
      CopyWith$Input$AddressInput.stub(_res);

  CopyWith$Input$CheckoutValidationRules<TRes> get validationRules =>
      CopyWith$Input$CheckoutValidationRules.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$CheckoutFilterInput {
  factory Input$CheckoutFilterInput({
    String? customer,
    Input$DateRangeInput? created,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? channels,
    Input$DateRangeInput? updatedAt,
    List<Enum$CheckoutAuthorizeStatusEnum>? authorizeStatus,
    List<Enum$CheckoutChargeStatusEnum>? chargeStatus,
  }) =>
      Input$CheckoutFilterInput._({
        if (customer != null) r'customer': customer,
        if (created != null) r'created': created,
        if (search != null) r'search': search,
        if (metadata != null) r'metadata': metadata,
        if (channels != null) r'channels': channels,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (authorizeStatus != null) r'authorizeStatus': authorizeStatus,
        if (chargeStatus != null) r'chargeStatus': chargeStatus,
      });

  Input$CheckoutFilterInput._(this._$data);

  factory Input$CheckoutFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('customer')) {
      final l$customer = data['customer'];
      result$data['customer'] = (l$customer as String?);
    }
    if (data.containsKey('created')) {
      final l$created = data['created'];
      result$data['created'] = l$created == null
          ? null
          : Input$DateRangeInput.fromJson((l$created as Map<String, dynamic>));
    }
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('channels')) {
      final l$channels = data['channels'];
      result$data['channels'] =
          (l$channels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateRangeInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('authorizeStatus')) {
      final l$authorizeStatus = data['authorizeStatus'];
      result$data['authorizeStatus'] = (l$authorizeStatus as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CheckoutAuthorizeStatusEnum((e as String)))
          .toList();
    }
    if (data.containsKey('chargeStatus')) {
      final l$chargeStatus = data['chargeStatus'];
      result$data['chargeStatus'] = (l$chargeStatus as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CheckoutChargeStatusEnum((e as String)))
          .toList();
    }
    return Input$CheckoutFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get customer => (_$data['customer'] as String?);

  Input$DateRangeInput? get created =>
      (_$data['created'] as Input$DateRangeInput?);

  String? get search => (_$data['search'] as String?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get channels => (_$data['channels'] as List<String>?);

  Input$DateRangeInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateRangeInput?);

  List<Enum$CheckoutAuthorizeStatusEnum>? get authorizeStatus =>
      (_$data['authorizeStatus'] as List<Enum$CheckoutAuthorizeStatusEnum>?);

  List<Enum$CheckoutChargeStatusEnum>? get chargeStatus =>
      (_$data['chargeStatus'] as List<Enum$CheckoutChargeStatusEnum>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('customer')) {
      final l$customer = customer;
      result$data['customer'] = l$customer;
    }
    if (_$data.containsKey('created')) {
      final l$created = created;
      result$data['created'] = l$created?.toJson();
    }
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('channels')) {
      final l$channels = channels;
      result$data['channels'] = l$channels?.map((e) => e).toList();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('authorizeStatus')) {
      final l$authorizeStatus = authorizeStatus;
      result$data['authorizeStatus'] = l$authorizeStatus
          ?.map((e) => toJson$Enum$CheckoutAuthorizeStatusEnum(e))
          .toList();
    }
    if (_$data.containsKey('chargeStatus')) {
      final l$chargeStatus = chargeStatus;
      result$data['chargeStatus'] = l$chargeStatus
          ?.map((e) => toJson$Enum$CheckoutChargeStatusEnum(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$CheckoutFilterInput<Input$CheckoutFilterInput> get copyWith =>
      CopyWith$Input$CheckoutFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CheckoutFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$customer = customer;
    final lOther$customer = other.customer;
    if (_$data.containsKey('customer') !=
        other._$data.containsKey('customer')) {
      return false;
    }
    if (l$customer != lOther$customer) {
      return false;
    }
    final l$created = created;
    final lOther$created = other.created;
    if (_$data.containsKey('created') != other._$data.containsKey('created')) {
      return false;
    }
    if (l$created != lOther$created) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$channels = channels;
    final lOther$channels = other.channels;
    if (_$data.containsKey('channels') !=
        other._$data.containsKey('channels')) {
      return false;
    }
    if (l$channels != null && lOther$channels != null) {
      if (l$channels.length != lOther$channels.length) {
        return false;
      }
      for (int i = 0; i < l$channels.length; i++) {
        final l$channels$entry = l$channels[i];
        final lOther$channels$entry = lOther$channels[i];
        if (l$channels$entry != lOther$channels$entry) {
          return false;
        }
      }
    } else if (l$channels != lOther$channels) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$authorizeStatus = authorizeStatus;
    final lOther$authorizeStatus = other.authorizeStatus;
    if (_$data.containsKey('authorizeStatus') !=
        other._$data.containsKey('authorizeStatus')) {
      return false;
    }
    if (l$authorizeStatus != null && lOther$authorizeStatus != null) {
      if (l$authorizeStatus.length != lOther$authorizeStatus.length) {
        return false;
      }
      for (int i = 0; i < l$authorizeStatus.length; i++) {
        final l$authorizeStatus$entry = l$authorizeStatus[i];
        final lOther$authorizeStatus$entry = lOther$authorizeStatus[i];
        if (l$authorizeStatus$entry != lOther$authorizeStatus$entry) {
          return false;
        }
      }
    } else if (l$authorizeStatus != lOther$authorizeStatus) {
      return false;
    }
    final l$chargeStatus = chargeStatus;
    final lOther$chargeStatus = other.chargeStatus;
    if (_$data.containsKey('chargeStatus') !=
        other._$data.containsKey('chargeStatus')) {
      return false;
    }
    if (l$chargeStatus != null && lOther$chargeStatus != null) {
      if (l$chargeStatus.length != lOther$chargeStatus.length) {
        return false;
      }
      for (int i = 0; i < l$chargeStatus.length; i++) {
        final l$chargeStatus$entry = l$chargeStatus[i];
        final lOther$chargeStatus$entry = lOther$chargeStatus[i];
        if (l$chargeStatus$entry != lOther$chargeStatus$entry) {
          return false;
        }
      }
    } else if (l$chargeStatus != lOther$chargeStatus) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$customer = customer;
    final l$created = created;
    final l$search = search;
    final l$metadata = metadata;
    final l$channels = channels;
    final l$updatedAt = updatedAt;
    final l$authorizeStatus = authorizeStatus;
    final l$chargeStatus = chargeStatus;
    return Object.hashAll([
      _$data.containsKey('customer') ? l$customer : const {},
      _$data.containsKey('created') ? l$created : const {},
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('channels')
          ? l$channels == null
              ? null
              : Object.hashAll(l$channels.map((v) => v))
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('authorizeStatus')
          ? l$authorizeStatus == null
              ? null
              : Object.hashAll(l$authorizeStatus.map((v) => v))
          : const {},
      _$data.containsKey('chargeStatus')
          ? l$chargeStatus == null
              ? null
              : Object.hashAll(l$chargeStatus.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckoutFilterInput<TRes> {
  factory CopyWith$Input$CheckoutFilterInput(
    Input$CheckoutFilterInput instance,
    TRes Function(Input$CheckoutFilterInput) then,
  ) = _CopyWithImpl$Input$CheckoutFilterInput;

  factory CopyWith$Input$CheckoutFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckoutFilterInput;

  TRes call({
    String? customer,
    Input$DateRangeInput? created,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? channels,
    Input$DateRangeInput? updatedAt,
    List<Enum$CheckoutAuthorizeStatusEnum>? authorizeStatus,
    List<Enum$CheckoutChargeStatusEnum>? chargeStatus,
  });
  CopyWith$Input$DateRangeInput<TRes> get created;
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
  CopyWith$Input$DateRangeInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$CheckoutFilterInput<TRes>
    implements CopyWith$Input$CheckoutFilterInput<TRes> {
  _CopyWithImpl$Input$CheckoutFilterInput(
    this._instance,
    this._then,
  );

  final Input$CheckoutFilterInput _instance;

  final TRes Function(Input$CheckoutFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? customer = _undefined,
    Object? created = _undefined,
    Object? search = _undefined,
    Object? metadata = _undefined,
    Object? channels = _undefined,
    Object? updatedAt = _undefined,
    Object? authorizeStatus = _undefined,
    Object? chargeStatus = _undefined,
  }) =>
      _then(Input$CheckoutFilterInput._({
        ..._instance._$data,
        if (customer != _undefined) 'customer': (customer as String?),
        if (created != _undefined)
          'created': (created as Input$DateRangeInput?),
        if (search != _undefined) 'search': (search as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (channels != _undefined) 'channels': (channels as List<String>?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateRangeInput?),
        if (authorizeStatus != _undefined)
          'authorizeStatus':
              (authorizeStatus as List<Enum$CheckoutAuthorizeStatusEnum>?),
        if (chargeStatus != _undefined)
          'chargeStatus':
              (chargeStatus as List<Enum$CheckoutChargeStatusEnum>?),
      }));

  CopyWith$Input$DateRangeInput<TRes> get created {
    final local$created = _instance.created;
    return local$created == null
        ? CopyWith$Input$DateRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateRangeInput(local$created, (e) => call(created: e));
  }

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$DateRangeInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateRangeInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }
}

class _CopyWithStubImpl$Input$CheckoutFilterInput<TRes>
    implements CopyWith$Input$CheckoutFilterInput<TRes> {
  _CopyWithStubImpl$Input$CheckoutFilterInput(this._res);

  TRes _res;

  call({
    String? customer,
    Input$DateRangeInput? created,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? channels,
    Input$DateRangeInput? updatedAt,
    List<Enum$CheckoutAuthorizeStatusEnum>? authorizeStatus,
    List<Enum$CheckoutChargeStatusEnum>? chargeStatus,
  }) =>
      _res;

  CopyWith$Input$DateRangeInput<TRes> get created =>
      CopyWith$Input$DateRangeInput.stub(_res);

  metadata(_fn) => _res;

  CopyWith$Input$DateRangeInput<TRes> get updatedAt =>
      CopyWith$Input$DateRangeInput.stub(_res);
}

class Input$CheckoutLineInput {
  factory Input$CheckoutLineInput({
    required int quantity,
    required String variantId,
    String? price,
    bool? forceNewLine,
    List<Input$MetadataInput>? metadata,
  }) =>
      Input$CheckoutLineInput._({
        r'quantity': quantity,
        r'variantId': variantId,
        if (price != null) r'price': price,
        if (forceNewLine != null) r'forceNewLine': forceNewLine,
        if (metadata != null) r'metadata': metadata,
      });

  Input$CheckoutLineInput._(this._$data);

  factory Input$CheckoutLineInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$variantId = data['variantId'];
    result$data['variantId'] = (l$variantId as String);
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] = (l$price as String?);
    }
    if (data.containsKey('forceNewLine')) {
      final l$forceNewLine = data['forceNewLine'];
      result$data['forceNewLine'] = (l$forceNewLine as bool?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$CheckoutLineInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get quantity => (_$data['quantity'] as int);

  String get variantId => (_$data['variantId'] as String);

  String? get price => (_$data['price'] as String?);

  bool? get forceNewLine => (_$data['forceNewLine'] as bool?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$variantId = variantId;
    result$data['variantId'] = l$variantId;
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] = l$price;
    }
    if (_$data.containsKey('forceNewLine')) {
      final l$forceNewLine = forceNewLine;
      result$data['forceNewLine'] = l$forceNewLine;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$CheckoutLineInput<Input$CheckoutLineInput> get copyWith =>
      CopyWith$Input$CheckoutLineInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CheckoutLineInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$variantId = variantId;
    final lOther$variantId = other.variantId;
    if (l$variantId != lOther$variantId) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$forceNewLine = forceNewLine;
    final lOther$forceNewLine = other.forceNewLine;
    if (_$data.containsKey('forceNewLine') !=
        other._$data.containsKey('forceNewLine')) {
      return false;
    }
    if (l$forceNewLine != lOther$forceNewLine) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$variantId = variantId;
    final l$price = price;
    final l$forceNewLine = forceNewLine;
    final l$metadata = metadata;
    return Object.hashAll([
      l$quantity,
      l$variantId,
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('forceNewLine') ? l$forceNewLine : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckoutLineInput<TRes> {
  factory CopyWith$Input$CheckoutLineInput(
    Input$CheckoutLineInput instance,
    TRes Function(Input$CheckoutLineInput) then,
  ) = _CopyWithImpl$Input$CheckoutLineInput;

  factory CopyWith$Input$CheckoutLineInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckoutLineInput;

  TRes call({
    int? quantity,
    String? variantId,
    String? price,
    bool? forceNewLine,
    List<Input$MetadataInput>? metadata,
  });
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$CheckoutLineInput<TRes>
    implements CopyWith$Input$CheckoutLineInput<TRes> {
  _CopyWithImpl$Input$CheckoutLineInput(
    this._instance,
    this._then,
  );

  final Input$CheckoutLineInput _instance;

  final TRes Function(Input$CheckoutLineInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? variantId = _undefined,
    Object? price = _undefined,
    Object? forceNewLine = _undefined,
    Object? metadata = _undefined,
  }) =>
      _then(Input$CheckoutLineInput._({
        ..._instance._$data,
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (variantId != _undefined && variantId != null)
          'variantId': (variantId as String),
        if (price != _undefined) 'price': (price as String?),
        if (forceNewLine != _undefined) 'forceNewLine': (forceNewLine as bool?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CheckoutLineInput<TRes>
    implements CopyWith$Input$CheckoutLineInput<TRes> {
  _CopyWithStubImpl$Input$CheckoutLineInput(this._res);

  TRes _res;

  call({
    int? quantity,
    String? variantId,
    String? price,
    bool? forceNewLine,
    List<Input$MetadataInput>? metadata,
  }) =>
      _res;

  metadata(_fn) => _res;
}

class Input$CheckoutLineUpdateInput {
  factory Input$CheckoutLineUpdateInput({
    String? variantId,
    int? quantity,
    String? price,
    String? lineId,
    List<Input$MetadataInput>? metadata,
  }) =>
      Input$CheckoutLineUpdateInput._({
        if (variantId != null) r'variantId': variantId,
        if (quantity != null) r'quantity': quantity,
        if (price != null) r'price': price,
        if (lineId != null) r'lineId': lineId,
        if (metadata != null) r'metadata': metadata,
      });

  Input$CheckoutLineUpdateInput._(this._$data);

  factory Input$CheckoutLineUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('variantId')) {
      final l$variantId = data['variantId'];
      result$data['variantId'] = (l$variantId as String?);
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = (l$quantity as int?);
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] = (l$price as String?);
    }
    if (data.containsKey('lineId')) {
      final l$lineId = data['lineId'];
      result$data['lineId'] = (l$lineId as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$CheckoutLineUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get variantId => (_$data['variantId'] as String?);

  int? get quantity => (_$data['quantity'] as int?);

  String? get price => (_$data['price'] as String?);

  String? get lineId => (_$data['lineId'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('variantId')) {
      final l$variantId = variantId;
      result$data['variantId'] = l$variantId;
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity;
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] = l$price;
    }
    if (_$data.containsKey('lineId')) {
      final l$lineId = lineId;
      result$data['lineId'] = l$lineId;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$CheckoutLineUpdateInput<Input$CheckoutLineUpdateInput>
      get copyWith => CopyWith$Input$CheckoutLineUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CheckoutLineUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$variantId = variantId;
    final lOther$variantId = other.variantId;
    if (_$data.containsKey('variantId') !=
        other._$data.containsKey('variantId')) {
      return false;
    }
    if (l$variantId != lOther$variantId) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$lineId = lineId;
    final lOther$lineId = other.lineId;
    if (_$data.containsKey('lineId') != other._$data.containsKey('lineId')) {
      return false;
    }
    if (l$lineId != lOther$lineId) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$variantId = variantId;
    final l$quantity = quantity;
    final l$price = price;
    final l$lineId = lineId;
    final l$metadata = metadata;
    return Object.hashAll([
      _$data.containsKey('variantId') ? l$variantId : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('lineId') ? l$lineId : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckoutLineUpdateInput<TRes> {
  factory CopyWith$Input$CheckoutLineUpdateInput(
    Input$CheckoutLineUpdateInput instance,
    TRes Function(Input$CheckoutLineUpdateInput) then,
  ) = _CopyWithImpl$Input$CheckoutLineUpdateInput;

  factory CopyWith$Input$CheckoutLineUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckoutLineUpdateInput;

  TRes call({
    String? variantId,
    int? quantity,
    String? price,
    String? lineId,
    List<Input$MetadataInput>? metadata,
  });
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$CheckoutLineUpdateInput<TRes>
    implements CopyWith$Input$CheckoutLineUpdateInput<TRes> {
  _CopyWithImpl$Input$CheckoutLineUpdateInput(
    this._instance,
    this._then,
  );

  final Input$CheckoutLineUpdateInput _instance;

  final TRes Function(Input$CheckoutLineUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? variantId = _undefined,
    Object? quantity = _undefined,
    Object? price = _undefined,
    Object? lineId = _undefined,
    Object? metadata = _undefined,
  }) =>
      _then(Input$CheckoutLineUpdateInput._({
        ..._instance._$data,
        if (variantId != _undefined) 'variantId': (variantId as String?),
        if (quantity != _undefined) 'quantity': (quantity as int?),
        if (price != _undefined) 'price': (price as String?),
        if (lineId != _undefined) 'lineId': (lineId as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CheckoutLineUpdateInput<TRes>
    implements CopyWith$Input$CheckoutLineUpdateInput<TRes> {
  _CopyWithStubImpl$Input$CheckoutLineUpdateInput(this._res);

  TRes _res;

  call({
    String? variantId,
    int? quantity,
    String? price,
    String? lineId,
    List<Input$MetadataInput>? metadata,
  }) =>
      _res;

  metadata(_fn) => _res;
}

class Input$CheckoutSettingsInput {
  factory Input$CheckoutSettingsInput({
    bool? useLegacyErrorFlow,
    bool? automaticallyCompleteFullyPaidCheckouts,
  }) =>
      Input$CheckoutSettingsInput._({
        if (useLegacyErrorFlow != null)
          r'useLegacyErrorFlow': useLegacyErrorFlow,
        if (automaticallyCompleteFullyPaidCheckouts != null)
          r'automaticallyCompleteFullyPaidCheckouts':
              automaticallyCompleteFullyPaidCheckouts,
      });

  Input$CheckoutSettingsInput._(this._$data);

  factory Input$CheckoutSettingsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('useLegacyErrorFlow')) {
      final l$useLegacyErrorFlow = data['useLegacyErrorFlow'];
      result$data['useLegacyErrorFlow'] = (l$useLegacyErrorFlow as bool?);
    }
    if (data.containsKey('automaticallyCompleteFullyPaidCheckouts')) {
      final l$automaticallyCompleteFullyPaidCheckouts =
          data['automaticallyCompleteFullyPaidCheckouts'];
      result$data['automaticallyCompleteFullyPaidCheckouts'] =
          (l$automaticallyCompleteFullyPaidCheckouts as bool?);
    }
    return Input$CheckoutSettingsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get useLegacyErrorFlow => (_$data['useLegacyErrorFlow'] as bool?);

  bool? get automaticallyCompleteFullyPaidCheckouts =>
      (_$data['automaticallyCompleteFullyPaidCheckouts'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('useLegacyErrorFlow')) {
      final l$useLegacyErrorFlow = useLegacyErrorFlow;
      result$data['useLegacyErrorFlow'] = l$useLegacyErrorFlow;
    }
    if (_$data.containsKey('automaticallyCompleteFullyPaidCheckouts')) {
      final l$automaticallyCompleteFullyPaidCheckouts =
          automaticallyCompleteFullyPaidCheckouts;
      result$data['automaticallyCompleteFullyPaidCheckouts'] =
          l$automaticallyCompleteFullyPaidCheckouts;
    }
    return result$data;
  }

  CopyWith$Input$CheckoutSettingsInput<Input$CheckoutSettingsInput>
      get copyWith => CopyWith$Input$CheckoutSettingsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CheckoutSettingsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$useLegacyErrorFlow = useLegacyErrorFlow;
    final lOther$useLegacyErrorFlow = other.useLegacyErrorFlow;
    if (_$data.containsKey('useLegacyErrorFlow') !=
        other._$data.containsKey('useLegacyErrorFlow')) {
      return false;
    }
    if (l$useLegacyErrorFlow != lOther$useLegacyErrorFlow) {
      return false;
    }
    final l$automaticallyCompleteFullyPaidCheckouts =
        automaticallyCompleteFullyPaidCheckouts;
    final lOther$automaticallyCompleteFullyPaidCheckouts =
        other.automaticallyCompleteFullyPaidCheckouts;
    if (_$data.containsKey('automaticallyCompleteFullyPaidCheckouts') !=
        other._$data.containsKey('automaticallyCompleteFullyPaidCheckouts')) {
      return false;
    }
    if (l$automaticallyCompleteFullyPaidCheckouts !=
        lOther$automaticallyCompleteFullyPaidCheckouts) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$useLegacyErrorFlow = useLegacyErrorFlow;
    final l$automaticallyCompleteFullyPaidCheckouts =
        automaticallyCompleteFullyPaidCheckouts;
    return Object.hashAll([
      _$data.containsKey('useLegacyErrorFlow')
          ? l$useLegacyErrorFlow
          : const {},
      _$data.containsKey('automaticallyCompleteFullyPaidCheckouts')
          ? l$automaticallyCompleteFullyPaidCheckouts
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckoutSettingsInput<TRes> {
  factory CopyWith$Input$CheckoutSettingsInput(
    Input$CheckoutSettingsInput instance,
    TRes Function(Input$CheckoutSettingsInput) then,
  ) = _CopyWithImpl$Input$CheckoutSettingsInput;

  factory CopyWith$Input$CheckoutSettingsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckoutSettingsInput;

  TRes call({
    bool? useLegacyErrorFlow,
    bool? automaticallyCompleteFullyPaidCheckouts,
  });
}

class _CopyWithImpl$Input$CheckoutSettingsInput<TRes>
    implements CopyWith$Input$CheckoutSettingsInput<TRes> {
  _CopyWithImpl$Input$CheckoutSettingsInput(
    this._instance,
    this._then,
  );

  final Input$CheckoutSettingsInput _instance;

  final TRes Function(Input$CheckoutSettingsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? useLegacyErrorFlow = _undefined,
    Object? automaticallyCompleteFullyPaidCheckouts = _undefined,
  }) =>
      _then(Input$CheckoutSettingsInput._({
        ..._instance._$data,
        if (useLegacyErrorFlow != _undefined)
          'useLegacyErrorFlow': (useLegacyErrorFlow as bool?),
        if (automaticallyCompleteFullyPaidCheckouts != _undefined)
          'automaticallyCompleteFullyPaidCheckouts':
              (automaticallyCompleteFullyPaidCheckouts as bool?),
      }));
}

class _CopyWithStubImpl$Input$CheckoutSettingsInput<TRes>
    implements CopyWith$Input$CheckoutSettingsInput<TRes> {
  _CopyWithStubImpl$Input$CheckoutSettingsInput(this._res);

  TRes _res;

  call({
    bool? useLegacyErrorFlow,
    bool? automaticallyCompleteFullyPaidCheckouts,
  }) =>
      _res;
}

class Input$CheckoutSortingInput {
  factory Input$CheckoutSortingInput({
    required Enum$OrderDirection direction,
    required Enum$CheckoutSortField field,
  }) =>
      Input$CheckoutSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$CheckoutSortingInput._(this._$data);

  factory Input$CheckoutSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$CheckoutSortField((l$field as String));
    return Input$CheckoutSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$CheckoutSortField get field =>
      (_$data['field'] as Enum$CheckoutSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$CheckoutSortField(l$field);
    return result$data;
  }

  CopyWith$Input$CheckoutSortingInput<Input$CheckoutSortingInput>
      get copyWith => CopyWith$Input$CheckoutSortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CheckoutSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$CheckoutSortingInput<TRes> {
  factory CopyWith$Input$CheckoutSortingInput(
    Input$CheckoutSortingInput instance,
    TRes Function(Input$CheckoutSortingInput) then,
  ) = _CopyWithImpl$Input$CheckoutSortingInput;

  factory CopyWith$Input$CheckoutSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckoutSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$CheckoutSortField? field,
  });
}

class _CopyWithImpl$Input$CheckoutSortingInput<TRes>
    implements CopyWith$Input$CheckoutSortingInput<TRes> {
  _CopyWithImpl$Input$CheckoutSortingInput(
    this._instance,
    this._then,
  );

  final Input$CheckoutSortingInput _instance;

  final TRes Function(Input$CheckoutSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$CheckoutSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$CheckoutSortField),
      }));
}

class _CopyWithStubImpl$Input$CheckoutSortingInput<TRes>
    implements CopyWith$Input$CheckoutSortingInput<TRes> {
  _CopyWithStubImpl$Input$CheckoutSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$CheckoutSortField? field,
  }) =>
      _res;
}

class Input$CheckoutValidationRules {
  factory Input$CheckoutValidationRules({
    Input$CheckoutAddressValidationRules? shippingAddress,
    Input$CheckoutAddressValidationRules? billingAddress,
  }) =>
      Input$CheckoutValidationRules._({
        if (shippingAddress != null) r'shippingAddress': shippingAddress,
        if (billingAddress != null) r'billingAddress': billingAddress,
      });

  Input$CheckoutValidationRules._(this._$data);

  factory Input$CheckoutValidationRules.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('shippingAddress')) {
      final l$shippingAddress = data['shippingAddress'];
      result$data['shippingAddress'] = l$shippingAddress == null
          ? null
          : Input$CheckoutAddressValidationRules.fromJson(
              (l$shippingAddress as Map<String, dynamic>));
    }
    if (data.containsKey('billingAddress')) {
      final l$billingAddress = data['billingAddress'];
      result$data['billingAddress'] = l$billingAddress == null
          ? null
          : Input$CheckoutAddressValidationRules.fromJson(
              (l$billingAddress as Map<String, dynamic>));
    }
    return Input$CheckoutValidationRules._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$CheckoutAddressValidationRules? get shippingAddress =>
      (_$data['shippingAddress'] as Input$CheckoutAddressValidationRules?);

  Input$CheckoutAddressValidationRules? get billingAddress =>
      (_$data['billingAddress'] as Input$CheckoutAddressValidationRules?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('shippingAddress')) {
      final l$shippingAddress = shippingAddress;
      result$data['shippingAddress'] = l$shippingAddress?.toJson();
    }
    if (_$data.containsKey('billingAddress')) {
      final l$billingAddress = billingAddress;
      result$data['billingAddress'] = l$billingAddress?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CheckoutValidationRules<Input$CheckoutValidationRules>
      get copyWith => CopyWith$Input$CheckoutValidationRules(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CheckoutValidationRules ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$shippingAddress = shippingAddress;
    final lOther$shippingAddress = other.shippingAddress;
    if (_$data.containsKey('shippingAddress') !=
        other._$data.containsKey('shippingAddress')) {
      return false;
    }
    if (l$shippingAddress != lOther$shippingAddress) {
      return false;
    }
    final l$billingAddress = billingAddress;
    final lOther$billingAddress = other.billingAddress;
    if (_$data.containsKey('billingAddress') !=
        other._$data.containsKey('billingAddress')) {
      return false;
    }
    if (l$billingAddress != lOther$billingAddress) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$shippingAddress = shippingAddress;
    final l$billingAddress = billingAddress;
    return Object.hashAll([
      _$data.containsKey('shippingAddress') ? l$shippingAddress : const {},
      _$data.containsKey('billingAddress') ? l$billingAddress : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckoutValidationRules<TRes> {
  factory CopyWith$Input$CheckoutValidationRules(
    Input$CheckoutValidationRules instance,
    TRes Function(Input$CheckoutValidationRules) then,
  ) = _CopyWithImpl$Input$CheckoutValidationRules;

  factory CopyWith$Input$CheckoutValidationRules.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckoutValidationRules;

  TRes call({
    Input$CheckoutAddressValidationRules? shippingAddress,
    Input$CheckoutAddressValidationRules? billingAddress,
  });
  CopyWith$Input$CheckoutAddressValidationRules<TRes> get shippingAddress;
  CopyWith$Input$CheckoutAddressValidationRules<TRes> get billingAddress;
}

class _CopyWithImpl$Input$CheckoutValidationRules<TRes>
    implements CopyWith$Input$CheckoutValidationRules<TRes> {
  _CopyWithImpl$Input$CheckoutValidationRules(
    this._instance,
    this._then,
  );

  final Input$CheckoutValidationRules _instance;

  final TRes Function(Input$CheckoutValidationRules) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? shippingAddress = _undefined,
    Object? billingAddress = _undefined,
  }) =>
      _then(Input$CheckoutValidationRules._({
        ..._instance._$data,
        if (shippingAddress != _undefined)
          'shippingAddress':
              (shippingAddress as Input$CheckoutAddressValidationRules?),
        if (billingAddress != _undefined)
          'billingAddress':
              (billingAddress as Input$CheckoutAddressValidationRules?),
      }));

  CopyWith$Input$CheckoutAddressValidationRules<TRes> get shippingAddress {
    final local$shippingAddress = _instance.shippingAddress;
    return local$shippingAddress == null
        ? CopyWith$Input$CheckoutAddressValidationRules.stub(_then(_instance))
        : CopyWith$Input$CheckoutAddressValidationRules(
            local$shippingAddress, (e) => call(shippingAddress: e));
  }

  CopyWith$Input$CheckoutAddressValidationRules<TRes> get billingAddress {
    final local$billingAddress = _instance.billingAddress;
    return local$billingAddress == null
        ? CopyWith$Input$CheckoutAddressValidationRules.stub(_then(_instance))
        : CopyWith$Input$CheckoutAddressValidationRules(
            local$billingAddress, (e) => call(billingAddress: e));
  }
}

class _CopyWithStubImpl$Input$CheckoutValidationRules<TRes>
    implements CopyWith$Input$CheckoutValidationRules<TRes> {
  _CopyWithStubImpl$Input$CheckoutValidationRules(this._res);

  TRes _res;

  call({
    Input$CheckoutAddressValidationRules? shippingAddress,
    Input$CheckoutAddressValidationRules? billingAddress,
  }) =>
      _res;

  CopyWith$Input$CheckoutAddressValidationRules<TRes> get shippingAddress =>
      CopyWith$Input$CheckoutAddressValidationRules.stub(_res);

  CopyWith$Input$CheckoutAddressValidationRules<TRes> get billingAddress =>
      CopyWith$Input$CheckoutAddressValidationRules.stub(_res);
}

class Input$CollectionChannelListingUpdateInput {
  factory Input$CollectionChannelListingUpdateInput({
    List<Input$PublishableChannelListingInput>? addChannels,
    List<String>? removeChannels,
  }) =>
      Input$CollectionChannelListingUpdateInput._({
        if (addChannels != null) r'addChannels': addChannels,
        if (removeChannels != null) r'removeChannels': removeChannels,
      });

  Input$CollectionChannelListingUpdateInput._(this._$data);

  factory Input$CollectionChannelListingUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('addChannels')) {
      final l$addChannels = data['addChannels'];
      result$data['addChannels'] = (l$addChannels as List<dynamic>?)
          ?.map((e) => Input$PublishableChannelListingInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('removeChannels')) {
      final l$removeChannels = data['removeChannels'];
      result$data['removeChannels'] = (l$removeChannels as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$CollectionChannelListingUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PublishableChannelListingInput>? get addChannels =>
      (_$data['addChannels'] as List<Input$PublishableChannelListingInput>?);

  List<String>? get removeChannels =>
      (_$data['removeChannels'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('addChannels')) {
      final l$addChannels = addChannels;
      result$data['addChannels'] =
          l$addChannels?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('removeChannels')) {
      final l$removeChannels = removeChannels;
      result$data['removeChannels'] = l$removeChannels?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$CollectionChannelListingUpdateInput<
          Input$CollectionChannelListingUpdateInput>
      get copyWith => CopyWith$Input$CollectionChannelListingUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CollectionChannelListingUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$addChannels = addChannels;
    final lOther$addChannels = other.addChannels;
    if (_$data.containsKey('addChannels') !=
        other._$data.containsKey('addChannels')) {
      return false;
    }
    if (l$addChannels != null && lOther$addChannels != null) {
      if (l$addChannels.length != lOther$addChannels.length) {
        return false;
      }
      for (int i = 0; i < l$addChannels.length; i++) {
        final l$addChannels$entry = l$addChannels[i];
        final lOther$addChannels$entry = lOther$addChannels[i];
        if (l$addChannels$entry != lOther$addChannels$entry) {
          return false;
        }
      }
    } else if (l$addChannels != lOther$addChannels) {
      return false;
    }
    final l$removeChannels = removeChannels;
    final lOther$removeChannels = other.removeChannels;
    if (_$data.containsKey('removeChannels') !=
        other._$data.containsKey('removeChannels')) {
      return false;
    }
    if (l$removeChannels != null && lOther$removeChannels != null) {
      if (l$removeChannels.length != lOther$removeChannels.length) {
        return false;
      }
      for (int i = 0; i < l$removeChannels.length; i++) {
        final l$removeChannels$entry = l$removeChannels[i];
        final lOther$removeChannels$entry = lOther$removeChannels[i];
        if (l$removeChannels$entry != lOther$removeChannels$entry) {
          return false;
        }
      }
    } else if (l$removeChannels != lOther$removeChannels) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$addChannels = addChannels;
    final l$removeChannels = removeChannels;
    return Object.hashAll([
      _$data.containsKey('addChannels')
          ? l$addChannels == null
              ? null
              : Object.hashAll(l$addChannels.map((v) => v))
          : const {},
      _$data.containsKey('removeChannels')
          ? l$removeChannels == null
              ? null
              : Object.hashAll(l$removeChannels.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CollectionChannelListingUpdateInput<TRes> {
  factory CopyWith$Input$CollectionChannelListingUpdateInput(
    Input$CollectionChannelListingUpdateInput instance,
    TRes Function(Input$CollectionChannelListingUpdateInput) then,
  ) = _CopyWithImpl$Input$CollectionChannelListingUpdateInput;

  factory CopyWith$Input$CollectionChannelListingUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CollectionChannelListingUpdateInput;

  TRes call({
    List<Input$PublishableChannelListingInput>? addChannels,
    List<String>? removeChannels,
  });
  TRes addChannels(
      Iterable<Input$PublishableChannelListingInput>? Function(
              Iterable<
                  CopyWith$Input$PublishableChannelListingInput<
                      Input$PublishableChannelListingInput>>?)
          _fn);
}

class _CopyWithImpl$Input$CollectionChannelListingUpdateInput<TRes>
    implements CopyWith$Input$CollectionChannelListingUpdateInput<TRes> {
  _CopyWithImpl$Input$CollectionChannelListingUpdateInput(
    this._instance,
    this._then,
  );

  final Input$CollectionChannelListingUpdateInput _instance;

  final TRes Function(Input$CollectionChannelListingUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? addChannels = _undefined,
    Object? removeChannels = _undefined,
  }) =>
      _then(Input$CollectionChannelListingUpdateInput._({
        ..._instance._$data,
        if (addChannels != _undefined)
          'addChannels':
              (addChannels as List<Input$PublishableChannelListingInput>?),
        if (removeChannels != _undefined)
          'removeChannels': (removeChannels as List<String>?),
      }));

  TRes addChannels(
          Iterable<Input$PublishableChannelListingInput>? Function(
                  Iterable<
                      CopyWith$Input$PublishableChannelListingInput<
                          Input$PublishableChannelListingInput>>?)
              _fn) =>
      call(
          addChannels: _fn(_instance.addChannels
              ?.map((e) => CopyWith$Input$PublishableChannelListingInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CollectionChannelListingUpdateInput<TRes>
    implements CopyWith$Input$CollectionChannelListingUpdateInput<TRes> {
  _CopyWithStubImpl$Input$CollectionChannelListingUpdateInput(this._res);

  TRes _res;

  call({
    List<Input$PublishableChannelListingInput>? addChannels,
    List<String>? removeChannels,
  }) =>
      _res;

  addChannels(_fn) => _res;
}

class Input$CollectionCreateInput {
  factory Input$CollectionCreateInput({
    bool? isPublished,
    String? name,
    String? slug,
    String? description,
    String? backgroundImage,
    String? backgroundImageAlt,
    Input$SeoInput? seo,
    String? publicationDate,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    List<String>? products,
  }) =>
      Input$CollectionCreateInput._({
        if (isPublished != null) r'isPublished': isPublished,
        if (name != null) r'name': name,
        if (slug != null) r'slug': slug,
        if (description != null) r'description': description,
        if (backgroundImage != null) r'backgroundImage': backgroundImage,
        if (backgroundImageAlt != null)
          r'backgroundImageAlt': backgroundImageAlt,
        if (seo != null) r'seo': seo,
        if (publicationDate != null) r'publicationDate': publicationDate,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (products != null) r'products': products,
      });

  Input$CollectionCreateInput._(this._$data);

  factory Input$CollectionCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('isPublished')) {
      final l$isPublished = data['isPublished'];
      result$data['isPublished'] = (l$isPublished as bool?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('backgroundImage')) {
      final l$backgroundImage = data['backgroundImage'];
      result$data['backgroundImage'] = (l$backgroundImage as String?);
    }
    if (data.containsKey('backgroundImageAlt')) {
      final l$backgroundImageAlt = data['backgroundImageAlt'];
      result$data['backgroundImageAlt'] = (l$backgroundImageAlt as String?);
    }
    if (data.containsKey('seo')) {
      final l$seo = data['seo'];
      result$data['seo'] = l$seo == null
          ? null
          : Input$SeoInput.fromJson((l$seo as Map<String, dynamic>));
    }
    if (data.containsKey('publicationDate')) {
      final l$publicationDate = data['publicationDate'];
      result$data['publicationDate'] = (l$publicationDate as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('products')) {
      final l$products = data['products'];
      result$data['products'] =
          (l$products as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$CollectionCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get isPublished => (_$data['isPublished'] as bool?);

  String? get name => (_$data['name'] as String?);

  String? get slug => (_$data['slug'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get backgroundImage => (_$data['backgroundImage'] as String?);

  String? get backgroundImageAlt => (_$data['backgroundImageAlt'] as String?);

  Input$SeoInput? get seo => (_$data['seo'] as Input$SeoInput?);

  String? get publicationDate => (_$data['publicationDate'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  List<String>? get products => (_$data['products'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('isPublished')) {
      final l$isPublished = isPublished;
      result$data['isPublished'] = l$isPublished;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('backgroundImage')) {
      final l$backgroundImage = backgroundImage;
      result$data['backgroundImage'] = l$backgroundImage;
    }
    if (_$data.containsKey('backgroundImageAlt')) {
      final l$backgroundImageAlt = backgroundImageAlt;
      result$data['backgroundImageAlt'] = l$backgroundImageAlt;
    }
    if (_$data.containsKey('seo')) {
      final l$seo = seo;
      result$data['seo'] = l$seo?.toJson();
    }
    if (_$data.containsKey('publicationDate')) {
      final l$publicationDate = publicationDate;
      result$data['publicationDate'] = l$publicationDate;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('products')) {
      final l$products = products;
      result$data['products'] = l$products?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$CollectionCreateInput<Input$CollectionCreateInput>
      get copyWith => CopyWith$Input$CollectionCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CollectionCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$isPublished = isPublished;
    final lOther$isPublished = other.isPublished;
    if (_$data.containsKey('isPublished') !=
        other._$data.containsKey('isPublished')) {
      return false;
    }
    if (l$isPublished != lOther$isPublished) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$backgroundImage = backgroundImage;
    final lOther$backgroundImage = other.backgroundImage;
    if (_$data.containsKey('backgroundImage') !=
        other._$data.containsKey('backgroundImage')) {
      return false;
    }
    if (l$backgroundImage != lOther$backgroundImage) {
      return false;
    }
    final l$backgroundImageAlt = backgroundImageAlt;
    final lOther$backgroundImageAlt = other.backgroundImageAlt;
    if (_$data.containsKey('backgroundImageAlt') !=
        other._$data.containsKey('backgroundImageAlt')) {
      return false;
    }
    if (l$backgroundImageAlt != lOther$backgroundImageAlt) {
      return false;
    }
    final l$seo = seo;
    final lOther$seo = other.seo;
    if (_$data.containsKey('seo') != other._$data.containsKey('seo')) {
      return false;
    }
    if (l$seo != lOther$seo) {
      return false;
    }
    final l$publicationDate = publicationDate;
    final lOther$publicationDate = other.publicationDate;
    if (_$data.containsKey('publicationDate') !=
        other._$data.containsKey('publicationDate')) {
      return false;
    }
    if (l$publicationDate != lOther$publicationDate) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$products = products;
    final lOther$products = other.products;
    if (_$data.containsKey('products') !=
        other._$data.containsKey('products')) {
      return false;
    }
    if (l$products != null && lOther$products != null) {
      if (l$products.length != lOther$products.length) {
        return false;
      }
      for (int i = 0; i < l$products.length; i++) {
        final l$products$entry = l$products[i];
        final lOther$products$entry = lOther$products[i];
        if (l$products$entry != lOther$products$entry) {
          return false;
        }
      }
    } else if (l$products != lOther$products) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$isPublished = isPublished;
    final l$name = name;
    final l$slug = slug;
    final l$description = description;
    final l$backgroundImage = backgroundImage;
    final l$backgroundImageAlt = backgroundImageAlt;
    final l$seo = seo;
    final l$publicationDate = publicationDate;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$products = products;
    return Object.hashAll([
      _$data.containsKey('isPublished') ? l$isPublished : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('backgroundImage') ? l$backgroundImage : const {},
      _$data.containsKey('backgroundImageAlt')
          ? l$backgroundImageAlt
          : const {},
      _$data.containsKey('seo') ? l$seo : const {},
      _$data.containsKey('publicationDate') ? l$publicationDate : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('products')
          ? l$products == null
              ? null
              : Object.hashAll(l$products.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CollectionCreateInput<TRes> {
  factory CopyWith$Input$CollectionCreateInput(
    Input$CollectionCreateInput instance,
    TRes Function(Input$CollectionCreateInput) then,
  ) = _CopyWithImpl$Input$CollectionCreateInput;

  factory CopyWith$Input$CollectionCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CollectionCreateInput;

  TRes call({
    bool? isPublished,
    String? name,
    String? slug,
    String? description,
    String? backgroundImage,
    String? backgroundImageAlt,
    Input$SeoInput? seo,
    String? publicationDate,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    List<String>? products,
  });
  CopyWith$Input$SeoInput<TRes> get seo;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$CollectionCreateInput<TRes>
    implements CopyWith$Input$CollectionCreateInput<TRes> {
  _CopyWithImpl$Input$CollectionCreateInput(
    this._instance,
    this._then,
  );

  final Input$CollectionCreateInput _instance;

  final TRes Function(Input$CollectionCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? isPublished = _undefined,
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? description = _undefined,
    Object? backgroundImage = _undefined,
    Object? backgroundImageAlt = _undefined,
    Object? seo = _undefined,
    Object? publicationDate = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? products = _undefined,
  }) =>
      _then(Input$CollectionCreateInput._({
        ..._instance._$data,
        if (isPublished != _undefined) 'isPublished': (isPublished as bool?),
        if (name != _undefined) 'name': (name as String?),
        if (slug != _undefined) 'slug': (slug as String?),
        if (description != _undefined) 'description': (description as String?),
        if (backgroundImage != _undefined)
          'backgroundImage': (backgroundImage as String?),
        if (backgroundImageAlt != _undefined)
          'backgroundImageAlt': (backgroundImageAlt as String?),
        if (seo != _undefined) 'seo': (seo as Input$SeoInput?),
        if (publicationDate != _undefined)
          'publicationDate': (publicationDate as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (products != _undefined) 'products': (products as List<String>?),
      }));

  CopyWith$Input$SeoInput<TRes> get seo {
    final local$seo = _instance.seo;
    return local$seo == null
        ? CopyWith$Input$SeoInput.stub(_then(_instance))
        : CopyWith$Input$SeoInput(local$seo, (e) => call(seo: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CollectionCreateInput<TRes>
    implements CopyWith$Input$CollectionCreateInput<TRes> {
  _CopyWithStubImpl$Input$CollectionCreateInput(this._res);

  TRes _res;

  call({
    bool? isPublished,
    String? name,
    String? slug,
    String? description,
    String? backgroundImage,
    String? backgroundImageAlt,
    Input$SeoInput? seo,
    String? publicationDate,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    List<String>? products,
  }) =>
      _res;

  CopyWith$Input$SeoInput<TRes> get seo => CopyWith$Input$SeoInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$CollectionFilterInput {
  factory Input$CollectionFilterInput({
    Enum$CollectionPublished? published,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<String>? slugs,
    String? channel,
  }) =>
      Input$CollectionFilterInput._({
        if (published != null) r'published': published,
        if (search != null) r'search': search,
        if (metadata != null) r'metadata': metadata,
        if (ids != null) r'ids': ids,
        if (slugs != null) r'slugs': slugs,
        if (channel != null) r'channel': channel,
      });

  Input$CollectionFilterInput._(this._$data);

  factory Input$CollectionFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('published')) {
      final l$published = data['published'];
      result$data['published'] = l$published == null
          ? null
          : fromJson$Enum$CollectionPublished((l$published as String));
    }
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('slugs')) {
      final l$slugs = data['slugs'];
      result$data['slugs'] =
          (l$slugs as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('channel')) {
      final l$channel = data['channel'];
      result$data['channel'] = (l$channel as String?);
    }
    return Input$CollectionFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CollectionPublished? get published =>
      (_$data['published'] as Enum$CollectionPublished?);

  String? get search => (_$data['search'] as String?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  List<String>? get slugs => (_$data['slugs'] as List<String>?);

  String? get channel => (_$data['channel'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('published')) {
      final l$published = published;
      result$data['published'] = l$published == null
          ? null
          : toJson$Enum$CollectionPublished(l$published);
    }
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('slugs')) {
      final l$slugs = slugs;
      result$data['slugs'] = l$slugs?.map((e) => e).toList();
    }
    if (_$data.containsKey('channel')) {
      final l$channel = channel;
      result$data['channel'] = l$channel;
    }
    return result$data;
  }

  CopyWith$Input$CollectionFilterInput<Input$CollectionFilterInput>
      get copyWith => CopyWith$Input$CollectionFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CollectionFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$published = published;
    final lOther$published = other.published;
    if (_$data.containsKey('published') !=
        other._$data.containsKey('published')) {
      return false;
    }
    if (l$published != lOther$published) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$slugs = slugs;
    final lOther$slugs = other.slugs;
    if (_$data.containsKey('slugs') != other._$data.containsKey('slugs')) {
      return false;
    }
    if (l$slugs != null && lOther$slugs != null) {
      if (l$slugs.length != lOther$slugs.length) {
        return false;
      }
      for (int i = 0; i < l$slugs.length; i++) {
        final l$slugs$entry = l$slugs[i];
        final lOther$slugs$entry = lOther$slugs[i];
        if (l$slugs$entry != lOther$slugs$entry) {
          return false;
        }
      }
    } else if (l$slugs != lOther$slugs) {
      return false;
    }
    final l$channel = channel;
    final lOther$channel = other.channel;
    if (_$data.containsKey('channel') != other._$data.containsKey('channel')) {
      return false;
    }
    if (l$channel != lOther$channel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$published = published;
    final l$search = search;
    final l$metadata = metadata;
    final l$ids = ids;
    final l$slugs = slugs;
    final l$channel = channel;
    return Object.hashAll([
      _$data.containsKey('published') ? l$published : const {},
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('slugs')
          ? l$slugs == null
              ? null
              : Object.hashAll(l$slugs.map((v) => v))
          : const {},
      _$data.containsKey('channel') ? l$channel : const {},
    ]);
  }
}

abstract class CopyWith$Input$CollectionFilterInput<TRes> {
  factory CopyWith$Input$CollectionFilterInput(
    Input$CollectionFilterInput instance,
    TRes Function(Input$CollectionFilterInput) then,
  ) = _CopyWithImpl$Input$CollectionFilterInput;

  factory CopyWith$Input$CollectionFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CollectionFilterInput;

  TRes call({
    Enum$CollectionPublished? published,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<String>? slugs,
    String? channel,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
}

class _CopyWithImpl$Input$CollectionFilterInput<TRes>
    implements CopyWith$Input$CollectionFilterInput<TRes> {
  _CopyWithImpl$Input$CollectionFilterInput(
    this._instance,
    this._then,
  );

  final Input$CollectionFilterInput _instance;

  final TRes Function(Input$CollectionFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? published = _undefined,
    Object? search = _undefined,
    Object? metadata = _undefined,
    Object? ids = _undefined,
    Object? slugs = _undefined,
    Object? channel = _undefined,
  }) =>
      _then(Input$CollectionFilterInput._({
        ..._instance._$data,
        if (published != _undefined)
          'published': (published as Enum$CollectionPublished?),
        if (search != _undefined) 'search': (search as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (slugs != _undefined) 'slugs': (slugs as List<String>?),
        if (channel != _undefined) 'channel': (channel as String?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CollectionFilterInput<TRes>
    implements CopyWith$Input$CollectionFilterInput<TRes> {
  _CopyWithStubImpl$Input$CollectionFilterInput(this._res);

  TRes _res;

  call({
    Enum$CollectionPublished? published,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<String>? slugs,
    String? channel,
  }) =>
      _res;

  metadata(_fn) => _res;
}

class Input$CollectionInput {
  factory Input$CollectionInput({
    bool? isPublished,
    String? name,
    String? slug,
    String? description,
    String? backgroundImage,
    String? backgroundImageAlt,
    Input$SeoInput? seo,
    String? publicationDate,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  }) =>
      Input$CollectionInput._({
        if (isPublished != null) r'isPublished': isPublished,
        if (name != null) r'name': name,
        if (slug != null) r'slug': slug,
        if (description != null) r'description': description,
        if (backgroundImage != null) r'backgroundImage': backgroundImage,
        if (backgroundImageAlt != null)
          r'backgroundImageAlt': backgroundImageAlt,
        if (seo != null) r'seo': seo,
        if (publicationDate != null) r'publicationDate': publicationDate,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
      });

  Input$CollectionInput._(this._$data);

  factory Input$CollectionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('isPublished')) {
      final l$isPublished = data['isPublished'];
      result$data['isPublished'] = (l$isPublished as bool?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('backgroundImage')) {
      final l$backgroundImage = data['backgroundImage'];
      result$data['backgroundImage'] = (l$backgroundImage as String?);
    }
    if (data.containsKey('backgroundImageAlt')) {
      final l$backgroundImageAlt = data['backgroundImageAlt'];
      result$data['backgroundImageAlt'] = (l$backgroundImageAlt as String?);
    }
    if (data.containsKey('seo')) {
      final l$seo = data['seo'];
      result$data['seo'] = l$seo == null
          ? null
          : Input$SeoInput.fromJson((l$seo as Map<String, dynamic>));
    }
    if (data.containsKey('publicationDate')) {
      final l$publicationDate = data['publicationDate'];
      result$data['publicationDate'] = (l$publicationDate as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$CollectionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get isPublished => (_$data['isPublished'] as bool?);

  String? get name => (_$data['name'] as String?);

  String? get slug => (_$data['slug'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get backgroundImage => (_$data['backgroundImage'] as String?);

  String? get backgroundImageAlt => (_$data['backgroundImageAlt'] as String?);

  Input$SeoInput? get seo => (_$data['seo'] as Input$SeoInput?);

  String? get publicationDate => (_$data['publicationDate'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('isPublished')) {
      final l$isPublished = isPublished;
      result$data['isPublished'] = l$isPublished;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('backgroundImage')) {
      final l$backgroundImage = backgroundImage;
      result$data['backgroundImage'] = l$backgroundImage;
    }
    if (_$data.containsKey('backgroundImageAlt')) {
      final l$backgroundImageAlt = backgroundImageAlt;
      result$data['backgroundImageAlt'] = l$backgroundImageAlt;
    }
    if (_$data.containsKey('seo')) {
      final l$seo = seo;
      result$data['seo'] = l$seo?.toJson();
    }
    if (_$data.containsKey('publicationDate')) {
      final l$publicationDate = publicationDate;
      result$data['publicationDate'] = l$publicationDate;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$CollectionInput<Input$CollectionInput> get copyWith =>
      CopyWith$Input$CollectionInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CollectionInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$isPublished = isPublished;
    final lOther$isPublished = other.isPublished;
    if (_$data.containsKey('isPublished') !=
        other._$data.containsKey('isPublished')) {
      return false;
    }
    if (l$isPublished != lOther$isPublished) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$backgroundImage = backgroundImage;
    final lOther$backgroundImage = other.backgroundImage;
    if (_$data.containsKey('backgroundImage') !=
        other._$data.containsKey('backgroundImage')) {
      return false;
    }
    if (l$backgroundImage != lOther$backgroundImage) {
      return false;
    }
    final l$backgroundImageAlt = backgroundImageAlt;
    final lOther$backgroundImageAlt = other.backgroundImageAlt;
    if (_$data.containsKey('backgroundImageAlt') !=
        other._$data.containsKey('backgroundImageAlt')) {
      return false;
    }
    if (l$backgroundImageAlt != lOther$backgroundImageAlt) {
      return false;
    }
    final l$seo = seo;
    final lOther$seo = other.seo;
    if (_$data.containsKey('seo') != other._$data.containsKey('seo')) {
      return false;
    }
    if (l$seo != lOther$seo) {
      return false;
    }
    final l$publicationDate = publicationDate;
    final lOther$publicationDate = other.publicationDate;
    if (_$data.containsKey('publicationDate') !=
        other._$data.containsKey('publicationDate')) {
      return false;
    }
    if (l$publicationDate != lOther$publicationDate) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$isPublished = isPublished;
    final l$name = name;
    final l$slug = slug;
    final l$description = description;
    final l$backgroundImage = backgroundImage;
    final l$backgroundImageAlt = backgroundImageAlt;
    final l$seo = seo;
    final l$publicationDate = publicationDate;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    return Object.hashAll([
      _$data.containsKey('isPublished') ? l$isPublished : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('backgroundImage') ? l$backgroundImage : const {},
      _$data.containsKey('backgroundImageAlt')
          ? l$backgroundImageAlt
          : const {},
      _$data.containsKey('seo') ? l$seo : const {},
      _$data.containsKey('publicationDate') ? l$publicationDate : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CollectionInput<TRes> {
  factory CopyWith$Input$CollectionInput(
    Input$CollectionInput instance,
    TRes Function(Input$CollectionInput) then,
  ) = _CopyWithImpl$Input$CollectionInput;

  factory CopyWith$Input$CollectionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CollectionInput;

  TRes call({
    bool? isPublished,
    String? name,
    String? slug,
    String? description,
    String? backgroundImage,
    String? backgroundImageAlt,
    Input$SeoInput? seo,
    String? publicationDate,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  });
  CopyWith$Input$SeoInput<TRes> get seo;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$CollectionInput<TRes>
    implements CopyWith$Input$CollectionInput<TRes> {
  _CopyWithImpl$Input$CollectionInput(
    this._instance,
    this._then,
  );

  final Input$CollectionInput _instance;

  final TRes Function(Input$CollectionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? isPublished = _undefined,
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? description = _undefined,
    Object? backgroundImage = _undefined,
    Object? backgroundImageAlt = _undefined,
    Object? seo = _undefined,
    Object? publicationDate = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
  }) =>
      _then(Input$CollectionInput._({
        ..._instance._$data,
        if (isPublished != _undefined) 'isPublished': (isPublished as bool?),
        if (name != _undefined) 'name': (name as String?),
        if (slug != _undefined) 'slug': (slug as String?),
        if (description != _undefined) 'description': (description as String?),
        if (backgroundImage != _undefined)
          'backgroundImage': (backgroundImage as String?),
        if (backgroundImageAlt != _undefined)
          'backgroundImageAlt': (backgroundImageAlt as String?),
        if (seo != _undefined) 'seo': (seo as Input$SeoInput?),
        if (publicationDate != _undefined)
          'publicationDate': (publicationDate as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
      }));

  CopyWith$Input$SeoInput<TRes> get seo {
    final local$seo = _instance.seo;
    return local$seo == null
        ? CopyWith$Input$SeoInput.stub(_then(_instance))
        : CopyWith$Input$SeoInput(local$seo, (e) => call(seo: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CollectionInput<TRes>
    implements CopyWith$Input$CollectionInput<TRes> {
  _CopyWithStubImpl$Input$CollectionInput(this._res);

  TRes _res;

  call({
    bool? isPublished,
    String? name,
    String? slug,
    String? description,
    String? backgroundImage,
    String? backgroundImageAlt,
    Input$SeoInput? seo,
    String? publicationDate,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  }) =>
      _res;

  CopyWith$Input$SeoInput<TRes> get seo => CopyWith$Input$SeoInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$CollectionSortingInput {
  factory Input$CollectionSortingInput({
    required Enum$OrderDirection direction,
    String? channel,
    required Enum$CollectionSortField field,
  }) =>
      Input$CollectionSortingInput._({
        r'direction': direction,
        if (channel != null) r'channel': channel,
        r'field': field,
      });

  Input$CollectionSortingInput._(this._$data);

  factory Input$CollectionSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    if (data.containsKey('channel')) {
      final l$channel = data['channel'];
      result$data['channel'] = (l$channel as String?);
    }
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$CollectionSortField((l$field as String));
    return Input$CollectionSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  String? get channel => (_$data['channel'] as String?);

  Enum$CollectionSortField get field =>
      (_$data['field'] as Enum$CollectionSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    if (_$data.containsKey('channel')) {
      final l$channel = channel;
      result$data['channel'] = l$channel;
    }
    final l$field = field;
    result$data['field'] = toJson$Enum$CollectionSortField(l$field);
    return result$data;
  }

  CopyWith$Input$CollectionSortingInput<Input$CollectionSortingInput>
      get copyWith => CopyWith$Input$CollectionSortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CollectionSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$channel = channel;
    final lOther$channel = other.channel;
    if (_$data.containsKey('channel') != other._$data.containsKey('channel')) {
      return false;
    }
    if (l$channel != lOther$channel) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$channel = channel;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      _$data.containsKey('channel') ? l$channel : const {},
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$CollectionSortingInput<TRes> {
  factory CopyWith$Input$CollectionSortingInput(
    Input$CollectionSortingInput instance,
    TRes Function(Input$CollectionSortingInput) then,
  ) = _CopyWithImpl$Input$CollectionSortingInput;

  factory CopyWith$Input$CollectionSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CollectionSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    String? channel,
    Enum$CollectionSortField? field,
  });
}

class _CopyWithImpl$Input$CollectionSortingInput<TRes>
    implements CopyWith$Input$CollectionSortingInput<TRes> {
  _CopyWithImpl$Input$CollectionSortingInput(
    this._instance,
    this._then,
  );

  final Input$CollectionSortingInput _instance;

  final TRes Function(Input$CollectionSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? channel = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$CollectionSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (channel != _undefined) 'channel': (channel as String?),
        if (field != _undefined && field != null)
          'field': (field as Enum$CollectionSortField),
      }));
}

class _CopyWithStubImpl$Input$CollectionSortingInput<TRes>
    implements CopyWith$Input$CollectionSortingInput<TRes> {
  _CopyWithStubImpl$Input$CollectionSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    String? channel,
    Enum$CollectionSortField? field,
  }) =>
      _res;
}

class Input$CollectionWhereInput {
  factory Input$CollectionWhereInput({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<Input$CollectionWhereInput>? AND,
    List<Input$CollectionWhereInput>? OR,
  }) =>
      Input$CollectionWhereInput._({
        if (metadata != null) r'metadata': metadata,
        if (ids != null) r'ids': ids,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
      });

  Input$CollectionWhereInput._(this._$data);

  factory Input$CollectionWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$CollectionWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$CollectionWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$CollectionWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  List<Input$CollectionWhereInput>? get AND =>
      (_$data['AND'] as List<Input$CollectionWhereInput>?);

  List<Input$CollectionWhereInput>? get OR =>
      (_$data['OR'] as List<Input$CollectionWhereInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$CollectionWhereInput<Input$CollectionWhereInput>
      get copyWith => CopyWith$Input$CollectionWhereInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CollectionWhereInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$metadata = metadata;
    final l$ids = ids;
    final l$AND = AND;
    final l$OR = OR;
    return Object.hashAll([
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CollectionWhereInput<TRes> {
  factory CopyWith$Input$CollectionWhereInput(
    Input$CollectionWhereInput instance,
    TRes Function(Input$CollectionWhereInput) then,
  ) = _CopyWithImpl$Input$CollectionWhereInput;

  factory CopyWith$Input$CollectionWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CollectionWhereInput;

  TRes call({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<Input$CollectionWhereInput>? AND,
    List<Input$CollectionWhereInput>? OR,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
  TRes AND(
      Iterable<Input$CollectionWhereInput>? Function(
              Iterable<
                  CopyWith$Input$CollectionWhereInput<
                      Input$CollectionWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$CollectionWhereInput>? Function(
              Iterable<
                  CopyWith$Input$CollectionWhereInput<
                      Input$CollectionWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$CollectionWhereInput<TRes>
    implements CopyWith$Input$CollectionWhereInput<TRes> {
  _CopyWithImpl$Input$CollectionWhereInput(
    this._instance,
    this._then,
  );

  final Input$CollectionWhereInput _instance;

  final TRes Function(Input$CollectionWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? metadata = _undefined,
    Object? ids = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
  }) =>
      _then(Input$CollectionWhereInput._({
        ..._instance._$data,
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (AND != _undefined)
          'AND': (AND as List<Input$CollectionWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$CollectionWhereInput>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes AND(
          Iterable<Input$CollectionWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$CollectionWhereInput<
                          Input$CollectionWhereInput>>?)
              _fn) =>
      call(
          AND:
              _fn(_instance.AND?.map((e) => CopyWith$Input$CollectionWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes OR(
          Iterable<Input$CollectionWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$CollectionWhereInput<
                          Input$CollectionWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$CollectionWhereInput(
                e,
                (i) => i,
              )))?.toList());
}

class _CopyWithStubImpl$Input$CollectionWhereInput<TRes>
    implements CopyWith$Input$CollectionWhereInput<TRes> {
  _CopyWithStubImpl$Input$CollectionWhereInput(this._res);

  TRes _res;

  call({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<Input$CollectionWhereInput>? AND,
    List<Input$CollectionWhereInput>? OR,
  }) =>
      _res;

  metadata(_fn) => _res;

  AND(_fn) => _res;

  OR(_fn) => _res;
}

class Input$ConfigurationItemInput {
  factory Input$ConfigurationItemInput({
    required String name,
    String? value,
  }) =>
      Input$ConfigurationItemInput._({
        r'name': name,
        if (value != null) r'value': value,
      });

  Input$ConfigurationItemInput._(this._$data);

  factory Input$ConfigurationItemInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('value')) {
      final l$value = data['value'];
      result$data['value'] = (l$value as String?);
    }
    return Input$ConfigurationItemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String? get value => (_$data['value'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('value')) {
      final l$value = value;
      result$data['value'] = l$value;
    }
    return result$data;
  }

  CopyWith$Input$ConfigurationItemInput<Input$ConfigurationItemInput>
      get copyWith => CopyWith$Input$ConfigurationItemInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ConfigurationItemInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (_$data.containsKey('value') != other._$data.containsKey('value')) {
      return false;
    }
    if (l$value != lOther$value) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$value = value;
    return Object.hashAll([
      l$name,
      _$data.containsKey('value') ? l$value : const {},
    ]);
  }
}

abstract class CopyWith$Input$ConfigurationItemInput<TRes> {
  factory CopyWith$Input$ConfigurationItemInput(
    Input$ConfigurationItemInput instance,
    TRes Function(Input$ConfigurationItemInput) then,
  ) = _CopyWithImpl$Input$ConfigurationItemInput;

  factory CopyWith$Input$ConfigurationItemInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ConfigurationItemInput;

  TRes call({
    String? name,
    String? value,
  });
}

class _CopyWithImpl$Input$ConfigurationItemInput<TRes>
    implements CopyWith$Input$ConfigurationItemInput<TRes> {
  _CopyWithImpl$Input$ConfigurationItemInput(
    this._instance,
    this._then,
  );

  final Input$ConfigurationItemInput _instance;

  final TRes Function(Input$ConfigurationItemInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? value = _undefined,
  }) =>
      _then(Input$ConfigurationItemInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (value != _undefined) 'value': (value as String?),
      }));
}

class _CopyWithStubImpl$Input$ConfigurationItemInput<TRes>
    implements CopyWith$Input$ConfigurationItemInput<TRes> {
  _CopyWithStubImpl$Input$ConfigurationItemInput(this._res);

  TRes _res;

  call({
    String? name,
    String? value,
  }) =>
      _res;
}

class Input$CountryFilterInput {
  factory Input$CountryFilterInput({bool? attachedToShippingZones}) =>
      Input$CountryFilterInput._({
        if (attachedToShippingZones != null)
          r'attachedToShippingZones': attachedToShippingZones,
      });

  Input$CountryFilterInput._(this._$data);

  factory Input$CountryFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('attachedToShippingZones')) {
      final l$attachedToShippingZones = data['attachedToShippingZones'];
      result$data['attachedToShippingZones'] =
          (l$attachedToShippingZones as bool?);
    }
    return Input$CountryFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get attachedToShippingZones =>
      (_$data['attachedToShippingZones'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('attachedToShippingZones')) {
      final l$attachedToShippingZones = attachedToShippingZones;
      result$data['attachedToShippingZones'] = l$attachedToShippingZones;
    }
    return result$data;
  }

  CopyWith$Input$CountryFilterInput<Input$CountryFilterInput> get copyWith =>
      CopyWith$Input$CountryFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CountryFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$attachedToShippingZones = attachedToShippingZones;
    final lOther$attachedToShippingZones = other.attachedToShippingZones;
    if (_$data.containsKey('attachedToShippingZones') !=
        other._$data.containsKey('attachedToShippingZones')) {
      return false;
    }
    if (l$attachedToShippingZones != lOther$attachedToShippingZones) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$attachedToShippingZones = attachedToShippingZones;
    return Object.hashAll([
      _$data.containsKey('attachedToShippingZones')
          ? l$attachedToShippingZones
          : const {}
    ]);
  }
}

abstract class CopyWith$Input$CountryFilterInput<TRes> {
  factory CopyWith$Input$CountryFilterInput(
    Input$CountryFilterInput instance,
    TRes Function(Input$CountryFilterInput) then,
  ) = _CopyWithImpl$Input$CountryFilterInput;

  factory CopyWith$Input$CountryFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CountryFilterInput;

  TRes call({bool? attachedToShippingZones});
}

class _CopyWithImpl$Input$CountryFilterInput<TRes>
    implements CopyWith$Input$CountryFilterInput<TRes> {
  _CopyWithImpl$Input$CountryFilterInput(
    this._instance,
    this._then,
  );

  final Input$CountryFilterInput _instance;

  final TRes Function(Input$CountryFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? attachedToShippingZones = _undefined}) =>
      _then(Input$CountryFilterInput._({
        ..._instance._$data,
        if (attachedToShippingZones != _undefined)
          'attachedToShippingZones': (attachedToShippingZones as bool?),
      }));
}

class _CopyWithStubImpl$Input$CountryFilterInput<TRes>
    implements CopyWith$Input$CountryFilterInput<TRes> {
  _CopyWithStubImpl$Input$CountryFilterInput(this._res);

  TRes _res;

  call({bool? attachedToShippingZones}) => _res;
}

class Input$CountryRateInput {
  factory Input$CountryRateInput({
    required Enum$CountryCode countryCode,
    required double rate,
  }) =>
      Input$CountryRateInput._({
        r'countryCode': countryCode,
        r'rate': rate,
      });

  Input$CountryRateInput._(this._$data);

  factory Input$CountryRateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$countryCode = data['countryCode'];
    result$data['countryCode'] =
        fromJson$Enum$CountryCode((l$countryCode as String));
    final l$rate = data['rate'];
    result$data['rate'] = (l$rate as num).toDouble();
    return Input$CountryRateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CountryCode get countryCode =>
      (_$data['countryCode'] as Enum$CountryCode);

  double get rate => (_$data['rate'] as double);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$countryCode = countryCode;
    result$data['countryCode'] = toJson$Enum$CountryCode(l$countryCode);
    final l$rate = rate;
    result$data['rate'] = l$rate;
    return result$data;
  }

  CopyWith$Input$CountryRateInput<Input$CountryRateInput> get copyWith =>
      CopyWith$Input$CountryRateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CountryRateInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$countryCode = countryCode;
    final lOther$countryCode = other.countryCode;
    if (l$countryCode != lOther$countryCode) {
      return false;
    }
    final l$rate = rate;
    final lOther$rate = other.rate;
    if (l$rate != lOther$rate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$countryCode = countryCode;
    final l$rate = rate;
    return Object.hashAll([
      l$countryCode,
      l$rate,
    ]);
  }
}

abstract class CopyWith$Input$CountryRateInput<TRes> {
  factory CopyWith$Input$CountryRateInput(
    Input$CountryRateInput instance,
    TRes Function(Input$CountryRateInput) then,
  ) = _CopyWithImpl$Input$CountryRateInput;

  factory CopyWith$Input$CountryRateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CountryRateInput;

  TRes call({
    Enum$CountryCode? countryCode,
    double? rate,
  });
}

class _CopyWithImpl$Input$CountryRateInput<TRes>
    implements CopyWith$Input$CountryRateInput<TRes> {
  _CopyWithImpl$Input$CountryRateInput(
    this._instance,
    this._then,
  );

  final Input$CountryRateInput _instance;

  final TRes Function(Input$CountryRateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? countryCode = _undefined,
    Object? rate = _undefined,
  }) =>
      _then(Input$CountryRateInput._({
        ..._instance._$data,
        if (countryCode != _undefined && countryCode != null)
          'countryCode': (countryCode as Enum$CountryCode),
        if (rate != _undefined && rate != null) 'rate': (rate as double),
      }));
}

class _CopyWithStubImpl$Input$CountryRateInput<TRes>
    implements CopyWith$Input$CountryRateInput<TRes> {
  _CopyWithStubImpl$Input$CountryRateInput(this._res);

  TRes _res;

  call({
    Enum$CountryCode? countryCode,
    double? rate,
  }) =>
      _res;
}

class Input$CountryRateUpdateInput {
  factory Input$CountryRateUpdateInput({
    required Enum$CountryCode countryCode,
    double? rate,
  }) =>
      Input$CountryRateUpdateInput._({
        r'countryCode': countryCode,
        if (rate != null) r'rate': rate,
      });

  Input$CountryRateUpdateInput._(this._$data);

  factory Input$CountryRateUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$countryCode = data['countryCode'];
    result$data['countryCode'] =
        fromJson$Enum$CountryCode((l$countryCode as String));
    if (data.containsKey('rate')) {
      final l$rate = data['rate'];
      result$data['rate'] = (l$rate as num?)?.toDouble();
    }
    return Input$CountryRateUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CountryCode get countryCode =>
      (_$data['countryCode'] as Enum$CountryCode);

  double? get rate => (_$data['rate'] as double?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$countryCode = countryCode;
    result$data['countryCode'] = toJson$Enum$CountryCode(l$countryCode);
    if (_$data.containsKey('rate')) {
      final l$rate = rate;
      result$data['rate'] = l$rate;
    }
    return result$data;
  }

  CopyWith$Input$CountryRateUpdateInput<Input$CountryRateUpdateInput>
      get copyWith => CopyWith$Input$CountryRateUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CountryRateUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$countryCode = countryCode;
    final lOther$countryCode = other.countryCode;
    if (l$countryCode != lOther$countryCode) {
      return false;
    }
    final l$rate = rate;
    final lOther$rate = other.rate;
    if (_$data.containsKey('rate') != other._$data.containsKey('rate')) {
      return false;
    }
    if (l$rate != lOther$rate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$countryCode = countryCode;
    final l$rate = rate;
    return Object.hashAll([
      l$countryCode,
      _$data.containsKey('rate') ? l$rate : const {},
    ]);
  }
}

abstract class CopyWith$Input$CountryRateUpdateInput<TRes> {
  factory CopyWith$Input$CountryRateUpdateInput(
    Input$CountryRateUpdateInput instance,
    TRes Function(Input$CountryRateUpdateInput) then,
  ) = _CopyWithImpl$Input$CountryRateUpdateInput;

  factory CopyWith$Input$CountryRateUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CountryRateUpdateInput;

  TRes call({
    Enum$CountryCode? countryCode,
    double? rate,
  });
}

class _CopyWithImpl$Input$CountryRateUpdateInput<TRes>
    implements CopyWith$Input$CountryRateUpdateInput<TRes> {
  _CopyWithImpl$Input$CountryRateUpdateInput(
    this._instance,
    this._then,
  );

  final Input$CountryRateUpdateInput _instance;

  final TRes Function(Input$CountryRateUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? countryCode = _undefined,
    Object? rate = _undefined,
  }) =>
      _then(Input$CountryRateUpdateInput._({
        ..._instance._$data,
        if (countryCode != _undefined && countryCode != null)
          'countryCode': (countryCode as Enum$CountryCode),
        if (rate != _undefined) 'rate': (rate as double?),
      }));
}

class _CopyWithStubImpl$Input$CountryRateUpdateInput<TRes>
    implements CopyWith$Input$CountryRateUpdateInput<TRes> {
  _CopyWithStubImpl$Input$CountryRateUpdateInput(this._res);

  TRes _res;

  call({
    Enum$CountryCode? countryCode,
    double? rate,
  }) =>
      _res;
}

class Input$CustomerBulkUpdateInput {
  factory Input$CustomerBulkUpdateInput({
    String? id,
    String? externalReference,
    required Input$CustomerInput input,
  }) =>
      Input$CustomerBulkUpdateInput._({
        if (id != null) r'id': id,
        if (externalReference != null) r'externalReference': externalReference,
        r'input': input,
      });

  Input$CustomerBulkUpdateInput._(this._$data);

  factory Input$CustomerBulkUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    final l$input = data['input'];
    result$data['input'] =
        Input$CustomerInput.fromJson((l$input as Map<String, dynamic>));
    return Input$CustomerBulkUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get externalReference => (_$data['externalReference'] as String?);

  Input$CustomerInput get input => (_$data['input'] as Input$CustomerInput);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    final l$input = input;
    result$data['input'] = l$input.toJson();
    return result$data;
  }

  CopyWith$Input$CustomerBulkUpdateInput<Input$CustomerBulkUpdateInput>
      get copyWith => CopyWith$Input$CustomerBulkUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CustomerBulkUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$input = input;
    final lOther$input = other.input;
    if (l$input != lOther$input) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$externalReference = externalReference;
    final l$input = input;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      l$input,
    ]);
  }
}

abstract class CopyWith$Input$CustomerBulkUpdateInput<TRes> {
  factory CopyWith$Input$CustomerBulkUpdateInput(
    Input$CustomerBulkUpdateInput instance,
    TRes Function(Input$CustomerBulkUpdateInput) then,
  ) = _CopyWithImpl$Input$CustomerBulkUpdateInput;

  factory CopyWith$Input$CustomerBulkUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CustomerBulkUpdateInput;

  TRes call({
    String? id,
    String? externalReference,
    Input$CustomerInput? input,
  });
  CopyWith$Input$CustomerInput<TRes> get input;
}

class _CopyWithImpl$Input$CustomerBulkUpdateInput<TRes>
    implements CopyWith$Input$CustomerBulkUpdateInput<TRes> {
  _CopyWithImpl$Input$CustomerBulkUpdateInput(
    this._instance,
    this._then,
  );

  final Input$CustomerBulkUpdateInput _instance;

  final TRes Function(Input$CustomerBulkUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? externalReference = _undefined,
    Object? input = _undefined,
  }) =>
      _then(Input$CustomerBulkUpdateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (input != _undefined && input != null)
          'input': (input as Input$CustomerInput),
      }));

  CopyWith$Input$CustomerInput<TRes> get input {
    final local$input = _instance.input;
    return CopyWith$Input$CustomerInput(local$input, (e) => call(input: e));
  }
}

class _CopyWithStubImpl$Input$CustomerBulkUpdateInput<TRes>
    implements CopyWith$Input$CustomerBulkUpdateInput<TRes> {
  _CopyWithStubImpl$Input$CustomerBulkUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? externalReference,
    Input$CustomerInput? input,
  }) =>
      _res;

  CopyWith$Input$CustomerInput<TRes> get input =>
      CopyWith$Input$CustomerInput.stub(_res);
}

class Input$CustomerFilterInput {
  factory Input$CustomerFilterInput({
    Input$DateRangeInput? dateJoined,
    Input$IntRangeInput? numberOfOrders,
    Input$DateRangeInput? placedOrders,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    Input$DateTimeRangeInput? updatedAt,
  }) =>
      Input$CustomerFilterInput._({
        if (dateJoined != null) r'dateJoined': dateJoined,
        if (numberOfOrders != null) r'numberOfOrders': numberOfOrders,
        if (placedOrders != null) r'placedOrders': placedOrders,
        if (search != null) r'search': search,
        if (metadata != null) r'metadata': metadata,
        if (ids != null) r'ids': ids,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$CustomerFilterInput._(this._$data);

  factory Input$CustomerFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('dateJoined')) {
      final l$dateJoined = data['dateJoined'];
      result$data['dateJoined'] = l$dateJoined == null
          ? null
          : Input$DateRangeInput.fromJson(
              (l$dateJoined as Map<String, dynamic>));
    }
    if (data.containsKey('numberOfOrders')) {
      final l$numberOfOrders = data['numberOfOrders'];
      result$data['numberOfOrders'] = l$numberOfOrders == null
          ? null
          : Input$IntRangeInput.fromJson(
              (l$numberOfOrders as Map<String, dynamic>));
    }
    if (data.containsKey('placedOrders')) {
      final l$placedOrders = data['placedOrders'];
      result$data['placedOrders'] = l$placedOrders == null
          ? null
          : Input$DateRangeInput.fromJson(
              (l$placedOrders as Map<String, dynamic>));
    }
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeRangeInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    return Input$CustomerFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$DateRangeInput? get dateJoined =>
      (_$data['dateJoined'] as Input$DateRangeInput?);

  Input$IntRangeInput? get numberOfOrders =>
      (_$data['numberOfOrders'] as Input$IntRangeInput?);

  Input$DateRangeInput? get placedOrders =>
      (_$data['placedOrders'] as Input$DateRangeInput?);

  String? get search => (_$data['search'] as String?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  Input$DateTimeRangeInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeRangeInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('dateJoined')) {
      final l$dateJoined = dateJoined;
      result$data['dateJoined'] = l$dateJoined?.toJson();
    }
    if (_$data.containsKey('numberOfOrders')) {
      final l$numberOfOrders = numberOfOrders;
      result$data['numberOfOrders'] = l$numberOfOrders?.toJson();
    }
    if (_$data.containsKey('placedOrders')) {
      final l$placedOrders = placedOrders;
      result$data['placedOrders'] = l$placedOrders?.toJson();
    }
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CustomerFilterInput<Input$CustomerFilterInput> get copyWith =>
      CopyWith$Input$CustomerFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CustomerFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$dateJoined = dateJoined;
    final lOther$dateJoined = other.dateJoined;
    if (_$data.containsKey('dateJoined') !=
        other._$data.containsKey('dateJoined')) {
      return false;
    }
    if (l$dateJoined != lOther$dateJoined) {
      return false;
    }
    final l$numberOfOrders = numberOfOrders;
    final lOther$numberOfOrders = other.numberOfOrders;
    if (_$data.containsKey('numberOfOrders') !=
        other._$data.containsKey('numberOfOrders')) {
      return false;
    }
    if (l$numberOfOrders != lOther$numberOfOrders) {
      return false;
    }
    final l$placedOrders = placedOrders;
    final lOther$placedOrders = other.placedOrders;
    if (_$data.containsKey('placedOrders') !=
        other._$data.containsKey('placedOrders')) {
      return false;
    }
    if (l$placedOrders != lOther$placedOrders) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$dateJoined = dateJoined;
    final l$numberOfOrders = numberOfOrders;
    final l$placedOrders = placedOrders;
    final l$search = search;
    final l$metadata = metadata;
    final l$ids = ids;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('dateJoined') ? l$dateJoined : const {},
      _$data.containsKey('numberOfOrders') ? l$numberOfOrders : const {},
      _$data.containsKey('placedOrders') ? l$placedOrders : const {},
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$CustomerFilterInput<TRes> {
  factory CopyWith$Input$CustomerFilterInput(
    Input$CustomerFilterInput instance,
    TRes Function(Input$CustomerFilterInput) then,
  ) = _CopyWithImpl$Input$CustomerFilterInput;

  factory CopyWith$Input$CustomerFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CustomerFilterInput;

  TRes call({
    Input$DateRangeInput? dateJoined,
    Input$IntRangeInput? numberOfOrders,
    Input$DateRangeInput? placedOrders,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    Input$DateTimeRangeInput? updatedAt,
  });
  CopyWith$Input$DateRangeInput<TRes> get dateJoined;
  CopyWith$Input$IntRangeInput<TRes> get numberOfOrders;
  CopyWith$Input$DateRangeInput<TRes> get placedOrders;
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$CustomerFilterInput<TRes>
    implements CopyWith$Input$CustomerFilterInput<TRes> {
  _CopyWithImpl$Input$CustomerFilterInput(
    this._instance,
    this._then,
  );

  final Input$CustomerFilterInput _instance;

  final TRes Function(Input$CustomerFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? dateJoined = _undefined,
    Object? numberOfOrders = _undefined,
    Object? placedOrders = _undefined,
    Object? search = _undefined,
    Object? metadata = _undefined,
    Object? ids = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$CustomerFilterInput._({
        ..._instance._$data,
        if (dateJoined != _undefined)
          'dateJoined': (dateJoined as Input$DateRangeInput?),
        if (numberOfOrders != _undefined)
          'numberOfOrders': (numberOfOrders as Input$IntRangeInput?),
        if (placedOrders != _undefined)
          'placedOrders': (placedOrders as Input$DateRangeInput?),
        if (search != _undefined) 'search': (search as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeRangeInput?),
      }));

  CopyWith$Input$DateRangeInput<TRes> get dateJoined {
    final local$dateJoined = _instance.dateJoined;
    return local$dateJoined == null
        ? CopyWith$Input$DateRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateRangeInput(
            local$dateJoined, (e) => call(dateJoined: e));
  }

  CopyWith$Input$IntRangeInput<TRes> get numberOfOrders {
    final local$numberOfOrders = _instance.numberOfOrders;
    return local$numberOfOrders == null
        ? CopyWith$Input$IntRangeInput.stub(_then(_instance))
        : CopyWith$Input$IntRangeInput(
            local$numberOfOrders, (e) => call(numberOfOrders: e));
  }

  CopyWith$Input$DateRangeInput<TRes> get placedOrders {
    final local$placedOrders = _instance.placedOrders;
    return local$placedOrders == null
        ? CopyWith$Input$DateRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateRangeInput(
            local$placedOrders, (e) => call(placedOrders: e));
  }

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeRangeInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }
}

class _CopyWithStubImpl$Input$CustomerFilterInput<TRes>
    implements CopyWith$Input$CustomerFilterInput<TRes> {
  _CopyWithStubImpl$Input$CustomerFilterInput(this._res);

  TRes _res;

  call({
    Input$DateRangeInput? dateJoined,
    Input$IntRangeInput? numberOfOrders,
    Input$DateRangeInput? placedOrders,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    Input$DateTimeRangeInput? updatedAt,
  }) =>
      _res;

  CopyWith$Input$DateRangeInput<TRes> get dateJoined =>
      CopyWith$Input$DateRangeInput.stub(_res);

  CopyWith$Input$IntRangeInput<TRes> get numberOfOrders =>
      CopyWith$Input$IntRangeInput.stub(_res);

  CopyWith$Input$DateRangeInput<TRes> get placedOrders =>
      CopyWith$Input$DateRangeInput.stub(_res);

  metadata(_fn) => _res;

  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeRangeInput.stub(_res);
}

class Input$CustomerInput {
  factory Input$CustomerInput({
    Input$AddressInput? defaultBillingAddress,
    Input$AddressInput? defaultShippingAddress,
    String? firstName,
    String? lastName,
    String? email,
    bool? isActive,
    String? note,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Enum$LanguageCodeEnum? languageCode,
    String? externalReference,
    bool? isConfirmed,
  }) =>
      Input$CustomerInput._({
        if (defaultBillingAddress != null)
          r'defaultBillingAddress': defaultBillingAddress,
        if (defaultShippingAddress != null)
          r'defaultShippingAddress': defaultShippingAddress,
        if (firstName != null) r'firstName': firstName,
        if (lastName != null) r'lastName': lastName,
        if (email != null) r'email': email,
        if (isActive != null) r'isActive': isActive,
        if (note != null) r'note': note,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (languageCode != null) r'languageCode': languageCode,
        if (externalReference != null) r'externalReference': externalReference,
        if (isConfirmed != null) r'isConfirmed': isConfirmed,
      });

  Input$CustomerInput._(this._$data);

  factory Input$CustomerInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('defaultBillingAddress')) {
      final l$defaultBillingAddress = data['defaultBillingAddress'];
      result$data['defaultBillingAddress'] = l$defaultBillingAddress == null
          ? null
          : Input$AddressInput.fromJson(
              (l$defaultBillingAddress as Map<String, dynamic>));
    }
    if (data.containsKey('defaultShippingAddress')) {
      final l$defaultShippingAddress = data['defaultShippingAddress'];
      result$data['defaultShippingAddress'] = l$defaultShippingAddress == null
          ? null
          : Input$AddressInput.fromJson(
              (l$defaultShippingAddress as Map<String, dynamic>));
    }
    if (data.containsKey('firstName')) {
      final l$firstName = data['firstName'];
      result$data['firstName'] = (l$firstName as String?);
    }
    if (data.containsKey('lastName')) {
      final l$lastName = data['lastName'];
      result$data['lastName'] = (l$lastName as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = (l$isActive as bool?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('languageCode')) {
      final l$languageCode = data['languageCode'];
      result$data['languageCode'] = l$languageCode == null
          ? null
          : fromJson$Enum$LanguageCodeEnum((l$languageCode as String));
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    if (data.containsKey('isConfirmed')) {
      final l$isConfirmed = data['isConfirmed'];
      result$data['isConfirmed'] = (l$isConfirmed as bool?);
    }
    return Input$CustomerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$AddressInput? get defaultBillingAddress =>
      (_$data['defaultBillingAddress'] as Input$AddressInput?);

  Input$AddressInput? get defaultShippingAddress =>
      (_$data['defaultShippingAddress'] as Input$AddressInput?);

  String? get firstName => (_$data['firstName'] as String?);

  String? get lastName => (_$data['lastName'] as String?);

  String? get email => (_$data['email'] as String?);

  bool? get isActive => (_$data['isActive'] as bool?);

  String? get note => (_$data['note'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  Enum$LanguageCodeEnum? get languageCode =>
      (_$data['languageCode'] as Enum$LanguageCodeEnum?);

  String? get externalReference => (_$data['externalReference'] as String?);

  bool? get isConfirmed => (_$data['isConfirmed'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('defaultBillingAddress')) {
      final l$defaultBillingAddress = defaultBillingAddress;
      result$data['defaultBillingAddress'] = l$defaultBillingAddress?.toJson();
    }
    if (_$data.containsKey('defaultShippingAddress')) {
      final l$defaultShippingAddress = defaultShippingAddress;
      result$data['defaultShippingAddress'] =
          l$defaultShippingAddress?.toJson();
    }
    if (_$data.containsKey('firstName')) {
      final l$firstName = firstName;
      result$data['firstName'] = l$firstName;
    }
    if (_$data.containsKey('lastName')) {
      final l$lastName = lastName;
      result$data['lastName'] = l$lastName;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('languageCode')) {
      final l$languageCode = languageCode;
      result$data['languageCode'] = l$languageCode == null
          ? null
          : toJson$Enum$LanguageCodeEnum(l$languageCode);
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    if (_$data.containsKey('isConfirmed')) {
      final l$isConfirmed = isConfirmed;
      result$data['isConfirmed'] = l$isConfirmed;
    }
    return result$data;
  }

  CopyWith$Input$CustomerInput<Input$CustomerInput> get copyWith =>
      CopyWith$Input$CustomerInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CustomerInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$defaultBillingAddress = defaultBillingAddress;
    final lOther$defaultBillingAddress = other.defaultBillingAddress;
    if (_$data.containsKey('defaultBillingAddress') !=
        other._$data.containsKey('defaultBillingAddress')) {
      return false;
    }
    if (l$defaultBillingAddress != lOther$defaultBillingAddress) {
      return false;
    }
    final l$defaultShippingAddress = defaultShippingAddress;
    final lOther$defaultShippingAddress = other.defaultShippingAddress;
    if (_$data.containsKey('defaultShippingAddress') !=
        other._$data.containsKey('defaultShippingAddress')) {
      return false;
    }
    if (l$defaultShippingAddress != lOther$defaultShippingAddress) {
      return false;
    }
    final l$firstName = firstName;
    final lOther$firstName = other.firstName;
    if (_$data.containsKey('firstName') !=
        other._$data.containsKey('firstName')) {
      return false;
    }
    if (l$firstName != lOther$firstName) {
      return false;
    }
    final l$lastName = lastName;
    final lOther$lastName = other.lastName;
    if (_$data.containsKey('lastName') !=
        other._$data.containsKey('lastName')) {
      return false;
    }
    if (l$lastName != lOther$lastName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$languageCode = languageCode;
    final lOther$languageCode = other.languageCode;
    if (_$data.containsKey('languageCode') !=
        other._$data.containsKey('languageCode')) {
      return false;
    }
    if (l$languageCode != lOther$languageCode) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$isConfirmed = isConfirmed;
    final lOther$isConfirmed = other.isConfirmed;
    if (_$data.containsKey('isConfirmed') !=
        other._$data.containsKey('isConfirmed')) {
      return false;
    }
    if (l$isConfirmed != lOther$isConfirmed) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$defaultBillingAddress = defaultBillingAddress;
    final l$defaultShippingAddress = defaultShippingAddress;
    final l$firstName = firstName;
    final l$lastName = lastName;
    final l$email = email;
    final l$isActive = isActive;
    final l$note = note;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$languageCode = languageCode;
    final l$externalReference = externalReference;
    final l$isConfirmed = isConfirmed;
    return Object.hashAll([
      _$data.containsKey('defaultBillingAddress')
          ? l$defaultBillingAddress
          : const {},
      _$data.containsKey('defaultShippingAddress')
          ? l$defaultShippingAddress
          : const {},
      _$data.containsKey('firstName') ? l$firstName : const {},
      _$data.containsKey('lastName') ? l$lastName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('note') ? l$note : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('languageCode') ? l$languageCode : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      _$data.containsKey('isConfirmed') ? l$isConfirmed : const {},
    ]);
  }
}

abstract class CopyWith$Input$CustomerInput<TRes> {
  factory CopyWith$Input$CustomerInput(
    Input$CustomerInput instance,
    TRes Function(Input$CustomerInput) then,
  ) = _CopyWithImpl$Input$CustomerInput;

  factory CopyWith$Input$CustomerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CustomerInput;

  TRes call({
    Input$AddressInput? defaultBillingAddress,
    Input$AddressInput? defaultShippingAddress,
    String? firstName,
    String? lastName,
    String? email,
    bool? isActive,
    String? note,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Enum$LanguageCodeEnum? languageCode,
    String? externalReference,
    bool? isConfirmed,
  });
  CopyWith$Input$AddressInput<TRes> get defaultBillingAddress;
  CopyWith$Input$AddressInput<TRes> get defaultShippingAddress;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$CustomerInput<TRes>
    implements CopyWith$Input$CustomerInput<TRes> {
  _CopyWithImpl$Input$CustomerInput(
    this._instance,
    this._then,
  );

  final Input$CustomerInput _instance;

  final TRes Function(Input$CustomerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? defaultBillingAddress = _undefined,
    Object? defaultShippingAddress = _undefined,
    Object? firstName = _undefined,
    Object? lastName = _undefined,
    Object? email = _undefined,
    Object? isActive = _undefined,
    Object? note = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? languageCode = _undefined,
    Object? externalReference = _undefined,
    Object? isConfirmed = _undefined,
  }) =>
      _then(Input$CustomerInput._({
        ..._instance._$data,
        if (defaultBillingAddress != _undefined)
          'defaultBillingAddress':
              (defaultBillingAddress as Input$AddressInput?),
        if (defaultShippingAddress != _undefined)
          'defaultShippingAddress':
              (defaultShippingAddress as Input$AddressInput?),
        if (firstName != _undefined) 'firstName': (firstName as String?),
        if (lastName != _undefined) 'lastName': (lastName as String?),
        if (email != _undefined) 'email': (email as String?),
        if (isActive != _undefined) 'isActive': (isActive as bool?),
        if (note != _undefined) 'note': (note as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (languageCode != _undefined)
          'languageCode': (languageCode as Enum$LanguageCodeEnum?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (isConfirmed != _undefined) 'isConfirmed': (isConfirmed as bool?),
      }));

  CopyWith$Input$AddressInput<TRes> get defaultBillingAddress {
    final local$defaultBillingAddress = _instance.defaultBillingAddress;
    return local$defaultBillingAddress == null
        ? CopyWith$Input$AddressInput.stub(_then(_instance))
        : CopyWith$Input$AddressInput(
            local$defaultBillingAddress, (e) => call(defaultBillingAddress: e));
  }

  CopyWith$Input$AddressInput<TRes> get defaultShippingAddress {
    final local$defaultShippingAddress = _instance.defaultShippingAddress;
    return local$defaultShippingAddress == null
        ? CopyWith$Input$AddressInput.stub(_then(_instance))
        : CopyWith$Input$AddressInput(local$defaultShippingAddress,
            (e) => call(defaultShippingAddress: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CustomerInput<TRes>
    implements CopyWith$Input$CustomerInput<TRes> {
  _CopyWithStubImpl$Input$CustomerInput(this._res);

  TRes _res;

  call({
    Input$AddressInput? defaultBillingAddress,
    Input$AddressInput? defaultShippingAddress,
    String? firstName,
    String? lastName,
    String? email,
    bool? isActive,
    String? note,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Enum$LanguageCodeEnum? languageCode,
    String? externalReference,
    bool? isConfirmed,
  }) =>
      _res;

  CopyWith$Input$AddressInput<TRes> get defaultBillingAddress =>
      CopyWith$Input$AddressInput.stub(_res);

  CopyWith$Input$AddressInput<TRes> get defaultShippingAddress =>
      CopyWith$Input$AddressInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$DateRangeInput {
  factory Input$DateRangeInput({
    String? gte,
    String? lte,
  }) =>
      Input$DateRangeInput._({
        if (gte != null) r'gte': gte,
        if (lte != null) r'lte': lte,
      });

  Input$DateRangeInput._(this._$data);

  factory Input$DateRangeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    return Input$DateRangeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get gte => (_$data['gte'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    return result$data;
  }

  CopyWith$Input$DateRangeInput<Input$DateRangeInput> get copyWith =>
      CopyWith$Input$DateRangeInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DateRangeInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$gte = gte;
    final l$lte = lte;
    return Object.hashAll([
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('lte') ? l$lte : const {},
    ]);
  }
}

abstract class CopyWith$Input$DateRangeInput<TRes> {
  factory CopyWith$Input$DateRangeInput(
    Input$DateRangeInput instance,
    TRes Function(Input$DateRangeInput) then,
  ) = _CopyWithImpl$Input$DateRangeInput;

  factory CopyWith$Input$DateRangeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DateRangeInput;

  TRes call({
    String? gte,
    String? lte,
  });
}

class _CopyWithImpl$Input$DateRangeInput<TRes>
    implements CopyWith$Input$DateRangeInput<TRes> {
  _CopyWithImpl$Input$DateRangeInput(
    this._instance,
    this._then,
  );

  final Input$DateRangeInput _instance;

  final TRes Function(Input$DateRangeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? gte = _undefined,
    Object? lte = _undefined,
  }) =>
      _then(Input$DateRangeInput._({
        ..._instance._$data,
        if (gte != _undefined) 'gte': (gte as String?),
        if (lte != _undefined) 'lte': (lte as String?),
      }));
}

class _CopyWithStubImpl$Input$DateRangeInput<TRes>
    implements CopyWith$Input$DateRangeInput<TRes> {
  _CopyWithStubImpl$Input$DateRangeInput(this._res);

  TRes _res;

  call({
    String? gte,
    String? lte,
  }) =>
      _res;
}

class Input$DateTimeFilterInput {
  factory Input$DateTimeFilterInput({
    String? eq,
    List<String>? oneOf,
    Input$DateTimeRangeInput? range,
  }) =>
      Input$DateTimeFilterInput._({
        if (eq != null) r'eq': eq,
        if (oneOf != null) r'oneOf': oneOf,
        if (range != null) r'range': range,
      });

  Input$DateTimeFilterInput._(this._$data);

  factory Input$DateTimeFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('oneOf')) {
      final l$oneOf = data['oneOf'];
      result$data['oneOf'] =
          (l$oneOf as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('range')) {
      final l$range = data['range'];
      result$data['range'] = l$range == null
          ? null
          : Input$DateTimeRangeInput.fromJson(
              (l$range as Map<String, dynamic>));
    }
    return Input$DateTimeFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get eq => (_$data['eq'] as String?);

  List<String>? get oneOf => (_$data['oneOf'] as List<String>?);

  Input$DateTimeRangeInput? get range =>
      (_$data['range'] as Input$DateTimeRangeInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('oneOf')) {
      final l$oneOf = oneOf;
      result$data['oneOf'] = l$oneOf?.map((e) => e).toList();
    }
    if (_$data.containsKey('range')) {
      final l$range = range;
      result$data['range'] = l$range?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$DateTimeFilterInput<Input$DateTimeFilterInput> get copyWith =>
      CopyWith$Input$DateTimeFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DateTimeFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$oneOf = oneOf;
    final lOther$oneOf = other.oneOf;
    if (_$data.containsKey('oneOf') != other._$data.containsKey('oneOf')) {
      return false;
    }
    if (l$oneOf != null && lOther$oneOf != null) {
      if (l$oneOf.length != lOther$oneOf.length) {
        return false;
      }
      for (int i = 0; i < l$oneOf.length; i++) {
        final l$oneOf$entry = l$oneOf[i];
        final lOther$oneOf$entry = lOther$oneOf[i];
        if (l$oneOf$entry != lOther$oneOf$entry) {
          return false;
        }
      }
    } else if (l$oneOf != lOther$oneOf) {
      return false;
    }
    final l$range = range;
    final lOther$range = other.range;
    if (_$data.containsKey('range') != other._$data.containsKey('range')) {
      return false;
    }
    if (l$range != lOther$range) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$oneOf = oneOf;
    final l$range = range;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('oneOf')
          ? l$oneOf == null
              ? null
              : Object.hashAll(l$oneOf.map((v) => v))
          : const {},
      _$data.containsKey('range') ? l$range : const {},
    ]);
  }
}

abstract class CopyWith$Input$DateTimeFilterInput<TRes> {
  factory CopyWith$Input$DateTimeFilterInput(
    Input$DateTimeFilterInput instance,
    TRes Function(Input$DateTimeFilterInput) then,
  ) = _CopyWithImpl$Input$DateTimeFilterInput;

  factory CopyWith$Input$DateTimeFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DateTimeFilterInput;

  TRes call({
    String? eq,
    List<String>? oneOf,
    Input$DateTimeRangeInput? range,
  });
  CopyWith$Input$DateTimeRangeInput<TRes> get range;
}

class _CopyWithImpl$Input$DateTimeFilterInput<TRes>
    implements CopyWith$Input$DateTimeFilterInput<TRes> {
  _CopyWithImpl$Input$DateTimeFilterInput(
    this._instance,
    this._then,
  );

  final Input$DateTimeFilterInput _instance;

  final TRes Function(Input$DateTimeFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? oneOf = _undefined,
    Object? range = _undefined,
  }) =>
      _then(Input$DateTimeFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as String?),
        if (oneOf != _undefined) 'oneOf': (oneOf as List<String>?),
        if (range != _undefined) 'range': (range as Input$DateTimeRangeInput?),
      }));

  CopyWith$Input$DateTimeRangeInput<TRes> get range {
    final local$range = _instance.range;
    return local$range == null
        ? CopyWith$Input$DateTimeRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeRangeInput(local$range, (e) => call(range: e));
  }
}

class _CopyWithStubImpl$Input$DateTimeFilterInput<TRes>
    implements CopyWith$Input$DateTimeFilterInput<TRes> {
  _CopyWithStubImpl$Input$DateTimeFilterInput(this._res);

  TRes _res;

  call({
    String? eq,
    List<String>? oneOf,
    Input$DateTimeRangeInput? range,
  }) =>
      _res;

  CopyWith$Input$DateTimeRangeInput<TRes> get range =>
      CopyWith$Input$DateTimeRangeInput.stub(_res);
}

class Input$DateTimeRangeInput {
  factory Input$DateTimeRangeInput({
    String? gte,
    String? lte,
  }) =>
      Input$DateTimeRangeInput._({
        if (gte != null) r'gte': gte,
        if (lte != null) r'lte': lte,
      });

  Input$DateTimeRangeInput._(this._$data);

  factory Input$DateTimeRangeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    return Input$DateTimeRangeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get gte => (_$data['gte'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    return result$data;
  }

  CopyWith$Input$DateTimeRangeInput<Input$DateTimeRangeInput> get copyWith =>
      CopyWith$Input$DateTimeRangeInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DateTimeRangeInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$gte = gte;
    final l$lte = lte;
    return Object.hashAll([
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('lte') ? l$lte : const {},
    ]);
  }
}

abstract class CopyWith$Input$DateTimeRangeInput<TRes> {
  factory CopyWith$Input$DateTimeRangeInput(
    Input$DateTimeRangeInput instance,
    TRes Function(Input$DateTimeRangeInput) then,
  ) = _CopyWithImpl$Input$DateTimeRangeInput;

  factory CopyWith$Input$DateTimeRangeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DateTimeRangeInput;

  TRes call({
    String? gte,
    String? lte,
  });
}

class _CopyWithImpl$Input$DateTimeRangeInput<TRes>
    implements CopyWith$Input$DateTimeRangeInput<TRes> {
  _CopyWithImpl$Input$DateTimeRangeInput(
    this._instance,
    this._then,
  );

  final Input$DateTimeRangeInput _instance;

  final TRes Function(Input$DateTimeRangeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? gte = _undefined,
    Object? lte = _undefined,
  }) =>
      _then(Input$DateTimeRangeInput._({
        ..._instance._$data,
        if (gte != _undefined) 'gte': (gte as String?),
        if (lte != _undefined) 'lte': (lte as String?),
      }));
}

class _CopyWithStubImpl$Input$DateTimeRangeInput<TRes>
    implements CopyWith$Input$DateTimeRangeInput<TRes> {
  _CopyWithStubImpl$Input$DateTimeRangeInput(this._res);

  TRes _res;

  call({
    String? gte,
    String? lte,
  }) =>
      _res;
}

class Input$DecimalFilterInput {
  factory Input$DecimalFilterInput({
    String? eq,
    List<String>? oneOf,
    Input$DecimalRangeInput? range,
  }) =>
      Input$DecimalFilterInput._({
        if (eq != null) r'eq': eq,
        if (oneOf != null) r'oneOf': oneOf,
        if (range != null) r'range': range,
      });

  Input$DecimalFilterInput._(this._$data);

  factory Input$DecimalFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('oneOf')) {
      final l$oneOf = data['oneOf'];
      result$data['oneOf'] =
          (l$oneOf as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('range')) {
      final l$range = data['range'];
      result$data['range'] = l$range == null
          ? null
          : Input$DecimalRangeInput.fromJson((l$range as Map<String, dynamic>));
    }
    return Input$DecimalFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get eq => (_$data['eq'] as String?);

  List<String>? get oneOf => (_$data['oneOf'] as List<String>?);

  Input$DecimalRangeInput? get range =>
      (_$data['range'] as Input$DecimalRangeInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('oneOf')) {
      final l$oneOf = oneOf;
      result$data['oneOf'] = l$oneOf?.map((e) => e).toList();
    }
    if (_$data.containsKey('range')) {
      final l$range = range;
      result$data['range'] = l$range?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$DecimalFilterInput<Input$DecimalFilterInput> get copyWith =>
      CopyWith$Input$DecimalFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DecimalFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$oneOf = oneOf;
    final lOther$oneOf = other.oneOf;
    if (_$data.containsKey('oneOf') != other._$data.containsKey('oneOf')) {
      return false;
    }
    if (l$oneOf != null && lOther$oneOf != null) {
      if (l$oneOf.length != lOther$oneOf.length) {
        return false;
      }
      for (int i = 0; i < l$oneOf.length; i++) {
        final l$oneOf$entry = l$oneOf[i];
        final lOther$oneOf$entry = lOther$oneOf[i];
        if (l$oneOf$entry != lOther$oneOf$entry) {
          return false;
        }
      }
    } else if (l$oneOf != lOther$oneOf) {
      return false;
    }
    final l$range = range;
    final lOther$range = other.range;
    if (_$data.containsKey('range') != other._$data.containsKey('range')) {
      return false;
    }
    if (l$range != lOther$range) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$oneOf = oneOf;
    final l$range = range;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('oneOf')
          ? l$oneOf == null
              ? null
              : Object.hashAll(l$oneOf.map((v) => v))
          : const {},
      _$data.containsKey('range') ? l$range : const {},
    ]);
  }
}

abstract class CopyWith$Input$DecimalFilterInput<TRes> {
  factory CopyWith$Input$DecimalFilterInput(
    Input$DecimalFilterInput instance,
    TRes Function(Input$DecimalFilterInput) then,
  ) = _CopyWithImpl$Input$DecimalFilterInput;

  factory CopyWith$Input$DecimalFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DecimalFilterInput;

  TRes call({
    String? eq,
    List<String>? oneOf,
    Input$DecimalRangeInput? range,
  });
  CopyWith$Input$DecimalRangeInput<TRes> get range;
}

class _CopyWithImpl$Input$DecimalFilterInput<TRes>
    implements CopyWith$Input$DecimalFilterInput<TRes> {
  _CopyWithImpl$Input$DecimalFilterInput(
    this._instance,
    this._then,
  );

  final Input$DecimalFilterInput _instance;

  final TRes Function(Input$DecimalFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? oneOf = _undefined,
    Object? range = _undefined,
  }) =>
      _then(Input$DecimalFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as String?),
        if (oneOf != _undefined) 'oneOf': (oneOf as List<String>?),
        if (range != _undefined) 'range': (range as Input$DecimalRangeInput?),
      }));

  CopyWith$Input$DecimalRangeInput<TRes> get range {
    final local$range = _instance.range;
    return local$range == null
        ? CopyWith$Input$DecimalRangeInput.stub(_then(_instance))
        : CopyWith$Input$DecimalRangeInput(local$range, (e) => call(range: e));
  }
}

class _CopyWithStubImpl$Input$DecimalFilterInput<TRes>
    implements CopyWith$Input$DecimalFilterInput<TRes> {
  _CopyWithStubImpl$Input$DecimalFilterInput(this._res);

  TRes _res;

  call({
    String? eq,
    List<String>? oneOf,
    Input$DecimalRangeInput? range,
  }) =>
      _res;

  CopyWith$Input$DecimalRangeInput<TRes> get range =>
      CopyWith$Input$DecimalRangeInput.stub(_res);
}

class Input$DecimalRangeInput {
  factory Input$DecimalRangeInput({
    String? gte,
    String? lte,
  }) =>
      Input$DecimalRangeInput._({
        if (gte != null) r'gte': gte,
        if (lte != null) r'lte': lte,
      });

  Input$DecimalRangeInput._(this._$data);

  factory Input$DecimalRangeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    return Input$DecimalRangeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get gte => (_$data['gte'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    return result$data;
  }

  CopyWith$Input$DecimalRangeInput<Input$DecimalRangeInput> get copyWith =>
      CopyWith$Input$DecimalRangeInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DecimalRangeInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$gte = gte;
    final l$lte = lte;
    return Object.hashAll([
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('lte') ? l$lte : const {},
    ]);
  }
}

abstract class CopyWith$Input$DecimalRangeInput<TRes> {
  factory CopyWith$Input$DecimalRangeInput(
    Input$DecimalRangeInput instance,
    TRes Function(Input$DecimalRangeInput) then,
  ) = _CopyWithImpl$Input$DecimalRangeInput;

  factory CopyWith$Input$DecimalRangeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DecimalRangeInput;

  TRes call({
    String? gte,
    String? lte,
  });
}

class _CopyWithImpl$Input$DecimalRangeInput<TRes>
    implements CopyWith$Input$DecimalRangeInput<TRes> {
  _CopyWithImpl$Input$DecimalRangeInput(
    this._instance,
    this._then,
  );

  final Input$DecimalRangeInput _instance;

  final TRes Function(Input$DecimalRangeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? gte = _undefined,
    Object? lte = _undefined,
  }) =>
      _then(Input$DecimalRangeInput._({
        ..._instance._$data,
        if (gte != _undefined) 'gte': (gte as String?),
        if (lte != _undefined) 'lte': (lte as String?),
      }));
}

class _CopyWithStubImpl$Input$DecimalRangeInput<TRes>
    implements CopyWith$Input$DecimalRangeInput<TRes> {
  _CopyWithStubImpl$Input$DecimalRangeInput(this._res);

  TRes _res;

  call({
    String? gte,
    String? lte,
  }) =>
      _res;
}

class Input$DigitalContentInput {
  factory Input$DigitalContentInput({
    required bool useDefaultSettings,
    int? maxDownloads,
    int? urlValidDays,
    bool? automaticFulfillment,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  }) =>
      Input$DigitalContentInput._({
        r'useDefaultSettings': useDefaultSettings,
        if (maxDownloads != null) r'maxDownloads': maxDownloads,
        if (urlValidDays != null) r'urlValidDays': urlValidDays,
        if (automaticFulfillment != null)
          r'automaticFulfillment': automaticFulfillment,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
      });

  Input$DigitalContentInput._(this._$data);

  factory Input$DigitalContentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$useDefaultSettings = data['useDefaultSettings'];
    result$data['useDefaultSettings'] = (l$useDefaultSettings as bool);
    if (data.containsKey('maxDownloads')) {
      final l$maxDownloads = data['maxDownloads'];
      result$data['maxDownloads'] = (l$maxDownloads as int?);
    }
    if (data.containsKey('urlValidDays')) {
      final l$urlValidDays = data['urlValidDays'];
      result$data['urlValidDays'] = (l$urlValidDays as int?);
    }
    if (data.containsKey('automaticFulfillment')) {
      final l$automaticFulfillment = data['automaticFulfillment'];
      result$data['automaticFulfillment'] = (l$automaticFulfillment as bool?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$DigitalContentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool get useDefaultSettings => (_$data['useDefaultSettings'] as bool);

  int? get maxDownloads => (_$data['maxDownloads'] as int?);

  int? get urlValidDays => (_$data['urlValidDays'] as int?);

  bool? get automaticFulfillment => (_$data['automaticFulfillment'] as bool?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$useDefaultSettings = useDefaultSettings;
    result$data['useDefaultSettings'] = l$useDefaultSettings;
    if (_$data.containsKey('maxDownloads')) {
      final l$maxDownloads = maxDownloads;
      result$data['maxDownloads'] = l$maxDownloads;
    }
    if (_$data.containsKey('urlValidDays')) {
      final l$urlValidDays = urlValidDays;
      result$data['urlValidDays'] = l$urlValidDays;
    }
    if (_$data.containsKey('automaticFulfillment')) {
      final l$automaticFulfillment = automaticFulfillment;
      result$data['automaticFulfillment'] = l$automaticFulfillment;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$DigitalContentInput<Input$DigitalContentInput> get copyWith =>
      CopyWith$Input$DigitalContentInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DigitalContentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$useDefaultSettings = useDefaultSettings;
    final lOther$useDefaultSettings = other.useDefaultSettings;
    if (l$useDefaultSettings != lOther$useDefaultSettings) {
      return false;
    }
    final l$maxDownloads = maxDownloads;
    final lOther$maxDownloads = other.maxDownloads;
    if (_$data.containsKey('maxDownloads') !=
        other._$data.containsKey('maxDownloads')) {
      return false;
    }
    if (l$maxDownloads != lOther$maxDownloads) {
      return false;
    }
    final l$urlValidDays = urlValidDays;
    final lOther$urlValidDays = other.urlValidDays;
    if (_$data.containsKey('urlValidDays') !=
        other._$data.containsKey('urlValidDays')) {
      return false;
    }
    if (l$urlValidDays != lOther$urlValidDays) {
      return false;
    }
    final l$automaticFulfillment = automaticFulfillment;
    final lOther$automaticFulfillment = other.automaticFulfillment;
    if (_$data.containsKey('automaticFulfillment') !=
        other._$data.containsKey('automaticFulfillment')) {
      return false;
    }
    if (l$automaticFulfillment != lOther$automaticFulfillment) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$useDefaultSettings = useDefaultSettings;
    final l$maxDownloads = maxDownloads;
    final l$urlValidDays = urlValidDays;
    final l$automaticFulfillment = automaticFulfillment;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    return Object.hashAll([
      l$useDefaultSettings,
      _$data.containsKey('maxDownloads') ? l$maxDownloads : const {},
      _$data.containsKey('urlValidDays') ? l$urlValidDays : const {},
      _$data.containsKey('automaticFulfillment')
          ? l$automaticFulfillment
          : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$DigitalContentInput<TRes> {
  factory CopyWith$Input$DigitalContentInput(
    Input$DigitalContentInput instance,
    TRes Function(Input$DigitalContentInput) then,
  ) = _CopyWithImpl$Input$DigitalContentInput;

  factory CopyWith$Input$DigitalContentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DigitalContentInput;

  TRes call({
    bool? useDefaultSettings,
    int? maxDownloads,
    int? urlValidDays,
    bool? automaticFulfillment,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  });
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$DigitalContentInput<TRes>
    implements CopyWith$Input$DigitalContentInput<TRes> {
  _CopyWithImpl$Input$DigitalContentInput(
    this._instance,
    this._then,
  );

  final Input$DigitalContentInput _instance;

  final TRes Function(Input$DigitalContentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? useDefaultSettings = _undefined,
    Object? maxDownloads = _undefined,
    Object? urlValidDays = _undefined,
    Object? automaticFulfillment = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
  }) =>
      _then(Input$DigitalContentInput._({
        ..._instance._$data,
        if (useDefaultSettings != _undefined && useDefaultSettings != null)
          'useDefaultSettings': (useDefaultSettings as bool),
        if (maxDownloads != _undefined) 'maxDownloads': (maxDownloads as int?),
        if (urlValidDays != _undefined) 'urlValidDays': (urlValidDays as int?),
        if (automaticFulfillment != _undefined)
          'automaticFulfillment': (automaticFulfillment as bool?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$DigitalContentInput<TRes>
    implements CopyWith$Input$DigitalContentInput<TRes> {
  _CopyWithStubImpl$Input$DigitalContentInput(this._res);

  TRes _res;

  call({
    bool? useDefaultSettings,
    int? maxDownloads,
    int? urlValidDays,
    bool? automaticFulfillment,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  }) =>
      _res;

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$DigitalContentUploadInput {
  factory Input$DigitalContentUploadInput({
    required bool useDefaultSettings,
    int? maxDownloads,
    int? urlValidDays,
    bool? automaticFulfillment,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    required String contentFile,
  }) =>
      Input$DigitalContentUploadInput._({
        r'useDefaultSettings': useDefaultSettings,
        if (maxDownloads != null) r'maxDownloads': maxDownloads,
        if (urlValidDays != null) r'urlValidDays': urlValidDays,
        if (automaticFulfillment != null)
          r'automaticFulfillment': automaticFulfillment,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        r'contentFile': contentFile,
      });

  Input$DigitalContentUploadInput._(this._$data);

  factory Input$DigitalContentUploadInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$useDefaultSettings = data['useDefaultSettings'];
    result$data['useDefaultSettings'] = (l$useDefaultSettings as bool);
    if (data.containsKey('maxDownloads')) {
      final l$maxDownloads = data['maxDownloads'];
      result$data['maxDownloads'] = (l$maxDownloads as int?);
    }
    if (data.containsKey('urlValidDays')) {
      final l$urlValidDays = data['urlValidDays'];
      result$data['urlValidDays'] = (l$urlValidDays as int?);
    }
    if (data.containsKey('automaticFulfillment')) {
      final l$automaticFulfillment = data['automaticFulfillment'];
      result$data['automaticFulfillment'] = (l$automaticFulfillment as bool?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    final l$contentFile = data['contentFile'];
    result$data['contentFile'] = (l$contentFile as String);
    return Input$DigitalContentUploadInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool get useDefaultSettings => (_$data['useDefaultSettings'] as bool);

  int? get maxDownloads => (_$data['maxDownloads'] as int?);

  int? get urlValidDays => (_$data['urlValidDays'] as int?);

  bool? get automaticFulfillment => (_$data['automaticFulfillment'] as bool?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  String get contentFile => (_$data['contentFile'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$useDefaultSettings = useDefaultSettings;
    result$data['useDefaultSettings'] = l$useDefaultSettings;
    if (_$data.containsKey('maxDownloads')) {
      final l$maxDownloads = maxDownloads;
      result$data['maxDownloads'] = l$maxDownloads;
    }
    if (_$data.containsKey('urlValidDays')) {
      final l$urlValidDays = urlValidDays;
      result$data['urlValidDays'] = l$urlValidDays;
    }
    if (_$data.containsKey('automaticFulfillment')) {
      final l$automaticFulfillment = automaticFulfillment;
      result$data['automaticFulfillment'] = l$automaticFulfillment;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    final l$contentFile = contentFile;
    result$data['contentFile'] = l$contentFile;
    return result$data;
  }

  CopyWith$Input$DigitalContentUploadInput<Input$DigitalContentUploadInput>
      get copyWith => CopyWith$Input$DigitalContentUploadInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DigitalContentUploadInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$useDefaultSettings = useDefaultSettings;
    final lOther$useDefaultSettings = other.useDefaultSettings;
    if (l$useDefaultSettings != lOther$useDefaultSettings) {
      return false;
    }
    final l$maxDownloads = maxDownloads;
    final lOther$maxDownloads = other.maxDownloads;
    if (_$data.containsKey('maxDownloads') !=
        other._$data.containsKey('maxDownloads')) {
      return false;
    }
    if (l$maxDownloads != lOther$maxDownloads) {
      return false;
    }
    final l$urlValidDays = urlValidDays;
    final lOther$urlValidDays = other.urlValidDays;
    if (_$data.containsKey('urlValidDays') !=
        other._$data.containsKey('urlValidDays')) {
      return false;
    }
    if (l$urlValidDays != lOther$urlValidDays) {
      return false;
    }
    final l$automaticFulfillment = automaticFulfillment;
    final lOther$automaticFulfillment = other.automaticFulfillment;
    if (_$data.containsKey('automaticFulfillment') !=
        other._$data.containsKey('automaticFulfillment')) {
      return false;
    }
    if (l$automaticFulfillment != lOther$automaticFulfillment) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$contentFile = contentFile;
    final lOther$contentFile = other.contentFile;
    if (l$contentFile != lOther$contentFile) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$useDefaultSettings = useDefaultSettings;
    final l$maxDownloads = maxDownloads;
    final l$urlValidDays = urlValidDays;
    final l$automaticFulfillment = automaticFulfillment;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$contentFile = contentFile;
    return Object.hashAll([
      l$useDefaultSettings,
      _$data.containsKey('maxDownloads') ? l$maxDownloads : const {},
      _$data.containsKey('urlValidDays') ? l$urlValidDays : const {},
      _$data.containsKey('automaticFulfillment')
          ? l$automaticFulfillment
          : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      l$contentFile,
    ]);
  }
}

abstract class CopyWith$Input$DigitalContentUploadInput<TRes> {
  factory CopyWith$Input$DigitalContentUploadInput(
    Input$DigitalContentUploadInput instance,
    TRes Function(Input$DigitalContentUploadInput) then,
  ) = _CopyWithImpl$Input$DigitalContentUploadInput;

  factory CopyWith$Input$DigitalContentUploadInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DigitalContentUploadInput;

  TRes call({
    bool? useDefaultSettings,
    int? maxDownloads,
    int? urlValidDays,
    bool? automaticFulfillment,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? contentFile,
  });
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$DigitalContentUploadInput<TRes>
    implements CopyWith$Input$DigitalContentUploadInput<TRes> {
  _CopyWithImpl$Input$DigitalContentUploadInput(
    this._instance,
    this._then,
  );

  final Input$DigitalContentUploadInput _instance;

  final TRes Function(Input$DigitalContentUploadInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? useDefaultSettings = _undefined,
    Object? maxDownloads = _undefined,
    Object? urlValidDays = _undefined,
    Object? automaticFulfillment = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? contentFile = _undefined,
  }) =>
      _then(Input$DigitalContentUploadInput._({
        ..._instance._$data,
        if (useDefaultSettings != _undefined && useDefaultSettings != null)
          'useDefaultSettings': (useDefaultSettings as bool),
        if (maxDownloads != _undefined) 'maxDownloads': (maxDownloads as int?),
        if (urlValidDays != _undefined) 'urlValidDays': (urlValidDays as int?),
        if (automaticFulfillment != _undefined)
          'automaticFulfillment': (automaticFulfillment as bool?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (contentFile != _undefined && contentFile != null)
          'contentFile': (contentFile as String),
      }));

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$DigitalContentUploadInput<TRes>
    implements CopyWith$Input$DigitalContentUploadInput<TRes> {
  _CopyWithStubImpl$Input$DigitalContentUploadInput(this._res);

  TRes _res;

  call({
    bool? useDefaultSettings,
    int? maxDownloads,
    int? urlValidDays,
    bool? automaticFulfillment,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? contentFile,
  }) =>
      _res;

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$DigitalContentUrlCreateInput {
  factory Input$DigitalContentUrlCreateInput({required String content}) =>
      Input$DigitalContentUrlCreateInput._({
        r'content': content,
      });

  Input$DigitalContentUrlCreateInput._(this._$data);

  factory Input$DigitalContentUrlCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$content = data['content'];
    result$data['content'] = (l$content as String);
    return Input$DigitalContentUrlCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get content => (_$data['content'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$content = content;
    result$data['content'] = l$content;
    return result$data;
  }

  CopyWith$Input$DigitalContentUrlCreateInput<
          Input$DigitalContentUrlCreateInput>
      get copyWith => CopyWith$Input$DigitalContentUrlCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DigitalContentUrlCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$content = content;
    return Object.hashAll([l$content]);
  }
}

abstract class CopyWith$Input$DigitalContentUrlCreateInput<TRes> {
  factory CopyWith$Input$DigitalContentUrlCreateInput(
    Input$DigitalContentUrlCreateInput instance,
    TRes Function(Input$DigitalContentUrlCreateInput) then,
  ) = _CopyWithImpl$Input$DigitalContentUrlCreateInput;

  factory CopyWith$Input$DigitalContentUrlCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DigitalContentUrlCreateInput;

  TRes call({String? content});
}

class _CopyWithImpl$Input$DigitalContentUrlCreateInput<TRes>
    implements CopyWith$Input$DigitalContentUrlCreateInput<TRes> {
  _CopyWithImpl$Input$DigitalContentUrlCreateInput(
    this._instance,
    this._then,
  );

  final Input$DigitalContentUrlCreateInput _instance;

  final TRes Function(Input$DigitalContentUrlCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? content = _undefined}) =>
      _then(Input$DigitalContentUrlCreateInput._({
        ..._instance._$data,
        if (content != _undefined && content != null)
          'content': (content as String),
      }));
}

class _CopyWithStubImpl$Input$DigitalContentUrlCreateInput<TRes>
    implements CopyWith$Input$DigitalContentUrlCreateInput<TRes> {
  _CopyWithStubImpl$Input$DigitalContentUrlCreateInput(this._res);

  TRes _res;

  call({String? content}) => _res;
}

class Input$DiscountedObjectWhereInput {
  factory Input$DiscountedObjectWhereInput({
    Input$DecimalFilterInput? baseSubtotalPrice,
    Input$DecimalFilterInput? baseTotalPrice,
    List<Input$DiscountedObjectWhereInput>? AND,
    List<Input$DiscountedObjectWhereInput>? OR,
  }) =>
      Input$DiscountedObjectWhereInput._({
        if (baseSubtotalPrice != null) r'baseSubtotalPrice': baseSubtotalPrice,
        if (baseTotalPrice != null) r'baseTotalPrice': baseTotalPrice,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
      });

  Input$DiscountedObjectWhereInput._(this._$data);

  factory Input$DiscountedObjectWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('baseSubtotalPrice')) {
      final l$baseSubtotalPrice = data['baseSubtotalPrice'];
      result$data['baseSubtotalPrice'] = l$baseSubtotalPrice == null
          ? null
          : Input$DecimalFilterInput.fromJson(
              (l$baseSubtotalPrice as Map<String, dynamic>));
    }
    if (data.containsKey('baseTotalPrice')) {
      final l$baseTotalPrice = data['baseTotalPrice'];
      result$data['baseTotalPrice'] = l$baseTotalPrice == null
          ? null
          : Input$DecimalFilterInput.fromJson(
              (l$baseTotalPrice as Map<String, dynamic>));
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$DiscountedObjectWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$DiscountedObjectWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$DiscountedObjectWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$DecimalFilterInput? get baseSubtotalPrice =>
      (_$data['baseSubtotalPrice'] as Input$DecimalFilterInput?);

  Input$DecimalFilterInput? get baseTotalPrice =>
      (_$data['baseTotalPrice'] as Input$DecimalFilterInput?);

  List<Input$DiscountedObjectWhereInput>? get AND =>
      (_$data['AND'] as List<Input$DiscountedObjectWhereInput>?);

  List<Input$DiscountedObjectWhereInput>? get OR =>
      (_$data['OR'] as List<Input$DiscountedObjectWhereInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('baseSubtotalPrice')) {
      final l$baseSubtotalPrice = baseSubtotalPrice;
      result$data['baseSubtotalPrice'] = l$baseSubtotalPrice?.toJson();
    }
    if (_$data.containsKey('baseTotalPrice')) {
      final l$baseTotalPrice = baseTotalPrice;
      result$data['baseTotalPrice'] = l$baseTotalPrice?.toJson();
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$DiscountedObjectWhereInput<Input$DiscountedObjectWhereInput>
      get copyWith => CopyWith$Input$DiscountedObjectWhereInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DiscountedObjectWhereInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$baseSubtotalPrice = baseSubtotalPrice;
    final lOther$baseSubtotalPrice = other.baseSubtotalPrice;
    if (_$data.containsKey('baseSubtotalPrice') !=
        other._$data.containsKey('baseSubtotalPrice')) {
      return false;
    }
    if (l$baseSubtotalPrice != lOther$baseSubtotalPrice) {
      return false;
    }
    final l$baseTotalPrice = baseTotalPrice;
    final lOther$baseTotalPrice = other.baseTotalPrice;
    if (_$data.containsKey('baseTotalPrice') !=
        other._$data.containsKey('baseTotalPrice')) {
      return false;
    }
    if (l$baseTotalPrice != lOther$baseTotalPrice) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$baseSubtotalPrice = baseSubtotalPrice;
    final l$baseTotalPrice = baseTotalPrice;
    final l$AND = AND;
    final l$OR = OR;
    return Object.hashAll([
      _$data.containsKey('baseSubtotalPrice') ? l$baseSubtotalPrice : const {},
      _$data.containsKey('baseTotalPrice') ? l$baseTotalPrice : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$DiscountedObjectWhereInput<TRes> {
  factory CopyWith$Input$DiscountedObjectWhereInput(
    Input$DiscountedObjectWhereInput instance,
    TRes Function(Input$DiscountedObjectWhereInput) then,
  ) = _CopyWithImpl$Input$DiscountedObjectWhereInput;

  factory CopyWith$Input$DiscountedObjectWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DiscountedObjectWhereInput;

  TRes call({
    Input$DecimalFilterInput? baseSubtotalPrice,
    Input$DecimalFilterInput? baseTotalPrice,
    List<Input$DiscountedObjectWhereInput>? AND,
    List<Input$DiscountedObjectWhereInput>? OR,
  });
  CopyWith$Input$DecimalFilterInput<TRes> get baseSubtotalPrice;
  CopyWith$Input$DecimalFilterInput<TRes> get baseTotalPrice;
  TRes AND(
      Iterable<Input$DiscountedObjectWhereInput>? Function(
              Iterable<
                  CopyWith$Input$DiscountedObjectWhereInput<
                      Input$DiscountedObjectWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$DiscountedObjectWhereInput>? Function(
              Iterable<
                  CopyWith$Input$DiscountedObjectWhereInput<
                      Input$DiscountedObjectWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$DiscountedObjectWhereInput<TRes>
    implements CopyWith$Input$DiscountedObjectWhereInput<TRes> {
  _CopyWithImpl$Input$DiscountedObjectWhereInput(
    this._instance,
    this._then,
  );

  final Input$DiscountedObjectWhereInput _instance;

  final TRes Function(Input$DiscountedObjectWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? baseSubtotalPrice = _undefined,
    Object? baseTotalPrice = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
  }) =>
      _then(Input$DiscountedObjectWhereInput._({
        ..._instance._$data,
        if (baseSubtotalPrice != _undefined)
          'baseSubtotalPrice': (baseSubtotalPrice as Input$DecimalFilterInput?),
        if (baseTotalPrice != _undefined)
          'baseTotalPrice': (baseTotalPrice as Input$DecimalFilterInput?),
        if (AND != _undefined)
          'AND': (AND as List<Input$DiscountedObjectWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$DiscountedObjectWhereInput>?),
      }));

  CopyWith$Input$DecimalFilterInput<TRes> get baseSubtotalPrice {
    final local$baseSubtotalPrice = _instance.baseSubtotalPrice;
    return local$baseSubtotalPrice == null
        ? CopyWith$Input$DecimalFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalFilterInput(
            local$baseSubtotalPrice, (e) => call(baseSubtotalPrice: e));
  }

  CopyWith$Input$DecimalFilterInput<TRes> get baseTotalPrice {
    final local$baseTotalPrice = _instance.baseTotalPrice;
    return local$baseTotalPrice == null
        ? CopyWith$Input$DecimalFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalFilterInput(
            local$baseTotalPrice, (e) => call(baseTotalPrice: e));
  }

  TRes AND(
          Iterable<Input$DiscountedObjectWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$DiscountedObjectWhereInput<
                          Input$DiscountedObjectWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$DiscountedObjectWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes OR(
          Iterable<Input$DiscountedObjectWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$DiscountedObjectWhereInput<
                          Input$DiscountedObjectWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR
              ?.map((e) => CopyWith$Input$DiscountedObjectWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$DiscountedObjectWhereInput<TRes>
    implements CopyWith$Input$DiscountedObjectWhereInput<TRes> {
  _CopyWithStubImpl$Input$DiscountedObjectWhereInput(this._res);

  TRes _res;

  call({
    Input$DecimalFilterInput? baseSubtotalPrice,
    Input$DecimalFilterInput? baseTotalPrice,
    List<Input$DiscountedObjectWhereInput>? AND,
    List<Input$DiscountedObjectWhereInput>? OR,
  }) =>
      _res;

  CopyWith$Input$DecimalFilterInput<TRes> get baseSubtotalPrice =>
      CopyWith$Input$DecimalFilterInput.stub(_res);

  CopyWith$Input$DecimalFilterInput<TRes> get baseTotalPrice =>
      CopyWith$Input$DecimalFilterInput.stub(_res);

  AND(_fn) => _res;

  OR(_fn) => _res;
}

class Input$DraftOrderCreateInput {
  factory Input$DraftOrderCreateInput({
    Input$AddressInput? billingAddress,
    bool? saveBillingAddress,
    String? user,
    String? userEmail,
    String? discount,
    Input$AddressInput? shippingAddress,
    bool? saveShippingAddress,
    String? shippingMethod,
    String? voucher,
    String? voucherCode,
    String? customerNote,
    String? channelId,
    String? redirectUrl,
    String? externalReference,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Enum$LanguageCodeEnum? languageCode,
    List<Input$OrderLineCreateInput>? lines,
  }) =>
      Input$DraftOrderCreateInput._({
        if (billingAddress != null) r'billingAddress': billingAddress,
        if (saveBillingAddress != null)
          r'saveBillingAddress': saveBillingAddress,
        if (user != null) r'user': user,
        if (userEmail != null) r'userEmail': userEmail,
        if (discount != null) r'discount': discount,
        if (shippingAddress != null) r'shippingAddress': shippingAddress,
        if (saveShippingAddress != null)
          r'saveShippingAddress': saveShippingAddress,
        if (shippingMethod != null) r'shippingMethod': shippingMethod,
        if (voucher != null) r'voucher': voucher,
        if (voucherCode != null) r'voucherCode': voucherCode,
        if (customerNote != null) r'customerNote': customerNote,
        if (channelId != null) r'channelId': channelId,
        if (redirectUrl != null) r'redirectUrl': redirectUrl,
        if (externalReference != null) r'externalReference': externalReference,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (languageCode != null) r'languageCode': languageCode,
        if (lines != null) r'lines': lines,
      });

  Input$DraftOrderCreateInput._(this._$data);

  factory Input$DraftOrderCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('billingAddress')) {
      final l$billingAddress = data['billingAddress'];
      result$data['billingAddress'] = l$billingAddress == null
          ? null
          : Input$AddressInput.fromJson(
              (l$billingAddress as Map<String, dynamic>));
    }
    if (data.containsKey('saveBillingAddress')) {
      final l$saveBillingAddress = data['saveBillingAddress'];
      result$data['saveBillingAddress'] = (l$saveBillingAddress as bool?);
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = (l$user as String?);
    }
    if (data.containsKey('userEmail')) {
      final l$userEmail = data['userEmail'];
      result$data['userEmail'] = (l$userEmail as String?);
    }
    if (data.containsKey('discount')) {
      final l$discount = data['discount'];
      result$data['discount'] = (l$discount as String?);
    }
    if (data.containsKey('shippingAddress')) {
      final l$shippingAddress = data['shippingAddress'];
      result$data['shippingAddress'] = l$shippingAddress == null
          ? null
          : Input$AddressInput.fromJson(
              (l$shippingAddress as Map<String, dynamic>));
    }
    if (data.containsKey('saveShippingAddress')) {
      final l$saveShippingAddress = data['saveShippingAddress'];
      result$data['saveShippingAddress'] = (l$saveShippingAddress as bool?);
    }
    if (data.containsKey('shippingMethod')) {
      final l$shippingMethod = data['shippingMethod'];
      result$data['shippingMethod'] = (l$shippingMethod as String?);
    }
    if (data.containsKey('voucher')) {
      final l$voucher = data['voucher'];
      result$data['voucher'] = (l$voucher as String?);
    }
    if (data.containsKey('voucherCode')) {
      final l$voucherCode = data['voucherCode'];
      result$data['voucherCode'] = (l$voucherCode as String?);
    }
    if (data.containsKey('customerNote')) {
      final l$customerNote = data['customerNote'];
      result$data['customerNote'] = (l$customerNote as String?);
    }
    if (data.containsKey('channelId')) {
      final l$channelId = data['channelId'];
      result$data['channelId'] = (l$channelId as String?);
    }
    if (data.containsKey('redirectUrl')) {
      final l$redirectUrl = data['redirectUrl'];
      result$data['redirectUrl'] = (l$redirectUrl as String?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('languageCode')) {
      final l$languageCode = data['languageCode'];
      result$data['languageCode'] = l$languageCode == null
          ? null
          : fromJson$Enum$LanguageCodeEnum((l$languageCode as String));
    }
    if (data.containsKey('lines')) {
      final l$lines = data['lines'];
      result$data['lines'] = (l$lines as List<dynamic>?)
          ?.map((e) =>
              Input$OrderLineCreateInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$DraftOrderCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$AddressInput? get billingAddress =>
      (_$data['billingAddress'] as Input$AddressInput?);

  bool? get saveBillingAddress => (_$data['saveBillingAddress'] as bool?);

  String? get user => (_$data['user'] as String?);

  String? get userEmail => (_$data['userEmail'] as String?);

  String? get discount => (_$data['discount'] as String?);

  Input$AddressInput? get shippingAddress =>
      (_$data['shippingAddress'] as Input$AddressInput?);

  bool? get saveShippingAddress => (_$data['saveShippingAddress'] as bool?);

  String? get shippingMethod => (_$data['shippingMethod'] as String?);

  String? get voucher => (_$data['voucher'] as String?);

  String? get voucherCode => (_$data['voucherCode'] as String?);

  String? get customerNote => (_$data['customerNote'] as String?);

  String? get channelId => (_$data['channelId'] as String?);

  String? get redirectUrl => (_$data['redirectUrl'] as String?);

  String? get externalReference => (_$data['externalReference'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  Enum$LanguageCodeEnum? get languageCode =>
      (_$data['languageCode'] as Enum$LanguageCodeEnum?);

  List<Input$OrderLineCreateInput>? get lines =>
      (_$data['lines'] as List<Input$OrderLineCreateInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('billingAddress')) {
      final l$billingAddress = billingAddress;
      result$data['billingAddress'] = l$billingAddress?.toJson();
    }
    if (_$data.containsKey('saveBillingAddress')) {
      final l$saveBillingAddress = saveBillingAddress;
      result$data['saveBillingAddress'] = l$saveBillingAddress;
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user;
    }
    if (_$data.containsKey('userEmail')) {
      final l$userEmail = userEmail;
      result$data['userEmail'] = l$userEmail;
    }
    if (_$data.containsKey('discount')) {
      final l$discount = discount;
      result$data['discount'] = l$discount;
    }
    if (_$data.containsKey('shippingAddress')) {
      final l$shippingAddress = shippingAddress;
      result$data['shippingAddress'] = l$shippingAddress?.toJson();
    }
    if (_$data.containsKey('saveShippingAddress')) {
      final l$saveShippingAddress = saveShippingAddress;
      result$data['saveShippingAddress'] = l$saveShippingAddress;
    }
    if (_$data.containsKey('shippingMethod')) {
      final l$shippingMethod = shippingMethod;
      result$data['shippingMethod'] = l$shippingMethod;
    }
    if (_$data.containsKey('voucher')) {
      final l$voucher = voucher;
      result$data['voucher'] = l$voucher;
    }
    if (_$data.containsKey('voucherCode')) {
      final l$voucherCode = voucherCode;
      result$data['voucherCode'] = l$voucherCode;
    }
    if (_$data.containsKey('customerNote')) {
      final l$customerNote = customerNote;
      result$data['customerNote'] = l$customerNote;
    }
    if (_$data.containsKey('channelId')) {
      final l$channelId = channelId;
      result$data['channelId'] = l$channelId;
    }
    if (_$data.containsKey('redirectUrl')) {
      final l$redirectUrl = redirectUrl;
      result$data['redirectUrl'] = l$redirectUrl;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('languageCode')) {
      final l$languageCode = languageCode;
      result$data['languageCode'] = l$languageCode == null
          ? null
          : toJson$Enum$LanguageCodeEnum(l$languageCode);
    }
    if (_$data.containsKey('lines')) {
      final l$lines = lines;
      result$data['lines'] = l$lines?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$DraftOrderCreateInput<Input$DraftOrderCreateInput>
      get copyWith => CopyWith$Input$DraftOrderCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DraftOrderCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$billingAddress = billingAddress;
    final lOther$billingAddress = other.billingAddress;
    if (_$data.containsKey('billingAddress') !=
        other._$data.containsKey('billingAddress')) {
      return false;
    }
    if (l$billingAddress != lOther$billingAddress) {
      return false;
    }
    final l$saveBillingAddress = saveBillingAddress;
    final lOther$saveBillingAddress = other.saveBillingAddress;
    if (_$data.containsKey('saveBillingAddress') !=
        other._$data.containsKey('saveBillingAddress')) {
      return false;
    }
    if (l$saveBillingAddress != lOther$saveBillingAddress) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$userEmail = userEmail;
    final lOther$userEmail = other.userEmail;
    if (_$data.containsKey('userEmail') !=
        other._$data.containsKey('userEmail')) {
      return false;
    }
    if (l$userEmail != lOther$userEmail) {
      return false;
    }
    final l$discount = discount;
    final lOther$discount = other.discount;
    if (_$data.containsKey('discount') !=
        other._$data.containsKey('discount')) {
      return false;
    }
    if (l$discount != lOther$discount) {
      return false;
    }
    final l$shippingAddress = shippingAddress;
    final lOther$shippingAddress = other.shippingAddress;
    if (_$data.containsKey('shippingAddress') !=
        other._$data.containsKey('shippingAddress')) {
      return false;
    }
    if (l$shippingAddress != lOther$shippingAddress) {
      return false;
    }
    final l$saveShippingAddress = saveShippingAddress;
    final lOther$saveShippingAddress = other.saveShippingAddress;
    if (_$data.containsKey('saveShippingAddress') !=
        other._$data.containsKey('saveShippingAddress')) {
      return false;
    }
    if (l$saveShippingAddress != lOther$saveShippingAddress) {
      return false;
    }
    final l$shippingMethod = shippingMethod;
    final lOther$shippingMethod = other.shippingMethod;
    if (_$data.containsKey('shippingMethod') !=
        other._$data.containsKey('shippingMethod')) {
      return false;
    }
    if (l$shippingMethod != lOther$shippingMethod) {
      return false;
    }
    final l$voucher = voucher;
    final lOther$voucher = other.voucher;
    if (_$data.containsKey('voucher') != other._$data.containsKey('voucher')) {
      return false;
    }
    if (l$voucher != lOther$voucher) {
      return false;
    }
    final l$voucherCode = voucherCode;
    final lOther$voucherCode = other.voucherCode;
    if (_$data.containsKey('voucherCode') !=
        other._$data.containsKey('voucherCode')) {
      return false;
    }
    if (l$voucherCode != lOther$voucherCode) {
      return false;
    }
    final l$customerNote = customerNote;
    final lOther$customerNote = other.customerNote;
    if (_$data.containsKey('customerNote') !=
        other._$data.containsKey('customerNote')) {
      return false;
    }
    if (l$customerNote != lOther$customerNote) {
      return false;
    }
    final l$channelId = channelId;
    final lOther$channelId = other.channelId;
    if (_$data.containsKey('channelId') !=
        other._$data.containsKey('channelId')) {
      return false;
    }
    if (l$channelId != lOther$channelId) {
      return false;
    }
    final l$redirectUrl = redirectUrl;
    final lOther$redirectUrl = other.redirectUrl;
    if (_$data.containsKey('redirectUrl') !=
        other._$data.containsKey('redirectUrl')) {
      return false;
    }
    if (l$redirectUrl != lOther$redirectUrl) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$languageCode = languageCode;
    final lOther$languageCode = other.languageCode;
    if (_$data.containsKey('languageCode') !=
        other._$data.containsKey('languageCode')) {
      return false;
    }
    if (l$languageCode != lOther$languageCode) {
      return false;
    }
    final l$lines = lines;
    final lOther$lines = other.lines;
    if (_$data.containsKey('lines') != other._$data.containsKey('lines')) {
      return false;
    }
    if (l$lines != null && lOther$lines != null) {
      if (l$lines.length != lOther$lines.length) {
        return false;
      }
      for (int i = 0; i < l$lines.length; i++) {
        final l$lines$entry = l$lines[i];
        final lOther$lines$entry = lOther$lines[i];
        if (l$lines$entry != lOther$lines$entry) {
          return false;
        }
      }
    } else if (l$lines != lOther$lines) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$billingAddress = billingAddress;
    final l$saveBillingAddress = saveBillingAddress;
    final l$user = user;
    final l$userEmail = userEmail;
    final l$discount = discount;
    final l$shippingAddress = shippingAddress;
    final l$saveShippingAddress = saveShippingAddress;
    final l$shippingMethod = shippingMethod;
    final l$voucher = voucher;
    final l$voucherCode = voucherCode;
    final l$customerNote = customerNote;
    final l$channelId = channelId;
    final l$redirectUrl = redirectUrl;
    final l$externalReference = externalReference;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$languageCode = languageCode;
    final l$lines = lines;
    return Object.hashAll([
      _$data.containsKey('billingAddress') ? l$billingAddress : const {},
      _$data.containsKey('saveBillingAddress')
          ? l$saveBillingAddress
          : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('userEmail') ? l$userEmail : const {},
      _$data.containsKey('discount') ? l$discount : const {},
      _$data.containsKey('shippingAddress') ? l$shippingAddress : const {},
      _$data.containsKey('saveShippingAddress')
          ? l$saveShippingAddress
          : const {},
      _$data.containsKey('shippingMethod') ? l$shippingMethod : const {},
      _$data.containsKey('voucher') ? l$voucher : const {},
      _$data.containsKey('voucherCode') ? l$voucherCode : const {},
      _$data.containsKey('customerNote') ? l$customerNote : const {},
      _$data.containsKey('channelId') ? l$channelId : const {},
      _$data.containsKey('redirectUrl') ? l$redirectUrl : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('languageCode') ? l$languageCode : const {},
      _$data.containsKey('lines')
          ? l$lines == null
              ? null
              : Object.hashAll(l$lines.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$DraftOrderCreateInput<TRes> {
  factory CopyWith$Input$DraftOrderCreateInput(
    Input$DraftOrderCreateInput instance,
    TRes Function(Input$DraftOrderCreateInput) then,
  ) = _CopyWithImpl$Input$DraftOrderCreateInput;

  factory CopyWith$Input$DraftOrderCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DraftOrderCreateInput;

  TRes call({
    Input$AddressInput? billingAddress,
    bool? saveBillingAddress,
    String? user,
    String? userEmail,
    String? discount,
    Input$AddressInput? shippingAddress,
    bool? saveShippingAddress,
    String? shippingMethod,
    String? voucher,
    String? voucherCode,
    String? customerNote,
    String? channelId,
    String? redirectUrl,
    String? externalReference,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Enum$LanguageCodeEnum? languageCode,
    List<Input$OrderLineCreateInput>? lines,
  });
  CopyWith$Input$AddressInput<TRes> get billingAddress;
  CopyWith$Input$AddressInput<TRes> get shippingAddress;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes lines(
      Iterable<Input$OrderLineCreateInput>? Function(
              Iterable<
                  CopyWith$Input$OrderLineCreateInput<
                      Input$OrderLineCreateInput>>?)
          _fn);
}

class _CopyWithImpl$Input$DraftOrderCreateInput<TRes>
    implements CopyWith$Input$DraftOrderCreateInput<TRes> {
  _CopyWithImpl$Input$DraftOrderCreateInput(
    this._instance,
    this._then,
  );

  final Input$DraftOrderCreateInput _instance;

  final TRes Function(Input$DraftOrderCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? billingAddress = _undefined,
    Object? saveBillingAddress = _undefined,
    Object? user = _undefined,
    Object? userEmail = _undefined,
    Object? discount = _undefined,
    Object? shippingAddress = _undefined,
    Object? saveShippingAddress = _undefined,
    Object? shippingMethod = _undefined,
    Object? voucher = _undefined,
    Object? voucherCode = _undefined,
    Object? customerNote = _undefined,
    Object? channelId = _undefined,
    Object? redirectUrl = _undefined,
    Object? externalReference = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? languageCode = _undefined,
    Object? lines = _undefined,
  }) =>
      _then(Input$DraftOrderCreateInput._({
        ..._instance._$data,
        if (billingAddress != _undefined)
          'billingAddress': (billingAddress as Input$AddressInput?),
        if (saveBillingAddress != _undefined)
          'saveBillingAddress': (saveBillingAddress as bool?),
        if (user != _undefined) 'user': (user as String?),
        if (userEmail != _undefined) 'userEmail': (userEmail as String?),
        if (discount != _undefined) 'discount': (discount as String?),
        if (shippingAddress != _undefined)
          'shippingAddress': (shippingAddress as Input$AddressInput?),
        if (saveShippingAddress != _undefined)
          'saveShippingAddress': (saveShippingAddress as bool?),
        if (shippingMethod != _undefined)
          'shippingMethod': (shippingMethod as String?),
        if (voucher != _undefined) 'voucher': (voucher as String?),
        if (voucherCode != _undefined) 'voucherCode': (voucherCode as String?),
        if (customerNote != _undefined)
          'customerNote': (customerNote as String?),
        if (channelId != _undefined) 'channelId': (channelId as String?),
        if (redirectUrl != _undefined) 'redirectUrl': (redirectUrl as String?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (languageCode != _undefined)
          'languageCode': (languageCode as Enum$LanguageCodeEnum?),
        if (lines != _undefined)
          'lines': (lines as List<Input$OrderLineCreateInput>?),
      }));

  CopyWith$Input$AddressInput<TRes> get billingAddress {
    final local$billingAddress = _instance.billingAddress;
    return local$billingAddress == null
        ? CopyWith$Input$AddressInput.stub(_then(_instance))
        : CopyWith$Input$AddressInput(
            local$billingAddress, (e) => call(billingAddress: e));
  }

  CopyWith$Input$AddressInput<TRes> get shippingAddress {
    final local$shippingAddress = _instance.shippingAddress;
    return local$shippingAddress == null
        ? CopyWith$Input$AddressInput.stub(_then(_instance))
        : CopyWith$Input$AddressInput(
            local$shippingAddress, (e) => call(shippingAddress: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes lines(
          Iterable<Input$OrderLineCreateInput>? Function(
                  Iterable<
                      CopyWith$Input$OrderLineCreateInput<
                          Input$OrderLineCreateInput>>?)
              _fn) =>
      call(
          lines: _fn(
              _instance.lines?.map((e) => CopyWith$Input$OrderLineCreateInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$DraftOrderCreateInput<TRes>
    implements CopyWith$Input$DraftOrderCreateInput<TRes> {
  _CopyWithStubImpl$Input$DraftOrderCreateInput(this._res);

  TRes _res;

  call({
    Input$AddressInput? billingAddress,
    bool? saveBillingAddress,
    String? user,
    String? userEmail,
    String? discount,
    Input$AddressInput? shippingAddress,
    bool? saveShippingAddress,
    String? shippingMethod,
    String? voucher,
    String? voucherCode,
    String? customerNote,
    String? channelId,
    String? redirectUrl,
    String? externalReference,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Enum$LanguageCodeEnum? languageCode,
    List<Input$OrderLineCreateInput>? lines,
  }) =>
      _res;

  CopyWith$Input$AddressInput<TRes> get billingAddress =>
      CopyWith$Input$AddressInput.stub(_res);

  CopyWith$Input$AddressInput<TRes> get shippingAddress =>
      CopyWith$Input$AddressInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;

  lines(_fn) => _res;
}

class Input$DraftOrderInput {
  factory Input$DraftOrderInput({
    Input$AddressInput? billingAddress,
    bool? saveBillingAddress,
    String? user,
    String? userEmail,
    String? discount,
    Input$AddressInput? shippingAddress,
    bool? saveShippingAddress,
    String? shippingMethod,
    String? voucher,
    String? voucherCode,
    String? customerNote,
    String? channelId,
    String? redirectUrl,
    String? externalReference,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Enum$LanguageCodeEnum? languageCode,
  }) =>
      Input$DraftOrderInput._({
        if (billingAddress != null) r'billingAddress': billingAddress,
        if (saveBillingAddress != null)
          r'saveBillingAddress': saveBillingAddress,
        if (user != null) r'user': user,
        if (userEmail != null) r'userEmail': userEmail,
        if (discount != null) r'discount': discount,
        if (shippingAddress != null) r'shippingAddress': shippingAddress,
        if (saveShippingAddress != null)
          r'saveShippingAddress': saveShippingAddress,
        if (shippingMethod != null) r'shippingMethod': shippingMethod,
        if (voucher != null) r'voucher': voucher,
        if (voucherCode != null) r'voucherCode': voucherCode,
        if (customerNote != null) r'customerNote': customerNote,
        if (channelId != null) r'channelId': channelId,
        if (redirectUrl != null) r'redirectUrl': redirectUrl,
        if (externalReference != null) r'externalReference': externalReference,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (languageCode != null) r'languageCode': languageCode,
      });

  Input$DraftOrderInput._(this._$data);

  factory Input$DraftOrderInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('billingAddress')) {
      final l$billingAddress = data['billingAddress'];
      result$data['billingAddress'] = l$billingAddress == null
          ? null
          : Input$AddressInput.fromJson(
              (l$billingAddress as Map<String, dynamic>));
    }
    if (data.containsKey('saveBillingAddress')) {
      final l$saveBillingAddress = data['saveBillingAddress'];
      result$data['saveBillingAddress'] = (l$saveBillingAddress as bool?);
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = (l$user as String?);
    }
    if (data.containsKey('userEmail')) {
      final l$userEmail = data['userEmail'];
      result$data['userEmail'] = (l$userEmail as String?);
    }
    if (data.containsKey('discount')) {
      final l$discount = data['discount'];
      result$data['discount'] = (l$discount as String?);
    }
    if (data.containsKey('shippingAddress')) {
      final l$shippingAddress = data['shippingAddress'];
      result$data['shippingAddress'] = l$shippingAddress == null
          ? null
          : Input$AddressInput.fromJson(
              (l$shippingAddress as Map<String, dynamic>));
    }
    if (data.containsKey('saveShippingAddress')) {
      final l$saveShippingAddress = data['saveShippingAddress'];
      result$data['saveShippingAddress'] = (l$saveShippingAddress as bool?);
    }
    if (data.containsKey('shippingMethod')) {
      final l$shippingMethod = data['shippingMethod'];
      result$data['shippingMethod'] = (l$shippingMethod as String?);
    }
    if (data.containsKey('voucher')) {
      final l$voucher = data['voucher'];
      result$data['voucher'] = (l$voucher as String?);
    }
    if (data.containsKey('voucherCode')) {
      final l$voucherCode = data['voucherCode'];
      result$data['voucherCode'] = (l$voucherCode as String?);
    }
    if (data.containsKey('customerNote')) {
      final l$customerNote = data['customerNote'];
      result$data['customerNote'] = (l$customerNote as String?);
    }
    if (data.containsKey('channelId')) {
      final l$channelId = data['channelId'];
      result$data['channelId'] = (l$channelId as String?);
    }
    if (data.containsKey('redirectUrl')) {
      final l$redirectUrl = data['redirectUrl'];
      result$data['redirectUrl'] = (l$redirectUrl as String?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('languageCode')) {
      final l$languageCode = data['languageCode'];
      result$data['languageCode'] = l$languageCode == null
          ? null
          : fromJson$Enum$LanguageCodeEnum((l$languageCode as String));
    }
    return Input$DraftOrderInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$AddressInput? get billingAddress =>
      (_$data['billingAddress'] as Input$AddressInput?);

  bool? get saveBillingAddress => (_$data['saveBillingAddress'] as bool?);

  String? get user => (_$data['user'] as String?);

  String? get userEmail => (_$data['userEmail'] as String?);

  String? get discount => (_$data['discount'] as String?);

  Input$AddressInput? get shippingAddress =>
      (_$data['shippingAddress'] as Input$AddressInput?);

  bool? get saveShippingAddress => (_$data['saveShippingAddress'] as bool?);

  String? get shippingMethod => (_$data['shippingMethod'] as String?);

  String? get voucher => (_$data['voucher'] as String?);

  String? get voucherCode => (_$data['voucherCode'] as String?);

  String? get customerNote => (_$data['customerNote'] as String?);

  String? get channelId => (_$data['channelId'] as String?);

  String? get redirectUrl => (_$data['redirectUrl'] as String?);

  String? get externalReference => (_$data['externalReference'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  Enum$LanguageCodeEnum? get languageCode =>
      (_$data['languageCode'] as Enum$LanguageCodeEnum?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('billingAddress')) {
      final l$billingAddress = billingAddress;
      result$data['billingAddress'] = l$billingAddress?.toJson();
    }
    if (_$data.containsKey('saveBillingAddress')) {
      final l$saveBillingAddress = saveBillingAddress;
      result$data['saveBillingAddress'] = l$saveBillingAddress;
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user;
    }
    if (_$data.containsKey('userEmail')) {
      final l$userEmail = userEmail;
      result$data['userEmail'] = l$userEmail;
    }
    if (_$data.containsKey('discount')) {
      final l$discount = discount;
      result$data['discount'] = l$discount;
    }
    if (_$data.containsKey('shippingAddress')) {
      final l$shippingAddress = shippingAddress;
      result$data['shippingAddress'] = l$shippingAddress?.toJson();
    }
    if (_$data.containsKey('saveShippingAddress')) {
      final l$saveShippingAddress = saveShippingAddress;
      result$data['saveShippingAddress'] = l$saveShippingAddress;
    }
    if (_$data.containsKey('shippingMethod')) {
      final l$shippingMethod = shippingMethod;
      result$data['shippingMethod'] = l$shippingMethod;
    }
    if (_$data.containsKey('voucher')) {
      final l$voucher = voucher;
      result$data['voucher'] = l$voucher;
    }
    if (_$data.containsKey('voucherCode')) {
      final l$voucherCode = voucherCode;
      result$data['voucherCode'] = l$voucherCode;
    }
    if (_$data.containsKey('customerNote')) {
      final l$customerNote = customerNote;
      result$data['customerNote'] = l$customerNote;
    }
    if (_$data.containsKey('channelId')) {
      final l$channelId = channelId;
      result$data['channelId'] = l$channelId;
    }
    if (_$data.containsKey('redirectUrl')) {
      final l$redirectUrl = redirectUrl;
      result$data['redirectUrl'] = l$redirectUrl;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('languageCode')) {
      final l$languageCode = languageCode;
      result$data['languageCode'] = l$languageCode == null
          ? null
          : toJson$Enum$LanguageCodeEnum(l$languageCode);
    }
    return result$data;
  }

  CopyWith$Input$DraftOrderInput<Input$DraftOrderInput> get copyWith =>
      CopyWith$Input$DraftOrderInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DraftOrderInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$billingAddress = billingAddress;
    final lOther$billingAddress = other.billingAddress;
    if (_$data.containsKey('billingAddress') !=
        other._$data.containsKey('billingAddress')) {
      return false;
    }
    if (l$billingAddress != lOther$billingAddress) {
      return false;
    }
    final l$saveBillingAddress = saveBillingAddress;
    final lOther$saveBillingAddress = other.saveBillingAddress;
    if (_$data.containsKey('saveBillingAddress') !=
        other._$data.containsKey('saveBillingAddress')) {
      return false;
    }
    if (l$saveBillingAddress != lOther$saveBillingAddress) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$userEmail = userEmail;
    final lOther$userEmail = other.userEmail;
    if (_$data.containsKey('userEmail') !=
        other._$data.containsKey('userEmail')) {
      return false;
    }
    if (l$userEmail != lOther$userEmail) {
      return false;
    }
    final l$discount = discount;
    final lOther$discount = other.discount;
    if (_$data.containsKey('discount') !=
        other._$data.containsKey('discount')) {
      return false;
    }
    if (l$discount != lOther$discount) {
      return false;
    }
    final l$shippingAddress = shippingAddress;
    final lOther$shippingAddress = other.shippingAddress;
    if (_$data.containsKey('shippingAddress') !=
        other._$data.containsKey('shippingAddress')) {
      return false;
    }
    if (l$shippingAddress != lOther$shippingAddress) {
      return false;
    }
    final l$saveShippingAddress = saveShippingAddress;
    final lOther$saveShippingAddress = other.saveShippingAddress;
    if (_$data.containsKey('saveShippingAddress') !=
        other._$data.containsKey('saveShippingAddress')) {
      return false;
    }
    if (l$saveShippingAddress != lOther$saveShippingAddress) {
      return false;
    }
    final l$shippingMethod = shippingMethod;
    final lOther$shippingMethod = other.shippingMethod;
    if (_$data.containsKey('shippingMethod') !=
        other._$data.containsKey('shippingMethod')) {
      return false;
    }
    if (l$shippingMethod != lOther$shippingMethod) {
      return false;
    }
    final l$voucher = voucher;
    final lOther$voucher = other.voucher;
    if (_$data.containsKey('voucher') != other._$data.containsKey('voucher')) {
      return false;
    }
    if (l$voucher != lOther$voucher) {
      return false;
    }
    final l$voucherCode = voucherCode;
    final lOther$voucherCode = other.voucherCode;
    if (_$data.containsKey('voucherCode') !=
        other._$data.containsKey('voucherCode')) {
      return false;
    }
    if (l$voucherCode != lOther$voucherCode) {
      return false;
    }
    final l$customerNote = customerNote;
    final lOther$customerNote = other.customerNote;
    if (_$data.containsKey('customerNote') !=
        other._$data.containsKey('customerNote')) {
      return false;
    }
    if (l$customerNote != lOther$customerNote) {
      return false;
    }
    final l$channelId = channelId;
    final lOther$channelId = other.channelId;
    if (_$data.containsKey('channelId') !=
        other._$data.containsKey('channelId')) {
      return false;
    }
    if (l$channelId != lOther$channelId) {
      return false;
    }
    final l$redirectUrl = redirectUrl;
    final lOther$redirectUrl = other.redirectUrl;
    if (_$data.containsKey('redirectUrl') !=
        other._$data.containsKey('redirectUrl')) {
      return false;
    }
    if (l$redirectUrl != lOther$redirectUrl) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$languageCode = languageCode;
    final lOther$languageCode = other.languageCode;
    if (_$data.containsKey('languageCode') !=
        other._$data.containsKey('languageCode')) {
      return false;
    }
    if (l$languageCode != lOther$languageCode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$billingAddress = billingAddress;
    final l$saveBillingAddress = saveBillingAddress;
    final l$user = user;
    final l$userEmail = userEmail;
    final l$discount = discount;
    final l$shippingAddress = shippingAddress;
    final l$saveShippingAddress = saveShippingAddress;
    final l$shippingMethod = shippingMethod;
    final l$voucher = voucher;
    final l$voucherCode = voucherCode;
    final l$customerNote = customerNote;
    final l$channelId = channelId;
    final l$redirectUrl = redirectUrl;
    final l$externalReference = externalReference;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$languageCode = languageCode;
    return Object.hashAll([
      _$data.containsKey('billingAddress') ? l$billingAddress : const {},
      _$data.containsKey('saveBillingAddress')
          ? l$saveBillingAddress
          : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('userEmail') ? l$userEmail : const {},
      _$data.containsKey('discount') ? l$discount : const {},
      _$data.containsKey('shippingAddress') ? l$shippingAddress : const {},
      _$data.containsKey('saveShippingAddress')
          ? l$saveShippingAddress
          : const {},
      _$data.containsKey('shippingMethod') ? l$shippingMethod : const {},
      _$data.containsKey('voucher') ? l$voucher : const {},
      _$data.containsKey('voucherCode') ? l$voucherCode : const {},
      _$data.containsKey('customerNote') ? l$customerNote : const {},
      _$data.containsKey('channelId') ? l$channelId : const {},
      _$data.containsKey('redirectUrl') ? l$redirectUrl : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('languageCode') ? l$languageCode : const {},
    ]);
  }
}

abstract class CopyWith$Input$DraftOrderInput<TRes> {
  factory CopyWith$Input$DraftOrderInput(
    Input$DraftOrderInput instance,
    TRes Function(Input$DraftOrderInput) then,
  ) = _CopyWithImpl$Input$DraftOrderInput;

  factory CopyWith$Input$DraftOrderInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DraftOrderInput;

  TRes call({
    Input$AddressInput? billingAddress,
    bool? saveBillingAddress,
    String? user,
    String? userEmail,
    String? discount,
    Input$AddressInput? shippingAddress,
    bool? saveShippingAddress,
    String? shippingMethod,
    String? voucher,
    String? voucherCode,
    String? customerNote,
    String? channelId,
    String? redirectUrl,
    String? externalReference,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Enum$LanguageCodeEnum? languageCode,
  });
  CopyWith$Input$AddressInput<TRes> get billingAddress;
  CopyWith$Input$AddressInput<TRes> get shippingAddress;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$DraftOrderInput<TRes>
    implements CopyWith$Input$DraftOrderInput<TRes> {
  _CopyWithImpl$Input$DraftOrderInput(
    this._instance,
    this._then,
  );

  final Input$DraftOrderInput _instance;

  final TRes Function(Input$DraftOrderInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? billingAddress = _undefined,
    Object? saveBillingAddress = _undefined,
    Object? user = _undefined,
    Object? userEmail = _undefined,
    Object? discount = _undefined,
    Object? shippingAddress = _undefined,
    Object? saveShippingAddress = _undefined,
    Object? shippingMethod = _undefined,
    Object? voucher = _undefined,
    Object? voucherCode = _undefined,
    Object? customerNote = _undefined,
    Object? channelId = _undefined,
    Object? redirectUrl = _undefined,
    Object? externalReference = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? languageCode = _undefined,
  }) =>
      _then(Input$DraftOrderInput._({
        ..._instance._$data,
        if (billingAddress != _undefined)
          'billingAddress': (billingAddress as Input$AddressInput?),
        if (saveBillingAddress != _undefined)
          'saveBillingAddress': (saveBillingAddress as bool?),
        if (user != _undefined) 'user': (user as String?),
        if (userEmail != _undefined) 'userEmail': (userEmail as String?),
        if (discount != _undefined) 'discount': (discount as String?),
        if (shippingAddress != _undefined)
          'shippingAddress': (shippingAddress as Input$AddressInput?),
        if (saveShippingAddress != _undefined)
          'saveShippingAddress': (saveShippingAddress as bool?),
        if (shippingMethod != _undefined)
          'shippingMethod': (shippingMethod as String?),
        if (voucher != _undefined) 'voucher': (voucher as String?),
        if (voucherCode != _undefined) 'voucherCode': (voucherCode as String?),
        if (customerNote != _undefined)
          'customerNote': (customerNote as String?),
        if (channelId != _undefined) 'channelId': (channelId as String?),
        if (redirectUrl != _undefined) 'redirectUrl': (redirectUrl as String?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (languageCode != _undefined)
          'languageCode': (languageCode as Enum$LanguageCodeEnum?),
      }));

  CopyWith$Input$AddressInput<TRes> get billingAddress {
    final local$billingAddress = _instance.billingAddress;
    return local$billingAddress == null
        ? CopyWith$Input$AddressInput.stub(_then(_instance))
        : CopyWith$Input$AddressInput(
            local$billingAddress, (e) => call(billingAddress: e));
  }

  CopyWith$Input$AddressInput<TRes> get shippingAddress {
    final local$shippingAddress = _instance.shippingAddress;
    return local$shippingAddress == null
        ? CopyWith$Input$AddressInput.stub(_then(_instance))
        : CopyWith$Input$AddressInput(
            local$shippingAddress, (e) => call(shippingAddress: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$DraftOrderInput<TRes>
    implements CopyWith$Input$DraftOrderInput<TRes> {
  _CopyWithStubImpl$Input$DraftOrderInput(this._res);

  TRes _res;

  call({
    Input$AddressInput? billingAddress,
    bool? saveBillingAddress,
    String? user,
    String? userEmail,
    String? discount,
    Input$AddressInput? shippingAddress,
    bool? saveShippingAddress,
    String? shippingMethod,
    String? voucher,
    String? voucherCode,
    String? customerNote,
    String? channelId,
    String? redirectUrl,
    String? externalReference,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Enum$LanguageCodeEnum? languageCode,
  }) =>
      _res;

  CopyWith$Input$AddressInput<TRes> get billingAddress =>
      CopyWith$Input$AddressInput.stub(_res);

  CopyWith$Input$AddressInput<TRes> get shippingAddress =>
      CopyWith$Input$AddressInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$EventDeliveryAttemptSortingInput {
  factory Input$EventDeliveryAttemptSortingInput({
    required Enum$OrderDirection direction,
    required Enum$EventDeliveryAttemptSortField field,
  }) =>
      Input$EventDeliveryAttemptSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$EventDeliveryAttemptSortingInput._(this._$data);

  factory Input$EventDeliveryAttemptSortingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EventDeliveryAttemptSortField((l$field as String));
    return Input$EventDeliveryAttemptSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$EventDeliveryAttemptSortField get field =>
      (_$data['field'] as Enum$EventDeliveryAttemptSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$EventDeliveryAttemptSortField(l$field);
    return result$data;
  }

  CopyWith$Input$EventDeliveryAttemptSortingInput<
          Input$EventDeliveryAttemptSortingInput>
      get copyWith => CopyWith$Input$EventDeliveryAttemptSortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EventDeliveryAttemptSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$EventDeliveryAttemptSortingInput<TRes> {
  factory CopyWith$Input$EventDeliveryAttemptSortingInput(
    Input$EventDeliveryAttemptSortingInput instance,
    TRes Function(Input$EventDeliveryAttemptSortingInput) then,
  ) = _CopyWithImpl$Input$EventDeliveryAttemptSortingInput;

  factory CopyWith$Input$EventDeliveryAttemptSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EventDeliveryAttemptSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$EventDeliveryAttemptSortField? field,
  });
}

class _CopyWithImpl$Input$EventDeliveryAttemptSortingInput<TRes>
    implements CopyWith$Input$EventDeliveryAttemptSortingInput<TRes> {
  _CopyWithImpl$Input$EventDeliveryAttemptSortingInput(
    this._instance,
    this._then,
  );

  final Input$EventDeliveryAttemptSortingInput _instance;

  final TRes Function(Input$EventDeliveryAttemptSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$EventDeliveryAttemptSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$EventDeliveryAttemptSortField),
      }));
}

class _CopyWithStubImpl$Input$EventDeliveryAttemptSortingInput<TRes>
    implements CopyWith$Input$EventDeliveryAttemptSortingInput<TRes> {
  _CopyWithStubImpl$Input$EventDeliveryAttemptSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$EventDeliveryAttemptSortField? field,
  }) =>
      _res;
}

class Input$EventDeliveryFilterInput {
  factory Input$EventDeliveryFilterInput({
    Enum$EventDeliveryStatusEnum? status,
    Enum$WebhookEventTypeEnum? eventType,
  }) =>
      Input$EventDeliveryFilterInput._({
        if (status != null) r'status': status,
        if (eventType != null) r'eventType': eventType,
      });

  Input$EventDeliveryFilterInput._(this._$data);

  factory Input$EventDeliveryFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$EventDeliveryStatusEnum((l$status as String));
    }
    if (data.containsKey('eventType')) {
      final l$eventType = data['eventType'];
      result$data['eventType'] = l$eventType == null
          ? null
          : fromJson$Enum$WebhookEventTypeEnum((l$eventType as String));
    }
    return Input$EventDeliveryFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EventDeliveryStatusEnum? get status =>
      (_$data['status'] as Enum$EventDeliveryStatusEnum?);

  Enum$WebhookEventTypeEnum? get eventType =>
      (_$data['eventType'] as Enum$WebhookEventTypeEnum?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$EventDeliveryStatusEnum(l$status);
    }
    if (_$data.containsKey('eventType')) {
      final l$eventType = eventType;
      result$data['eventType'] = l$eventType == null
          ? null
          : toJson$Enum$WebhookEventTypeEnum(l$eventType);
    }
    return result$data;
  }

  CopyWith$Input$EventDeliveryFilterInput<Input$EventDeliveryFilterInput>
      get copyWith => CopyWith$Input$EventDeliveryFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EventDeliveryFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$eventType = eventType;
    final lOther$eventType = other.eventType;
    if (_$data.containsKey('eventType') !=
        other._$data.containsKey('eventType')) {
      return false;
    }
    if (l$eventType != lOther$eventType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$status = status;
    final l$eventType = eventType;
    return Object.hashAll([
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('eventType') ? l$eventType : const {},
    ]);
  }
}

abstract class CopyWith$Input$EventDeliveryFilterInput<TRes> {
  factory CopyWith$Input$EventDeliveryFilterInput(
    Input$EventDeliveryFilterInput instance,
    TRes Function(Input$EventDeliveryFilterInput) then,
  ) = _CopyWithImpl$Input$EventDeliveryFilterInput;

  factory CopyWith$Input$EventDeliveryFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EventDeliveryFilterInput;

  TRes call({
    Enum$EventDeliveryStatusEnum? status,
    Enum$WebhookEventTypeEnum? eventType,
  });
}

class _CopyWithImpl$Input$EventDeliveryFilterInput<TRes>
    implements CopyWith$Input$EventDeliveryFilterInput<TRes> {
  _CopyWithImpl$Input$EventDeliveryFilterInput(
    this._instance,
    this._then,
  );

  final Input$EventDeliveryFilterInput _instance;

  final TRes Function(Input$EventDeliveryFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? status = _undefined,
    Object? eventType = _undefined,
  }) =>
      _then(Input$EventDeliveryFilterInput._({
        ..._instance._$data,
        if (status != _undefined)
          'status': (status as Enum$EventDeliveryStatusEnum?),
        if (eventType != _undefined)
          'eventType': (eventType as Enum$WebhookEventTypeEnum?),
      }));
}

class _CopyWithStubImpl$Input$EventDeliveryFilterInput<TRes>
    implements CopyWith$Input$EventDeliveryFilterInput<TRes> {
  _CopyWithStubImpl$Input$EventDeliveryFilterInput(this._res);

  TRes _res;

  call({
    Enum$EventDeliveryStatusEnum? status,
    Enum$WebhookEventTypeEnum? eventType,
  }) =>
      _res;
}

class Input$EventDeliverySortingInput {
  factory Input$EventDeliverySortingInput({
    required Enum$OrderDirection direction,
    required Enum$EventDeliverySortField field,
  }) =>
      Input$EventDeliverySortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$EventDeliverySortingInput._(this._$data);

  factory Input$EventDeliverySortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EventDeliverySortField((l$field as String));
    return Input$EventDeliverySortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$EventDeliverySortField get field =>
      (_$data['field'] as Enum$EventDeliverySortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$EventDeliverySortField(l$field);
    return result$data;
  }

  CopyWith$Input$EventDeliverySortingInput<Input$EventDeliverySortingInput>
      get copyWith => CopyWith$Input$EventDeliverySortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EventDeliverySortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$EventDeliverySortingInput<TRes> {
  factory CopyWith$Input$EventDeliverySortingInput(
    Input$EventDeliverySortingInput instance,
    TRes Function(Input$EventDeliverySortingInput) then,
  ) = _CopyWithImpl$Input$EventDeliverySortingInput;

  factory CopyWith$Input$EventDeliverySortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EventDeliverySortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$EventDeliverySortField? field,
  });
}

class _CopyWithImpl$Input$EventDeliverySortingInput<TRes>
    implements CopyWith$Input$EventDeliverySortingInput<TRes> {
  _CopyWithImpl$Input$EventDeliverySortingInput(
    this._instance,
    this._then,
  );

  final Input$EventDeliverySortingInput _instance;

  final TRes Function(Input$EventDeliverySortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$EventDeliverySortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$EventDeliverySortField),
      }));
}

class _CopyWithStubImpl$Input$EventDeliverySortingInput<TRes>
    implements CopyWith$Input$EventDeliverySortingInput<TRes> {
  _CopyWithStubImpl$Input$EventDeliverySortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$EventDeliverySortField? field,
  }) =>
      _res;
}

class Input$ExportFileFilterInput {
  factory Input$ExportFileFilterInput({
    Input$DateTimeRangeInput? createdAt,
    Input$DateTimeRangeInput? updatedAt,
    Enum$JobStatusEnum? status,
    String? user,
    String? app,
  }) =>
      Input$ExportFileFilterInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (status != null) r'status': status,
        if (user != null) r'user': user,
        if (app != null) r'app': app,
      });

  Input$ExportFileFilterInput._(this._$data);

  factory Input$ExportFileFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeRangeInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeRangeInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$JobStatusEnum((l$status as String));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = (l$user as String?);
    }
    if (data.containsKey('app')) {
      final l$app = data['app'];
      result$data['app'] = (l$app as String?);
    }
    return Input$ExportFileFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$DateTimeRangeInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeRangeInput?);

  Input$DateTimeRangeInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeRangeInput?);

  Enum$JobStatusEnum? get status => (_$data['status'] as Enum$JobStatusEnum?);

  String? get user => (_$data['user'] as String?);

  String? get app => (_$data['app'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$JobStatusEnum(l$status);
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user;
    }
    if (_$data.containsKey('app')) {
      final l$app = app;
      result$data['app'] = l$app;
    }
    return result$data;
  }

  CopyWith$Input$ExportFileFilterInput<Input$ExportFileFilterInput>
      get copyWith => CopyWith$Input$ExportFileFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ExportFileFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$app = app;
    final lOther$app = other.app;
    if (_$data.containsKey('app') != other._$data.containsKey('app')) {
      return false;
    }
    if (l$app != lOther$app) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$status = status;
    final l$user = user;
    final l$app = app;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('app') ? l$app : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExportFileFilterInput<TRes> {
  factory CopyWith$Input$ExportFileFilterInput(
    Input$ExportFileFilterInput instance,
    TRes Function(Input$ExportFileFilterInput) then,
  ) = _CopyWithImpl$Input$ExportFileFilterInput;

  factory CopyWith$Input$ExportFileFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ExportFileFilterInput;

  TRes call({
    Input$DateTimeRangeInput? createdAt,
    Input$DateTimeRangeInput? updatedAt,
    Enum$JobStatusEnum? status,
    String? user,
    String? app,
  });
  CopyWith$Input$DateTimeRangeInput<TRes> get createdAt;
  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$ExportFileFilterInput<TRes>
    implements CopyWith$Input$ExportFileFilterInput<TRes> {
  _CopyWithImpl$Input$ExportFileFilterInput(
    this._instance,
    this._then,
  );

  final Input$ExportFileFilterInput _instance;

  final TRes Function(Input$ExportFileFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? status = _undefined,
    Object? user = _undefined,
    Object? app = _undefined,
  }) =>
      _then(Input$ExportFileFilterInput._({
        ..._instance._$data,
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeRangeInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeRangeInput?),
        if (status != _undefined) 'status': (status as Enum$JobStatusEnum?),
        if (user != _undefined) 'user': (user as String?),
        if (app != _undefined) 'app': (app as String?),
      }));

  CopyWith$Input$DateTimeRangeInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeRangeInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeRangeInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }
}

class _CopyWithStubImpl$Input$ExportFileFilterInput<TRes>
    implements CopyWith$Input$ExportFileFilterInput<TRes> {
  _CopyWithStubImpl$Input$ExportFileFilterInput(this._res);

  TRes _res;

  call({
    Input$DateTimeRangeInput? createdAt,
    Input$DateTimeRangeInput? updatedAt,
    Enum$JobStatusEnum? status,
    String? user,
    String? app,
  }) =>
      _res;

  CopyWith$Input$DateTimeRangeInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeRangeInput.stub(_res);

  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeRangeInput.stub(_res);
}

class Input$ExportFileSortingInput {
  factory Input$ExportFileSortingInput({
    required Enum$OrderDirection direction,
    required Enum$ExportFileSortField field,
  }) =>
      Input$ExportFileSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$ExportFileSortingInput._(this._$data);

  factory Input$ExportFileSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ExportFileSortField((l$field as String));
    return Input$ExportFileSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$ExportFileSortField get field =>
      (_$data['field'] as Enum$ExportFileSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$ExportFileSortField(l$field);
    return result$data;
  }

  CopyWith$Input$ExportFileSortingInput<Input$ExportFileSortingInput>
      get copyWith => CopyWith$Input$ExportFileSortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ExportFileSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$ExportFileSortingInput<TRes> {
  factory CopyWith$Input$ExportFileSortingInput(
    Input$ExportFileSortingInput instance,
    TRes Function(Input$ExportFileSortingInput) then,
  ) = _CopyWithImpl$Input$ExportFileSortingInput;

  factory CopyWith$Input$ExportFileSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ExportFileSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$ExportFileSortField? field,
  });
}

class _CopyWithImpl$Input$ExportFileSortingInput<TRes>
    implements CopyWith$Input$ExportFileSortingInput<TRes> {
  _CopyWithImpl$Input$ExportFileSortingInput(
    this._instance,
    this._then,
  );

  final Input$ExportFileSortingInput _instance;

  final TRes Function(Input$ExportFileSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$ExportFileSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$ExportFileSortField),
      }));
}

class _CopyWithStubImpl$Input$ExportFileSortingInput<TRes>
    implements CopyWith$Input$ExportFileSortingInput<TRes> {
  _CopyWithStubImpl$Input$ExportFileSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$ExportFileSortField? field,
  }) =>
      _res;
}

class Input$ExportGiftCardsInput {
  factory Input$ExportGiftCardsInput({
    required Enum$ExportScope scope,
    Input$GiftCardFilterInput? filter,
    List<String>? ids,
    required Enum$FileTypesEnum fileType,
  }) =>
      Input$ExportGiftCardsInput._({
        r'scope': scope,
        if (filter != null) r'filter': filter,
        if (ids != null) r'ids': ids,
        r'fileType': fileType,
      });

  Input$ExportGiftCardsInput._(this._$data);

  factory Input$ExportGiftCardsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$scope = data['scope'];
    result$data['scope'] = fromJson$Enum$ExportScope((l$scope as String));
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$GiftCardFilterInput.fromJson(
              (l$filter as Map<String, dynamic>));
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    final l$fileType = data['fileType'];
    result$data['fileType'] =
        fromJson$Enum$FileTypesEnum((l$fileType as String));
    return Input$ExportGiftCardsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ExportScope get scope => (_$data['scope'] as Enum$ExportScope);

  Input$GiftCardFilterInput? get filter =>
      (_$data['filter'] as Input$GiftCardFilterInput?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  Enum$FileTypesEnum get fileType => (_$data['fileType'] as Enum$FileTypesEnum);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$scope = scope;
    result$data['scope'] = toJson$Enum$ExportScope(l$scope);
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    final l$fileType = fileType;
    result$data['fileType'] = toJson$Enum$FileTypesEnum(l$fileType);
    return result$data;
  }

  CopyWith$Input$ExportGiftCardsInput<Input$ExportGiftCardsInput>
      get copyWith => CopyWith$Input$ExportGiftCardsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ExportGiftCardsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$scope = scope;
    final lOther$scope = other.scope;
    if (l$scope != lOther$scope) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$fileType = fileType;
    final lOther$fileType = other.fileType;
    if (l$fileType != lOther$fileType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$scope = scope;
    final l$filter = filter;
    final l$ids = ids;
    final l$fileType = fileType;
    return Object.hashAll([
      l$scope,
      _$data.containsKey('filter') ? l$filter : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      l$fileType,
    ]);
  }
}

abstract class CopyWith$Input$ExportGiftCardsInput<TRes> {
  factory CopyWith$Input$ExportGiftCardsInput(
    Input$ExportGiftCardsInput instance,
    TRes Function(Input$ExportGiftCardsInput) then,
  ) = _CopyWithImpl$Input$ExportGiftCardsInput;

  factory CopyWith$Input$ExportGiftCardsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ExportGiftCardsInput;

  TRes call({
    Enum$ExportScope? scope,
    Input$GiftCardFilterInput? filter,
    List<String>? ids,
    Enum$FileTypesEnum? fileType,
  });
  CopyWith$Input$GiftCardFilterInput<TRes> get filter;
}

class _CopyWithImpl$Input$ExportGiftCardsInput<TRes>
    implements CopyWith$Input$ExportGiftCardsInput<TRes> {
  _CopyWithImpl$Input$ExportGiftCardsInput(
    this._instance,
    this._then,
  );

  final Input$ExportGiftCardsInput _instance;

  final TRes Function(Input$ExportGiftCardsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? scope = _undefined,
    Object? filter = _undefined,
    Object? ids = _undefined,
    Object? fileType = _undefined,
  }) =>
      _then(Input$ExportGiftCardsInput._({
        ..._instance._$data,
        if (scope != _undefined && scope != null)
          'scope': (scope as Enum$ExportScope),
        if (filter != _undefined)
          'filter': (filter as Input$GiftCardFilterInput?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (fileType != _undefined && fileType != null)
          'fileType': (fileType as Enum$FileTypesEnum),
      }));

  CopyWith$Input$GiftCardFilterInput<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$GiftCardFilterInput.stub(_then(_instance))
        : CopyWith$Input$GiftCardFilterInput(
            local$filter, (e) => call(filter: e));
  }
}

class _CopyWithStubImpl$Input$ExportGiftCardsInput<TRes>
    implements CopyWith$Input$ExportGiftCardsInput<TRes> {
  _CopyWithStubImpl$Input$ExportGiftCardsInput(this._res);

  TRes _res;

  call({
    Enum$ExportScope? scope,
    Input$GiftCardFilterInput? filter,
    List<String>? ids,
    Enum$FileTypesEnum? fileType,
  }) =>
      _res;

  CopyWith$Input$GiftCardFilterInput<TRes> get filter =>
      CopyWith$Input$GiftCardFilterInput.stub(_res);
}

class Input$ExportInfoInput {
  factory Input$ExportInfoInput({
    List<String>? attributes,
    List<String>? warehouses,
    List<String>? channels,
    List<Enum$ProductFieldEnum>? fields,
  }) =>
      Input$ExportInfoInput._({
        if (attributes != null) r'attributes': attributes,
        if (warehouses != null) r'warehouses': warehouses,
        if (channels != null) r'channels': channels,
        if (fields != null) r'fields': fields,
      });

  Input$ExportInfoInput._(this._$data);

  factory Input$ExportInfoInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('attributes')) {
      final l$attributes = data['attributes'];
      result$data['attributes'] =
          (l$attributes as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('warehouses')) {
      final l$warehouses = data['warehouses'];
      result$data['warehouses'] =
          (l$warehouses as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('channels')) {
      final l$channels = data['channels'];
      result$data['channels'] =
          (l$channels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('fields')) {
      final l$fields = data['fields'];
      result$data['fields'] = (l$fields as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ProductFieldEnum((e as String)))
          .toList();
    }
    return Input$ExportInfoInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get attributes => (_$data['attributes'] as List<String>?);

  List<String>? get warehouses => (_$data['warehouses'] as List<String>?);

  List<String>? get channels => (_$data['channels'] as List<String>?);

  List<Enum$ProductFieldEnum>? get fields =>
      (_$data['fields'] as List<Enum$ProductFieldEnum>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('attributes')) {
      final l$attributes = attributes;
      result$data['attributes'] = l$attributes?.map((e) => e).toList();
    }
    if (_$data.containsKey('warehouses')) {
      final l$warehouses = warehouses;
      result$data['warehouses'] = l$warehouses?.map((e) => e).toList();
    }
    if (_$data.containsKey('channels')) {
      final l$channels = channels;
      result$data['channels'] = l$channels?.map((e) => e).toList();
    }
    if (_$data.containsKey('fields')) {
      final l$fields = fields;
      result$data['fields'] =
          l$fields?.map((e) => toJson$Enum$ProductFieldEnum(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$ExportInfoInput<Input$ExportInfoInput> get copyWith =>
      CopyWith$Input$ExportInfoInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ExportInfoInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$attributes = attributes;
    final lOther$attributes = other.attributes;
    if (_$data.containsKey('attributes') !=
        other._$data.containsKey('attributes')) {
      return false;
    }
    if (l$attributes != null && lOther$attributes != null) {
      if (l$attributes.length != lOther$attributes.length) {
        return false;
      }
      for (int i = 0; i < l$attributes.length; i++) {
        final l$attributes$entry = l$attributes[i];
        final lOther$attributes$entry = lOther$attributes[i];
        if (l$attributes$entry != lOther$attributes$entry) {
          return false;
        }
      }
    } else if (l$attributes != lOther$attributes) {
      return false;
    }
    final l$warehouses = warehouses;
    final lOther$warehouses = other.warehouses;
    if (_$data.containsKey('warehouses') !=
        other._$data.containsKey('warehouses')) {
      return false;
    }
    if (l$warehouses != null && lOther$warehouses != null) {
      if (l$warehouses.length != lOther$warehouses.length) {
        return false;
      }
      for (int i = 0; i < l$warehouses.length; i++) {
        final l$warehouses$entry = l$warehouses[i];
        final lOther$warehouses$entry = lOther$warehouses[i];
        if (l$warehouses$entry != lOther$warehouses$entry) {
          return false;
        }
      }
    } else if (l$warehouses != lOther$warehouses) {
      return false;
    }
    final l$channels = channels;
    final lOther$channels = other.channels;
    if (_$data.containsKey('channels') !=
        other._$data.containsKey('channels')) {
      return false;
    }
    if (l$channels != null && lOther$channels != null) {
      if (l$channels.length != lOther$channels.length) {
        return false;
      }
      for (int i = 0; i < l$channels.length; i++) {
        final l$channels$entry = l$channels[i];
        final lOther$channels$entry = lOther$channels[i];
        if (l$channels$entry != lOther$channels$entry) {
          return false;
        }
      }
    } else if (l$channels != lOther$channels) {
      return false;
    }
    final l$fields = fields;
    final lOther$fields = other.fields;
    if (_$data.containsKey('fields') != other._$data.containsKey('fields')) {
      return false;
    }
    if (l$fields != null && lOther$fields != null) {
      if (l$fields.length != lOther$fields.length) {
        return false;
      }
      for (int i = 0; i < l$fields.length; i++) {
        final l$fields$entry = l$fields[i];
        final lOther$fields$entry = lOther$fields[i];
        if (l$fields$entry != lOther$fields$entry) {
          return false;
        }
      }
    } else if (l$fields != lOther$fields) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$attributes = attributes;
    final l$warehouses = warehouses;
    final l$channels = channels;
    final l$fields = fields;
    return Object.hashAll([
      _$data.containsKey('attributes')
          ? l$attributes == null
              ? null
              : Object.hashAll(l$attributes.map((v) => v))
          : const {},
      _$data.containsKey('warehouses')
          ? l$warehouses == null
              ? null
              : Object.hashAll(l$warehouses.map((v) => v))
          : const {},
      _$data.containsKey('channels')
          ? l$channels == null
              ? null
              : Object.hashAll(l$channels.map((v) => v))
          : const {},
      _$data.containsKey('fields')
          ? l$fields == null
              ? null
              : Object.hashAll(l$fields.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExportInfoInput<TRes> {
  factory CopyWith$Input$ExportInfoInput(
    Input$ExportInfoInput instance,
    TRes Function(Input$ExportInfoInput) then,
  ) = _CopyWithImpl$Input$ExportInfoInput;

  factory CopyWith$Input$ExportInfoInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ExportInfoInput;

  TRes call({
    List<String>? attributes,
    List<String>? warehouses,
    List<String>? channels,
    List<Enum$ProductFieldEnum>? fields,
  });
}

class _CopyWithImpl$Input$ExportInfoInput<TRes>
    implements CopyWith$Input$ExportInfoInput<TRes> {
  _CopyWithImpl$Input$ExportInfoInput(
    this._instance,
    this._then,
  );

  final Input$ExportInfoInput _instance;

  final TRes Function(Input$ExportInfoInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? attributes = _undefined,
    Object? warehouses = _undefined,
    Object? channels = _undefined,
    Object? fields = _undefined,
  }) =>
      _then(Input$ExportInfoInput._({
        ..._instance._$data,
        if (attributes != _undefined)
          'attributes': (attributes as List<String>?),
        if (warehouses != _undefined)
          'warehouses': (warehouses as List<String>?),
        if (channels != _undefined) 'channels': (channels as List<String>?),
        if (fields != _undefined)
          'fields': (fields as List<Enum$ProductFieldEnum>?),
      }));
}

class _CopyWithStubImpl$Input$ExportInfoInput<TRes>
    implements CopyWith$Input$ExportInfoInput<TRes> {
  _CopyWithStubImpl$Input$ExportInfoInput(this._res);

  TRes _res;

  call({
    List<String>? attributes,
    List<String>? warehouses,
    List<String>? channels,
    List<Enum$ProductFieldEnum>? fields,
  }) =>
      _res;
}

class Input$ExportProductsInput {
  factory Input$ExportProductsInput({
    required Enum$ExportScope scope,
    Input$ProductFilterInput? filter,
    List<String>? ids,
    Input$ExportInfoInput? exportInfo,
    required Enum$FileTypesEnum fileType,
  }) =>
      Input$ExportProductsInput._({
        r'scope': scope,
        if (filter != null) r'filter': filter,
        if (ids != null) r'ids': ids,
        if (exportInfo != null) r'exportInfo': exportInfo,
        r'fileType': fileType,
      });

  Input$ExportProductsInput._(this._$data);

  factory Input$ExportProductsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$scope = data['scope'];
    result$data['scope'] = fromJson$Enum$ExportScope((l$scope as String));
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$ProductFilterInput.fromJson(
              (l$filter as Map<String, dynamic>));
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('exportInfo')) {
      final l$exportInfo = data['exportInfo'];
      result$data['exportInfo'] = l$exportInfo == null
          ? null
          : Input$ExportInfoInput.fromJson(
              (l$exportInfo as Map<String, dynamic>));
    }
    final l$fileType = data['fileType'];
    result$data['fileType'] =
        fromJson$Enum$FileTypesEnum((l$fileType as String));
    return Input$ExportProductsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ExportScope get scope => (_$data['scope'] as Enum$ExportScope);

  Input$ProductFilterInput? get filter =>
      (_$data['filter'] as Input$ProductFilterInput?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  Input$ExportInfoInput? get exportInfo =>
      (_$data['exportInfo'] as Input$ExportInfoInput?);

  Enum$FileTypesEnum get fileType => (_$data['fileType'] as Enum$FileTypesEnum);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$scope = scope;
    result$data['scope'] = toJson$Enum$ExportScope(l$scope);
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('exportInfo')) {
      final l$exportInfo = exportInfo;
      result$data['exportInfo'] = l$exportInfo?.toJson();
    }
    final l$fileType = fileType;
    result$data['fileType'] = toJson$Enum$FileTypesEnum(l$fileType);
    return result$data;
  }

  CopyWith$Input$ExportProductsInput<Input$ExportProductsInput> get copyWith =>
      CopyWith$Input$ExportProductsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ExportProductsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$scope = scope;
    final lOther$scope = other.scope;
    if (l$scope != lOther$scope) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$exportInfo = exportInfo;
    final lOther$exportInfo = other.exportInfo;
    if (_$data.containsKey('exportInfo') !=
        other._$data.containsKey('exportInfo')) {
      return false;
    }
    if (l$exportInfo != lOther$exportInfo) {
      return false;
    }
    final l$fileType = fileType;
    final lOther$fileType = other.fileType;
    if (l$fileType != lOther$fileType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$scope = scope;
    final l$filter = filter;
    final l$ids = ids;
    final l$exportInfo = exportInfo;
    final l$fileType = fileType;
    return Object.hashAll([
      l$scope,
      _$data.containsKey('filter') ? l$filter : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('exportInfo') ? l$exportInfo : const {},
      l$fileType,
    ]);
  }
}

abstract class CopyWith$Input$ExportProductsInput<TRes> {
  factory CopyWith$Input$ExportProductsInput(
    Input$ExportProductsInput instance,
    TRes Function(Input$ExportProductsInput) then,
  ) = _CopyWithImpl$Input$ExportProductsInput;

  factory CopyWith$Input$ExportProductsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ExportProductsInput;

  TRes call({
    Enum$ExportScope? scope,
    Input$ProductFilterInput? filter,
    List<String>? ids,
    Input$ExportInfoInput? exportInfo,
    Enum$FileTypesEnum? fileType,
  });
  CopyWith$Input$ProductFilterInput<TRes> get filter;
  CopyWith$Input$ExportInfoInput<TRes> get exportInfo;
}

class _CopyWithImpl$Input$ExportProductsInput<TRes>
    implements CopyWith$Input$ExportProductsInput<TRes> {
  _CopyWithImpl$Input$ExportProductsInput(
    this._instance,
    this._then,
  );

  final Input$ExportProductsInput _instance;

  final TRes Function(Input$ExportProductsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? scope = _undefined,
    Object? filter = _undefined,
    Object? ids = _undefined,
    Object? exportInfo = _undefined,
    Object? fileType = _undefined,
  }) =>
      _then(Input$ExportProductsInput._({
        ..._instance._$data,
        if (scope != _undefined && scope != null)
          'scope': (scope as Enum$ExportScope),
        if (filter != _undefined)
          'filter': (filter as Input$ProductFilterInput?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (exportInfo != _undefined)
          'exportInfo': (exportInfo as Input$ExportInfoInput?),
        if (fileType != _undefined && fileType != null)
          'fileType': (fileType as Enum$FileTypesEnum),
      }));

  CopyWith$Input$ProductFilterInput<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$ProductFilterInput.stub(_then(_instance))
        : CopyWith$Input$ProductFilterInput(
            local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$ExportInfoInput<TRes> get exportInfo {
    final local$exportInfo = _instance.exportInfo;
    return local$exportInfo == null
        ? CopyWith$Input$ExportInfoInput.stub(_then(_instance))
        : CopyWith$Input$ExportInfoInput(
            local$exportInfo, (e) => call(exportInfo: e));
  }
}

class _CopyWithStubImpl$Input$ExportProductsInput<TRes>
    implements CopyWith$Input$ExportProductsInput<TRes> {
  _CopyWithStubImpl$Input$ExportProductsInput(this._res);

  TRes _res;

  call({
    Enum$ExportScope? scope,
    Input$ProductFilterInput? filter,
    List<String>? ids,
    Input$ExportInfoInput? exportInfo,
    Enum$FileTypesEnum? fileType,
  }) =>
      _res;

  CopyWith$Input$ProductFilterInput<TRes> get filter =>
      CopyWith$Input$ProductFilterInput.stub(_res);

  CopyWith$Input$ExportInfoInput<TRes> get exportInfo =>
      CopyWith$Input$ExportInfoInput.stub(_res);
}

class Input$ExportVoucherCodesInput {
  factory Input$ExportVoucherCodesInput({
    String? voucherId,
    List<String>? ids,
    required Enum$FileTypesEnum fileType,
  }) =>
      Input$ExportVoucherCodesInput._({
        if (voucherId != null) r'voucherId': voucherId,
        if (ids != null) r'ids': ids,
        r'fileType': fileType,
      });

  Input$ExportVoucherCodesInput._(this._$data);

  factory Input$ExportVoucherCodesInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('voucherId')) {
      final l$voucherId = data['voucherId'];
      result$data['voucherId'] = (l$voucherId as String?);
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    final l$fileType = data['fileType'];
    result$data['fileType'] =
        fromJson$Enum$FileTypesEnum((l$fileType as String));
    return Input$ExportVoucherCodesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get voucherId => (_$data['voucherId'] as String?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  Enum$FileTypesEnum get fileType => (_$data['fileType'] as Enum$FileTypesEnum);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('voucherId')) {
      final l$voucherId = voucherId;
      result$data['voucherId'] = l$voucherId;
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    final l$fileType = fileType;
    result$data['fileType'] = toJson$Enum$FileTypesEnum(l$fileType);
    return result$data;
  }

  CopyWith$Input$ExportVoucherCodesInput<Input$ExportVoucherCodesInput>
      get copyWith => CopyWith$Input$ExportVoucherCodesInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ExportVoucherCodesInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$voucherId = voucherId;
    final lOther$voucherId = other.voucherId;
    if (_$data.containsKey('voucherId') !=
        other._$data.containsKey('voucherId')) {
      return false;
    }
    if (l$voucherId != lOther$voucherId) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$fileType = fileType;
    final lOther$fileType = other.fileType;
    if (l$fileType != lOther$fileType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$voucherId = voucherId;
    final l$ids = ids;
    final l$fileType = fileType;
    return Object.hashAll([
      _$data.containsKey('voucherId') ? l$voucherId : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      l$fileType,
    ]);
  }
}

abstract class CopyWith$Input$ExportVoucherCodesInput<TRes> {
  factory CopyWith$Input$ExportVoucherCodesInput(
    Input$ExportVoucherCodesInput instance,
    TRes Function(Input$ExportVoucherCodesInput) then,
  ) = _CopyWithImpl$Input$ExportVoucherCodesInput;

  factory CopyWith$Input$ExportVoucherCodesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ExportVoucherCodesInput;

  TRes call({
    String? voucherId,
    List<String>? ids,
    Enum$FileTypesEnum? fileType,
  });
}

class _CopyWithImpl$Input$ExportVoucherCodesInput<TRes>
    implements CopyWith$Input$ExportVoucherCodesInput<TRes> {
  _CopyWithImpl$Input$ExportVoucherCodesInput(
    this._instance,
    this._then,
  );

  final Input$ExportVoucherCodesInput _instance;

  final TRes Function(Input$ExportVoucherCodesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? voucherId = _undefined,
    Object? ids = _undefined,
    Object? fileType = _undefined,
  }) =>
      _then(Input$ExportVoucherCodesInput._({
        ..._instance._$data,
        if (voucherId != _undefined) 'voucherId': (voucherId as String?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (fileType != _undefined && fileType != null)
          'fileType': (fileType as Enum$FileTypesEnum),
      }));
}

class _CopyWithStubImpl$Input$ExportVoucherCodesInput<TRes>
    implements CopyWith$Input$ExportVoucherCodesInput<TRes> {
  _CopyWithStubImpl$Input$ExportVoucherCodesInput(this._res);

  TRes _res;

  call({
    String? voucherId,
    List<String>? ids,
    Enum$FileTypesEnum? fileType,
  }) =>
      _res;
}

class Input$ExternalNotificationTriggerInput {
  factory Input$ExternalNotificationTriggerInput({
    required List<String> ids,
    String? extraPayload,
    required String externalEventType,
  }) =>
      Input$ExternalNotificationTriggerInput._({
        r'ids': ids,
        if (extraPayload != null) r'extraPayload': extraPayload,
        r'externalEventType': externalEventType,
      });

  Input$ExternalNotificationTriggerInput._(this._$data);

  factory Input$ExternalNotificationTriggerInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$ids = data['ids'];
    result$data['ids'] =
        (l$ids as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('extraPayload')) {
      final l$extraPayload = data['extraPayload'];
      result$data['extraPayload'] = (l$extraPayload as String?);
    }
    final l$externalEventType = data['externalEventType'];
    result$data['externalEventType'] = (l$externalEventType as String);
    return Input$ExternalNotificationTriggerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String> get ids => (_$data['ids'] as List<String>);

  String? get extraPayload => (_$data['extraPayload'] as String?);

  String get externalEventType => (_$data['externalEventType'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$ids = ids;
    result$data['ids'] = l$ids.map((e) => e).toList();
    if (_$data.containsKey('extraPayload')) {
      final l$extraPayload = extraPayload;
      result$data['extraPayload'] = l$extraPayload;
    }
    final l$externalEventType = externalEventType;
    result$data['externalEventType'] = l$externalEventType;
    return result$data;
  }

  CopyWith$Input$ExternalNotificationTriggerInput<
          Input$ExternalNotificationTriggerInput>
      get copyWith => CopyWith$Input$ExternalNotificationTriggerInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ExternalNotificationTriggerInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (l$ids.length != lOther$ids.length) {
      return false;
    }
    for (int i = 0; i < l$ids.length; i++) {
      final l$ids$entry = l$ids[i];
      final lOther$ids$entry = lOther$ids[i];
      if (l$ids$entry != lOther$ids$entry) {
        return false;
      }
    }
    final l$extraPayload = extraPayload;
    final lOther$extraPayload = other.extraPayload;
    if (_$data.containsKey('extraPayload') !=
        other._$data.containsKey('extraPayload')) {
      return false;
    }
    if (l$extraPayload != lOther$extraPayload) {
      return false;
    }
    final l$externalEventType = externalEventType;
    final lOther$externalEventType = other.externalEventType;
    if (l$externalEventType != lOther$externalEventType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$ids = ids;
    final l$extraPayload = extraPayload;
    final l$externalEventType = externalEventType;
    return Object.hashAll([
      Object.hashAll(l$ids.map((v) => v)),
      _$data.containsKey('extraPayload') ? l$extraPayload : const {},
      l$externalEventType,
    ]);
  }
}

abstract class CopyWith$Input$ExternalNotificationTriggerInput<TRes> {
  factory CopyWith$Input$ExternalNotificationTriggerInput(
    Input$ExternalNotificationTriggerInput instance,
    TRes Function(Input$ExternalNotificationTriggerInput) then,
  ) = _CopyWithImpl$Input$ExternalNotificationTriggerInput;

  factory CopyWith$Input$ExternalNotificationTriggerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ExternalNotificationTriggerInput;

  TRes call({
    List<String>? ids,
    String? extraPayload,
    String? externalEventType,
  });
}

class _CopyWithImpl$Input$ExternalNotificationTriggerInput<TRes>
    implements CopyWith$Input$ExternalNotificationTriggerInput<TRes> {
  _CopyWithImpl$Input$ExternalNotificationTriggerInput(
    this._instance,
    this._then,
  );

  final Input$ExternalNotificationTriggerInput _instance;

  final TRes Function(Input$ExternalNotificationTriggerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? ids = _undefined,
    Object? extraPayload = _undefined,
    Object? externalEventType = _undefined,
  }) =>
      _then(Input$ExternalNotificationTriggerInput._({
        ..._instance._$data,
        if (ids != _undefined && ids != null) 'ids': (ids as List<String>),
        if (extraPayload != _undefined)
          'extraPayload': (extraPayload as String?),
        if (externalEventType != _undefined && externalEventType != null)
          'externalEventType': (externalEventType as String),
      }));
}

class _CopyWithStubImpl$Input$ExternalNotificationTriggerInput<TRes>
    implements CopyWith$Input$ExternalNotificationTriggerInput<TRes> {
  _CopyWithStubImpl$Input$ExternalNotificationTriggerInput(this._res);

  TRes _res;

  call({
    List<String>? ids,
    String? extraPayload,
    String? externalEventType,
  }) =>
      _res;
}

class Input$FulfillmentCancelInput {
  factory Input$FulfillmentCancelInput({String? warehouseId}) =>
      Input$FulfillmentCancelInput._({
        if (warehouseId != null) r'warehouseId': warehouseId,
      });

  Input$FulfillmentCancelInput._(this._$data);

  factory Input$FulfillmentCancelInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('warehouseId')) {
      final l$warehouseId = data['warehouseId'];
      result$data['warehouseId'] = (l$warehouseId as String?);
    }
    return Input$FulfillmentCancelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get warehouseId => (_$data['warehouseId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('warehouseId')) {
      final l$warehouseId = warehouseId;
      result$data['warehouseId'] = l$warehouseId;
    }
    return result$data;
  }

  CopyWith$Input$FulfillmentCancelInput<Input$FulfillmentCancelInput>
      get copyWith => CopyWith$Input$FulfillmentCancelInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$FulfillmentCancelInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$warehouseId = warehouseId;
    final lOther$warehouseId = other.warehouseId;
    if (_$data.containsKey('warehouseId') !=
        other._$data.containsKey('warehouseId')) {
      return false;
    }
    if (l$warehouseId != lOther$warehouseId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$warehouseId = warehouseId;
    return Object.hashAll(
        [_$data.containsKey('warehouseId') ? l$warehouseId : const {}]);
  }
}

abstract class CopyWith$Input$FulfillmentCancelInput<TRes> {
  factory CopyWith$Input$FulfillmentCancelInput(
    Input$FulfillmentCancelInput instance,
    TRes Function(Input$FulfillmentCancelInput) then,
  ) = _CopyWithImpl$Input$FulfillmentCancelInput;

  factory CopyWith$Input$FulfillmentCancelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FulfillmentCancelInput;

  TRes call({String? warehouseId});
}

class _CopyWithImpl$Input$FulfillmentCancelInput<TRes>
    implements CopyWith$Input$FulfillmentCancelInput<TRes> {
  _CopyWithImpl$Input$FulfillmentCancelInput(
    this._instance,
    this._then,
  );

  final Input$FulfillmentCancelInput _instance;

  final TRes Function(Input$FulfillmentCancelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? warehouseId = _undefined}) =>
      _then(Input$FulfillmentCancelInput._({
        ..._instance._$data,
        if (warehouseId != _undefined) 'warehouseId': (warehouseId as String?),
      }));
}

class _CopyWithStubImpl$Input$FulfillmentCancelInput<TRes>
    implements CopyWith$Input$FulfillmentCancelInput<TRes> {
  _CopyWithStubImpl$Input$FulfillmentCancelInput(this._res);

  TRes _res;

  call({String? warehouseId}) => _res;
}

class Input$FulfillmentFilterInput {
  factory Input$FulfillmentFilterInput({
    Input$FulfillmentStatusEnumFilterInput? status,
    Input$MetadataFilterInput? metadata,
  }) =>
      Input$FulfillmentFilterInput._({
        if (status != null) r'status': status,
        if (metadata != null) r'metadata': metadata,
      });

  Input$FulfillmentFilterInput._(this._$data);

  factory Input$FulfillmentFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$FulfillmentStatusEnumFilterInput.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = l$metadata == null
          ? null
          : Input$MetadataFilterInput.fromJson(
              (l$metadata as Map<String, dynamic>));
    }
    return Input$FulfillmentFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$FulfillmentStatusEnumFilterInput? get status =>
      (_$data['status'] as Input$FulfillmentStatusEnumFilterInput?);

  Input$MetadataFilterInput? get metadata =>
      (_$data['metadata'] as Input$MetadataFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$FulfillmentFilterInput<Input$FulfillmentFilterInput>
      get copyWith => CopyWith$Input$FulfillmentFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$FulfillmentFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$status = status;
    final l$metadata = metadata;
    return Object.hashAll([
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('metadata') ? l$metadata : const {},
    ]);
  }
}

abstract class CopyWith$Input$FulfillmentFilterInput<TRes> {
  factory CopyWith$Input$FulfillmentFilterInput(
    Input$FulfillmentFilterInput instance,
    TRes Function(Input$FulfillmentFilterInput) then,
  ) = _CopyWithImpl$Input$FulfillmentFilterInput;

  factory CopyWith$Input$FulfillmentFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FulfillmentFilterInput;

  TRes call({
    Input$FulfillmentStatusEnumFilterInput? status,
    Input$MetadataFilterInput? metadata,
  });
  CopyWith$Input$FulfillmentStatusEnumFilterInput<TRes> get status;
  CopyWith$Input$MetadataFilterInput<TRes> get metadata;
}

class _CopyWithImpl$Input$FulfillmentFilterInput<TRes>
    implements CopyWith$Input$FulfillmentFilterInput<TRes> {
  _CopyWithImpl$Input$FulfillmentFilterInput(
    this._instance,
    this._then,
  );

  final Input$FulfillmentFilterInput _instance;

  final TRes Function(Input$FulfillmentFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? status = _undefined,
    Object? metadata = _undefined,
  }) =>
      _then(Input$FulfillmentFilterInput._({
        ..._instance._$data,
        if (status != _undefined)
          'status': (status as Input$FulfillmentStatusEnumFilterInput?),
        if (metadata != _undefined)
          'metadata': (metadata as Input$MetadataFilterInput?),
      }));

  CopyWith$Input$FulfillmentStatusEnumFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$FulfillmentStatusEnumFilterInput.stub(_then(_instance))
        : CopyWith$Input$FulfillmentStatusEnumFilterInput(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$MetadataFilterInput<TRes> get metadata {
    final local$metadata = _instance.metadata;
    return local$metadata == null
        ? CopyWith$Input$MetadataFilterInput.stub(_then(_instance))
        : CopyWith$Input$MetadataFilterInput(
            local$metadata, (e) => call(metadata: e));
  }
}

class _CopyWithStubImpl$Input$FulfillmentFilterInput<TRes>
    implements CopyWith$Input$FulfillmentFilterInput<TRes> {
  _CopyWithStubImpl$Input$FulfillmentFilterInput(this._res);

  TRes _res;

  call({
    Input$FulfillmentStatusEnumFilterInput? status,
    Input$MetadataFilterInput? metadata,
  }) =>
      _res;

  CopyWith$Input$FulfillmentStatusEnumFilterInput<TRes> get status =>
      CopyWith$Input$FulfillmentStatusEnumFilterInput.stub(_res);

  CopyWith$Input$MetadataFilterInput<TRes> get metadata =>
      CopyWith$Input$MetadataFilterInput.stub(_res);
}

class Input$FulfillmentStatusEnumFilterInput {
  factory Input$FulfillmentStatusEnumFilterInput({
    Enum$FulfillmentStatus? eq,
    List<Enum$FulfillmentStatus>? oneOf,
  }) =>
      Input$FulfillmentStatusEnumFilterInput._({
        if (eq != null) r'eq': eq,
        if (oneOf != null) r'oneOf': oneOf,
      });

  Input$FulfillmentStatusEnumFilterInput._(this._$data);

  factory Input$FulfillmentStatusEnumFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$FulfillmentStatus((l$eq as String));
    }
    if (data.containsKey('oneOf')) {
      final l$oneOf = data['oneOf'];
      result$data['oneOf'] = (l$oneOf as List<dynamic>?)
          ?.map((e) => fromJson$Enum$FulfillmentStatus((e as String)))
          .toList();
    }
    return Input$FulfillmentStatusEnumFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$FulfillmentStatus? get eq => (_$data['eq'] as Enum$FulfillmentStatus?);

  List<Enum$FulfillmentStatus>? get oneOf =>
      (_$data['oneOf'] as List<Enum$FulfillmentStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] =
          l$eq == null ? null : toJson$Enum$FulfillmentStatus(l$eq);
    }
    if (_$data.containsKey('oneOf')) {
      final l$oneOf = oneOf;
      result$data['oneOf'] =
          l$oneOf?.map((e) => toJson$Enum$FulfillmentStatus(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$FulfillmentStatusEnumFilterInput<
          Input$FulfillmentStatusEnumFilterInput>
      get copyWith => CopyWith$Input$FulfillmentStatusEnumFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$FulfillmentStatusEnumFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$oneOf = oneOf;
    final lOther$oneOf = other.oneOf;
    if (_$data.containsKey('oneOf') != other._$data.containsKey('oneOf')) {
      return false;
    }
    if (l$oneOf != null && lOther$oneOf != null) {
      if (l$oneOf.length != lOther$oneOf.length) {
        return false;
      }
      for (int i = 0; i < l$oneOf.length; i++) {
        final l$oneOf$entry = l$oneOf[i];
        final lOther$oneOf$entry = lOther$oneOf[i];
        if (l$oneOf$entry != lOther$oneOf$entry) {
          return false;
        }
      }
    } else if (l$oneOf != lOther$oneOf) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$oneOf = oneOf;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('oneOf')
          ? l$oneOf == null
              ? null
              : Object.hashAll(l$oneOf.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$FulfillmentStatusEnumFilterInput<TRes> {
  factory CopyWith$Input$FulfillmentStatusEnumFilterInput(
    Input$FulfillmentStatusEnumFilterInput instance,
    TRes Function(Input$FulfillmentStatusEnumFilterInput) then,
  ) = _CopyWithImpl$Input$FulfillmentStatusEnumFilterInput;

  factory CopyWith$Input$FulfillmentStatusEnumFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FulfillmentStatusEnumFilterInput;

  TRes call({
    Enum$FulfillmentStatus? eq,
    List<Enum$FulfillmentStatus>? oneOf,
  });
}

class _CopyWithImpl$Input$FulfillmentStatusEnumFilterInput<TRes>
    implements CopyWith$Input$FulfillmentStatusEnumFilterInput<TRes> {
  _CopyWithImpl$Input$FulfillmentStatusEnumFilterInput(
    this._instance,
    this._then,
  );

  final Input$FulfillmentStatusEnumFilterInput _instance;

  final TRes Function(Input$FulfillmentStatusEnumFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? oneOf = _undefined,
  }) =>
      _then(Input$FulfillmentStatusEnumFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as Enum$FulfillmentStatus?),
        if (oneOf != _undefined)
          'oneOf': (oneOf as List<Enum$FulfillmentStatus>?),
      }));
}

class _CopyWithStubImpl$Input$FulfillmentStatusEnumFilterInput<TRes>
    implements CopyWith$Input$FulfillmentStatusEnumFilterInput<TRes> {
  _CopyWithStubImpl$Input$FulfillmentStatusEnumFilterInput(this._res);

  TRes _res;

  call({
    Enum$FulfillmentStatus? eq,
    List<Enum$FulfillmentStatus>? oneOf,
  }) =>
      _res;
}

class Input$FulfillmentUpdateTrackingInput {
  factory Input$FulfillmentUpdateTrackingInput({
    String? trackingNumber,
    bool? notifyCustomer,
  }) =>
      Input$FulfillmentUpdateTrackingInput._({
        if (trackingNumber != null) r'trackingNumber': trackingNumber,
        if (notifyCustomer != null) r'notifyCustomer': notifyCustomer,
      });

  Input$FulfillmentUpdateTrackingInput._(this._$data);

  factory Input$FulfillmentUpdateTrackingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('trackingNumber')) {
      final l$trackingNumber = data['trackingNumber'];
      result$data['trackingNumber'] = (l$trackingNumber as String?);
    }
    if (data.containsKey('notifyCustomer')) {
      final l$notifyCustomer = data['notifyCustomer'];
      result$data['notifyCustomer'] = (l$notifyCustomer as bool?);
    }
    return Input$FulfillmentUpdateTrackingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get trackingNumber => (_$data['trackingNumber'] as String?);

  bool? get notifyCustomer => (_$data['notifyCustomer'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('trackingNumber')) {
      final l$trackingNumber = trackingNumber;
      result$data['trackingNumber'] = l$trackingNumber;
    }
    if (_$data.containsKey('notifyCustomer')) {
      final l$notifyCustomer = notifyCustomer;
      result$data['notifyCustomer'] = l$notifyCustomer;
    }
    return result$data;
  }

  CopyWith$Input$FulfillmentUpdateTrackingInput<
          Input$FulfillmentUpdateTrackingInput>
      get copyWith => CopyWith$Input$FulfillmentUpdateTrackingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$FulfillmentUpdateTrackingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$trackingNumber = trackingNumber;
    final lOther$trackingNumber = other.trackingNumber;
    if (_$data.containsKey('trackingNumber') !=
        other._$data.containsKey('trackingNumber')) {
      return false;
    }
    if (l$trackingNumber != lOther$trackingNumber) {
      return false;
    }
    final l$notifyCustomer = notifyCustomer;
    final lOther$notifyCustomer = other.notifyCustomer;
    if (_$data.containsKey('notifyCustomer') !=
        other._$data.containsKey('notifyCustomer')) {
      return false;
    }
    if (l$notifyCustomer != lOther$notifyCustomer) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$trackingNumber = trackingNumber;
    final l$notifyCustomer = notifyCustomer;
    return Object.hashAll([
      _$data.containsKey('trackingNumber') ? l$trackingNumber : const {},
      _$data.containsKey('notifyCustomer') ? l$notifyCustomer : const {},
    ]);
  }
}

abstract class CopyWith$Input$FulfillmentUpdateTrackingInput<TRes> {
  factory CopyWith$Input$FulfillmentUpdateTrackingInput(
    Input$FulfillmentUpdateTrackingInput instance,
    TRes Function(Input$FulfillmentUpdateTrackingInput) then,
  ) = _CopyWithImpl$Input$FulfillmentUpdateTrackingInput;

  factory CopyWith$Input$FulfillmentUpdateTrackingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FulfillmentUpdateTrackingInput;

  TRes call({
    String? trackingNumber,
    bool? notifyCustomer,
  });
}

class _CopyWithImpl$Input$FulfillmentUpdateTrackingInput<TRes>
    implements CopyWith$Input$FulfillmentUpdateTrackingInput<TRes> {
  _CopyWithImpl$Input$FulfillmentUpdateTrackingInput(
    this._instance,
    this._then,
  );

  final Input$FulfillmentUpdateTrackingInput _instance;

  final TRes Function(Input$FulfillmentUpdateTrackingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? trackingNumber = _undefined,
    Object? notifyCustomer = _undefined,
  }) =>
      _then(Input$FulfillmentUpdateTrackingInput._({
        ..._instance._$data,
        if (trackingNumber != _undefined)
          'trackingNumber': (trackingNumber as String?),
        if (notifyCustomer != _undefined)
          'notifyCustomer': (notifyCustomer as bool?),
      }));
}

class _CopyWithStubImpl$Input$FulfillmentUpdateTrackingInput<TRes>
    implements CopyWith$Input$FulfillmentUpdateTrackingInput<TRes> {
  _CopyWithStubImpl$Input$FulfillmentUpdateTrackingInput(this._res);

  TRes _res;

  call({
    String? trackingNumber,
    bool? notifyCustomer,
  }) =>
      _res;
}

class Input$GiftCardAddNoteInput {
  factory Input$GiftCardAddNoteInput({required String message}) =>
      Input$GiftCardAddNoteInput._({
        r'message': message,
      });

  Input$GiftCardAddNoteInput._(this._$data);

  factory Input$GiftCardAddNoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$message = data['message'];
    result$data['message'] = (l$message as String);
    return Input$GiftCardAddNoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get message => (_$data['message'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$message = message;
    result$data['message'] = l$message;
    return result$data;
  }

  CopyWith$Input$GiftCardAddNoteInput<Input$GiftCardAddNoteInput>
      get copyWith => CopyWith$Input$GiftCardAddNoteInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$GiftCardAddNoteInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$message = message;
    return Object.hashAll([l$message]);
  }
}

abstract class CopyWith$Input$GiftCardAddNoteInput<TRes> {
  factory CopyWith$Input$GiftCardAddNoteInput(
    Input$GiftCardAddNoteInput instance,
    TRes Function(Input$GiftCardAddNoteInput) then,
  ) = _CopyWithImpl$Input$GiftCardAddNoteInput;

  factory CopyWith$Input$GiftCardAddNoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GiftCardAddNoteInput;

  TRes call({String? message});
}

class _CopyWithImpl$Input$GiftCardAddNoteInput<TRes>
    implements CopyWith$Input$GiftCardAddNoteInput<TRes> {
  _CopyWithImpl$Input$GiftCardAddNoteInput(
    this._instance,
    this._then,
  );

  final Input$GiftCardAddNoteInput _instance;

  final TRes Function(Input$GiftCardAddNoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? message = _undefined}) =>
      _then(Input$GiftCardAddNoteInput._({
        ..._instance._$data,
        if (message != _undefined && message != null)
          'message': (message as String),
      }));
}

class _CopyWithStubImpl$Input$GiftCardAddNoteInput<TRes>
    implements CopyWith$Input$GiftCardAddNoteInput<TRes> {
  _CopyWithStubImpl$Input$GiftCardAddNoteInput(this._res);

  TRes _res;

  call({String? message}) => _res;
}

class Input$GiftCardBulkCreateInput {
  factory Input$GiftCardBulkCreateInput({
    required int count,
    required Input$PriceInput balance,
    List<String>? tags,
    String? expiryDate,
    required bool isActive,
  }) =>
      Input$GiftCardBulkCreateInput._({
        r'count': count,
        r'balance': balance,
        if (tags != null) r'tags': tags,
        if (expiryDate != null) r'expiryDate': expiryDate,
        r'isActive': isActive,
      });

  Input$GiftCardBulkCreateInput._(this._$data);

  factory Input$GiftCardBulkCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$count = data['count'];
    result$data['count'] = (l$count as int);
    final l$balance = data['balance'];
    result$data['balance'] =
        Input$PriceInput.fromJson((l$balance as Map<String, dynamic>));
    if (data.containsKey('tags')) {
      final l$tags = data['tags'];
      result$data['tags'] =
          (l$tags as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('expiryDate')) {
      final l$expiryDate = data['expiryDate'];
      result$data['expiryDate'] = (l$expiryDate as String?);
    }
    final l$isActive = data['isActive'];
    result$data['isActive'] = (l$isActive as bool);
    return Input$GiftCardBulkCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get count => (_$data['count'] as int);

  Input$PriceInput get balance => (_$data['balance'] as Input$PriceInput);

  List<String>? get tags => (_$data['tags'] as List<String>?);

  String? get expiryDate => (_$data['expiryDate'] as String?);

  bool get isActive => (_$data['isActive'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$count = count;
    result$data['count'] = l$count;
    final l$balance = balance;
    result$data['balance'] = l$balance.toJson();
    if (_$data.containsKey('tags')) {
      final l$tags = tags;
      result$data['tags'] = l$tags?.map((e) => e).toList();
    }
    if (_$data.containsKey('expiryDate')) {
      final l$expiryDate = expiryDate;
      result$data['expiryDate'] = l$expiryDate;
    }
    final l$isActive = isActive;
    result$data['isActive'] = l$isActive;
    return result$data;
  }

  CopyWith$Input$GiftCardBulkCreateInput<Input$GiftCardBulkCreateInput>
      get copyWith => CopyWith$Input$GiftCardBulkCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$GiftCardBulkCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (l$count != lOther$count) {
      return false;
    }
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) {
      return false;
    }
    final l$tags = tags;
    final lOther$tags = other.tags;
    if (_$data.containsKey('tags') != other._$data.containsKey('tags')) {
      return false;
    }
    if (l$tags != null && lOther$tags != null) {
      if (l$tags.length != lOther$tags.length) {
        return false;
      }
      for (int i = 0; i < l$tags.length; i++) {
        final l$tags$entry = l$tags[i];
        final lOther$tags$entry = lOther$tags[i];
        if (l$tags$entry != lOther$tags$entry) {
          return false;
        }
      }
    } else if (l$tags != lOther$tags) {
      return false;
    }
    final l$expiryDate = expiryDate;
    final lOther$expiryDate = other.expiryDate;
    if (_$data.containsKey('expiryDate') !=
        other._$data.containsKey('expiryDate')) {
      return false;
    }
    if (l$expiryDate != lOther$expiryDate) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (l$isActive != lOther$isActive) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$count = count;
    final l$balance = balance;
    final l$tags = tags;
    final l$expiryDate = expiryDate;
    final l$isActive = isActive;
    return Object.hashAll([
      l$count,
      l$balance,
      _$data.containsKey('tags')
          ? l$tags == null
              ? null
              : Object.hashAll(l$tags.map((v) => v))
          : const {},
      _$data.containsKey('expiryDate') ? l$expiryDate : const {},
      l$isActive,
    ]);
  }
}

abstract class CopyWith$Input$GiftCardBulkCreateInput<TRes> {
  factory CopyWith$Input$GiftCardBulkCreateInput(
    Input$GiftCardBulkCreateInput instance,
    TRes Function(Input$GiftCardBulkCreateInput) then,
  ) = _CopyWithImpl$Input$GiftCardBulkCreateInput;

  factory CopyWith$Input$GiftCardBulkCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GiftCardBulkCreateInput;

  TRes call({
    int? count,
    Input$PriceInput? balance,
    List<String>? tags,
    String? expiryDate,
    bool? isActive,
  });
  CopyWith$Input$PriceInput<TRes> get balance;
}

class _CopyWithImpl$Input$GiftCardBulkCreateInput<TRes>
    implements CopyWith$Input$GiftCardBulkCreateInput<TRes> {
  _CopyWithImpl$Input$GiftCardBulkCreateInput(
    this._instance,
    this._then,
  );

  final Input$GiftCardBulkCreateInput _instance;

  final TRes Function(Input$GiftCardBulkCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? count = _undefined,
    Object? balance = _undefined,
    Object? tags = _undefined,
    Object? expiryDate = _undefined,
    Object? isActive = _undefined,
  }) =>
      _then(Input$GiftCardBulkCreateInput._({
        ..._instance._$data,
        if (count != _undefined && count != null) 'count': (count as int),
        if (balance != _undefined && balance != null)
          'balance': (balance as Input$PriceInput),
        if (tags != _undefined) 'tags': (tags as List<String>?),
        if (expiryDate != _undefined) 'expiryDate': (expiryDate as String?),
        if (isActive != _undefined && isActive != null)
          'isActive': (isActive as bool),
      }));

  CopyWith$Input$PriceInput<TRes> get balance {
    final local$balance = _instance.balance;
    return CopyWith$Input$PriceInput(local$balance, (e) => call(balance: e));
  }
}

class _CopyWithStubImpl$Input$GiftCardBulkCreateInput<TRes>
    implements CopyWith$Input$GiftCardBulkCreateInput<TRes> {
  _CopyWithStubImpl$Input$GiftCardBulkCreateInput(this._res);

  TRes _res;

  call({
    int? count,
    Input$PriceInput? balance,
    List<String>? tags,
    String? expiryDate,
    bool? isActive,
  }) =>
      _res;

  CopyWith$Input$PriceInput<TRes> get balance =>
      CopyWith$Input$PriceInput.stub(_res);
}

class Input$GiftCardCreateInput {
  factory Input$GiftCardCreateInput({
    List<String>? addTags,
    String? expiryDate,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? startDate,
    String? endDate,
    required Input$PriceInput balance,
    String? userEmail,
    String? channel,
    required bool isActive,
    String? code,
    String? note,
  }) =>
      Input$GiftCardCreateInput._({
        if (addTags != null) r'addTags': addTags,
        if (expiryDate != null) r'expiryDate': expiryDate,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (startDate != null) r'startDate': startDate,
        if (endDate != null) r'endDate': endDate,
        r'balance': balance,
        if (userEmail != null) r'userEmail': userEmail,
        if (channel != null) r'channel': channel,
        r'isActive': isActive,
        if (code != null) r'code': code,
        if (note != null) r'note': note,
      });

  Input$GiftCardCreateInput._(this._$data);

  factory Input$GiftCardCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('addTags')) {
      final l$addTags = data['addTags'];
      result$data['addTags'] =
          (l$addTags as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('expiryDate')) {
      final l$expiryDate = data['expiryDate'];
      result$data['expiryDate'] = (l$expiryDate as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('startDate')) {
      final l$startDate = data['startDate'];
      result$data['startDate'] = (l$startDate as String?);
    }
    if (data.containsKey('endDate')) {
      final l$endDate = data['endDate'];
      result$data['endDate'] = (l$endDate as String?);
    }
    final l$balance = data['balance'];
    result$data['balance'] =
        Input$PriceInput.fromJson((l$balance as Map<String, dynamic>));
    if (data.containsKey('userEmail')) {
      final l$userEmail = data['userEmail'];
      result$data['userEmail'] = (l$userEmail as String?);
    }
    if (data.containsKey('channel')) {
      final l$channel = data['channel'];
      result$data['channel'] = (l$channel as String?);
    }
    final l$isActive = data['isActive'];
    result$data['isActive'] = (l$isActive as bool);
    if (data.containsKey('code')) {
      final l$code = data['code'];
      result$data['code'] = (l$code as String?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    return Input$GiftCardCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get addTags => (_$data['addTags'] as List<String>?);

  String? get expiryDate => (_$data['expiryDate'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  String? get startDate => (_$data['startDate'] as String?);

  String? get endDate => (_$data['endDate'] as String?);

  Input$PriceInput get balance => (_$data['balance'] as Input$PriceInput);

  String? get userEmail => (_$data['userEmail'] as String?);

  String? get channel => (_$data['channel'] as String?);

  bool get isActive => (_$data['isActive'] as bool);

  String? get code => (_$data['code'] as String?);

  String? get note => (_$data['note'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('addTags')) {
      final l$addTags = addTags;
      result$data['addTags'] = l$addTags?.map((e) => e).toList();
    }
    if (_$data.containsKey('expiryDate')) {
      final l$expiryDate = expiryDate;
      result$data['expiryDate'] = l$expiryDate;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('startDate')) {
      final l$startDate = startDate;
      result$data['startDate'] = l$startDate;
    }
    if (_$data.containsKey('endDate')) {
      final l$endDate = endDate;
      result$data['endDate'] = l$endDate;
    }
    final l$balance = balance;
    result$data['balance'] = l$balance.toJson();
    if (_$data.containsKey('userEmail')) {
      final l$userEmail = userEmail;
      result$data['userEmail'] = l$userEmail;
    }
    if (_$data.containsKey('channel')) {
      final l$channel = channel;
      result$data['channel'] = l$channel;
    }
    final l$isActive = isActive;
    result$data['isActive'] = l$isActive;
    if (_$data.containsKey('code')) {
      final l$code = code;
      result$data['code'] = l$code;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    return result$data;
  }

  CopyWith$Input$GiftCardCreateInput<Input$GiftCardCreateInput> get copyWith =>
      CopyWith$Input$GiftCardCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$GiftCardCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$addTags = addTags;
    final lOther$addTags = other.addTags;
    if (_$data.containsKey('addTags') != other._$data.containsKey('addTags')) {
      return false;
    }
    if (l$addTags != null && lOther$addTags != null) {
      if (l$addTags.length != lOther$addTags.length) {
        return false;
      }
      for (int i = 0; i < l$addTags.length; i++) {
        final l$addTags$entry = l$addTags[i];
        final lOther$addTags$entry = lOther$addTags[i];
        if (l$addTags$entry != lOther$addTags$entry) {
          return false;
        }
      }
    } else if (l$addTags != lOther$addTags) {
      return false;
    }
    final l$expiryDate = expiryDate;
    final lOther$expiryDate = other.expiryDate;
    if (_$data.containsKey('expiryDate') !=
        other._$data.containsKey('expiryDate')) {
      return false;
    }
    if (l$expiryDate != lOther$expiryDate) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (_$data.containsKey('startDate') !=
        other._$data.containsKey('startDate')) {
      return false;
    }
    if (l$startDate != lOther$startDate) {
      return false;
    }
    final l$endDate = endDate;
    final lOther$endDate = other.endDate;
    if (_$data.containsKey('endDate') != other._$data.containsKey('endDate')) {
      return false;
    }
    if (l$endDate != lOther$endDate) {
      return false;
    }
    final l$balance = balance;
    final lOther$balance = other.balance;
    if (l$balance != lOther$balance) {
      return false;
    }
    final l$userEmail = userEmail;
    final lOther$userEmail = other.userEmail;
    if (_$data.containsKey('userEmail') !=
        other._$data.containsKey('userEmail')) {
      return false;
    }
    if (l$userEmail != lOther$userEmail) {
      return false;
    }
    final l$channel = channel;
    final lOther$channel = other.channel;
    if (_$data.containsKey('channel') != other._$data.containsKey('channel')) {
      return false;
    }
    if (l$channel != lOther$channel) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$code = code;
    final lOther$code = other.code;
    if (_$data.containsKey('code') != other._$data.containsKey('code')) {
      return false;
    }
    if (l$code != lOther$code) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$addTags = addTags;
    final l$expiryDate = expiryDate;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$startDate = startDate;
    final l$endDate = endDate;
    final l$balance = balance;
    final l$userEmail = userEmail;
    final l$channel = channel;
    final l$isActive = isActive;
    final l$code = code;
    final l$note = note;
    return Object.hashAll([
      _$data.containsKey('addTags')
          ? l$addTags == null
              ? null
              : Object.hashAll(l$addTags.map((v) => v))
          : const {},
      _$data.containsKey('expiryDate') ? l$expiryDate : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('startDate') ? l$startDate : const {},
      _$data.containsKey('endDate') ? l$endDate : const {},
      l$balance,
      _$data.containsKey('userEmail') ? l$userEmail : const {},
      _$data.containsKey('channel') ? l$channel : const {},
      l$isActive,
      _$data.containsKey('code') ? l$code : const {},
      _$data.containsKey('note') ? l$note : const {},
    ]);
  }
}

abstract class CopyWith$Input$GiftCardCreateInput<TRes> {
  factory CopyWith$Input$GiftCardCreateInput(
    Input$GiftCardCreateInput instance,
    TRes Function(Input$GiftCardCreateInput) then,
  ) = _CopyWithImpl$Input$GiftCardCreateInput;

  factory CopyWith$Input$GiftCardCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GiftCardCreateInput;

  TRes call({
    List<String>? addTags,
    String? expiryDate,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? startDate,
    String? endDate,
    Input$PriceInput? balance,
    String? userEmail,
    String? channel,
    bool? isActive,
    String? code,
    String? note,
  });
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  CopyWith$Input$PriceInput<TRes> get balance;
}

class _CopyWithImpl$Input$GiftCardCreateInput<TRes>
    implements CopyWith$Input$GiftCardCreateInput<TRes> {
  _CopyWithImpl$Input$GiftCardCreateInput(
    this._instance,
    this._then,
  );

  final Input$GiftCardCreateInput _instance;

  final TRes Function(Input$GiftCardCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? addTags = _undefined,
    Object? expiryDate = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? startDate = _undefined,
    Object? endDate = _undefined,
    Object? balance = _undefined,
    Object? userEmail = _undefined,
    Object? channel = _undefined,
    Object? isActive = _undefined,
    Object? code = _undefined,
    Object? note = _undefined,
  }) =>
      _then(Input$GiftCardCreateInput._({
        ..._instance._$data,
        if (addTags != _undefined) 'addTags': (addTags as List<String>?),
        if (expiryDate != _undefined) 'expiryDate': (expiryDate as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (startDate != _undefined) 'startDate': (startDate as String?),
        if (endDate != _undefined) 'endDate': (endDate as String?),
        if (balance != _undefined && balance != null)
          'balance': (balance as Input$PriceInput),
        if (userEmail != _undefined) 'userEmail': (userEmail as String?),
        if (channel != _undefined) 'channel': (channel as String?),
        if (isActive != _undefined && isActive != null)
          'isActive': (isActive as bool),
        if (code != _undefined) 'code': (code as String?),
        if (note != _undefined) 'note': (note as String?),
      }));

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$PriceInput<TRes> get balance {
    final local$balance = _instance.balance;
    return CopyWith$Input$PriceInput(local$balance, (e) => call(balance: e));
  }
}

class _CopyWithStubImpl$Input$GiftCardCreateInput<TRes>
    implements CopyWith$Input$GiftCardCreateInput<TRes> {
  _CopyWithStubImpl$Input$GiftCardCreateInput(this._res);

  TRes _res;

  call({
    List<String>? addTags,
    String? expiryDate,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? startDate,
    String? endDate,
    Input$PriceInput? balance,
    String? userEmail,
    String? channel,
    bool? isActive,
    String? code,
    String? note,
  }) =>
      _res;

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;

  CopyWith$Input$PriceInput<TRes> get balance =>
      CopyWith$Input$PriceInput.stub(_res);
}

class Input$GiftCardEventFilterInput {
  factory Input$GiftCardEventFilterInput({
    Enum$GiftCardEventsEnum? type,
    List<String>? orders,
  }) =>
      Input$GiftCardEventFilterInput._({
        if (type != null) r'type': type,
        if (orders != null) r'orders': orders,
      });

  Input$GiftCardEventFilterInput._(this._$data);

  factory Input$GiftCardEventFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : fromJson$Enum$GiftCardEventsEnum((l$type as String));
    }
    if (data.containsKey('orders')) {
      final l$orders = data['orders'];
      result$data['orders'] =
          (l$orders as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$GiftCardEventFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$GiftCardEventsEnum? get type =>
      (_$data['type'] as Enum$GiftCardEventsEnum?);

  List<String>? get orders => (_$data['orders'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] =
          l$type == null ? null : toJson$Enum$GiftCardEventsEnum(l$type);
    }
    if (_$data.containsKey('orders')) {
      final l$orders = orders;
      result$data['orders'] = l$orders?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$GiftCardEventFilterInput<Input$GiftCardEventFilterInput>
      get copyWith => CopyWith$Input$GiftCardEventFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$GiftCardEventFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$orders = orders;
    final lOther$orders = other.orders;
    if (_$data.containsKey('orders') != other._$data.containsKey('orders')) {
      return false;
    }
    if (l$orders != null && lOther$orders != null) {
      if (l$orders.length != lOther$orders.length) {
        return false;
      }
      for (int i = 0; i < l$orders.length; i++) {
        final l$orders$entry = l$orders[i];
        final lOther$orders$entry = lOther$orders[i];
        if (l$orders$entry != lOther$orders$entry) {
          return false;
        }
      }
    } else if (l$orders != lOther$orders) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$type = type;
    final l$orders = orders;
    return Object.hashAll([
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('orders')
          ? l$orders == null
              ? null
              : Object.hashAll(l$orders.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$GiftCardEventFilterInput<TRes> {
  factory CopyWith$Input$GiftCardEventFilterInput(
    Input$GiftCardEventFilterInput instance,
    TRes Function(Input$GiftCardEventFilterInput) then,
  ) = _CopyWithImpl$Input$GiftCardEventFilterInput;

  factory CopyWith$Input$GiftCardEventFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GiftCardEventFilterInput;

  TRes call({
    Enum$GiftCardEventsEnum? type,
    List<String>? orders,
  });
}

class _CopyWithImpl$Input$GiftCardEventFilterInput<TRes>
    implements CopyWith$Input$GiftCardEventFilterInput<TRes> {
  _CopyWithImpl$Input$GiftCardEventFilterInput(
    this._instance,
    this._then,
  );

  final Input$GiftCardEventFilterInput _instance;

  final TRes Function(Input$GiftCardEventFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? type = _undefined,
    Object? orders = _undefined,
  }) =>
      _then(Input$GiftCardEventFilterInput._({
        ..._instance._$data,
        if (type != _undefined) 'type': (type as Enum$GiftCardEventsEnum?),
        if (orders != _undefined) 'orders': (orders as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$GiftCardEventFilterInput<TRes>
    implements CopyWith$Input$GiftCardEventFilterInput<TRes> {
  _CopyWithStubImpl$Input$GiftCardEventFilterInput(this._res);

  TRes _res;

  call({
    Enum$GiftCardEventsEnum? type,
    List<String>? orders,
  }) =>
      _res;
}

class Input$GiftCardFilterInput {
  factory Input$GiftCardFilterInput({
    bool? isActive,
    List<Input$MetadataFilter>? metadata,
    List<String>? tags,
    List<String>? products,
    List<String>? usedBy,
    bool? used,
    String? currency,
    Input$PriceRangeInput? currentBalance,
    Input$PriceRangeInput? initialBalance,
    String? code,
    String? createdByEmail,
  }) =>
      Input$GiftCardFilterInput._({
        if (isActive != null) r'isActive': isActive,
        if (metadata != null) r'metadata': metadata,
        if (tags != null) r'tags': tags,
        if (products != null) r'products': products,
        if (usedBy != null) r'usedBy': usedBy,
        if (used != null) r'used': used,
        if (currency != null) r'currency': currency,
        if (currentBalance != null) r'currentBalance': currentBalance,
        if (initialBalance != null) r'initialBalance': initialBalance,
        if (code != null) r'code': code,
        if (createdByEmail != null) r'createdByEmail': createdByEmail,
      });

  Input$GiftCardFilterInput._(this._$data);

  factory Input$GiftCardFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = (l$isActive as bool?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('tags')) {
      final l$tags = data['tags'];
      result$data['tags'] =
          (l$tags as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('products')) {
      final l$products = data['products'];
      result$data['products'] =
          (l$products as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('usedBy')) {
      final l$usedBy = data['usedBy'];
      result$data['usedBy'] =
          (l$usedBy as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('used')) {
      final l$used = data['used'];
      result$data['used'] = (l$used as bool?);
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = (l$currency as String?);
    }
    if (data.containsKey('currentBalance')) {
      final l$currentBalance = data['currentBalance'];
      result$data['currentBalance'] = l$currentBalance == null
          ? null
          : Input$PriceRangeInput.fromJson(
              (l$currentBalance as Map<String, dynamic>));
    }
    if (data.containsKey('initialBalance')) {
      final l$initialBalance = data['initialBalance'];
      result$data['initialBalance'] = l$initialBalance == null
          ? null
          : Input$PriceRangeInput.fromJson(
              (l$initialBalance as Map<String, dynamic>));
    }
    if (data.containsKey('code')) {
      final l$code = data['code'];
      result$data['code'] = (l$code as String?);
    }
    if (data.containsKey('createdByEmail')) {
      final l$createdByEmail = data['createdByEmail'];
      result$data['createdByEmail'] = (l$createdByEmail as String?);
    }
    return Input$GiftCardFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get isActive => (_$data['isActive'] as bool?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get tags => (_$data['tags'] as List<String>?);

  List<String>? get products => (_$data['products'] as List<String>?);

  List<String>? get usedBy => (_$data['usedBy'] as List<String>?);

  bool? get used => (_$data['used'] as bool?);

  String? get currency => (_$data['currency'] as String?);

  Input$PriceRangeInput? get currentBalance =>
      (_$data['currentBalance'] as Input$PriceRangeInput?);

  Input$PriceRangeInput? get initialBalance =>
      (_$data['initialBalance'] as Input$PriceRangeInput?);

  String? get code => (_$data['code'] as String?);

  String? get createdByEmail => (_$data['createdByEmail'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('tags')) {
      final l$tags = tags;
      result$data['tags'] = l$tags?.map((e) => e).toList();
    }
    if (_$data.containsKey('products')) {
      final l$products = products;
      result$data['products'] = l$products?.map((e) => e).toList();
    }
    if (_$data.containsKey('usedBy')) {
      final l$usedBy = usedBy;
      result$data['usedBy'] = l$usedBy?.map((e) => e).toList();
    }
    if (_$data.containsKey('used')) {
      final l$used = used;
      result$data['used'] = l$used;
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency;
    }
    if (_$data.containsKey('currentBalance')) {
      final l$currentBalance = currentBalance;
      result$data['currentBalance'] = l$currentBalance?.toJson();
    }
    if (_$data.containsKey('initialBalance')) {
      final l$initialBalance = initialBalance;
      result$data['initialBalance'] = l$initialBalance?.toJson();
    }
    if (_$data.containsKey('code')) {
      final l$code = code;
      result$data['code'] = l$code;
    }
    if (_$data.containsKey('createdByEmail')) {
      final l$createdByEmail = createdByEmail;
      result$data['createdByEmail'] = l$createdByEmail;
    }
    return result$data;
  }

  CopyWith$Input$GiftCardFilterInput<Input$GiftCardFilterInput> get copyWith =>
      CopyWith$Input$GiftCardFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$GiftCardFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$tags = tags;
    final lOther$tags = other.tags;
    if (_$data.containsKey('tags') != other._$data.containsKey('tags')) {
      return false;
    }
    if (l$tags != null && lOther$tags != null) {
      if (l$tags.length != lOther$tags.length) {
        return false;
      }
      for (int i = 0; i < l$tags.length; i++) {
        final l$tags$entry = l$tags[i];
        final lOther$tags$entry = lOther$tags[i];
        if (l$tags$entry != lOther$tags$entry) {
          return false;
        }
      }
    } else if (l$tags != lOther$tags) {
      return false;
    }
    final l$products = products;
    final lOther$products = other.products;
    if (_$data.containsKey('products') !=
        other._$data.containsKey('products')) {
      return false;
    }
    if (l$products != null && lOther$products != null) {
      if (l$products.length != lOther$products.length) {
        return false;
      }
      for (int i = 0; i < l$products.length; i++) {
        final l$products$entry = l$products[i];
        final lOther$products$entry = lOther$products[i];
        if (l$products$entry != lOther$products$entry) {
          return false;
        }
      }
    } else if (l$products != lOther$products) {
      return false;
    }
    final l$usedBy = usedBy;
    final lOther$usedBy = other.usedBy;
    if (_$data.containsKey('usedBy') != other._$data.containsKey('usedBy')) {
      return false;
    }
    if (l$usedBy != null && lOther$usedBy != null) {
      if (l$usedBy.length != lOther$usedBy.length) {
        return false;
      }
      for (int i = 0; i < l$usedBy.length; i++) {
        final l$usedBy$entry = l$usedBy[i];
        final lOther$usedBy$entry = lOther$usedBy[i];
        if (l$usedBy$entry != lOther$usedBy$entry) {
          return false;
        }
      }
    } else if (l$usedBy != lOther$usedBy) {
      return false;
    }
    final l$used = used;
    final lOther$used = other.used;
    if (_$data.containsKey('used') != other._$data.containsKey('used')) {
      return false;
    }
    if (l$used != lOther$used) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$currentBalance = currentBalance;
    final lOther$currentBalance = other.currentBalance;
    if (_$data.containsKey('currentBalance') !=
        other._$data.containsKey('currentBalance')) {
      return false;
    }
    if (l$currentBalance != lOther$currentBalance) {
      return false;
    }
    final l$initialBalance = initialBalance;
    final lOther$initialBalance = other.initialBalance;
    if (_$data.containsKey('initialBalance') !=
        other._$data.containsKey('initialBalance')) {
      return false;
    }
    if (l$initialBalance != lOther$initialBalance) {
      return false;
    }
    final l$code = code;
    final lOther$code = other.code;
    if (_$data.containsKey('code') != other._$data.containsKey('code')) {
      return false;
    }
    if (l$code != lOther$code) {
      return false;
    }
    final l$createdByEmail = createdByEmail;
    final lOther$createdByEmail = other.createdByEmail;
    if (_$data.containsKey('createdByEmail') !=
        other._$data.containsKey('createdByEmail')) {
      return false;
    }
    if (l$createdByEmail != lOther$createdByEmail) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$isActive = isActive;
    final l$metadata = metadata;
    final l$tags = tags;
    final l$products = products;
    final l$usedBy = usedBy;
    final l$used = used;
    final l$currency = currency;
    final l$currentBalance = currentBalance;
    final l$initialBalance = initialBalance;
    final l$code = code;
    final l$createdByEmail = createdByEmail;
    return Object.hashAll([
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('tags')
          ? l$tags == null
              ? null
              : Object.hashAll(l$tags.map((v) => v))
          : const {},
      _$data.containsKey('products')
          ? l$products == null
              ? null
              : Object.hashAll(l$products.map((v) => v))
          : const {},
      _$data.containsKey('usedBy')
          ? l$usedBy == null
              ? null
              : Object.hashAll(l$usedBy.map((v) => v))
          : const {},
      _$data.containsKey('used') ? l$used : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('currentBalance') ? l$currentBalance : const {},
      _$data.containsKey('initialBalance') ? l$initialBalance : const {},
      _$data.containsKey('code') ? l$code : const {},
      _$data.containsKey('createdByEmail') ? l$createdByEmail : const {},
    ]);
  }
}

abstract class CopyWith$Input$GiftCardFilterInput<TRes> {
  factory CopyWith$Input$GiftCardFilterInput(
    Input$GiftCardFilterInput instance,
    TRes Function(Input$GiftCardFilterInput) then,
  ) = _CopyWithImpl$Input$GiftCardFilterInput;

  factory CopyWith$Input$GiftCardFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GiftCardFilterInput;

  TRes call({
    bool? isActive,
    List<Input$MetadataFilter>? metadata,
    List<String>? tags,
    List<String>? products,
    List<String>? usedBy,
    bool? used,
    String? currency,
    Input$PriceRangeInput? currentBalance,
    Input$PriceRangeInput? initialBalance,
    String? code,
    String? createdByEmail,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
  CopyWith$Input$PriceRangeInput<TRes> get currentBalance;
  CopyWith$Input$PriceRangeInput<TRes> get initialBalance;
}

class _CopyWithImpl$Input$GiftCardFilterInput<TRes>
    implements CopyWith$Input$GiftCardFilterInput<TRes> {
  _CopyWithImpl$Input$GiftCardFilterInput(
    this._instance,
    this._then,
  );

  final Input$GiftCardFilterInput _instance;

  final TRes Function(Input$GiftCardFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? isActive = _undefined,
    Object? metadata = _undefined,
    Object? tags = _undefined,
    Object? products = _undefined,
    Object? usedBy = _undefined,
    Object? used = _undefined,
    Object? currency = _undefined,
    Object? currentBalance = _undefined,
    Object? initialBalance = _undefined,
    Object? code = _undefined,
    Object? createdByEmail = _undefined,
  }) =>
      _then(Input$GiftCardFilterInput._({
        ..._instance._$data,
        if (isActive != _undefined) 'isActive': (isActive as bool?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (tags != _undefined) 'tags': (tags as List<String>?),
        if (products != _undefined) 'products': (products as List<String>?),
        if (usedBy != _undefined) 'usedBy': (usedBy as List<String>?),
        if (used != _undefined) 'used': (used as bool?),
        if (currency != _undefined) 'currency': (currency as String?),
        if (currentBalance != _undefined)
          'currentBalance': (currentBalance as Input$PriceRangeInput?),
        if (initialBalance != _undefined)
          'initialBalance': (initialBalance as Input$PriceRangeInput?),
        if (code != _undefined) 'code': (code as String?),
        if (createdByEmail != _undefined)
          'createdByEmail': (createdByEmail as String?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$PriceRangeInput<TRes> get currentBalance {
    final local$currentBalance = _instance.currentBalance;
    return local$currentBalance == null
        ? CopyWith$Input$PriceRangeInput.stub(_then(_instance))
        : CopyWith$Input$PriceRangeInput(
            local$currentBalance, (e) => call(currentBalance: e));
  }

  CopyWith$Input$PriceRangeInput<TRes> get initialBalance {
    final local$initialBalance = _instance.initialBalance;
    return local$initialBalance == null
        ? CopyWith$Input$PriceRangeInput.stub(_then(_instance))
        : CopyWith$Input$PriceRangeInput(
            local$initialBalance, (e) => call(initialBalance: e));
  }
}

class _CopyWithStubImpl$Input$GiftCardFilterInput<TRes>
    implements CopyWith$Input$GiftCardFilterInput<TRes> {
  _CopyWithStubImpl$Input$GiftCardFilterInput(this._res);

  TRes _res;

  call({
    bool? isActive,
    List<Input$MetadataFilter>? metadata,
    List<String>? tags,
    List<String>? products,
    List<String>? usedBy,
    bool? used,
    String? currency,
    Input$PriceRangeInput? currentBalance,
    Input$PriceRangeInput? initialBalance,
    String? code,
    String? createdByEmail,
  }) =>
      _res;

  metadata(_fn) => _res;

  CopyWith$Input$PriceRangeInput<TRes> get currentBalance =>
      CopyWith$Input$PriceRangeInput.stub(_res);

  CopyWith$Input$PriceRangeInput<TRes> get initialBalance =>
      CopyWith$Input$PriceRangeInput.stub(_res);
}

class Input$GiftCardResendInput {
  factory Input$GiftCardResendInput({
    required String id,
    String? email,
    required String channel,
  }) =>
      Input$GiftCardResendInput._({
        r'id': id,
        if (email != null) r'email': email,
        r'channel': channel,
      });

  Input$GiftCardResendInput._(this._$data);

  factory Input$GiftCardResendInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    final l$channel = data['channel'];
    result$data['channel'] = (l$channel as String);
    return Input$GiftCardResendInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);

  String? get email => (_$data['email'] as String?);

  String get channel => (_$data['channel'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    final l$channel = channel;
    result$data['channel'] = l$channel;
    return result$data;
  }

  CopyWith$Input$GiftCardResendInput<Input$GiftCardResendInput> get copyWith =>
      CopyWith$Input$GiftCardResendInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$GiftCardResendInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$channel = channel;
    final lOther$channel = other.channel;
    if (l$channel != lOther$channel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$channel = channel;
    return Object.hashAll([
      l$id,
      _$data.containsKey('email') ? l$email : const {},
      l$channel,
    ]);
  }
}

abstract class CopyWith$Input$GiftCardResendInput<TRes> {
  factory CopyWith$Input$GiftCardResendInput(
    Input$GiftCardResendInput instance,
    TRes Function(Input$GiftCardResendInput) then,
  ) = _CopyWithImpl$Input$GiftCardResendInput;

  factory CopyWith$Input$GiftCardResendInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GiftCardResendInput;

  TRes call({
    String? id,
    String? email,
    String? channel,
  });
}

class _CopyWithImpl$Input$GiftCardResendInput<TRes>
    implements CopyWith$Input$GiftCardResendInput<TRes> {
  _CopyWithImpl$Input$GiftCardResendInput(
    this._instance,
    this._then,
  );

  final Input$GiftCardResendInput _instance;

  final TRes Function(Input$GiftCardResendInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? email = _undefined,
    Object? channel = _undefined,
  }) =>
      _then(Input$GiftCardResendInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (email != _undefined) 'email': (email as String?),
        if (channel != _undefined && channel != null)
          'channel': (channel as String),
      }));
}

class _CopyWithStubImpl$Input$GiftCardResendInput<TRes>
    implements CopyWith$Input$GiftCardResendInput<TRes> {
  _CopyWithStubImpl$Input$GiftCardResendInput(this._res);

  TRes _res;

  call({
    String? id,
    String? email,
    String? channel,
  }) =>
      _res;
}

class Input$GiftCardSettingsUpdateInput {
  factory Input$GiftCardSettingsUpdateInput({
    Enum$GiftCardSettingsExpiryTypeEnum? expiryType,
    Input$TimePeriodInputType? expiryPeriod,
  }) =>
      Input$GiftCardSettingsUpdateInput._({
        if (expiryType != null) r'expiryType': expiryType,
        if (expiryPeriod != null) r'expiryPeriod': expiryPeriod,
      });

  Input$GiftCardSettingsUpdateInput._(this._$data);

  factory Input$GiftCardSettingsUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('expiryType')) {
      final l$expiryType = data['expiryType'];
      result$data['expiryType'] = l$expiryType == null
          ? null
          : fromJson$Enum$GiftCardSettingsExpiryTypeEnum(
              (l$expiryType as String));
    }
    if (data.containsKey('expiryPeriod')) {
      final l$expiryPeriod = data['expiryPeriod'];
      result$data['expiryPeriod'] = l$expiryPeriod == null
          ? null
          : Input$TimePeriodInputType.fromJson(
              (l$expiryPeriod as Map<String, dynamic>));
    }
    return Input$GiftCardSettingsUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$GiftCardSettingsExpiryTypeEnum? get expiryType =>
      (_$data['expiryType'] as Enum$GiftCardSettingsExpiryTypeEnum?);

  Input$TimePeriodInputType? get expiryPeriod =>
      (_$data['expiryPeriod'] as Input$TimePeriodInputType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('expiryType')) {
      final l$expiryType = expiryType;
      result$data['expiryType'] = l$expiryType == null
          ? null
          : toJson$Enum$GiftCardSettingsExpiryTypeEnum(l$expiryType);
    }
    if (_$data.containsKey('expiryPeriod')) {
      final l$expiryPeriod = expiryPeriod;
      result$data['expiryPeriod'] = l$expiryPeriod?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GiftCardSettingsUpdateInput<Input$GiftCardSettingsUpdateInput>
      get copyWith => CopyWith$Input$GiftCardSettingsUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$GiftCardSettingsUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$expiryType = expiryType;
    final lOther$expiryType = other.expiryType;
    if (_$data.containsKey('expiryType') !=
        other._$data.containsKey('expiryType')) {
      return false;
    }
    if (l$expiryType != lOther$expiryType) {
      return false;
    }
    final l$expiryPeriod = expiryPeriod;
    final lOther$expiryPeriod = other.expiryPeriod;
    if (_$data.containsKey('expiryPeriod') !=
        other._$data.containsKey('expiryPeriod')) {
      return false;
    }
    if (l$expiryPeriod != lOther$expiryPeriod) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$expiryType = expiryType;
    final l$expiryPeriod = expiryPeriod;
    return Object.hashAll([
      _$data.containsKey('expiryType') ? l$expiryType : const {},
      _$data.containsKey('expiryPeriod') ? l$expiryPeriod : const {},
    ]);
  }
}

abstract class CopyWith$Input$GiftCardSettingsUpdateInput<TRes> {
  factory CopyWith$Input$GiftCardSettingsUpdateInput(
    Input$GiftCardSettingsUpdateInput instance,
    TRes Function(Input$GiftCardSettingsUpdateInput) then,
  ) = _CopyWithImpl$Input$GiftCardSettingsUpdateInput;

  factory CopyWith$Input$GiftCardSettingsUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GiftCardSettingsUpdateInput;

  TRes call({
    Enum$GiftCardSettingsExpiryTypeEnum? expiryType,
    Input$TimePeriodInputType? expiryPeriod,
  });
  CopyWith$Input$TimePeriodInputType<TRes> get expiryPeriod;
}

class _CopyWithImpl$Input$GiftCardSettingsUpdateInput<TRes>
    implements CopyWith$Input$GiftCardSettingsUpdateInput<TRes> {
  _CopyWithImpl$Input$GiftCardSettingsUpdateInput(
    this._instance,
    this._then,
  );

  final Input$GiftCardSettingsUpdateInput _instance;

  final TRes Function(Input$GiftCardSettingsUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? expiryType = _undefined,
    Object? expiryPeriod = _undefined,
  }) =>
      _then(Input$GiftCardSettingsUpdateInput._({
        ..._instance._$data,
        if (expiryType != _undefined)
          'expiryType': (expiryType as Enum$GiftCardSettingsExpiryTypeEnum?),
        if (expiryPeriod != _undefined)
          'expiryPeriod': (expiryPeriod as Input$TimePeriodInputType?),
      }));

  CopyWith$Input$TimePeriodInputType<TRes> get expiryPeriod {
    final local$expiryPeriod = _instance.expiryPeriod;
    return local$expiryPeriod == null
        ? CopyWith$Input$TimePeriodInputType.stub(_then(_instance))
        : CopyWith$Input$TimePeriodInputType(
            local$expiryPeriod, (e) => call(expiryPeriod: e));
  }
}

class _CopyWithStubImpl$Input$GiftCardSettingsUpdateInput<TRes>
    implements CopyWith$Input$GiftCardSettingsUpdateInput<TRes> {
  _CopyWithStubImpl$Input$GiftCardSettingsUpdateInput(this._res);

  TRes _res;

  call({
    Enum$GiftCardSettingsExpiryTypeEnum? expiryType,
    Input$TimePeriodInputType? expiryPeriod,
  }) =>
      _res;

  CopyWith$Input$TimePeriodInputType<TRes> get expiryPeriod =>
      CopyWith$Input$TimePeriodInputType.stub(_res);
}

class Input$GiftCardSortingInput {
  factory Input$GiftCardSortingInput({
    required Enum$OrderDirection direction,
    required Enum$GiftCardSortField field,
  }) =>
      Input$GiftCardSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$GiftCardSortingInput._(this._$data);

  factory Input$GiftCardSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$GiftCardSortField((l$field as String));
    return Input$GiftCardSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$GiftCardSortField get field =>
      (_$data['field'] as Enum$GiftCardSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$GiftCardSortField(l$field);
    return result$data;
  }

  CopyWith$Input$GiftCardSortingInput<Input$GiftCardSortingInput>
      get copyWith => CopyWith$Input$GiftCardSortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$GiftCardSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$GiftCardSortingInput<TRes> {
  factory CopyWith$Input$GiftCardSortingInput(
    Input$GiftCardSortingInput instance,
    TRes Function(Input$GiftCardSortingInput) then,
  ) = _CopyWithImpl$Input$GiftCardSortingInput;

  factory CopyWith$Input$GiftCardSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GiftCardSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$GiftCardSortField? field,
  });
}

class _CopyWithImpl$Input$GiftCardSortingInput<TRes>
    implements CopyWith$Input$GiftCardSortingInput<TRes> {
  _CopyWithImpl$Input$GiftCardSortingInput(
    this._instance,
    this._then,
  );

  final Input$GiftCardSortingInput _instance;

  final TRes Function(Input$GiftCardSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$GiftCardSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$GiftCardSortField),
      }));
}

class _CopyWithStubImpl$Input$GiftCardSortingInput<TRes>
    implements CopyWith$Input$GiftCardSortingInput<TRes> {
  _CopyWithStubImpl$Input$GiftCardSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$GiftCardSortField? field,
  }) =>
      _res;
}

class Input$GiftCardTagFilterInput {
  factory Input$GiftCardTagFilterInput({String? search}) =>
      Input$GiftCardTagFilterInput._({
        if (search != null) r'search': search,
      });

  Input$GiftCardTagFilterInput._(this._$data);

  factory Input$GiftCardTagFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    return Input$GiftCardTagFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get search => (_$data['search'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    return result$data;
  }

  CopyWith$Input$GiftCardTagFilterInput<Input$GiftCardTagFilterInput>
      get copyWith => CopyWith$Input$GiftCardTagFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$GiftCardTagFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$search = search;
    return Object.hashAll([_$data.containsKey('search') ? l$search : const {}]);
  }
}

abstract class CopyWith$Input$GiftCardTagFilterInput<TRes> {
  factory CopyWith$Input$GiftCardTagFilterInput(
    Input$GiftCardTagFilterInput instance,
    TRes Function(Input$GiftCardTagFilterInput) then,
  ) = _CopyWithImpl$Input$GiftCardTagFilterInput;

  factory CopyWith$Input$GiftCardTagFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GiftCardTagFilterInput;

  TRes call({String? search});
}

class _CopyWithImpl$Input$GiftCardTagFilterInput<TRes>
    implements CopyWith$Input$GiftCardTagFilterInput<TRes> {
  _CopyWithImpl$Input$GiftCardTagFilterInput(
    this._instance,
    this._then,
  );

  final Input$GiftCardTagFilterInput _instance;

  final TRes Function(Input$GiftCardTagFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? search = _undefined}) =>
      _then(Input$GiftCardTagFilterInput._({
        ..._instance._$data,
        if (search != _undefined) 'search': (search as String?),
      }));
}

class _CopyWithStubImpl$Input$GiftCardTagFilterInput<TRes>
    implements CopyWith$Input$GiftCardTagFilterInput<TRes> {
  _CopyWithStubImpl$Input$GiftCardTagFilterInput(this._res);

  TRes _res;

  call({String? search}) => _res;
}

class Input$GiftCardUpdateInput {
  factory Input$GiftCardUpdateInput({
    List<String>? addTags,
    String? expiryDate,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? startDate,
    String? endDate,
    List<String>? removeTags,
    String? balanceAmount,
  }) =>
      Input$GiftCardUpdateInput._({
        if (addTags != null) r'addTags': addTags,
        if (expiryDate != null) r'expiryDate': expiryDate,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (startDate != null) r'startDate': startDate,
        if (endDate != null) r'endDate': endDate,
        if (removeTags != null) r'removeTags': removeTags,
        if (balanceAmount != null) r'balanceAmount': balanceAmount,
      });

  Input$GiftCardUpdateInput._(this._$data);

  factory Input$GiftCardUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('addTags')) {
      final l$addTags = data['addTags'];
      result$data['addTags'] =
          (l$addTags as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('expiryDate')) {
      final l$expiryDate = data['expiryDate'];
      result$data['expiryDate'] = (l$expiryDate as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('startDate')) {
      final l$startDate = data['startDate'];
      result$data['startDate'] = (l$startDate as String?);
    }
    if (data.containsKey('endDate')) {
      final l$endDate = data['endDate'];
      result$data['endDate'] = (l$endDate as String?);
    }
    if (data.containsKey('removeTags')) {
      final l$removeTags = data['removeTags'];
      result$data['removeTags'] =
          (l$removeTags as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('balanceAmount')) {
      final l$balanceAmount = data['balanceAmount'];
      result$data['balanceAmount'] = (l$balanceAmount as String?);
    }
    return Input$GiftCardUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get addTags => (_$data['addTags'] as List<String>?);

  String? get expiryDate => (_$data['expiryDate'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  String? get startDate => (_$data['startDate'] as String?);

  String? get endDate => (_$data['endDate'] as String?);

  List<String>? get removeTags => (_$data['removeTags'] as List<String>?);

  String? get balanceAmount => (_$data['balanceAmount'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('addTags')) {
      final l$addTags = addTags;
      result$data['addTags'] = l$addTags?.map((e) => e).toList();
    }
    if (_$data.containsKey('expiryDate')) {
      final l$expiryDate = expiryDate;
      result$data['expiryDate'] = l$expiryDate;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('startDate')) {
      final l$startDate = startDate;
      result$data['startDate'] = l$startDate;
    }
    if (_$data.containsKey('endDate')) {
      final l$endDate = endDate;
      result$data['endDate'] = l$endDate;
    }
    if (_$data.containsKey('removeTags')) {
      final l$removeTags = removeTags;
      result$data['removeTags'] = l$removeTags?.map((e) => e).toList();
    }
    if (_$data.containsKey('balanceAmount')) {
      final l$balanceAmount = balanceAmount;
      result$data['balanceAmount'] = l$balanceAmount;
    }
    return result$data;
  }

  CopyWith$Input$GiftCardUpdateInput<Input$GiftCardUpdateInput> get copyWith =>
      CopyWith$Input$GiftCardUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$GiftCardUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$addTags = addTags;
    final lOther$addTags = other.addTags;
    if (_$data.containsKey('addTags') != other._$data.containsKey('addTags')) {
      return false;
    }
    if (l$addTags != null && lOther$addTags != null) {
      if (l$addTags.length != lOther$addTags.length) {
        return false;
      }
      for (int i = 0; i < l$addTags.length; i++) {
        final l$addTags$entry = l$addTags[i];
        final lOther$addTags$entry = lOther$addTags[i];
        if (l$addTags$entry != lOther$addTags$entry) {
          return false;
        }
      }
    } else if (l$addTags != lOther$addTags) {
      return false;
    }
    final l$expiryDate = expiryDate;
    final lOther$expiryDate = other.expiryDate;
    if (_$data.containsKey('expiryDate') !=
        other._$data.containsKey('expiryDate')) {
      return false;
    }
    if (l$expiryDate != lOther$expiryDate) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (_$data.containsKey('startDate') !=
        other._$data.containsKey('startDate')) {
      return false;
    }
    if (l$startDate != lOther$startDate) {
      return false;
    }
    final l$endDate = endDate;
    final lOther$endDate = other.endDate;
    if (_$data.containsKey('endDate') != other._$data.containsKey('endDate')) {
      return false;
    }
    if (l$endDate != lOther$endDate) {
      return false;
    }
    final l$removeTags = removeTags;
    final lOther$removeTags = other.removeTags;
    if (_$data.containsKey('removeTags') !=
        other._$data.containsKey('removeTags')) {
      return false;
    }
    if (l$removeTags != null && lOther$removeTags != null) {
      if (l$removeTags.length != lOther$removeTags.length) {
        return false;
      }
      for (int i = 0; i < l$removeTags.length; i++) {
        final l$removeTags$entry = l$removeTags[i];
        final lOther$removeTags$entry = lOther$removeTags[i];
        if (l$removeTags$entry != lOther$removeTags$entry) {
          return false;
        }
      }
    } else if (l$removeTags != lOther$removeTags) {
      return false;
    }
    final l$balanceAmount = balanceAmount;
    final lOther$balanceAmount = other.balanceAmount;
    if (_$data.containsKey('balanceAmount') !=
        other._$data.containsKey('balanceAmount')) {
      return false;
    }
    if (l$balanceAmount != lOther$balanceAmount) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$addTags = addTags;
    final l$expiryDate = expiryDate;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$startDate = startDate;
    final l$endDate = endDate;
    final l$removeTags = removeTags;
    final l$balanceAmount = balanceAmount;
    return Object.hashAll([
      _$data.containsKey('addTags')
          ? l$addTags == null
              ? null
              : Object.hashAll(l$addTags.map((v) => v))
          : const {},
      _$data.containsKey('expiryDate') ? l$expiryDate : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('startDate') ? l$startDate : const {},
      _$data.containsKey('endDate') ? l$endDate : const {},
      _$data.containsKey('removeTags')
          ? l$removeTags == null
              ? null
              : Object.hashAll(l$removeTags.map((v) => v))
          : const {},
      _$data.containsKey('balanceAmount') ? l$balanceAmount : const {},
    ]);
  }
}

abstract class CopyWith$Input$GiftCardUpdateInput<TRes> {
  factory CopyWith$Input$GiftCardUpdateInput(
    Input$GiftCardUpdateInput instance,
    TRes Function(Input$GiftCardUpdateInput) then,
  ) = _CopyWithImpl$Input$GiftCardUpdateInput;

  factory CopyWith$Input$GiftCardUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GiftCardUpdateInput;

  TRes call({
    List<String>? addTags,
    String? expiryDate,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? startDate,
    String? endDate,
    List<String>? removeTags,
    String? balanceAmount,
  });
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$GiftCardUpdateInput<TRes>
    implements CopyWith$Input$GiftCardUpdateInput<TRes> {
  _CopyWithImpl$Input$GiftCardUpdateInput(
    this._instance,
    this._then,
  );

  final Input$GiftCardUpdateInput _instance;

  final TRes Function(Input$GiftCardUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? addTags = _undefined,
    Object? expiryDate = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? startDate = _undefined,
    Object? endDate = _undefined,
    Object? removeTags = _undefined,
    Object? balanceAmount = _undefined,
  }) =>
      _then(Input$GiftCardUpdateInput._({
        ..._instance._$data,
        if (addTags != _undefined) 'addTags': (addTags as List<String>?),
        if (expiryDate != _undefined) 'expiryDate': (expiryDate as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (startDate != _undefined) 'startDate': (startDate as String?),
        if (endDate != _undefined) 'endDate': (endDate as String?),
        if (removeTags != _undefined)
          'removeTags': (removeTags as List<String>?),
        if (balanceAmount != _undefined)
          'balanceAmount': (balanceAmount as String?),
      }));

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$GiftCardUpdateInput<TRes>
    implements CopyWith$Input$GiftCardUpdateInput<TRes> {
  _CopyWithStubImpl$Input$GiftCardUpdateInput(this._res);

  TRes _res;

  call({
    List<String>? addTags,
    String? expiryDate,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? startDate,
    String? endDate,
    List<String>? removeTags,
    String? balanceAmount,
  }) =>
      _res;

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$GlobalIDFilterInput {
  factory Input$GlobalIDFilterInput({
    String? eq,
    List<String>? oneOf,
  }) =>
      Input$GlobalIDFilterInput._({
        if (eq != null) r'eq': eq,
        if (oneOf != null) r'oneOf': oneOf,
      });

  Input$GlobalIDFilterInput._(this._$data);

  factory Input$GlobalIDFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('oneOf')) {
      final l$oneOf = data['oneOf'];
      result$data['oneOf'] =
          (l$oneOf as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$GlobalIDFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get eq => (_$data['eq'] as String?);

  List<String>? get oneOf => (_$data['oneOf'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('oneOf')) {
      final l$oneOf = oneOf;
      result$data['oneOf'] = l$oneOf?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$GlobalIDFilterInput<Input$GlobalIDFilterInput> get copyWith =>
      CopyWith$Input$GlobalIDFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$GlobalIDFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$oneOf = oneOf;
    final lOther$oneOf = other.oneOf;
    if (_$data.containsKey('oneOf') != other._$data.containsKey('oneOf')) {
      return false;
    }
    if (l$oneOf != null && lOther$oneOf != null) {
      if (l$oneOf.length != lOther$oneOf.length) {
        return false;
      }
      for (int i = 0; i < l$oneOf.length; i++) {
        final l$oneOf$entry = l$oneOf[i];
        final lOther$oneOf$entry = lOther$oneOf[i];
        if (l$oneOf$entry != lOther$oneOf$entry) {
          return false;
        }
      }
    } else if (l$oneOf != lOther$oneOf) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$oneOf = oneOf;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('oneOf')
          ? l$oneOf == null
              ? null
              : Object.hashAll(l$oneOf.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$GlobalIDFilterInput<TRes> {
  factory CopyWith$Input$GlobalIDFilterInput(
    Input$GlobalIDFilterInput instance,
    TRes Function(Input$GlobalIDFilterInput) then,
  ) = _CopyWithImpl$Input$GlobalIDFilterInput;

  factory CopyWith$Input$GlobalIDFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GlobalIDFilterInput;

  TRes call({
    String? eq,
    List<String>? oneOf,
  });
}

class _CopyWithImpl$Input$GlobalIDFilterInput<TRes>
    implements CopyWith$Input$GlobalIDFilterInput<TRes> {
  _CopyWithImpl$Input$GlobalIDFilterInput(
    this._instance,
    this._then,
  );

  final Input$GlobalIDFilterInput _instance;

  final TRes Function(Input$GlobalIDFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? oneOf = _undefined,
  }) =>
      _then(Input$GlobalIDFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as String?),
        if (oneOf != _undefined) 'oneOf': (oneOf as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$GlobalIDFilterInput<TRes>
    implements CopyWith$Input$GlobalIDFilterInput<TRes> {
  _CopyWithStubImpl$Input$GlobalIDFilterInput(this._res);

  TRes _res;

  call({
    String? eq,
    List<String>? oneOf,
  }) =>
      _res;
}

class Input$IntFilterInput {
  factory Input$IntFilterInput({
    int? eq,
    List<int>? oneOf,
    Input$IntRangeInput? range,
  }) =>
      Input$IntFilterInput._({
        if (eq != null) r'eq': eq,
        if (oneOf != null) r'oneOf': oneOf,
        if (range != null) r'range': range,
      });

  Input$IntFilterInput._(this._$data);

  factory Input$IntFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as int?);
    }
    if (data.containsKey('oneOf')) {
      final l$oneOf = data['oneOf'];
      result$data['oneOf'] =
          (l$oneOf as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('range')) {
      final l$range = data['range'];
      result$data['range'] = l$range == null
          ? null
          : Input$IntRangeInput.fromJson((l$range as Map<String, dynamic>));
    }
    return Input$IntFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get eq => (_$data['eq'] as int?);

  List<int>? get oneOf => (_$data['oneOf'] as List<int>?);

  Input$IntRangeInput? get range => (_$data['range'] as Input$IntRangeInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('oneOf')) {
      final l$oneOf = oneOf;
      result$data['oneOf'] = l$oneOf?.map((e) => e).toList();
    }
    if (_$data.containsKey('range')) {
      final l$range = range;
      result$data['range'] = l$range?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$IntFilterInput<Input$IntFilterInput> get copyWith =>
      CopyWith$Input$IntFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$IntFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$oneOf = oneOf;
    final lOther$oneOf = other.oneOf;
    if (_$data.containsKey('oneOf') != other._$data.containsKey('oneOf')) {
      return false;
    }
    if (l$oneOf != null && lOther$oneOf != null) {
      if (l$oneOf.length != lOther$oneOf.length) {
        return false;
      }
      for (int i = 0; i < l$oneOf.length; i++) {
        final l$oneOf$entry = l$oneOf[i];
        final lOther$oneOf$entry = lOther$oneOf[i];
        if (l$oneOf$entry != lOther$oneOf$entry) {
          return false;
        }
      }
    } else if (l$oneOf != lOther$oneOf) {
      return false;
    }
    final l$range = range;
    final lOther$range = other.range;
    if (_$data.containsKey('range') != other._$data.containsKey('range')) {
      return false;
    }
    if (l$range != lOther$range) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$oneOf = oneOf;
    final l$range = range;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('oneOf')
          ? l$oneOf == null
              ? null
              : Object.hashAll(l$oneOf.map((v) => v))
          : const {},
      _$data.containsKey('range') ? l$range : const {},
    ]);
  }
}

abstract class CopyWith$Input$IntFilterInput<TRes> {
  factory CopyWith$Input$IntFilterInput(
    Input$IntFilterInput instance,
    TRes Function(Input$IntFilterInput) then,
  ) = _CopyWithImpl$Input$IntFilterInput;

  factory CopyWith$Input$IntFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IntFilterInput;

  TRes call({
    int? eq,
    List<int>? oneOf,
    Input$IntRangeInput? range,
  });
  CopyWith$Input$IntRangeInput<TRes> get range;
}

class _CopyWithImpl$Input$IntFilterInput<TRes>
    implements CopyWith$Input$IntFilterInput<TRes> {
  _CopyWithImpl$Input$IntFilterInput(
    this._instance,
    this._then,
  );

  final Input$IntFilterInput _instance;

  final TRes Function(Input$IntFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? oneOf = _undefined,
    Object? range = _undefined,
  }) =>
      _then(Input$IntFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as int?),
        if (oneOf != _undefined) 'oneOf': (oneOf as List<int>?),
        if (range != _undefined) 'range': (range as Input$IntRangeInput?),
      }));

  CopyWith$Input$IntRangeInput<TRes> get range {
    final local$range = _instance.range;
    return local$range == null
        ? CopyWith$Input$IntRangeInput.stub(_then(_instance))
        : CopyWith$Input$IntRangeInput(local$range, (e) => call(range: e));
  }
}

class _CopyWithStubImpl$Input$IntFilterInput<TRes>
    implements CopyWith$Input$IntFilterInput<TRes> {
  _CopyWithStubImpl$Input$IntFilterInput(this._res);

  TRes _res;

  call({
    int? eq,
    List<int>? oneOf,
    Input$IntRangeInput? range,
  }) =>
      _res;

  CopyWith$Input$IntRangeInput<TRes> get range =>
      CopyWith$Input$IntRangeInput.stub(_res);
}

class Input$IntRangeInput {
  factory Input$IntRangeInput({
    int? gte,
    int? lte,
  }) =>
      Input$IntRangeInput._({
        if (gte != null) r'gte': gte,
        if (lte != null) r'lte': lte,
      });

  Input$IntRangeInput._(this._$data);

  factory Input$IntRangeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    return Input$IntRangeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get gte => (_$data['gte'] as int?);

  int? get lte => (_$data['lte'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    return result$data;
  }

  CopyWith$Input$IntRangeInput<Input$IntRangeInput> get copyWith =>
      CopyWith$Input$IntRangeInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$IntRangeInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$gte = gte;
    final l$lte = lte;
    return Object.hashAll([
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('lte') ? l$lte : const {},
    ]);
  }
}

abstract class CopyWith$Input$IntRangeInput<TRes> {
  factory CopyWith$Input$IntRangeInput(
    Input$IntRangeInput instance,
    TRes Function(Input$IntRangeInput) then,
  ) = _CopyWithImpl$Input$IntRangeInput;

  factory CopyWith$Input$IntRangeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IntRangeInput;

  TRes call({
    int? gte,
    int? lte,
  });
}

class _CopyWithImpl$Input$IntRangeInput<TRes>
    implements CopyWith$Input$IntRangeInput<TRes> {
  _CopyWithImpl$Input$IntRangeInput(
    this._instance,
    this._then,
  );

  final Input$IntRangeInput _instance;

  final TRes Function(Input$IntRangeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? gte = _undefined,
    Object? lte = _undefined,
  }) =>
      _then(Input$IntRangeInput._({
        ..._instance._$data,
        if (gte != _undefined) 'gte': (gte as int?),
        if (lte != _undefined) 'lte': (lte as int?),
      }));
}

class _CopyWithStubImpl$Input$IntRangeInput<TRes>
    implements CopyWith$Input$IntRangeInput<TRes> {
  _CopyWithStubImpl$Input$IntRangeInput(this._res);

  TRes _res;

  call({
    int? gte,
    int? lte,
  }) =>
      _res;
}

class Input$InvoiceCreateInput {
  factory Input$InvoiceCreateInput({
    required String number,
    required String url,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  }) =>
      Input$InvoiceCreateInput._({
        r'number': number,
        r'url': url,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
      });

  Input$InvoiceCreateInput._(this._$data);

  factory Input$InvoiceCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$number = data['number'];
    result$data['number'] = (l$number as String);
    final l$url = data['url'];
    result$data['url'] = (l$url as String);
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$InvoiceCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get number => (_$data['number'] as String);

  String get url => (_$data['url'] as String);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$number = number;
    result$data['number'] = l$number;
    final l$url = url;
    result$data['url'] = l$url;
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$InvoiceCreateInput<Input$InvoiceCreateInput> get copyWith =>
      CopyWith$Input$InvoiceCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$InvoiceCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$number = number;
    final l$url = url;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    return Object.hashAll([
      l$number,
      l$url,
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvoiceCreateInput<TRes> {
  factory CopyWith$Input$InvoiceCreateInput(
    Input$InvoiceCreateInput instance,
    TRes Function(Input$InvoiceCreateInput) then,
  ) = _CopyWithImpl$Input$InvoiceCreateInput;

  factory CopyWith$Input$InvoiceCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvoiceCreateInput;

  TRes call({
    String? number,
    String? url,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  });
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$InvoiceCreateInput<TRes>
    implements CopyWith$Input$InvoiceCreateInput<TRes> {
  _CopyWithImpl$Input$InvoiceCreateInput(
    this._instance,
    this._then,
  );

  final Input$InvoiceCreateInput _instance;

  final TRes Function(Input$InvoiceCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? number = _undefined,
    Object? url = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
  }) =>
      _then(Input$InvoiceCreateInput._({
        ..._instance._$data,
        if (number != _undefined && number != null)
          'number': (number as String),
        if (url != _undefined && url != null) 'url': (url as String),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$InvoiceCreateInput<TRes>
    implements CopyWith$Input$InvoiceCreateInput<TRes> {
  _CopyWithStubImpl$Input$InvoiceCreateInput(this._res);

  TRes _res;

  call({
    String? number,
    String? url,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  }) =>
      _res;

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$InvoiceFilterInput {
  factory Input$InvoiceFilterInput({Input$DateTimeRangeInput? createdAt}) =>
      Input$InvoiceFilterInput._({
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$InvoiceFilterInput._(this._$data);

  factory Input$InvoiceFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeRangeInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    return Input$InvoiceFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$DateTimeRangeInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeRangeInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$InvoiceFilterInput<Input$InvoiceFilterInput> get copyWith =>
      CopyWith$Input$InvoiceFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$InvoiceFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    return Object.hashAll(
        [_$data.containsKey('createdAt') ? l$createdAt : const {}]);
  }
}

abstract class CopyWith$Input$InvoiceFilterInput<TRes> {
  factory CopyWith$Input$InvoiceFilterInput(
    Input$InvoiceFilterInput instance,
    TRes Function(Input$InvoiceFilterInput) then,
  ) = _CopyWithImpl$Input$InvoiceFilterInput;

  factory CopyWith$Input$InvoiceFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvoiceFilterInput;

  TRes call({Input$DateTimeRangeInput? createdAt});
  CopyWith$Input$DateTimeRangeInput<TRes> get createdAt;
}

class _CopyWithImpl$Input$InvoiceFilterInput<TRes>
    implements CopyWith$Input$InvoiceFilterInput<TRes> {
  _CopyWithImpl$Input$InvoiceFilterInput(
    this._instance,
    this._then,
  );

  final Input$InvoiceFilterInput _instance;

  final TRes Function(Input$InvoiceFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? createdAt = _undefined}) =>
      _then(Input$InvoiceFilterInput._({
        ..._instance._$data,
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeRangeInput?),
      }));

  CopyWith$Input$DateTimeRangeInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeRangeInput(
            local$createdAt, (e) => call(createdAt: e));
  }
}

class _CopyWithStubImpl$Input$InvoiceFilterInput<TRes>
    implements CopyWith$Input$InvoiceFilterInput<TRes> {
  _CopyWithStubImpl$Input$InvoiceFilterInput(this._res);

  TRes _res;

  call({Input$DateTimeRangeInput? createdAt}) => _res;

  CopyWith$Input$DateTimeRangeInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeRangeInput.stub(_res);
}

class Input$LinesFilterInput {
  factory Input$LinesFilterInput({Input$MetadataFilterInput? metadata}) =>
      Input$LinesFilterInput._({
        if (metadata != null) r'metadata': metadata,
      });

  Input$LinesFilterInput._(this._$data);

  factory Input$LinesFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = l$metadata == null
          ? null
          : Input$MetadataFilterInput.fromJson(
              (l$metadata as Map<String, dynamic>));
    }
    return Input$LinesFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$MetadataFilterInput? get metadata =>
      (_$data['metadata'] as Input$MetadataFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$LinesFilterInput<Input$LinesFilterInput> get copyWith =>
      CopyWith$Input$LinesFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$LinesFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$metadata = metadata;
    return Object.hashAll(
        [_$data.containsKey('metadata') ? l$metadata : const {}]);
  }
}

abstract class CopyWith$Input$LinesFilterInput<TRes> {
  factory CopyWith$Input$LinesFilterInput(
    Input$LinesFilterInput instance,
    TRes Function(Input$LinesFilterInput) then,
  ) = _CopyWithImpl$Input$LinesFilterInput;

  factory CopyWith$Input$LinesFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LinesFilterInput;

  TRes call({Input$MetadataFilterInput? metadata});
  CopyWith$Input$MetadataFilterInput<TRes> get metadata;
}

class _CopyWithImpl$Input$LinesFilterInput<TRes>
    implements CopyWith$Input$LinesFilterInput<TRes> {
  _CopyWithImpl$Input$LinesFilterInput(
    this._instance,
    this._then,
  );

  final Input$LinesFilterInput _instance;

  final TRes Function(Input$LinesFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? metadata = _undefined}) => _then(Input$LinesFilterInput._({
        ..._instance._$data,
        if (metadata != _undefined)
          'metadata': (metadata as Input$MetadataFilterInput?),
      }));

  CopyWith$Input$MetadataFilterInput<TRes> get metadata {
    final local$metadata = _instance.metadata;
    return local$metadata == null
        ? CopyWith$Input$MetadataFilterInput.stub(_then(_instance))
        : CopyWith$Input$MetadataFilterInput(
            local$metadata, (e) => call(metadata: e));
  }
}

class _CopyWithStubImpl$Input$LinesFilterInput<TRes>
    implements CopyWith$Input$LinesFilterInput<TRes> {
  _CopyWithStubImpl$Input$LinesFilterInput(this._res);

  TRes _res;

  call({Input$MetadataFilterInput? metadata}) => _res;

  CopyWith$Input$MetadataFilterInput<TRes> get metadata =>
      CopyWith$Input$MetadataFilterInput.stub(_res);
}

class Input$MeasurementUnitsEnumFilterInput {
  factory Input$MeasurementUnitsEnumFilterInput({
    Enum$MeasurementUnitsEnum? eq,
    List<Enum$MeasurementUnitsEnum>? oneOf,
  }) =>
      Input$MeasurementUnitsEnumFilterInput._({
        if (eq != null) r'eq': eq,
        if (oneOf != null) r'oneOf': oneOf,
      });

  Input$MeasurementUnitsEnumFilterInput._(this._$data);

  factory Input$MeasurementUnitsEnumFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$MeasurementUnitsEnum((l$eq as String));
    }
    if (data.containsKey('oneOf')) {
      final l$oneOf = data['oneOf'];
      result$data['oneOf'] = (l$oneOf as List<dynamic>?)
          ?.map((e) => fromJson$Enum$MeasurementUnitsEnum((e as String)))
          .toList();
    }
    return Input$MeasurementUnitsEnumFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$MeasurementUnitsEnum? get eq =>
      (_$data['eq'] as Enum$MeasurementUnitsEnum?);

  List<Enum$MeasurementUnitsEnum>? get oneOf =>
      (_$data['oneOf'] as List<Enum$MeasurementUnitsEnum>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] =
          l$eq == null ? null : toJson$Enum$MeasurementUnitsEnum(l$eq);
    }
    if (_$data.containsKey('oneOf')) {
      final l$oneOf = oneOf;
      result$data['oneOf'] =
          l$oneOf?.map((e) => toJson$Enum$MeasurementUnitsEnum(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$MeasurementUnitsEnumFilterInput<
          Input$MeasurementUnitsEnumFilterInput>
      get copyWith => CopyWith$Input$MeasurementUnitsEnumFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MeasurementUnitsEnumFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$oneOf = oneOf;
    final lOther$oneOf = other.oneOf;
    if (_$data.containsKey('oneOf') != other._$data.containsKey('oneOf')) {
      return false;
    }
    if (l$oneOf != null && lOther$oneOf != null) {
      if (l$oneOf.length != lOther$oneOf.length) {
        return false;
      }
      for (int i = 0; i < l$oneOf.length; i++) {
        final l$oneOf$entry = l$oneOf[i];
        final lOther$oneOf$entry = lOther$oneOf[i];
        if (l$oneOf$entry != lOther$oneOf$entry) {
          return false;
        }
      }
    } else if (l$oneOf != lOther$oneOf) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$oneOf = oneOf;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('oneOf')
          ? l$oneOf == null
              ? null
              : Object.hashAll(l$oneOf.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$MeasurementUnitsEnumFilterInput<TRes> {
  factory CopyWith$Input$MeasurementUnitsEnumFilterInput(
    Input$MeasurementUnitsEnumFilterInput instance,
    TRes Function(Input$MeasurementUnitsEnumFilterInput) then,
  ) = _CopyWithImpl$Input$MeasurementUnitsEnumFilterInput;

  factory CopyWith$Input$MeasurementUnitsEnumFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MeasurementUnitsEnumFilterInput;

  TRes call({
    Enum$MeasurementUnitsEnum? eq,
    List<Enum$MeasurementUnitsEnum>? oneOf,
  });
}

class _CopyWithImpl$Input$MeasurementUnitsEnumFilterInput<TRes>
    implements CopyWith$Input$MeasurementUnitsEnumFilterInput<TRes> {
  _CopyWithImpl$Input$MeasurementUnitsEnumFilterInput(
    this._instance,
    this._then,
  );

  final Input$MeasurementUnitsEnumFilterInput _instance;

  final TRes Function(Input$MeasurementUnitsEnumFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? oneOf = _undefined,
  }) =>
      _then(Input$MeasurementUnitsEnumFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as Enum$MeasurementUnitsEnum?),
        if (oneOf != _undefined)
          'oneOf': (oneOf as List<Enum$MeasurementUnitsEnum>?),
      }));
}

class _CopyWithStubImpl$Input$MeasurementUnitsEnumFilterInput<TRes>
    implements CopyWith$Input$MeasurementUnitsEnumFilterInput<TRes> {
  _CopyWithStubImpl$Input$MeasurementUnitsEnumFilterInput(this._res);

  TRes _res;

  call({
    Enum$MeasurementUnitsEnum? eq,
    List<Enum$MeasurementUnitsEnum>? oneOf,
  }) =>
      _res;
}

class Input$MediaInput {
  factory Input$MediaInput({
    String? alt,
    String? image,
    String? mediaUrl,
  }) =>
      Input$MediaInput._({
        if (alt != null) r'alt': alt,
        if (image != null) r'image': image,
        if (mediaUrl != null) r'mediaUrl': mediaUrl,
      });

  Input$MediaInput._(this._$data);

  factory Input$MediaInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('alt')) {
      final l$alt = data['alt'];
      result$data['alt'] = (l$alt as String?);
    }
    if (data.containsKey('image')) {
      final l$image = data['image'];
      result$data['image'] = (l$image as String?);
    }
    if (data.containsKey('mediaUrl')) {
      final l$mediaUrl = data['mediaUrl'];
      result$data['mediaUrl'] = (l$mediaUrl as String?);
    }
    return Input$MediaInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get alt => (_$data['alt'] as String?);

  String? get image => (_$data['image'] as String?);

  String? get mediaUrl => (_$data['mediaUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('alt')) {
      final l$alt = alt;
      result$data['alt'] = l$alt;
    }
    if (_$data.containsKey('image')) {
      final l$image = image;
      result$data['image'] = l$image;
    }
    if (_$data.containsKey('mediaUrl')) {
      final l$mediaUrl = mediaUrl;
      result$data['mediaUrl'] = l$mediaUrl;
    }
    return result$data;
  }

  CopyWith$Input$MediaInput<Input$MediaInput> get copyWith =>
      CopyWith$Input$MediaInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MediaInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$alt = alt;
    final lOther$alt = other.alt;
    if (_$data.containsKey('alt') != other._$data.containsKey('alt')) {
      return false;
    }
    if (l$alt != lOther$alt) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (_$data.containsKey('image') != other._$data.containsKey('image')) {
      return false;
    }
    if (l$image != lOther$image) {
      return false;
    }
    final l$mediaUrl = mediaUrl;
    final lOther$mediaUrl = other.mediaUrl;
    if (_$data.containsKey('mediaUrl') !=
        other._$data.containsKey('mediaUrl')) {
      return false;
    }
    if (l$mediaUrl != lOther$mediaUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$alt = alt;
    final l$image = image;
    final l$mediaUrl = mediaUrl;
    return Object.hashAll([
      _$data.containsKey('alt') ? l$alt : const {},
      _$data.containsKey('image') ? l$image : const {},
      _$data.containsKey('mediaUrl') ? l$mediaUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$MediaInput<TRes> {
  factory CopyWith$Input$MediaInput(
    Input$MediaInput instance,
    TRes Function(Input$MediaInput) then,
  ) = _CopyWithImpl$Input$MediaInput;

  factory CopyWith$Input$MediaInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MediaInput;

  TRes call({
    String? alt,
    String? image,
    String? mediaUrl,
  });
}

class _CopyWithImpl$Input$MediaInput<TRes>
    implements CopyWith$Input$MediaInput<TRes> {
  _CopyWithImpl$Input$MediaInput(
    this._instance,
    this._then,
  );

  final Input$MediaInput _instance;

  final TRes Function(Input$MediaInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? alt = _undefined,
    Object? image = _undefined,
    Object? mediaUrl = _undefined,
  }) =>
      _then(Input$MediaInput._({
        ..._instance._$data,
        if (alt != _undefined) 'alt': (alt as String?),
        if (image != _undefined) 'image': (image as String?),
        if (mediaUrl != _undefined) 'mediaUrl': (mediaUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$MediaInput<TRes>
    implements CopyWith$Input$MediaInput<TRes> {
  _CopyWithStubImpl$Input$MediaInput(this._res);

  TRes _res;

  call({
    String? alt,
    String? image,
    String? mediaUrl,
  }) =>
      _res;
}

class Input$MediaSortingInput {
  factory Input$MediaSortingInput({
    required Enum$OrderDirection direction,
    required Enum$MediaChoicesSortField field,
  }) =>
      Input$MediaSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$MediaSortingInput._(this._$data);

  factory Input$MediaSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$MediaChoicesSortField((l$field as String));
    return Input$MediaSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$MediaChoicesSortField get field =>
      (_$data['field'] as Enum$MediaChoicesSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$MediaChoicesSortField(l$field);
    return result$data;
  }

  CopyWith$Input$MediaSortingInput<Input$MediaSortingInput> get copyWith =>
      CopyWith$Input$MediaSortingInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MediaSortingInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$MediaSortingInput<TRes> {
  factory CopyWith$Input$MediaSortingInput(
    Input$MediaSortingInput instance,
    TRes Function(Input$MediaSortingInput) then,
  ) = _CopyWithImpl$Input$MediaSortingInput;

  factory CopyWith$Input$MediaSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MediaSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$MediaChoicesSortField? field,
  });
}

class _CopyWithImpl$Input$MediaSortingInput<TRes>
    implements CopyWith$Input$MediaSortingInput<TRes> {
  _CopyWithImpl$Input$MediaSortingInput(
    this._instance,
    this._then,
  );

  final Input$MediaSortingInput _instance;

  final TRes Function(Input$MediaSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$MediaSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$MediaChoicesSortField),
      }));
}

class _CopyWithStubImpl$Input$MediaSortingInput<TRes>
    implements CopyWith$Input$MediaSortingInput<TRes> {
  _CopyWithStubImpl$Input$MediaSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$MediaChoicesSortField? field,
  }) =>
      _res;
}

class Input$MenuCreateInput {
  factory Input$MenuCreateInput({
    required String name,
    String? slug,
    List<Input$MenuItemInput>? items,
  }) =>
      Input$MenuCreateInput._({
        r'name': name,
        if (slug != null) r'slug': slug,
        if (items != null) r'items': items,
      });

  Input$MenuCreateInput._(this._$data);

  factory Input$MenuCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('items')) {
      final l$items = data['items'];
      result$data['items'] = (l$items as List<dynamic>?)
          ?.map(
              (e) => Input$MenuItemInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$MenuCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String? get slug => (_$data['slug'] as String?);

  List<Input$MenuItemInput>? get items =>
      (_$data['items'] as List<Input$MenuItemInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('items')) {
      final l$items = items;
      result$data['items'] = l$items?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$MenuCreateInput<Input$MenuCreateInput> get copyWith =>
      CopyWith$Input$MenuCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MenuCreateInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$items = items;
    final lOther$items = other.items;
    if (_$data.containsKey('items') != other._$data.containsKey('items')) {
      return false;
    }
    if (l$items != null && lOther$items != null) {
      if (l$items.length != lOther$items.length) {
        return false;
      }
      for (int i = 0; i < l$items.length; i++) {
        final l$items$entry = l$items[i];
        final lOther$items$entry = lOther$items[i];
        if (l$items$entry != lOther$items$entry) {
          return false;
        }
      }
    } else if (l$items != lOther$items) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$items = items;
    return Object.hashAll([
      l$name,
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('items')
          ? l$items == null
              ? null
              : Object.hashAll(l$items.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$MenuCreateInput<TRes> {
  factory CopyWith$Input$MenuCreateInput(
    Input$MenuCreateInput instance,
    TRes Function(Input$MenuCreateInput) then,
  ) = _CopyWithImpl$Input$MenuCreateInput;

  factory CopyWith$Input$MenuCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MenuCreateInput;

  TRes call({
    String? name,
    String? slug,
    List<Input$MenuItemInput>? items,
  });
  TRes items(
      Iterable<Input$MenuItemInput>? Function(
              Iterable<CopyWith$Input$MenuItemInput<Input$MenuItemInput>>?)
          _fn);
}

class _CopyWithImpl$Input$MenuCreateInput<TRes>
    implements CopyWith$Input$MenuCreateInput<TRes> {
  _CopyWithImpl$Input$MenuCreateInput(
    this._instance,
    this._then,
  );

  final Input$MenuCreateInput _instance;

  final TRes Function(Input$MenuCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? items = _undefined,
  }) =>
      _then(Input$MenuCreateInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (slug != _undefined) 'slug': (slug as String?),
        if (items != _undefined) 'items': (items as List<Input$MenuItemInput>?),
      }));

  TRes items(
          Iterable<Input$MenuItemInput>? Function(
                  Iterable<CopyWith$Input$MenuItemInput<Input$MenuItemInput>>?)
              _fn) =>
      call(
          items: _fn(_instance.items?.map((e) => CopyWith$Input$MenuItemInput(
                e,
                (i) => i,
              )))?.toList());
}

class _CopyWithStubImpl$Input$MenuCreateInput<TRes>
    implements CopyWith$Input$MenuCreateInput<TRes> {
  _CopyWithStubImpl$Input$MenuCreateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? slug,
    List<Input$MenuItemInput>? items,
  }) =>
      _res;

  items(_fn) => _res;
}

class Input$MenuFilterInput {
  factory Input$MenuFilterInput({
    String? search,
    List<String>? slug,
    List<Input$MetadataFilter>? metadata,
    List<String>? slugs,
  }) =>
      Input$MenuFilterInput._({
        if (search != null) r'search': search,
        if (slug != null) r'slug': slug,
        if (metadata != null) r'metadata': metadata,
        if (slugs != null) r'slugs': slugs,
      });

  Input$MenuFilterInput._(this._$data);

  factory Input$MenuFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] =
          (l$slug as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('slugs')) {
      final l$slugs = data['slugs'];
      result$data['slugs'] =
          (l$slugs as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$MenuFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get search => (_$data['search'] as String?);

  List<String>? get slug => (_$data['slug'] as List<String>?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get slugs => (_$data['slugs'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug?.map((e) => e).toList();
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('slugs')) {
      final l$slugs = slugs;
      result$data['slugs'] = l$slugs?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$MenuFilterInput<Input$MenuFilterInput> get copyWith =>
      CopyWith$Input$MenuFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MenuFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != null && lOther$slug != null) {
      if (l$slug.length != lOther$slug.length) {
        return false;
      }
      for (int i = 0; i < l$slug.length; i++) {
        final l$slug$entry = l$slug[i];
        final lOther$slug$entry = lOther$slug[i];
        if (l$slug$entry != lOther$slug$entry) {
          return false;
        }
      }
    } else if (l$slug != lOther$slug) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$slugs = slugs;
    final lOther$slugs = other.slugs;
    if (_$data.containsKey('slugs') != other._$data.containsKey('slugs')) {
      return false;
    }
    if (l$slugs != null && lOther$slugs != null) {
      if (l$slugs.length != lOther$slugs.length) {
        return false;
      }
      for (int i = 0; i < l$slugs.length; i++) {
        final l$slugs$entry = l$slugs[i];
        final lOther$slugs$entry = lOther$slugs[i];
        if (l$slugs$entry != lOther$slugs$entry) {
          return false;
        }
      }
    } else if (l$slugs != lOther$slugs) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$search = search;
    final l$slug = slug;
    final l$metadata = metadata;
    final l$slugs = slugs;
    return Object.hashAll([
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('slug')
          ? l$slug == null
              ? null
              : Object.hashAll(l$slug.map((v) => v))
          : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('slugs')
          ? l$slugs == null
              ? null
              : Object.hashAll(l$slugs.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$MenuFilterInput<TRes> {
  factory CopyWith$Input$MenuFilterInput(
    Input$MenuFilterInput instance,
    TRes Function(Input$MenuFilterInput) then,
  ) = _CopyWithImpl$Input$MenuFilterInput;

  factory CopyWith$Input$MenuFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MenuFilterInput;

  TRes call({
    String? search,
    List<String>? slug,
    List<Input$MetadataFilter>? metadata,
    List<String>? slugs,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
}

class _CopyWithImpl$Input$MenuFilterInput<TRes>
    implements CopyWith$Input$MenuFilterInput<TRes> {
  _CopyWithImpl$Input$MenuFilterInput(
    this._instance,
    this._then,
  );

  final Input$MenuFilterInput _instance;

  final TRes Function(Input$MenuFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? search = _undefined,
    Object? slug = _undefined,
    Object? metadata = _undefined,
    Object? slugs = _undefined,
  }) =>
      _then(Input$MenuFilterInput._({
        ..._instance._$data,
        if (search != _undefined) 'search': (search as String?),
        if (slug != _undefined) 'slug': (slug as List<String>?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (slugs != _undefined) 'slugs': (slugs as List<String>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$MenuFilterInput<TRes>
    implements CopyWith$Input$MenuFilterInput<TRes> {
  _CopyWithStubImpl$Input$MenuFilterInput(this._res);

  TRes _res;

  call({
    String? search,
    List<String>? slug,
    List<Input$MetadataFilter>? metadata,
    List<String>? slugs,
  }) =>
      _res;

  metadata(_fn) => _res;
}

class Input$MenuInput {
  factory Input$MenuInput({
    String? name,
    String? slug,
  }) =>
      Input$MenuInput._({
        if (name != null) r'name': name,
        if (slug != null) r'slug': slug,
      });

  Input$MenuInput._(this._$data);

  factory Input$MenuInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    return Input$MenuInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get slug => (_$data['slug'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    return result$data;
  }

  CopyWith$Input$MenuInput<Input$MenuInput> get copyWith =>
      CopyWith$Input$MenuInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MenuInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('slug') ? l$slug : const {},
    ]);
  }
}

abstract class CopyWith$Input$MenuInput<TRes> {
  factory CopyWith$Input$MenuInput(
    Input$MenuInput instance,
    TRes Function(Input$MenuInput) then,
  ) = _CopyWithImpl$Input$MenuInput;

  factory CopyWith$Input$MenuInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MenuInput;

  TRes call({
    String? name,
    String? slug,
  });
}

class _CopyWithImpl$Input$MenuInput<TRes>
    implements CopyWith$Input$MenuInput<TRes> {
  _CopyWithImpl$Input$MenuInput(
    this._instance,
    this._then,
  );

  final Input$MenuInput _instance;

  final TRes Function(Input$MenuInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? slug = _undefined,
  }) =>
      _then(Input$MenuInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (slug != _undefined) 'slug': (slug as String?),
      }));
}

class _CopyWithStubImpl$Input$MenuInput<TRes>
    implements CopyWith$Input$MenuInput<TRes> {
  _CopyWithStubImpl$Input$MenuInput(this._res);

  TRes _res;

  call({
    String? name,
    String? slug,
  }) =>
      _res;
}

class Input$MenuItemCreateInput {
  factory Input$MenuItemCreateInput({
    required String name,
    String? url,
    String? category,
    String? collection,
    String? page,
    required String menu,
    String? parent,
  }) =>
      Input$MenuItemCreateInput._({
        r'name': name,
        if (url != null) r'url': url,
        if (category != null) r'category': category,
        if (collection != null) r'collection': collection,
        if (page != null) r'page': page,
        r'menu': menu,
        if (parent != null) r'parent': parent,
      });

  Input$MenuItemCreateInput._(this._$data);

  factory Input$MenuItemCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as String?);
    }
    if (data.containsKey('collection')) {
      final l$collection = data['collection'];
      result$data['collection'] = (l$collection as String?);
    }
    if (data.containsKey('page')) {
      final l$page = data['page'];
      result$data['page'] = (l$page as String?);
    }
    final l$menu = data['menu'];
    result$data['menu'] = (l$menu as String);
    if (data.containsKey('parent')) {
      final l$parent = data['parent'];
      result$data['parent'] = (l$parent as String?);
    }
    return Input$MenuItemCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String? get url => (_$data['url'] as String?);

  String? get category => (_$data['category'] as String?);

  String? get collection => (_$data['collection'] as String?);

  String? get page => (_$data['page'] as String?);

  String get menu => (_$data['menu'] as String);

  String? get parent => (_$data['parent'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('collection')) {
      final l$collection = collection;
      result$data['collection'] = l$collection;
    }
    if (_$data.containsKey('page')) {
      final l$page = page;
      result$data['page'] = l$page;
    }
    final l$menu = menu;
    result$data['menu'] = l$menu;
    if (_$data.containsKey('parent')) {
      final l$parent = parent;
      result$data['parent'] = l$parent;
    }
    return result$data;
  }

  CopyWith$Input$MenuItemCreateInput<Input$MenuItemCreateInput> get copyWith =>
      CopyWith$Input$MenuItemCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MenuItemCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$collection = collection;
    final lOther$collection = other.collection;
    if (_$data.containsKey('collection') !=
        other._$data.containsKey('collection')) {
      return false;
    }
    if (l$collection != lOther$collection) {
      return false;
    }
    final l$page = page;
    final lOther$page = other.page;
    if (_$data.containsKey('page') != other._$data.containsKey('page')) {
      return false;
    }
    if (l$page != lOther$page) {
      return false;
    }
    final l$menu = menu;
    final lOther$menu = other.menu;
    if (l$menu != lOther$menu) {
      return false;
    }
    final l$parent = parent;
    final lOther$parent = other.parent;
    if (_$data.containsKey('parent') != other._$data.containsKey('parent')) {
      return false;
    }
    if (l$parent != lOther$parent) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$url = url;
    final l$category = category;
    final l$collection = collection;
    final l$page = page;
    final l$menu = menu;
    final l$parent = parent;
    return Object.hashAll([
      l$name,
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('collection') ? l$collection : const {},
      _$data.containsKey('page') ? l$page : const {},
      l$menu,
      _$data.containsKey('parent') ? l$parent : const {},
    ]);
  }
}

abstract class CopyWith$Input$MenuItemCreateInput<TRes> {
  factory CopyWith$Input$MenuItemCreateInput(
    Input$MenuItemCreateInput instance,
    TRes Function(Input$MenuItemCreateInput) then,
  ) = _CopyWithImpl$Input$MenuItemCreateInput;

  factory CopyWith$Input$MenuItemCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MenuItemCreateInput;

  TRes call({
    String? name,
    String? url,
    String? category,
    String? collection,
    String? page,
    String? menu,
    String? parent,
  });
}

class _CopyWithImpl$Input$MenuItemCreateInput<TRes>
    implements CopyWith$Input$MenuItemCreateInput<TRes> {
  _CopyWithImpl$Input$MenuItemCreateInput(
    this._instance,
    this._then,
  );

  final Input$MenuItemCreateInput _instance;

  final TRes Function(Input$MenuItemCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? url = _undefined,
    Object? category = _undefined,
    Object? collection = _undefined,
    Object? page = _undefined,
    Object? menu = _undefined,
    Object? parent = _undefined,
  }) =>
      _then(Input$MenuItemCreateInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (url != _undefined) 'url': (url as String?),
        if (category != _undefined) 'category': (category as String?),
        if (collection != _undefined) 'collection': (collection as String?),
        if (page != _undefined) 'page': (page as String?),
        if (menu != _undefined && menu != null) 'menu': (menu as String),
        if (parent != _undefined) 'parent': (parent as String?),
      }));
}

class _CopyWithStubImpl$Input$MenuItemCreateInput<TRes>
    implements CopyWith$Input$MenuItemCreateInput<TRes> {
  _CopyWithStubImpl$Input$MenuItemCreateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? url,
    String? category,
    String? collection,
    String? page,
    String? menu,
    String? parent,
  }) =>
      _res;
}

class Input$MenuItemFilterInput {
  factory Input$MenuItemFilterInput({
    String? search,
    List<Input$MetadataFilter>? metadata,
  }) =>
      Input$MenuItemFilterInput._({
        if (search != null) r'search': search,
        if (metadata != null) r'metadata': metadata,
      });

  Input$MenuItemFilterInput._(this._$data);

  factory Input$MenuItemFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$MenuItemFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get search => (_$data['search'] as String?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$MenuItemFilterInput<Input$MenuItemFilterInput> get copyWith =>
      CopyWith$Input$MenuItemFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MenuItemFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$search = search;
    final l$metadata = metadata;
    return Object.hashAll([
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$MenuItemFilterInput<TRes> {
  factory CopyWith$Input$MenuItemFilterInput(
    Input$MenuItemFilterInput instance,
    TRes Function(Input$MenuItemFilterInput) then,
  ) = _CopyWithImpl$Input$MenuItemFilterInput;

  factory CopyWith$Input$MenuItemFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MenuItemFilterInput;

  TRes call({
    String? search,
    List<Input$MetadataFilter>? metadata,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
}

class _CopyWithImpl$Input$MenuItemFilterInput<TRes>
    implements CopyWith$Input$MenuItemFilterInput<TRes> {
  _CopyWithImpl$Input$MenuItemFilterInput(
    this._instance,
    this._then,
  );

  final Input$MenuItemFilterInput _instance;

  final TRes Function(Input$MenuItemFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? search = _undefined,
    Object? metadata = _undefined,
  }) =>
      _then(Input$MenuItemFilterInput._({
        ..._instance._$data,
        if (search != _undefined) 'search': (search as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$MenuItemFilterInput<TRes>
    implements CopyWith$Input$MenuItemFilterInput<TRes> {
  _CopyWithStubImpl$Input$MenuItemFilterInput(this._res);

  TRes _res;

  call({
    String? search,
    List<Input$MetadataFilter>? metadata,
  }) =>
      _res;

  metadata(_fn) => _res;
}

class Input$MenuItemInput {
  factory Input$MenuItemInput({
    String? name,
    String? url,
    String? category,
    String? collection,
    String? page,
  }) =>
      Input$MenuItemInput._({
        if (name != null) r'name': name,
        if (url != null) r'url': url,
        if (category != null) r'category': category,
        if (collection != null) r'collection': collection,
        if (page != null) r'page': page,
      });

  Input$MenuItemInput._(this._$data);

  factory Input$MenuItemInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as String?);
    }
    if (data.containsKey('collection')) {
      final l$collection = data['collection'];
      result$data['collection'] = (l$collection as String?);
    }
    if (data.containsKey('page')) {
      final l$page = data['page'];
      result$data['page'] = (l$page as String?);
    }
    return Input$MenuItemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get url => (_$data['url'] as String?);

  String? get category => (_$data['category'] as String?);

  String? get collection => (_$data['collection'] as String?);

  String? get page => (_$data['page'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('collection')) {
      final l$collection = collection;
      result$data['collection'] = l$collection;
    }
    if (_$data.containsKey('page')) {
      final l$page = page;
      result$data['page'] = l$page;
    }
    return result$data;
  }

  CopyWith$Input$MenuItemInput<Input$MenuItemInput> get copyWith =>
      CopyWith$Input$MenuItemInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MenuItemInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$collection = collection;
    final lOther$collection = other.collection;
    if (_$data.containsKey('collection') !=
        other._$data.containsKey('collection')) {
      return false;
    }
    if (l$collection != lOther$collection) {
      return false;
    }
    final l$page = page;
    final lOther$page = other.page;
    if (_$data.containsKey('page') != other._$data.containsKey('page')) {
      return false;
    }
    if (l$page != lOther$page) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$url = url;
    final l$category = category;
    final l$collection = collection;
    final l$page = page;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('collection') ? l$collection : const {},
      _$data.containsKey('page') ? l$page : const {},
    ]);
  }
}

abstract class CopyWith$Input$MenuItemInput<TRes> {
  factory CopyWith$Input$MenuItemInput(
    Input$MenuItemInput instance,
    TRes Function(Input$MenuItemInput) then,
  ) = _CopyWithImpl$Input$MenuItemInput;

  factory CopyWith$Input$MenuItemInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MenuItemInput;

  TRes call({
    String? name,
    String? url,
    String? category,
    String? collection,
    String? page,
  });
}

class _CopyWithImpl$Input$MenuItemInput<TRes>
    implements CopyWith$Input$MenuItemInput<TRes> {
  _CopyWithImpl$Input$MenuItemInput(
    this._instance,
    this._then,
  );

  final Input$MenuItemInput _instance;

  final TRes Function(Input$MenuItemInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? url = _undefined,
    Object? category = _undefined,
    Object? collection = _undefined,
    Object? page = _undefined,
  }) =>
      _then(Input$MenuItemInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (url != _undefined) 'url': (url as String?),
        if (category != _undefined) 'category': (category as String?),
        if (collection != _undefined) 'collection': (collection as String?),
        if (page != _undefined) 'page': (page as String?),
      }));
}

class _CopyWithStubImpl$Input$MenuItemInput<TRes>
    implements CopyWith$Input$MenuItemInput<TRes> {
  _CopyWithStubImpl$Input$MenuItemInput(this._res);

  TRes _res;

  call({
    String? name,
    String? url,
    String? category,
    String? collection,
    String? page,
  }) =>
      _res;
}

class Input$MenuItemMoveInput {
  factory Input$MenuItemMoveInput({
    required String itemId,
    String? parentId,
    int? sortOrder,
  }) =>
      Input$MenuItemMoveInput._({
        r'itemId': itemId,
        if (parentId != null) r'parentId': parentId,
        if (sortOrder != null) r'sortOrder': sortOrder,
      });

  Input$MenuItemMoveInput._(this._$data);

  factory Input$MenuItemMoveInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    if (data.containsKey('parentId')) {
      final l$parentId = data['parentId'];
      result$data['parentId'] = (l$parentId as String?);
    }
    if (data.containsKey('sortOrder')) {
      final l$sortOrder = data['sortOrder'];
      result$data['sortOrder'] = (l$sortOrder as int?);
    }
    return Input$MenuItemMoveInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get itemId => (_$data['itemId'] as String);

  String? get parentId => (_$data['parentId'] as String?);

  int? get sortOrder => (_$data['sortOrder'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    if (_$data.containsKey('parentId')) {
      final l$parentId = parentId;
      result$data['parentId'] = l$parentId;
    }
    if (_$data.containsKey('sortOrder')) {
      final l$sortOrder = sortOrder;
      result$data['sortOrder'] = l$sortOrder;
    }
    return result$data;
  }

  CopyWith$Input$MenuItemMoveInput<Input$MenuItemMoveInput> get copyWith =>
      CopyWith$Input$MenuItemMoveInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MenuItemMoveInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$parentId = parentId;
    final lOther$parentId = other.parentId;
    if (_$data.containsKey('parentId') !=
        other._$data.containsKey('parentId')) {
      return false;
    }
    if (l$parentId != lOther$parentId) {
      return false;
    }
    final l$sortOrder = sortOrder;
    final lOther$sortOrder = other.sortOrder;
    if (_$data.containsKey('sortOrder') !=
        other._$data.containsKey('sortOrder')) {
      return false;
    }
    if (l$sortOrder != lOther$sortOrder) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$itemId = itemId;
    final l$parentId = parentId;
    final l$sortOrder = sortOrder;
    return Object.hashAll([
      l$itemId,
      _$data.containsKey('parentId') ? l$parentId : const {},
      _$data.containsKey('sortOrder') ? l$sortOrder : const {},
    ]);
  }
}

abstract class CopyWith$Input$MenuItemMoveInput<TRes> {
  factory CopyWith$Input$MenuItemMoveInput(
    Input$MenuItemMoveInput instance,
    TRes Function(Input$MenuItemMoveInput) then,
  ) = _CopyWithImpl$Input$MenuItemMoveInput;

  factory CopyWith$Input$MenuItemMoveInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MenuItemMoveInput;

  TRes call({
    String? itemId,
    String? parentId,
    int? sortOrder,
  });
}

class _CopyWithImpl$Input$MenuItemMoveInput<TRes>
    implements CopyWith$Input$MenuItemMoveInput<TRes> {
  _CopyWithImpl$Input$MenuItemMoveInput(
    this._instance,
    this._then,
  );

  final Input$MenuItemMoveInput _instance;

  final TRes Function(Input$MenuItemMoveInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? itemId = _undefined,
    Object? parentId = _undefined,
    Object? sortOrder = _undefined,
  }) =>
      _then(Input$MenuItemMoveInput._({
        ..._instance._$data,
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (parentId != _undefined) 'parentId': (parentId as String?),
        if (sortOrder != _undefined) 'sortOrder': (sortOrder as int?),
      }));
}

class _CopyWithStubImpl$Input$MenuItemMoveInput<TRes>
    implements CopyWith$Input$MenuItemMoveInput<TRes> {
  _CopyWithStubImpl$Input$MenuItemMoveInput(this._res);

  TRes _res;

  call({
    String? itemId,
    String? parentId,
    int? sortOrder,
  }) =>
      _res;
}

class Input$MenuItemSortingInput {
  factory Input$MenuItemSortingInput({
    required Enum$OrderDirection direction,
    required Enum$MenuItemsSortField field,
  }) =>
      Input$MenuItemSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$MenuItemSortingInput._(this._$data);

  factory Input$MenuItemSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$MenuItemsSortField((l$field as String));
    return Input$MenuItemSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$MenuItemsSortField get field =>
      (_$data['field'] as Enum$MenuItemsSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$MenuItemsSortField(l$field);
    return result$data;
  }

  CopyWith$Input$MenuItemSortingInput<Input$MenuItemSortingInput>
      get copyWith => CopyWith$Input$MenuItemSortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MenuItemSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$MenuItemSortingInput<TRes> {
  factory CopyWith$Input$MenuItemSortingInput(
    Input$MenuItemSortingInput instance,
    TRes Function(Input$MenuItemSortingInput) then,
  ) = _CopyWithImpl$Input$MenuItemSortingInput;

  factory CopyWith$Input$MenuItemSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MenuItemSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$MenuItemsSortField? field,
  });
}

class _CopyWithImpl$Input$MenuItemSortingInput<TRes>
    implements CopyWith$Input$MenuItemSortingInput<TRes> {
  _CopyWithImpl$Input$MenuItemSortingInput(
    this._instance,
    this._then,
  );

  final Input$MenuItemSortingInput _instance;

  final TRes Function(Input$MenuItemSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$MenuItemSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$MenuItemsSortField),
      }));
}

class _CopyWithStubImpl$Input$MenuItemSortingInput<TRes>
    implements CopyWith$Input$MenuItemSortingInput<TRes> {
  _CopyWithStubImpl$Input$MenuItemSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$MenuItemsSortField? field,
  }) =>
      _res;
}

class Input$MenuSortingInput {
  factory Input$MenuSortingInput({
    required Enum$OrderDirection direction,
    required Enum$MenuSortField field,
  }) =>
      Input$MenuSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$MenuSortingInput._(this._$data);

  factory Input$MenuSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$MenuSortField((l$field as String));
    return Input$MenuSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$MenuSortField get field => (_$data['field'] as Enum$MenuSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$MenuSortField(l$field);
    return result$data;
  }

  CopyWith$Input$MenuSortingInput<Input$MenuSortingInput> get copyWith =>
      CopyWith$Input$MenuSortingInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MenuSortingInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$MenuSortingInput<TRes> {
  factory CopyWith$Input$MenuSortingInput(
    Input$MenuSortingInput instance,
    TRes Function(Input$MenuSortingInput) then,
  ) = _CopyWithImpl$Input$MenuSortingInput;

  factory CopyWith$Input$MenuSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MenuSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$MenuSortField? field,
  });
}

class _CopyWithImpl$Input$MenuSortingInput<TRes>
    implements CopyWith$Input$MenuSortingInput<TRes> {
  _CopyWithImpl$Input$MenuSortingInput(
    this._instance,
    this._then,
  );

  final Input$MenuSortingInput _instance;

  final TRes Function(Input$MenuSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$MenuSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$MenuSortField),
      }));
}

class _CopyWithStubImpl$Input$MenuSortingInput<TRes>
    implements CopyWith$Input$MenuSortingInput<TRes> {
  _CopyWithStubImpl$Input$MenuSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$MenuSortField? field,
  }) =>
      _res;
}

class Input$MetadataFilter {
  factory Input$MetadataFilter({
    required String key,
    String? value,
  }) =>
      Input$MetadataFilter._({
        r'key': key,
        if (value != null) r'value': value,
      });

  Input$MetadataFilter._(this._$data);

  factory Input$MetadataFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$key = data['key'];
    result$data['key'] = (l$key as String);
    if (data.containsKey('value')) {
      final l$value = data['value'];
      result$data['value'] = (l$value as String?);
    }
    return Input$MetadataFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String get key => (_$data['key'] as String);

  String? get value => (_$data['value'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$key = key;
    result$data['key'] = l$key;
    if (_$data.containsKey('value')) {
      final l$value = value;
      result$data['value'] = l$value;
    }
    return result$data;
  }

  CopyWith$Input$MetadataFilter<Input$MetadataFilter> get copyWith =>
      CopyWith$Input$MetadataFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MetadataFilter || runtimeType != other.runtimeType) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (l$key != lOther$key) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (_$data.containsKey('value') != other._$data.containsKey('value')) {
      return false;
    }
    if (l$value != lOther$value) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$key = key;
    final l$value = value;
    return Object.hashAll([
      l$key,
      _$data.containsKey('value') ? l$value : const {},
    ]);
  }
}

abstract class CopyWith$Input$MetadataFilter<TRes> {
  factory CopyWith$Input$MetadataFilter(
    Input$MetadataFilter instance,
    TRes Function(Input$MetadataFilter) then,
  ) = _CopyWithImpl$Input$MetadataFilter;

  factory CopyWith$Input$MetadataFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$MetadataFilter;

  TRes call({
    String? key,
    String? value,
  });
}

class _CopyWithImpl$Input$MetadataFilter<TRes>
    implements CopyWith$Input$MetadataFilter<TRes> {
  _CopyWithImpl$Input$MetadataFilter(
    this._instance,
    this._then,
  );

  final Input$MetadataFilter _instance;

  final TRes Function(Input$MetadataFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? key = _undefined,
    Object? value = _undefined,
  }) =>
      _then(Input$MetadataFilter._({
        ..._instance._$data,
        if (key != _undefined && key != null) 'key': (key as String),
        if (value != _undefined) 'value': (value as String?),
      }));
}

class _CopyWithStubImpl$Input$MetadataFilter<TRes>
    implements CopyWith$Input$MetadataFilter<TRes> {
  _CopyWithStubImpl$Input$MetadataFilter(this._res);

  TRes _res;

  call({
    String? key,
    String? value,
  }) =>
      _res;
}

class Input$MetadataFilterInput {
  factory Input$MetadataFilterInput({
    required String key,
    Input$MetadataValueFilterInput? value,
  }) =>
      Input$MetadataFilterInput._({
        r'key': key,
        if (value != null) r'value': value,
      });

  Input$MetadataFilterInput._(this._$data);

  factory Input$MetadataFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$key = data['key'];
    result$data['key'] = (l$key as String);
    if (data.containsKey('value')) {
      final l$value = data['value'];
      result$data['value'] = l$value == null
          ? null
          : Input$MetadataValueFilterInput.fromJson(
              (l$value as Map<String, dynamic>));
    }
    return Input$MetadataFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get key => (_$data['key'] as String);

  Input$MetadataValueFilterInput? get value =>
      (_$data['value'] as Input$MetadataValueFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$key = key;
    result$data['key'] = l$key;
    if (_$data.containsKey('value')) {
      final l$value = value;
      result$data['value'] = l$value?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$MetadataFilterInput<Input$MetadataFilterInput> get copyWith =>
      CopyWith$Input$MetadataFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MetadataFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (l$key != lOther$key) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (_$data.containsKey('value') != other._$data.containsKey('value')) {
      return false;
    }
    if (l$value != lOther$value) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$key = key;
    final l$value = value;
    return Object.hashAll([
      l$key,
      _$data.containsKey('value') ? l$value : const {},
    ]);
  }
}

abstract class CopyWith$Input$MetadataFilterInput<TRes> {
  factory CopyWith$Input$MetadataFilterInput(
    Input$MetadataFilterInput instance,
    TRes Function(Input$MetadataFilterInput) then,
  ) = _CopyWithImpl$Input$MetadataFilterInput;

  factory CopyWith$Input$MetadataFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MetadataFilterInput;

  TRes call({
    String? key,
    Input$MetadataValueFilterInput? value,
  });
  CopyWith$Input$MetadataValueFilterInput<TRes> get value;
}

class _CopyWithImpl$Input$MetadataFilterInput<TRes>
    implements CopyWith$Input$MetadataFilterInput<TRes> {
  _CopyWithImpl$Input$MetadataFilterInput(
    this._instance,
    this._then,
  );

  final Input$MetadataFilterInput _instance;

  final TRes Function(Input$MetadataFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? key = _undefined,
    Object? value = _undefined,
  }) =>
      _then(Input$MetadataFilterInput._({
        ..._instance._$data,
        if (key != _undefined && key != null) 'key': (key as String),
        if (value != _undefined)
          'value': (value as Input$MetadataValueFilterInput?),
      }));

  CopyWith$Input$MetadataValueFilterInput<TRes> get value {
    final local$value = _instance.value;
    return local$value == null
        ? CopyWith$Input$MetadataValueFilterInput.stub(_then(_instance))
        : CopyWith$Input$MetadataValueFilterInput(
            local$value, (e) => call(value: e));
  }
}

class _CopyWithStubImpl$Input$MetadataFilterInput<TRes>
    implements CopyWith$Input$MetadataFilterInput<TRes> {
  _CopyWithStubImpl$Input$MetadataFilterInput(this._res);

  TRes _res;

  call({
    String? key,
    Input$MetadataValueFilterInput? value,
  }) =>
      _res;

  CopyWith$Input$MetadataValueFilterInput<TRes> get value =>
      CopyWith$Input$MetadataValueFilterInput.stub(_res);
}

class Input$MetadataInput {
  factory Input$MetadataInput({
    required String key,
    required String value,
  }) =>
      Input$MetadataInput._({
        r'key': key,
        r'value': value,
      });

  Input$MetadataInput._(this._$data);

  factory Input$MetadataInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$key = data['key'];
    result$data['key'] = (l$key as String);
    final l$value = data['value'];
    result$data['value'] = (l$value as String);
    return Input$MetadataInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get key => (_$data['key'] as String);

  String get value => (_$data['value'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$key = key;
    result$data['key'] = l$key;
    final l$value = value;
    result$data['value'] = l$value;
    return result$data;
  }

  CopyWith$Input$MetadataInput<Input$MetadataInput> get copyWith =>
      CopyWith$Input$MetadataInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MetadataInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (l$key != lOther$key) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (l$value != lOther$value) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$key = key;
    final l$value = value;
    return Object.hashAll([
      l$key,
      l$value,
    ]);
  }
}

abstract class CopyWith$Input$MetadataInput<TRes> {
  factory CopyWith$Input$MetadataInput(
    Input$MetadataInput instance,
    TRes Function(Input$MetadataInput) then,
  ) = _CopyWithImpl$Input$MetadataInput;

  factory CopyWith$Input$MetadataInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MetadataInput;

  TRes call({
    String? key,
    String? value,
  });
}

class _CopyWithImpl$Input$MetadataInput<TRes>
    implements CopyWith$Input$MetadataInput<TRes> {
  _CopyWithImpl$Input$MetadataInput(
    this._instance,
    this._then,
  );

  final Input$MetadataInput _instance;

  final TRes Function(Input$MetadataInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? key = _undefined,
    Object? value = _undefined,
  }) =>
      _then(Input$MetadataInput._({
        ..._instance._$data,
        if (key != _undefined && key != null) 'key': (key as String),
        if (value != _undefined && value != null) 'value': (value as String),
      }));
}

class _CopyWithStubImpl$Input$MetadataInput<TRes>
    implements CopyWith$Input$MetadataInput<TRes> {
  _CopyWithStubImpl$Input$MetadataInput(this._res);

  TRes _res;

  call({
    String? key,
    String? value,
  }) =>
      _res;
}

class Input$MetadataValueFilterInput {
  factory Input$MetadataValueFilterInput({
    String? eq,
    List<String>? oneOf,
  }) =>
      Input$MetadataValueFilterInput._({
        if (eq != null) r'eq': eq,
        if (oneOf != null) r'oneOf': oneOf,
      });

  Input$MetadataValueFilterInput._(this._$data);

  factory Input$MetadataValueFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('oneOf')) {
      final l$oneOf = data['oneOf'];
      result$data['oneOf'] =
          (l$oneOf as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$MetadataValueFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get eq => (_$data['eq'] as String?);

  List<String>? get oneOf => (_$data['oneOf'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('oneOf')) {
      final l$oneOf = oneOf;
      result$data['oneOf'] = l$oneOf?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$MetadataValueFilterInput<Input$MetadataValueFilterInput>
      get copyWith => CopyWith$Input$MetadataValueFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MetadataValueFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$oneOf = oneOf;
    final lOther$oneOf = other.oneOf;
    if (_$data.containsKey('oneOf') != other._$data.containsKey('oneOf')) {
      return false;
    }
    if (l$oneOf != null && lOther$oneOf != null) {
      if (l$oneOf.length != lOther$oneOf.length) {
        return false;
      }
      for (int i = 0; i < l$oneOf.length; i++) {
        final l$oneOf$entry = l$oneOf[i];
        final lOther$oneOf$entry = lOther$oneOf[i];
        if (l$oneOf$entry != lOther$oneOf$entry) {
          return false;
        }
      }
    } else if (l$oneOf != lOther$oneOf) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$oneOf = oneOf;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('oneOf')
          ? l$oneOf == null
              ? null
              : Object.hashAll(l$oneOf.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$MetadataValueFilterInput<TRes> {
  factory CopyWith$Input$MetadataValueFilterInput(
    Input$MetadataValueFilterInput instance,
    TRes Function(Input$MetadataValueFilterInput) then,
  ) = _CopyWithImpl$Input$MetadataValueFilterInput;

  factory CopyWith$Input$MetadataValueFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MetadataValueFilterInput;

  TRes call({
    String? eq,
    List<String>? oneOf,
  });
}

class _CopyWithImpl$Input$MetadataValueFilterInput<TRes>
    implements CopyWith$Input$MetadataValueFilterInput<TRes> {
  _CopyWithImpl$Input$MetadataValueFilterInput(
    this._instance,
    this._then,
  );

  final Input$MetadataValueFilterInput _instance;

  final TRes Function(Input$MetadataValueFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? oneOf = _undefined,
  }) =>
      _then(Input$MetadataValueFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as String?),
        if (oneOf != _undefined) 'oneOf': (oneOf as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$MetadataValueFilterInput<TRes>
    implements CopyWith$Input$MetadataValueFilterInput<TRes> {
  _CopyWithStubImpl$Input$MetadataValueFilterInput(this._res);

  TRes _res;

  call({
    String? eq,
    List<String>? oneOf,
  }) =>
      _res;
}

class Input$MoneyInput {
  factory Input$MoneyInput({
    required String currency,
    required String amount,
  }) =>
      Input$MoneyInput._({
        r'currency': currency,
        r'amount': amount,
      });

  Input$MoneyInput._(this._$data);

  factory Input$MoneyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$currency = data['currency'];
    result$data['currency'] = (l$currency as String);
    final l$amount = data['amount'];
    result$data['amount'] = (l$amount as String);
    return Input$MoneyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get currency => (_$data['currency'] as String);

  String get amount => (_$data['amount'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$currency = currency;
    result$data['currency'] = l$currency;
    final l$amount = amount;
    result$data['amount'] = l$amount;
    return result$data;
  }

  CopyWith$Input$MoneyInput<Input$MoneyInput> get copyWith =>
      CopyWith$Input$MoneyInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MoneyInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (l$amount != lOther$amount) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$currency = currency;
    final l$amount = amount;
    return Object.hashAll([
      l$currency,
      l$amount,
    ]);
  }
}

abstract class CopyWith$Input$MoneyInput<TRes> {
  factory CopyWith$Input$MoneyInput(
    Input$MoneyInput instance,
    TRes Function(Input$MoneyInput) then,
  ) = _CopyWithImpl$Input$MoneyInput;

  factory CopyWith$Input$MoneyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MoneyInput;

  TRes call({
    String? currency,
    String? amount,
  });
}

class _CopyWithImpl$Input$MoneyInput<TRes>
    implements CopyWith$Input$MoneyInput<TRes> {
  _CopyWithImpl$Input$MoneyInput(
    this._instance,
    this._then,
  );

  final Input$MoneyInput _instance;

  final TRes Function(Input$MoneyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? currency = _undefined,
    Object? amount = _undefined,
  }) =>
      _then(Input$MoneyInput._({
        ..._instance._$data,
        if (currency != _undefined && currency != null)
          'currency': (currency as String),
        if (amount != _undefined && amount != null)
          'amount': (amount as String),
      }));
}

class _CopyWithStubImpl$Input$MoneyInput<TRes>
    implements CopyWith$Input$MoneyInput<TRes> {
  _CopyWithStubImpl$Input$MoneyInput(this._res);

  TRes _res;

  call({
    String? currency,
    String? amount,
  }) =>
      _res;
}

class Input$MoveProductInput {
  factory Input$MoveProductInput({
    required String productId,
    int? sortOrder,
  }) =>
      Input$MoveProductInput._({
        r'productId': productId,
        if (sortOrder != null) r'sortOrder': sortOrder,
      });

  Input$MoveProductInput._(this._$data);

  factory Input$MoveProductInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$productId = data['productId'];
    result$data['productId'] = (l$productId as String);
    if (data.containsKey('sortOrder')) {
      final l$sortOrder = data['sortOrder'];
      result$data['sortOrder'] = (l$sortOrder as int?);
    }
    return Input$MoveProductInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get productId => (_$data['productId'] as String);

  int? get sortOrder => (_$data['sortOrder'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$productId = productId;
    result$data['productId'] = l$productId;
    if (_$data.containsKey('sortOrder')) {
      final l$sortOrder = sortOrder;
      result$data['sortOrder'] = l$sortOrder;
    }
    return result$data;
  }

  CopyWith$Input$MoveProductInput<Input$MoveProductInput> get copyWith =>
      CopyWith$Input$MoveProductInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MoveProductInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$productId = productId;
    final lOther$productId = other.productId;
    if (l$productId != lOther$productId) {
      return false;
    }
    final l$sortOrder = sortOrder;
    final lOther$sortOrder = other.sortOrder;
    if (_$data.containsKey('sortOrder') !=
        other._$data.containsKey('sortOrder')) {
      return false;
    }
    if (l$sortOrder != lOther$sortOrder) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$productId = productId;
    final l$sortOrder = sortOrder;
    return Object.hashAll([
      l$productId,
      _$data.containsKey('sortOrder') ? l$sortOrder : const {},
    ]);
  }
}

abstract class CopyWith$Input$MoveProductInput<TRes> {
  factory CopyWith$Input$MoveProductInput(
    Input$MoveProductInput instance,
    TRes Function(Input$MoveProductInput) then,
  ) = _CopyWithImpl$Input$MoveProductInput;

  factory CopyWith$Input$MoveProductInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MoveProductInput;

  TRes call({
    String? productId,
    int? sortOrder,
  });
}

class _CopyWithImpl$Input$MoveProductInput<TRes>
    implements CopyWith$Input$MoveProductInput<TRes> {
  _CopyWithImpl$Input$MoveProductInput(
    this._instance,
    this._then,
  );

  final Input$MoveProductInput _instance;

  final TRes Function(Input$MoveProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? productId = _undefined,
    Object? sortOrder = _undefined,
  }) =>
      _then(Input$MoveProductInput._({
        ..._instance._$data,
        if (productId != _undefined && productId != null)
          'productId': (productId as String),
        if (sortOrder != _undefined) 'sortOrder': (sortOrder as int?),
      }));
}

class _CopyWithStubImpl$Input$MoveProductInput<TRes>
    implements CopyWith$Input$MoveProductInput<TRes> {
  _CopyWithStubImpl$Input$MoveProductInput(this._res);

  TRes _res;

  call({
    String? productId,
    int? sortOrder,
  }) =>
      _res;
}

class Input$NameTranslationInput {
  factory Input$NameTranslationInput({String? name}) =>
      Input$NameTranslationInput._({
        if (name != null) r'name': name,
      });

  Input$NameTranslationInput._(this._$data);

  factory Input$NameTranslationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    return Input$NameTranslationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    return result$data;
  }

  CopyWith$Input$NameTranslationInput<Input$NameTranslationInput>
      get copyWith => CopyWith$Input$NameTranslationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$NameTranslationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    return Object.hashAll([_$data.containsKey('name') ? l$name : const {}]);
  }
}

abstract class CopyWith$Input$NameTranslationInput<TRes> {
  factory CopyWith$Input$NameTranslationInput(
    Input$NameTranslationInput instance,
    TRes Function(Input$NameTranslationInput) then,
  ) = _CopyWithImpl$Input$NameTranslationInput;

  factory CopyWith$Input$NameTranslationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NameTranslationInput;

  TRes call({String? name});
}

class _CopyWithImpl$Input$NameTranslationInput<TRes>
    implements CopyWith$Input$NameTranslationInput<TRes> {
  _CopyWithImpl$Input$NameTranslationInput(
    this._instance,
    this._then,
  );

  final Input$NameTranslationInput _instance;

  final TRes Function(Input$NameTranslationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? name = _undefined}) => _then(Input$NameTranslationInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
      }));
}

class _CopyWithStubImpl$Input$NameTranslationInput<TRes>
    implements CopyWith$Input$NameTranslationInput<TRes> {
  _CopyWithStubImpl$Input$NameTranslationInput(this._res);

  TRes _res;

  call({String? name}) => _res;
}

class Input$OrderAddNoteInput {
  factory Input$OrderAddNoteInput({required String message}) =>
      Input$OrderAddNoteInput._({
        r'message': message,
      });

  Input$OrderAddNoteInput._(this._$data);

  factory Input$OrderAddNoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$message = data['message'];
    result$data['message'] = (l$message as String);
    return Input$OrderAddNoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get message => (_$data['message'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$message = message;
    result$data['message'] = l$message;
    return result$data;
  }

  CopyWith$Input$OrderAddNoteInput<Input$OrderAddNoteInput> get copyWith =>
      CopyWith$Input$OrderAddNoteInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderAddNoteInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$message = message;
    return Object.hashAll([l$message]);
  }
}

abstract class CopyWith$Input$OrderAddNoteInput<TRes> {
  factory CopyWith$Input$OrderAddNoteInput(
    Input$OrderAddNoteInput instance,
    TRes Function(Input$OrderAddNoteInput) then,
  ) = _CopyWithImpl$Input$OrderAddNoteInput;

  factory CopyWith$Input$OrderAddNoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderAddNoteInput;

  TRes call({String? message});
}

class _CopyWithImpl$Input$OrderAddNoteInput<TRes>
    implements CopyWith$Input$OrderAddNoteInput<TRes> {
  _CopyWithImpl$Input$OrderAddNoteInput(
    this._instance,
    this._then,
  );

  final Input$OrderAddNoteInput _instance;

  final TRes Function(Input$OrderAddNoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? message = _undefined}) => _then(Input$OrderAddNoteInput._({
        ..._instance._$data,
        if (message != _undefined && message != null)
          'message': (message as String),
      }));
}

class _CopyWithStubImpl$Input$OrderAddNoteInput<TRes>
    implements CopyWith$Input$OrderAddNoteInput<TRes> {
  _CopyWithStubImpl$Input$OrderAddNoteInput(this._res);

  TRes _res;

  call({String? message}) => _res;
}

class Input$OrderAuthorizeStatusEnumFilterInput {
  factory Input$OrderAuthorizeStatusEnumFilterInput({
    Enum$OrderAuthorizeStatusEnum? eq,
    List<Enum$OrderAuthorizeStatusEnum>? oneOf,
  }) =>
      Input$OrderAuthorizeStatusEnumFilterInput._({
        if (eq != null) r'eq': eq,
        if (oneOf != null) r'oneOf': oneOf,
      });

  Input$OrderAuthorizeStatusEnumFilterInput._(this._$data);

  factory Input$OrderAuthorizeStatusEnumFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$OrderAuthorizeStatusEnum((l$eq as String));
    }
    if (data.containsKey('oneOf')) {
      final l$oneOf = data['oneOf'];
      result$data['oneOf'] = (l$oneOf as List<dynamic>?)
          ?.map((e) => fromJson$Enum$OrderAuthorizeStatusEnum((e as String)))
          .toList();
    }
    return Input$OrderAuthorizeStatusEnumFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderAuthorizeStatusEnum? get eq =>
      (_$data['eq'] as Enum$OrderAuthorizeStatusEnum?);

  List<Enum$OrderAuthorizeStatusEnum>? get oneOf =>
      (_$data['oneOf'] as List<Enum$OrderAuthorizeStatusEnum>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] =
          l$eq == null ? null : toJson$Enum$OrderAuthorizeStatusEnum(l$eq);
    }
    if (_$data.containsKey('oneOf')) {
      final l$oneOf = oneOf;
      result$data['oneOf'] =
          l$oneOf?.map((e) => toJson$Enum$OrderAuthorizeStatusEnum(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$OrderAuthorizeStatusEnumFilterInput<
          Input$OrderAuthorizeStatusEnumFilterInput>
      get copyWith => CopyWith$Input$OrderAuthorizeStatusEnumFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderAuthorizeStatusEnumFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$oneOf = oneOf;
    final lOther$oneOf = other.oneOf;
    if (_$data.containsKey('oneOf') != other._$data.containsKey('oneOf')) {
      return false;
    }
    if (l$oneOf != null && lOther$oneOf != null) {
      if (l$oneOf.length != lOther$oneOf.length) {
        return false;
      }
      for (int i = 0; i < l$oneOf.length; i++) {
        final l$oneOf$entry = l$oneOf[i];
        final lOther$oneOf$entry = lOther$oneOf[i];
        if (l$oneOf$entry != lOther$oneOf$entry) {
          return false;
        }
      }
    } else if (l$oneOf != lOther$oneOf) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$oneOf = oneOf;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('oneOf')
          ? l$oneOf == null
              ? null
              : Object.hashAll(l$oneOf.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderAuthorizeStatusEnumFilterInput<TRes> {
  factory CopyWith$Input$OrderAuthorizeStatusEnumFilterInput(
    Input$OrderAuthorizeStatusEnumFilterInput instance,
    TRes Function(Input$OrderAuthorizeStatusEnumFilterInput) then,
  ) = _CopyWithImpl$Input$OrderAuthorizeStatusEnumFilterInput;

  factory CopyWith$Input$OrderAuthorizeStatusEnumFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderAuthorizeStatusEnumFilterInput;

  TRes call({
    Enum$OrderAuthorizeStatusEnum? eq,
    List<Enum$OrderAuthorizeStatusEnum>? oneOf,
  });
}

class _CopyWithImpl$Input$OrderAuthorizeStatusEnumFilterInput<TRes>
    implements CopyWith$Input$OrderAuthorizeStatusEnumFilterInput<TRes> {
  _CopyWithImpl$Input$OrderAuthorizeStatusEnumFilterInput(
    this._instance,
    this._then,
  );

  final Input$OrderAuthorizeStatusEnumFilterInput _instance;

  final TRes Function(Input$OrderAuthorizeStatusEnumFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? oneOf = _undefined,
  }) =>
      _then(Input$OrderAuthorizeStatusEnumFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as Enum$OrderAuthorizeStatusEnum?),
        if (oneOf != _undefined)
          'oneOf': (oneOf as List<Enum$OrderAuthorizeStatusEnum>?),
      }));
}

class _CopyWithStubImpl$Input$OrderAuthorizeStatusEnumFilterInput<TRes>
    implements CopyWith$Input$OrderAuthorizeStatusEnumFilterInput<TRes> {
  _CopyWithStubImpl$Input$OrderAuthorizeStatusEnumFilterInput(this._res);

  TRes _res;

  call({
    Enum$OrderAuthorizeStatusEnum? eq,
    List<Enum$OrderAuthorizeStatusEnum>? oneOf,
  }) =>
      _res;
}

class Input$OrderBulkCreateDeliveryMethodInput {
  factory Input$OrderBulkCreateDeliveryMethodInput({
    String? warehouseId,
    String? warehouseName,
    String? shippingMethodId,
    String? shippingMethodName,
    Input$TaxedMoneyInput? shippingPrice,
    String? shippingTaxRate,
    String? shippingTaxClassId,
    String? shippingTaxClassName,
    List<Input$MetadataInput>? shippingTaxClassMetadata,
    List<Input$MetadataInput>? shippingTaxClassPrivateMetadata,
  }) =>
      Input$OrderBulkCreateDeliveryMethodInput._({
        if (warehouseId != null) r'warehouseId': warehouseId,
        if (warehouseName != null) r'warehouseName': warehouseName,
        if (shippingMethodId != null) r'shippingMethodId': shippingMethodId,
        if (shippingMethodName != null)
          r'shippingMethodName': shippingMethodName,
        if (shippingPrice != null) r'shippingPrice': shippingPrice,
        if (shippingTaxRate != null) r'shippingTaxRate': shippingTaxRate,
        if (shippingTaxClassId != null)
          r'shippingTaxClassId': shippingTaxClassId,
        if (shippingTaxClassName != null)
          r'shippingTaxClassName': shippingTaxClassName,
        if (shippingTaxClassMetadata != null)
          r'shippingTaxClassMetadata': shippingTaxClassMetadata,
        if (shippingTaxClassPrivateMetadata != null)
          r'shippingTaxClassPrivateMetadata': shippingTaxClassPrivateMetadata,
      });

  Input$OrderBulkCreateDeliveryMethodInput._(this._$data);

  factory Input$OrderBulkCreateDeliveryMethodInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('warehouseId')) {
      final l$warehouseId = data['warehouseId'];
      result$data['warehouseId'] = (l$warehouseId as String?);
    }
    if (data.containsKey('warehouseName')) {
      final l$warehouseName = data['warehouseName'];
      result$data['warehouseName'] = (l$warehouseName as String?);
    }
    if (data.containsKey('shippingMethodId')) {
      final l$shippingMethodId = data['shippingMethodId'];
      result$data['shippingMethodId'] = (l$shippingMethodId as String?);
    }
    if (data.containsKey('shippingMethodName')) {
      final l$shippingMethodName = data['shippingMethodName'];
      result$data['shippingMethodName'] = (l$shippingMethodName as String?);
    }
    if (data.containsKey('shippingPrice')) {
      final l$shippingPrice = data['shippingPrice'];
      result$data['shippingPrice'] = l$shippingPrice == null
          ? null
          : Input$TaxedMoneyInput.fromJson(
              (l$shippingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('shippingTaxRate')) {
      final l$shippingTaxRate = data['shippingTaxRate'];
      result$data['shippingTaxRate'] = (l$shippingTaxRate as String?);
    }
    if (data.containsKey('shippingTaxClassId')) {
      final l$shippingTaxClassId = data['shippingTaxClassId'];
      result$data['shippingTaxClassId'] = (l$shippingTaxClassId as String?);
    }
    if (data.containsKey('shippingTaxClassName')) {
      final l$shippingTaxClassName = data['shippingTaxClassName'];
      result$data['shippingTaxClassName'] = (l$shippingTaxClassName as String?);
    }
    if (data.containsKey('shippingTaxClassMetadata')) {
      final l$shippingTaxClassMetadata = data['shippingTaxClassMetadata'];
      result$data['shippingTaxClassMetadata'] = (l$shippingTaxClassMetadata
              as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('shippingTaxClassPrivateMetadata')) {
      final l$shippingTaxClassPrivateMetadata =
          data['shippingTaxClassPrivateMetadata'];
      result$data['shippingTaxClassPrivateMetadata'] =
          (l$shippingTaxClassPrivateMetadata as List<dynamic>?)
              ?.map((e) =>
                  Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
              .toList();
    }
    return Input$OrderBulkCreateDeliveryMethodInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get warehouseId => (_$data['warehouseId'] as String?);

  String? get warehouseName => (_$data['warehouseName'] as String?);

  String? get shippingMethodId => (_$data['shippingMethodId'] as String?);

  String? get shippingMethodName => (_$data['shippingMethodName'] as String?);

  Input$TaxedMoneyInput? get shippingPrice =>
      (_$data['shippingPrice'] as Input$TaxedMoneyInput?);

  String? get shippingTaxRate => (_$data['shippingTaxRate'] as String?);

  String? get shippingTaxClassId => (_$data['shippingTaxClassId'] as String?);

  String? get shippingTaxClassName =>
      (_$data['shippingTaxClassName'] as String?);

  List<Input$MetadataInput>? get shippingTaxClassMetadata =>
      (_$data['shippingTaxClassMetadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get shippingTaxClassPrivateMetadata =>
      (_$data['shippingTaxClassPrivateMetadata'] as List<Input$MetadataInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('warehouseId')) {
      final l$warehouseId = warehouseId;
      result$data['warehouseId'] = l$warehouseId;
    }
    if (_$data.containsKey('warehouseName')) {
      final l$warehouseName = warehouseName;
      result$data['warehouseName'] = l$warehouseName;
    }
    if (_$data.containsKey('shippingMethodId')) {
      final l$shippingMethodId = shippingMethodId;
      result$data['shippingMethodId'] = l$shippingMethodId;
    }
    if (_$data.containsKey('shippingMethodName')) {
      final l$shippingMethodName = shippingMethodName;
      result$data['shippingMethodName'] = l$shippingMethodName;
    }
    if (_$data.containsKey('shippingPrice')) {
      final l$shippingPrice = shippingPrice;
      result$data['shippingPrice'] = l$shippingPrice?.toJson();
    }
    if (_$data.containsKey('shippingTaxRate')) {
      final l$shippingTaxRate = shippingTaxRate;
      result$data['shippingTaxRate'] = l$shippingTaxRate;
    }
    if (_$data.containsKey('shippingTaxClassId')) {
      final l$shippingTaxClassId = shippingTaxClassId;
      result$data['shippingTaxClassId'] = l$shippingTaxClassId;
    }
    if (_$data.containsKey('shippingTaxClassName')) {
      final l$shippingTaxClassName = shippingTaxClassName;
      result$data['shippingTaxClassName'] = l$shippingTaxClassName;
    }
    if (_$data.containsKey('shippingTaxClassMetadata')) {
      final l$shippingTaxClassMetadata = shippingTaxClassMetadata;
      result$data['shippingTaxClassMetadata'] =
          l$shippingTaxClassMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('shippingTaxClassPrivateMetadata')) {
      final l$shippingTaxClassPrivateMetadata = shippingTaxClassPrivateMetadata;
      result$data['shippingTaxClassPrivateMetadata'] =
          l$shippingTaxClassPrivateMetadata?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$OrderBulkCreateDeliveryMethodInput<
          Input$OrderBulkCreateDeliveryMethodInput>
      get copyWith => CopyWith$Input$OrderBulkCreateDeliveryMethodInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderBulkCreateDeliveryMethodInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$warehouseId = warehouseId;
    final lOther$warehouseId = other.warehouseId;
    if (_$data.containsKey('warehouseId') !=
        other._$data.containsKey('warehouseId')) {
      return false;
    }
    if (l$warehouseId != lOther$warehouseId) {
      return false;
    }
    final l$warehouseName = warehouseName;
    final lOther$warehouseName = other.warehouseName;
    if (_$data.containsKey('warehouseName') !=
        other._$data.containsKey('warehouseName')) {
      return false;
    }
    if (l$warehouseName != lOther$warehouseName) {
      return false;
    }
    final l$shippingMethodId = shippingMethodId;
    final lOther$shippingMethodId = other.shippingMethodId;
    if (_$data.containsKey('shippingMethodId') !=
        other._$data.containsKey('shippingMethodId')) {
      return false;
    }
    if (l$shippingMethodId != lOther$shippingMethodId) {
      return false;
    }
    final l$shippingMethodName = shippingMethodName;
    final lOther$shippingMethodName = other.shippingMethodName;
    if (_$data.containsKey('shippingMethodName') !=
        other._$data.containsKey('shippingMethodName')) {
      return false;
    }
    if (l$shippingMethodName != lOther$shippingMethodName) {
      return false;
    }
    final l$shippingPrice = shippingPrice;
    final lOther$shippingPrice = other.shippingPrice;
    if (_$data.containsKey('shippingPrice') !=
        other._$data.containsKey('shippingPrice')) {
      return false;
    }
    if (l$shippingPrice != lOther$shippingPrice) {
      return false;
    }
    final l$shippingTaxRate = shippingTaxRate;
    final lOther$shippingTaxRate = other.shippingTaxRate;
    if (_$data.containsKey('shippingTaxRate') !=
        other._$data.containsKey('shippingTaxRate')) {
      return false;
    }
    if (l$shippingTaxRate != lOther$shippingTaxRate) {
      return false;
    }
    final l$shippingTaxClassId = shippingTaxClassId;
    final lOther$shippingTaxClassId = other.shippingTaxClassId;
    if (_$data.containsKey('shippingTaxClassId') !=
        other._$data.containsKey('shippingTaxClassId')) {
      return false;
    }
    if (l$shippingTaxClassId != lOther$shippingTaxClassId) {
      return false;
    }
    final l$shippingTaxClassName = shippingTaxClassName;
    final lOther$shippingTaxClassName = other.shippingTaxClassName;
    if (_$data.containsKey('shippingTaxClassName') !=
        other._$data.containsKey('shippingTaxClassName')) {
      return false;
    }
    if (l$shippingTaxClassName != lOther$shippingTaxClassName) {
      return false;
    }
    final l$shippingTaxClassMetadata = shippingTaxClassMetadata;
    final lOther$shippingTaxClassMetadata = other.shippingTaxClassMetadata;
    if (_$data.containsKey('shippingTaxClassMetadata') !=
        other._$data.containsKey('shippingTaxClassMetadata')) {
      return false;
    }
    if (l$shippingTaxClassMetadata != null &&
        lOther$shippingTaxClassMetadata != null) {
      if (l$shippingTaxClassMetadata.length !=
          lOther$shippingTaxClassMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$shippingTaxClassMetadata.length; i++) {
        final l$shippingTaxClassMetadata$entry = l$shippingTaxClassMetadata[i];
        final lOther$shippingTaxClassMetadata$entry =
            lOther$shippingTaxClassMetadata[i];
        if (l$shippingTaxClassMetadata$entry !=
            lOther$shippingTaxClassMetadata$entry) {
          return false;
        }
      }
    } else if (l$shippingTaxClassMetadata != lOther$shippingTaxClassMetadata) {
      return false;
    }
    final l$shippingTaxClassPrivateMetadata = shippingTaxClassPrivateMetadata;
    final lOther$shippingTaxClassPrivateMetadata =
        other.shippingTaxClassPrivateMetadata;
    if (_$data.containsKey('shippingTaxClassPrivateMetadata') !=
        other._$data.containsKey('shippingTaxClassPrivateMetadata')) {
      return false;
    }
    if (l$shippingTaxClassPrivateMetadata != null &&
        lOther$shippingTaxClassPrivateMetadata != null) {
      if (l$shippingTaxClassPrivateMetadata.length !=
          lOther$shippingTaxClassPrivateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$shippingTaxClassPrivateMetadata.length; i++) {
        final l$shippingTaxClassPrivateMetadata$entry =
            l$shippingTaxClassPrivateMetadata[i];
        final lOther$shippingTaxClassPrivateMetadata$entry =
            lOther$shippingTaxClassPrivateMetadata[i];
        if (l$shippingTaxClassPrivateMetadata$entry !=
            lOther$shippingTaxClassPrivateMetadata$entry) {
          return false;
        }
      }
    } else if (l$shippingTaxClassPrivateMetadata !=
        lOther$shippingTaxClassPrivateMetadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$warehouseId = warehouseId;
    final l$warehouseName = warehouseName;
    final l$shippingMethodId = shippingMethodId;
    final l$shippingMethodName = shippingMethodName;
    final l$shippingPrice = shippingPrice;
    final l$shippingTaxRate = shippingTaxRate;
    final l$shippingTaxClassId = shippingTaxClassId;
    final l$shippingTaxClassName = shippingTaxClassName;
    final l$shippingTaxClassMetadata = shippingTaxClassMetadata;
    final l$shippingTaxClassPrivateMetadata = shippingTaxClassPrivateMetadata;
    return Object.hashAll([
      _$data.containsKey('warehouseId') ? l$warehouseId : const {},
      _$data.containsKey('warehouseName') ? l$warehouseName : const {},
      _$data.containsKey('shippingMethodId') ? l$shippingMethodId : const {},
      _$data.containsKey('shippingMethodName')
          ? l$shippingMethodName
          : const {},
      _$data.containsKey('shippingPrice') ? l$shippingPrice : const {},
      _$data.containsKey('shippingTaxRate') ? l$shippingTaxRate : const {},
      _$data.containsKey('shippingTaxClassId')
          ? l$shippingTaxClassId
          : const {},
      _$data.containsKey('shippingTaxClassName')
          ? l$shippingTaxClassName
          : const {},
      _$data.containsKey('shippingTaxClassMetadata')
          ? l$shippingTaxClassMetadata == null
              ? null
              : Object.hashAll(l$shippingTaxClassMetadata.map((v) => v))
          : const {},
      _$data.containsKey('shippingTaxClassPrivateMetadata')
          ? l$shippingTaxClassPrivateMetadata == null
              ? null
              : Object.hashAll(l$shippingTaxClassPrivateMetadata.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderBulkCreateDeliveryMethodInput<TRes> {
  factory CopyWith$Input$OrderBulkCreateDeliveryMethodInput(
    Input$OrderBulkCreateDeliveryMethodInput instance,
    TRes Function(Input$OrderBulkCreateDeliveryMethodInput) then,
  ) = _CopyWithImpl$Input$OrderBulkCreateDeliveryMethodInput;

  factory CopyWith$Input$OrderBulkCreateDeliveryMethodInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderBulkCreateDeliveryMethodInput;

  TRes call({
    String? warehouseId,
    String? warehouseName,
    String? shippingMethodId,
    String? shippingMethodName,
    Input$TaxedMoneyInput? shippingPrice,
    String? shippingTaxRate,
    String? shippingTaxClassId,
    String? shippingTaxClassName,
    List<Input$MetadataInput>? shippingTaxClassMetadata,
    List<Input$MetadataInput>? shippingTaxClassPrivateMetadata,
  });
  CopyWith$Input$TaxedMoneyInput<TRes> get shippingPrice;
  TRes shippingTaxClassMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes shippingTaxClassPrivateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$OrderBulkCreateDeliveryMethodInput<TRes>
    implements CopyWith$Input$OrderBulkCreateDeliveryMethodInput<TRes> {
  _CopyWithImpl$Input$OrderBulkCreateDeliveryMethodInput(
    this._instance,
    this._then,
  );

  final Input$OrderBulkCreateDeliveryMethodInput _instance;

  final TRes Function(Input$OrderBulkCreateDeliveryMethodInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? warehouseId = _undefined,
    Object? warehouseName = _undefined,
    Object? shippingMethodId = _undefined,
    Object? shippingMethodName = _undefined,
    Object? shippingPrice = _undefined,
    Object? shippingTaxRate = _undefined,
    Object? shippingTaxClassId = _undefined,
    Object? shippingTaxClassName = _undefined,
    Object? shippingTaxClassMetadata = _undefined,
    Object? shippingTaxClassPrivateMetadata = _undefined,
  }) =>
      _then(Input$OrderBulkCreateDeliveryMethodInput._({
        ..._instance._$data,
        if (warehouseId != _undefined) 'warehouseId': (warehouseId as String?),
        if (warehouseName != _undefined)
          'warehouseName': (warehouseName as String?),
        if (shippingMethodId != _undefined)
          'shippingMethodId': (shippingMethodId as String?),
        if (shippingMethodName != _undefined)
          'shippingMethodName': (shippingMethodName as String?),
        if (shippingPrice != _undefined)
          'shippingPrice': (shippingPrice as Input$TaxedMoneyInput?),
        if (shippingTaxRate != _undefined)
          'shippingTaxRate': (shippingTaxRate as String?),
        if (shippingTaxClassId != _undefined)
          'shippingTaxClassId': (shippingTaxClassId as String?),
        if (shippingTaxClassName != _undefined)
          'shippingTaxClassName': (shippingTaxClassName as String?),
        if (shippingTaxClassMetadata != _undefined)
          'shippingTaxClassMetadata':
              (shippingTaxClassMetadata as List<Input$MetadataInput>?),
        if (shippingTaxClassPrivateMetadata != _undefined)
          'shippingTaxClassPrivateMetadata':
              (shippingTaxClassPrivateMetadata as List<Input$MetadataInput>?),
      }));

  CopyWith$Input$TaxedMoneyInput<TRes> get shippingPrice {
    final local$shippingPrice = _instance.shippingPrice;
    return local$shippingPrice == null
        ? CopyWith$Input$TaxedMoneyInput.stub(_then(_instance))
        : CopyWith$Input$TaxedMoneyInput(
            local$shippingPrice, (e) => call(shippingPrice: e));
  }

  TRes shippingTaxClassMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          shippingTaxClassMetadata: _fn(_instance.shippingTaxClassMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes shippingTaxClassPrivateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          shippingTaxClassPrivateMetadata: _fn(_instance
              .shippingTaxClassPrivateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$OrderBulkCreateDeliveryMethodInput<TRes>
    implements CopyWith$Input$OrderBulkCreateDeliveryMethodInput<TRes> {
  _CopyWithStubImpl$Input$OrderBulkCreateDeliveryMethodInput(this._res);

  TRes _res;

  call({
    String? warehouseId,
    String? warehouseName,
    String? shippingMethodId,
    String? shippingMethodName,
    Input$TaxedMoneyInput? shippingPrice,
    String? shippingTaxRate,
    String? shippingTaxClassId,
    String? shippingTaxClassName,
    List<Input$MetadataInput>? shippingTaxClassMetadata,
    List<Input$MetadataInput>? shippingTaxClassPrivateMetadata,
  }) =>
      _res;

  CopyWith$Input$TaxedMoneyInput<TRes> get shippingPrice =>
      CopyWith$Input$TaxedMoneyInput.stub(_res);

  shippingTaxClassMetadata(_fn) => _res;

  shippingTaxClassPrivateMetadata(_fn) => _res;
}

class Input$OrderBulkCreateFulfillmentInput {
  factory Input$OrderBulkCreateFulfillmentInput({
    String? trackingCode,
    List<Input$OrderBulkCreateFulfillmentLineInput>? lines,
  }) =>
      Input$OrderBulkCreateFulfillmentInput._({
        if (trackingCode != null) r'trackingCode': trackingCode,
        if (lines != null) r'lines': lines,
      });

  Input$OrderBulkCreateFulfillmentInput._(this._$data);

  factory Input$OrderBulkCreateFulfillmentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('trackingCode')) {
      final l$trackingCode = data['trackingCode'];
      result$data['trackingCode'] = (l$trackingCode as String?);
    }
    if (data.containsKey('lines')) {
      final l$lines = data['lines'];
      result$data['lines'] = (l$lines as List<dynamic>?)
          ?.map((e) => Input$OrderBulkCreateFulfillmentLineInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$OrderBulkCreateFulfillmentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get trackingCode => (_$data['trackingCode'] as String?);

  List<Input$OrderBulkCreateFulfillmentLineInput>? get lines =>
      (_$data['lines'] as List<Input$OrderBulkCreateFulfillmentLineInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('trackingCode')) {
      final l$trackingCode = trackingCode;
      result$data['trackingCode'] = l$trackingCode;
    }
    if (_$data.containsKey('lines')) {
      final l$lines = lines;
      result$data['lines'] = l$lines?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$OrderBulkCreateFulfillmentInput<
          Input$OrderBulkCreateFulfillmentInput>
      get copyWith => CopyWith$Input$OrderBulkCreateFulfillmentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderBulkCreateFulfillmentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$trackingCode = trackingCode;
    final lOther$trackingCode = other.trackingCode;
    if (_$data.containsKey('trackingCode') !=
        other._$data.containsKey('trackingCode')) {
      return false;
    }
    if (l$trackingCode != lOther$trackingCode) {
      return false;
    }
    final l$lines = lines;
    final lOther$lines = other.lines;
    if (_$data.containsKey('lines') != other._$data.containsKey('lines')) {
      return false;
    }
    if (l$lines != null && lOther$lines != null) {
      if (l$lines.length != lOther$lines.length) {
        return false;
      }
      for (int i = 0; i < l$lines.length; i++) {
        final l$lines$entry = l$lines[i];
        final lOther$lines$entry = lOther$lines[i];
        if (l$lines$entry != lOther$lines$entry) {
          return false;
        }
      }
    } else if (l$lines != lOther$lines) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$trackingCode = trackingCode;
    final l$lines = lines;
    return Object.hashAll([
      _$data.containsKey('trackingCode') ? l$trackingCode : const {},
      _$data.containsKey('lines')
          ? l$lines == null
              ? null
              : Object.hashAll(l$lines.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderBulkCreateFulfillmentInput<TRes> {
  factory CopyWith$Input$OrderBulkCreateFulfillmentInput(
    Input$OrderBulkCreateFulfillmentInput instance,
    TRes Function(Input$OrderBulkCreateFulfillmentInput) then,
  ) = _CopyWithImpl$Input$OrderBulkCreateFulfillmentInput;

  factory CopyWith$Input$OrderBulkCreateFulfillmentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderBulkCreateFulfillmentInput;

  TRes call({
    String? trackingCode,
    List<Input$OrderBulkCreateFulfillmentLineInput>? lines,
  });
  TRes lines(
      Iterable<Input$OrderBulkCreateFulfillmentLineInput>? Function(
              Iterable<
                  CopyWith$Input$OrderBulkCreateFulfillmentLineInput<
                      Input$OrderBulkCreateFulfillmentLineInput>>?)
          _fn);
}

class _CopyWithImpl$Input$OrderBulkCreateFulfillmentInput<TRes>
    implements CopyWith$Input$OrderBulkCreateFulfillmentInput<TRes> {
  _CopyWithImpl$Input$OrderBulkCreateFulfillmentInput(
    this._instance,
    this._then,
  );

  final Input$OrderBulkCreateFulfillmentInput _instance;

  final TRes Function(Input$OrderBulkCreateFulfillmentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? trackingCode = _undefined,
    Object? lines = _undefined,
  }) =>
      _then(Input$OrderBulkCreateFulfillmentInput._({
        ..._instance._$data,
        if (trackingCode != _undefined)
          'trackingCode': (trackingCode as String?),
        if (lines != _undefined)
          'lines': (lines as List<Input$OrderBulkCreateFulfillmentLineInput>?),
      }));

  TRes lines(
          Iterable<Input$OrderBulkCreateFulfillmentLineInput>? Function(
                  Iterable<
                      CopyWith$Input$OrderBulkCreateFulfillmentLineInput<
                          Input$OrderBulkCreateFulfillmentLineInput>>?)
              _fn) =>
      call(
          lines: _fn(_instance.lines
              ?.map((e) => CopyWith$Input$OrderBulkCreateFulfillmentLineInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$OrderBulkCreateFulfillmentInput<TRes>
    implements CopyWith$Input$OrderBulkCreateFulfillmentInput<TRes> {
  _CopyWithStubImpl$Input$OrderBulkCreateFulfillmentInput(this._res);

  TRes _res;

  call({
    String? trackingCode,
    List<Input$OrderBulkCreateFulfillmentLineInput>? lines,
  }) =>
      _res;

  lines(_fn) => _res;
}

class Input$OrderBulkCreateFulfillmentLineInput {
  factory Input$OrderBulkCreateFulfillmentLineInput({
    String? variantId,
    String? variantSku,
    String? variantExternalReference,
    required int quantity,
    required String warehouse,
    required int orderLineIndex,
  }) =>
      Input$OrderBulkCreateFulfillmentLineInput._({
        if (variantId != null) r'variantId': variantId,
        if (variantSku != null) r'variantSku': variantSku,
        if (variantExternalReference != null)
          r'variantExternalReference': variantExternalReference,
        r'quantity': quantity,
        r'warehouse': warehouse,
        r'orderLineIndex': orderLineIndex,
      });

  Input$OrderBulkCreateFulfillmentLineInput._(this._$data);

  factory Input$OrderBulkCreateFulfillmentLineInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('variantId')) {
      final l$variantId = data['variantId'];
      result$data['variantId'] = (l$variantId as String?);
    }
    if (data.containsKey('variantSku')) {
      final l$variantSku = data['variantSku'];
      result$data['variantSku'] = (l$variantSku as String?);
    }
    if (data.containsKey('variantExternalReference')) {
      final l$variantExternalReference = data['variantExternalReference'];
      result$data['variantExternalReference'] =
          (l$variantExternalReference as String?);
    }
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$warehouse = data['warehouse'];
    result$data['warehouse'] = (l$warehouse as String);
    final l$orderLineIndex = data['orderLineIndex'];
    result$data['orderLineIndex'] = (l$orderLineIndex as int);
    return Input$OrderBulkCreateFulfillmentLineInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get variantId => (_$data['variantId'] as String?);

  String? get variantSku => (_$data['variantSku'] as String?);

  String? get variantExternalReference =>
      (_$data['variantExternalReference'] as String?);

  int get quantity => (_$data['quantity'] as int);

  String get warehouse => (_$data['warehouse'] as String);

  int get orderLineIndex => (_$data['orderLineIndex'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('variantId')) {
      final l$variantId = variantId;
      result$data['variantId'] = l$variantId;
    }
    if (_$data.containsKey('variantSku')) {
      final l$variantSku = variantSku;
      result$data['variantSku'] = l$variantSku;
    }
    if (_$data.containsKey('variantExternalReference')) {
      final l$variantExternalReference = variantExternalReference;
      result$data['variantExternalReference'] = l$variantExternalReference;
    }
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$warehouse = warehouse;
    result$data['warehouse'] = l$warehouse;
    final l$orderLineIndex = orderLineIndex;
    result$data['orderLineIndex'] = l$orderLineIndex;
    return result$data;
  }

  CopyWith$Input$OrderBulkCreateFulfillmentLineInput<
          Input$OrderBulkCreateFulfillmentLineInput>
      get copyWith => CopyWith$Input$OrderBulkCreateFulfillmentLineInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderBulkCreateFulfillmentLineInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$variantId = variantId;
    final lOther$variantId = other.variantId;
    if (_$data.containsKey('variantId') !=
        other._$data.containsKey('variantId')) {
      return false;
    }
    if (l$variantId != lOther$variantId) {
      return false;
    }
    final l$variantSku = variantSku;
    final lOther$variantSku = other.variantSku;
    if (_$data.containsKey('variantSku') !=
        other._$data.containsKey('variantSku')) {
      return false;
    }
    if (l$variantSku != lOther$variantSku) {
      return false;
    }
    final l$variantExternalReference = variantExternalReference;
    final lOther$variantExternalReference = other.variantExternalReference;
    if (_$data.containsKey('variantExternalReference') !=
        other._$data.containsKey('variantExternalReference')) {
      return false;
    }
    if (l$variantExternalReference != lOther$variantExternalReference) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$warehouse = warehouse;
    final lOther$warehouse = other.warehouse;
    if (l$warehouse != lOther$warehouse) {
      return false;
    }
    final l$orderLineIndex = orderLineIndex;
    final lOther$orderLineIndex = other.orderLineIndex;
    if (l$orderLineIndex != lOther$orderLineIndex) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$variantId = variantId;
    final l$variantSku = variantSku;
    final l$variantExternalReference = variantExternalReference;
    final l$quantity = quantity;
    final l$warehouse = warehouse;
    final l$orderLineIndex = orderLineIndex;
    return Object.hashAll([
      _$data.containsKey('variantId') ? l$variantId : const {},
      _$data.containsKey('variantSku') ? l$variantSku : const {},
      _$data.containsKey('variantExternalReference')
          ? l$variantExternalReference
          : const {},
      l$quantity,
      l$warehouse,
      l$orderLineIndex,
    ]);
  }
}

abstract class CopyWith$Input$OrderBulkCreateFulfillmentLineInput<TRes> {
  factory CopyWith$Input$OrderBulkCreateFulfillmentLineInput(
    Input$OrderBulkCreateFulfillmentLineInput instance,
    TRes Function(Input$OrderBulkCreateFulfillmentLineInput) then,
  ) = _CopyWithImpl$Input$OrderBulkCreateFulfillmentLineInput;

  factory CopyWith$Input$OrderBulkCreateFulfillmentLineInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderBulkCreateFulfillmentLineInput;

  TRes call({
    String? variantId,
    String? variantSku,
    String? variantExternalReference,
    int? quantity,
    String? warehouse,
    int? orderLineIndex,
  });
}

class _CopyWithImpl$Input$OrderBulkCreateFulfillmentLineInput<TRes>
    implements CopyWith$Input$OrderBulkCreateFulfillmentLineInput<TRes> {
  _CopyWithImpl$Input$OrderBulkCreateFulfillmentLineInput(
    this._instance,
    this._then,
  );

  final Input$OrderBulkCreateFulfillmentLineInput _instance;

  final TRes Function(Input$OrderBulkCreateFulfillmentLineInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? variantId = _undefined,
    Object? variantSku = _undefined,
    Object? variantExternalReference = _undefined,
    Object? quantity = _undefined,
    Object? warehouse = _undefined,
    Object? orderLineIndex = _undefined,
  }) =>
      _then(Input$OrderBulkCreateFulfillmentLineInput._({
        ..._instance._$data,
        if (variantId != _undefined) 'variantId': (variantId as String?),
        if (variantSku != _undefined) 'variantSku': (variantSku as String?),
        if (variantExternalReference != _undefined)
          'variantExternalReference': (variantExternalReference as String?),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (warehouse != _undefined && warehouse != null)
          'warehouse': (warehouse as String),
        if (orderLineIndex != _undefined && orderLineIndex != null)
          'orderLineIndex': (orderLineIndex as int),
      }));
}

class _CopyWithStubImpl$Input$OrderBulkCreateFulfillmentLineInput<TRes>
    implements CopyWith$Input$OrderBulkCreateFulfillmentLineInput<TRes> {
  _CopyWithStubImpl$Input$OrderBulkCreateFulfillmentLineInput(this._res);

  TRes _res;

  call({
    String? variantId,
    String? variantSku,
    String? variantExternalReference,
    int? quantity,
    String? warehouse,
    int? orderLineIndex,
  }) =>
      _res;
}

class Input$OrderBulkCreateInput {
  factory Input$OrderBulkCreateInput({
    String? externalReference,
    required String channel,
    required String createdAt,
    Enum$OrderStatus? status,
    required Input$OrderBulkCreateUserInput user,
    required Input$AddressInput billingAddress,
    Input$AddressInput? shippingAddress,
    required String currency,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? customerNote,
    List<Input$OrderBulkCreateNoteInput>? notes,
    required Enum$LanguageCodeEnum languageCode,
    bool? displayGrossPrices,
    String? weight,
    String? redirectUrl,
    required List<Input$OrderBulkCreateOrderLineInput> lines,
    Input$OrderBulkCreateDeliveryMethodInput? deliveryMethod,
    List<String>? giftCards,
    String? voucherCode,
    List<Input$OrderDiscountCommonInput>? discounts,
    List<Input$OrderBulkCreateFulfillmentInput>? fulfillments,
    List<Input$TransactionCreateInput>? transactions,
    List<Input$OrderBulkCreateInvoiceInput>? invoices,
  }) =>
      Input$OrderBulkCreateInput._({
        if (externalReference != null) r'externalReference': externalReference,
        r'channel': channel,
        r'createdAt': createdAt,
        if (status != null) r'status': status,
        r'user': user,
        r'billingAddress': billingAddress,
        if (shippingAddress != null) r'shippingAddress': shippingAddress,
        r'currency': currency,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (customerNote != null) r'customerNote': customerNote,
        if (notes != null) r'notes': notes,
        r'languageCode': languageCode,
        if (displayGrossPrices != null)
          r'displayGrossPrices': displayGrossPrices,
        if (weight != null) r'weight': weight,
        if (redirectUrl != null) r'redirectUrl': redirectUrl,
        r'lines': lines,
        if (deliveryMethod != null) r'deliveryMethod': deliveryMethod,
        if (giftCards != null) r'giftCards': giftCards,
        if (voucherCode != null) r'voucherCode': voucherCode,
        if (discounts != null) r'discounts': discounts,
        if (fulfillments != null) r'fulfillments': fulfillments,
        if (transactions != null) r'transactions': transactions,
        if (invoices != null) r'invoices': invoices,
      });

  Input$OrderBulkCreateInput._(this._$data);

  factory Input$OrderBulkCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    final l$channel = data['channel'];
    result$data['channel'] = (l$channel as String);
    final l$createdAt = data['createdAt'];
    result$data['createdAt'] = (l$createdAt as String);
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$OrderStatus((l$status as String));
    }
    final l$user = data['user'];
    result$data['user'] = Input$OrderBulkCreateUserInput.fromJson(
        (l$user as Map<String, dynamic>));
    final l$billingAddress = data['billingAddress'];
    result$data['billingAddress'] =
        Input$AddressInput.fromJson((l$billingAddress as Map<String, dynamic>));
    if (data.containsKey('shippingAddress')) {
      final l$shippingAddress = data['shippingAddress'];
      result$data['shippingAddress'] = l$shippingAddress == null
          ? null
          : Input$AddressInput.fromJson(
              (l$shippingAddress as Map<String, dynamic>));
    }
    final l$currency = data['currency'];
    result$data['currency'] = (l$currency as String);
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('customerNote')) {
      final l$customerNote = data['customerNote'];
      result$data['customerNote'] = (l$customerNote as String?);
    }
    if (data.containsKey('notes')) {
      final l$notes = data['notes'];
      result$data['notes'] = (l$notes as List<dynamic>?)
          ?.map((e) => Input$OrderBulkCreateNoteInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    final l$languageCode = data['languageCode'];
    result$data['languageCode'] =
        fromJson$Enum$LanguageCodeEnum((l$languageCode as String));
    if (data.containsKey('displayGrossPrices')) {
      final l$displayGrossPrices = data['displayGrossPrices'];
      result$data['displayGrossPrices'] = (l$displayGrossPrices as bool?);
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as String?);
    }
    if (data.containsKey('redirectUrl')) {
      final l$redirectUrl = data['redirectUrl'];
      result$data['redirectUrl'] = (l$redirectUrl as String?);
    }
    final l$lines = data['lines'];
    result$data['lines'] = (l$lines as List<dynamic>)
        .map((e) => Input$OrderBulkCreateOrderLineInput.fromJson(
            (e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('deliveryMethod')) {
      final l$deliveryMethod = data['deliveryMethod'];
      result$data['deliveryMethod'] = l$deliveryMethod == null
          ? null
          : Input$OrderBulkCreateDeliveryMethodInput.fromJson(
              (l$deliveryMethod as Map<String, dynamic>));
    }
    if (data.containsKey('giftCards')) {
      final l$giftCards = data['giftCards'];
      result$data['giftCards'] =
          (l$giftCards as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('voucherCode')) {
      final l$voucherCode = data['voucherCode'];
      result$data['voucherCode'] = (l$voucherCode as String?);
    }
    if (data.containsKey('discounts')) {
      final l$discounts = data['discounts'];
      result$data['discounts'] = (l$discounts as List<dynamic>?)
          ?.map((e) => Input$OrderDiscountCommonInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('fulfillments')) {
      final l$fulfillments = data['fulfillments'];
      result$data['fulfillments'] = (l$fulfillments as List<dynamic>?)
          ?.map((e) => Input$OrderBulkCreateFulfillmentInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('transactions')) {
      final l$transactions = data['transactions'];
      result$data['transactions'] = (l$transactions as List<dynamic>?)
          ?.map((e) => Input$TransactionCreateInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('invoices')) {
      final l$invoices = data['invoices'];
      result$data['invoices'] = (l$invoices as List<dynamic>?)
          ?.map((e) => Input$OrderBulkCreateInvoiceInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$OrderBulkCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get externalReference => (_$data['externalReference'] as String?);

  String get channel => (_$data['channel'] as String);

  String get createdAt => (_$data['createdAt'] as String);

  Enum$OrderStatus? get status => (_$data['status'] as Enum$OrderStatus?);

  Input$OrderBulkCreateUserInput get user =>
      (_$data['user'] as Input$OrderBulkCreateUserInput);

  Input$AddressInput get billingAddress =>
      (_$data['billingAddress'] as Input$AddressInput);

  Input$AddressInput? get shippingAddress =>
      (_$data['shippingAddress'] as Input$AddressInput?);

  String get currency => (_$data['currency'] as String);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  String? get customerNote => (_$data['customerNote'] as String?);

  List<Input$OrderBulkCreateNoteInput>? get notes =>
      (_$data['notes'] as List<Input$OrderBulkCreateNoteInput>?);

  Enum$LanguageCodeEnum get languageCode =>
      (_$data['languageCode'] as Enum$LanguageCodeEnum);

  bool? get displayGrossPrices => (_$data['displayGrossPrices'] as bool?);

  String? get weight => (_$data['weight'] as String?);

  String? get redirectUrl => (_$data['redirectUrl'] as String?);

  List<Input$OrderBulkCreateOrderLineInput> get lines =>
      (_$data['lines'] as List<Input$OrderBulkCreateOrderLineInput>);

  Input$OrderBulkCreateDeliveryMethodInput? get deliveryMethod =>
      (_$data['deliveryMethod'] as Input$OrderBulkCreateDeliveryMethodInput?);

  List<String>? get giftCards => (_$data['giftCards'] as List<String>?);

  String? get voucherCode => (_$data['voucherCode'] as String?);

  List<Input$OrderDiscountCommonInput>? get discounts =>
      (_$data['discounts'] as List<Input$OrderDiscountCommonInput>?);

  List<Input$OrderBulkCreateFulfillmentInput>? get fulfillments =>
      (_$data['fulfillments'] as List<Input$OrderBulkCreateFulfillmentInput>?);

  List<Input$TransactionCreateInput>? get transactions =>
      (_$data['transactions'] as List<Input$TransactionCreateInput>?);

  List<Input$OrderBulkCreateInvoiceInput>? get invoices =>
      (_$data['invoices'] as List<Input$OrderBulkCreateInvoiceInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    final l$channel = channel;
    result$data['channel'] = l$channel;
    final l$createdAt = createdAt;
    result$data['createdAt'] = l$createdAt;
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$OrderStatus(l$status);
    }
    final l$user = user;
    result$data['user'] = l$user.toJson();
    final l$billingAddress = billingAddress;
    result$data['billingAddress'] = l$billingAddress.toJson();
    if (_$data.containsKey('shippingAddress')) {
      final l$shippingAddress = shippingAddress;
      result$data['shippingAddress'] = l$shippingAddress?.toJson();
    }
    final l$currency = currency;
    result$data['currency'] = l$currency;
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('customerNote')) {
      final l$customerNote = customerNote;
      result$data['customerNote'] = l$customerNote;
    }
    if (_$data.containsKey('notes')) {
      final l$notes = notes;
      result$data['notes'] = l$notes?.map((e) => e.toJson()).toList();
    }
    final l$languageCode = languageCode;
    result$data['languageCode'] = toJson$Enum$LanguageCodeEnum(l$languageCode);
    if (_$data.containsKey('displayGrossPrices')) {
      final l$displayGrossPrices = displayGrossPrices;
      result$data['displayGrossPrices'] = l$displayGrossPrices;
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    if (_$data.containsKey('redirectUrl')) {
      final l$redirectUrl = redirectUrl;
      result$data['redirectUrl'] = l$redirectUrl;
    }
    final l$lines = lines;
    result$data['lines'] = l$lines.map((e) => e.toJson()).toList();
    if (_$data.containsKey('deliveryMethod')) {
      final l$deliveryMethod = deliveryMethod;
      result$data['deliveryMethod'] = l$deliveryMethod?.toJson();
    }
    if (_$data.containsKey('giftCards')) {
      final l$giftCards = giftCards;
      result$data['giftCards'] = l$giftCards?.map((e) => e).toList();
    }
    if (_$data.containsKey('voucherCode')) {
      final l$voucherCode = voucherCode;
      result$data['voucherCode'] = l$voucherCode;
    }
    if (_$data.containsKey('discounts')) {
      final l$discounts = discounts;
      result$data['discounts'] = l$discounts?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('fulfillments')) {
      final l$fulfillments = fulfillments;
      result$data['fulfillments'] =
          l$fulfillments?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('transactions')) {
      final l$transactions = transactions;
      result$data['transactions'] =
          l$transactions?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('invoices')) {
      final l$invoices = invoices;
      result$data['invoices'] = l$invoices?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$OrderBulkCreateInput<Input$OrderBulkCreateInput>
      get copyWith => CopyWith$Input$OrderBulkCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderBulkCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$channel = channel;
    final lOther$channel = other.channel;
    if (l$channel != lOther$channel) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) {
      return false;
    }
    final l$billingAddress = billingAddress;
    final lOther$billingAddress = other.billingAddress;
    if (l$billingAddress != lOther$billingAddress) {
      return false;
    }
    final l$shippingAddress = shippingAddress;
    final lOther$shippingAddress = other.shippingAddress;
    if (_$data.containsKey('shippingAddress') !=
        other._$data.containsKey('shippingAddress')) {
      return false;
    }
    if (l$shippingAddress != lOther$shippingAddress) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$customerNote = customerNote;
    final lOther$customerNote = other.customerNote;
    if (_$data.containsKey('customerNote') !=
        other._$data.containsKey('customerNote')) {
      return false;
    }
    if (l$customerNote != lOther$customerNote) {
      return false;
    }
    final l$notes = notes;
    final lOther$notes = other.notes;
    if (_$data.containsKey('notes') != other._$data.containsKey('notes')) {
      return false;
    }
    if (l$notes != null && lOther$notes != null) {
      if (l$notes.length != lOther$notes.length) {
        return false;
      }
      for (int i = 0; i < l$notes.length; i++) {
        final l$notes$entry = l$notes[i];
        final lOther$notes$entry = lOther$notes[i];
        if (l$notes$entry != lOther$notes$entry) {
          return false;
        }
      }
    } else if (l$notes != lOther$notes) {
      return false;
    }
    final l$languageCode = languageCode;
    final lOther$languageCode = other.languageCode;
    if (l$languageCode != lOther$languageCode) {
      return false;
    }
    final l$displayGrossPrices = displayGrossPrices;
    final lOther$displayGrossPrices = other.displayGrossPrices;
    if (_$data.containsKey('displayGrossPrices') !=
        other._$data.containsKey('displayGrossPrices')) {
      return false;
    }
    if (l$displayGrossPrices != lOther$displayGrossPrices) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    final l$redirectUrl = redirectUrl;
    final lOther$redirectUrl = other.redirectUrl;
    if (_$data.containsKey('redirectUrl') !=
        other._$data.containsKey('redirectUrl')) {
      return false;
    }
    if (l$redirectUrl != lOther$redirectUrl) {
      return false;
    }
    final l$lines = lines;
    final lOther$lines = other.lines;
    if (l$lines.length != lOther$lines.length) {
      return false;
    }
    for (int i = 0; i < l$lines.length; i++) {
      final l$lines$entry = l$lines[i];
      final lOther$lines$entry = lOther$lines[i];
      if (l$lines$entry != lOther$lines$entry) {
        return false;
      }
    }
    final l$deliveryMethod = deliveryMethod;
    final lOther$deliveryMethod = other.deliveryMethod;
    if (_$data.containsKey('deliveryMethod') !=
        other._$data.containsKey('deliveryMethod')) {
      return false;
    }
    if (l$deliveryMethod != lOther$deliveryMethod) {
      return false;
    }
    final l$giftCards = giftCards;
    final lOther$giftCards = other.giftCards;
    if (_$data.containsKey('giftCards') !=
        other._$data.containsKey('giftCards')) {
      return false;
    }
    if (l$giftCards != null && lOther$giftCards != null) {
      if (l$giftCards.length != lOther$giftCards.length) {
        return false;
      }
      for (int i = 0; i < l$giftCards.length; i++) {
        final l$giftCards$entry = l$giftCards[i];
        final lOther$giftCards$entry = lOther$giftCards[i];
        if (l$giftCards$entry != lOther$giftCards$entry) {
          return false;
        }
      }
    } else if (l$giftCards != lOther$giftCards) {
      return false;
    }
    final l$voucherCode = voucherCode;
    final lOther$voucherCode = other.voucherCode;
    if (_$data.containsKey('voucherCode') !=
        other._$data.containsKey('voucherCode')) {
      return false;
    }
    if (l$voucherCode != lOther$voucherCode) {
      return false;
    }
    final l$discounts = discounts;
    final lOther$discounts = other.discounts;
    if (_$data.containsKey('discounts') !=
        other._$data.containsKey('discounts')) {
      return false;
    }
    if (l$discounts != null && lOther$discounts != null) {
      if (l$discounts.length != lOther$discounts.length) {
        return false;
      }
      for (int i = 0; i < l$discounts.length; i++) {
        final l$discounts$entry = l$discounts[i];
        final lOther$discounts$entry = lOther$discounts[i];
        if (l$discounts$entry != lOther$discounts$entry) {
          return false;
        }
      }
    } else if (l$discounts != lOther$discounts) {
      return false;
    }
    final l$fulfillments = fulfillments;
    final lOther$fulfillments = other.fulfillments;
    if (_$data.containsKey('fulfillments') !=
        other._$data.containsKey('fulfillments')) {
      return false;
    }
    if (l$fulfillments != null && lOther$fulfillments != null) {
      if (l$fulfillments.length != lOther$fulfillments.length) {
        return false;
      }
      for (int i = 0; i < l$fulfillments.length; i++) {
        final l$fulfillments$entry = l$fulfillments[i];
        final lOther$fulfillments$entry = lOther$fulfillments[i];
        if (l$fulfillments$entry != lOther$fulfillments$entry) {
          return false;
        }
      }
    } else if (l$fulfillments != lOther$fulfillments) {
      return false;
    }
    final l$transactions = transactions;
    final lOther$transactions = other.transactions;
    if (_$data.containsKey('transactions') !=
        other._$data.containsKey('transactions')) {
      return false;
    }
    if (l$transactions != null && lOther$transactions != null) {
      if (l$transactions.length != lOther$transactions.length) {
        return false;
      }
      for (int i = 0; i < l$transactions.length; i++) {
        final l$transactions$entry = l$transactions[i];
        final lOther$transactions$entry = lOther$transactions[i];
        if (l$transactions$entry != lOther$transactions$entry) {
          return false;
        }
      }
    } else if (l$transactions != lOther$transactions) {
      return false;
    }
    final l$invoices = invoices;
    final lOther$invoices = other.invoices;
    if (_$data.containsKey('invoices') !=
        other._$data.containsKey('invoices')) {
      return false;
    }
    if (l$invoices != null && lOther$invoices != null) {
      if (l$invoices.length != lOther$invoices.length) {
        return false;
      }
      for (int i = 0; i < l$invoices.length; i++) {
        final l$invoices$entry = l$invoices[i];
        final lOther$invoices$entry = lOther$invoices[i];
        if (l$invoices$entry != lOther$invoices$entry) {
          return false;
        }
      }
    } else if (l$invoices != lOther$invoices) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$externalReference = externalReference;
    final l$channel = channel;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$user = user;
    final l$billingAddress = billingAddress;
    final l$shippingAddress = shippingAddress;
    final l$currency = currency;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$customerNote = customerNote;
    final l$notes = notes;
    final l$languageCode = languageCode;
    final l$displayGrossPrices = displayGrossPrices;
    final l$weight = weight;
    final l$redirectUrl = redirectUrl;
    final l$lines = lines;
    final l$deliveryMethod = deliveryMethod;
    final l$giftCards = giftCards;
    final l$voucherCode = voucherCode;
    final l$discounts = discounts;
    final l$fulfillments = fulfillments;
    final l$transactions = transactions;
    final l$invoices = invoices;
    return Object.hashAll([
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      l$channel,
      l$createdAt,
      _$data.containsKey('status') ? l$status : const {},
      l$user,
      l$billingAddress,
      _$data.containsKey('shippingAddress') ? l$shippingAddress : const {},
      l$currency,
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('customerNote') ? l$customerNote : const {},
      _$data.containsKey('notes')
          ? l$notes == null
              ? null
              : Object.hashAll(l$notes.map((v) => v))
          : const {},
      l$languageCode,
      _$data.containsKey('displayGrossPrices')
          ? l$displayGrossPrices
          : const {},
      _$data.containsKey('weight') ? l$weight : const {},
      _$data.containsKey('redirectUrl') ? l$redirectUrl : const {},
      Object.hashAll(l$lines.map((v) => v)),
      _$data.containsKey('deliveryMethod') ? l$deliveryMethod : const {},
      _$data.containsKey('giftCards')
          ? l$giftCards == null
              ? null
              : Object.hashAll(l$giftCards.map((v) => v))
          : const {},
      _$data.containsKey('voucherCode') ? l$voucherCode : const {},
      _$data.containsKey('discounts')
          ? l$discounts == null
              ? null
              : Object.hashAll(l$discounts.map((v) => v))
          : const {},
      _$data.containsKey('fulfillments')
          ? l$fulfillments == null
              ? null
              : Object.hashAll(l$fulfillments.map((v) => v))
          : const {},
      _$data.containsKey('transactions')
          ? l$transactions == null
              ? null
              : Object.hashAll(l$transactions.map((v) => v))
          : const {},
      _$data.containsKey('invoices')
          ? l$invoices == null
              ? null
              : Object.hashAll(l$invoices.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderBulkCreateInput<TRes> {
  factory CopyWith$Input$OrderBulkCreateInput(
    Input$OrderBulkCreateInput instance,
    TRes Function(Input$OrderBulkCreateInput) then,
  ) = _CopyWithImpl$Input$OrderBulkCreateInput;

  factory CopyWith$Input$OrderBulkCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderBulkCreateInput;

  TRes call({
    String? externalReference,
    String? channel,
    String? createdAt,
    Enum$OrderStatus? status,
    Input$OrderBulkCreateUserInput? user,
    Input$AddressInput? billingAddress,
    Input$AddressInput? shippingAddress,
    String? currency,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? customerNote,
    List<Input$OrderBulkCreateNoteInput>? notes,
    Enum$LanguageCodeEnum? languageCode,
    bool? displayGrossPrices,
    String? weight,
    String? redirectUrl,
    List<Input$OrderBulkCreateOrderLineInput>? lines,
    Input$OrderBulkCreateDeliveryMethodInput? deliveryMethod,
    List<String>? giftCards,
    String? voucherCode,
    List<Input$OrderDiscountCommonInput>? discounts,
    List<Input$OrderBulkCreateFulfillmentInput>? fulfillments,
    List<Input$TransactionCreateInput>? transactions,
    List<Input$OrderBulkCreateInvoiceInput>? invoices,
  });
  CopyWith$Input$OrderBulkCreateUserInput<TRes> get user;
  CopyWith$Input$AddressInput<TRes> get billingAddress;
  CopyWith$Input$AddressInput<TRes> get shippingAddress;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes notes(
      Iterable<Input$OrderBulkCreateNoteInput>? Function(
              Iterable<
                  CopyWith$Input$OrderBulkCreateNoteInput<
                      Input$OrderBulkCreateNoteInput>>?)
          _fn);
  TRes lines(
      Iterable<Input$OrderBulkCreateOrderLineInput> Function(
              Iterable<
                  CopyWith$Input$OrderBulkCreateOrderLineInput<
                      Input$OrderBulkCreateOrderLineInput>>)
          _fn);
  CopyWith$Input$OrderBulkCreateDeliveryMethodInput<TRes> get deliveryMethod;
  TRes discounts(
      Iterable<Input$OrderDiscountCommonInput>? Function(
              Iterable<
                  CopyWith$Input$OrderDiscountCommonInput<
                      Input$OrderDiscountCommonInput>>?)
          _fn);
  TRes fulfillments(
      Iterable<Input$OrderBulkCreateFulfillmentInput>? Function(
              Iterable<
                  CopyWith$Input$OrderBulkCreateFulfillmentInput<
                      Input$OrderBulkCreateFulfillmentInput>>?)
          _fn);
  TRes transactions(
      Iterable<Input$TransactionCreateInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionCreateInput<
                      Input$TransactionCreateInput>>?)
          _fn);
  TRes invoices(
      Iterable<Input$OrderBulkCreateInvoiceInput>? Function(
              Iterable<
                  CopyWith$Input$OrderBulkCreateInvoiceInput<
                      Input$OrderBulkCreateInvoiceInput>>?)
          _fn);
}

class _CopyWithImpl$Input$OrderBulkCreateInput<TRes>
    implements CopyWith$Input$OrderBulkCreateInput<TRes> {
  _CopyWithImpl$Input$OrderBulkCreateInput(
    this._instance,
    this._then,
  );

  final Input$OrderBulkCreateInput _instance;

  final TRes Function(Input$OrderBulkCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? externalReference = _undefined,
    Object? channel = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? user = _undefined,
    Object? billingAddress = _undefined,
    Object? shippingAddress = _undefined,
    Object? currency = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? customerNote = _undefined,
    Object? notes = _undefined,
    Object? languageCode = _undefined,
    Object? displayGrossPrices = _undefined,
    Object? weight = _undefined,
    Object? redirectUrl = _undefined,
    Object? lines = _undefined,
    Object? deliveryMethod = _undefined,
    Object? giftCards = _undefined,
    Object? voucherCode = _undefined,
    Object? discounts = _undefined,
    Object? fulfillments = _undefined,
    Object? transactions = _undefined,
    Object? invoices = _undefined,
  }) =>
      _then(Input$OrderBulkCreateInput._({
        ..._instance._$data,
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (channel != _undefined && channel != null)
          'channel': (channel as String),
        if (createdAt != _undefined && createdAt != null)
          'createdAt': (createdAt as String),
        if (status != _undefined) 'status': (status as Enum$OrderStatus?),
        if (user != _undefined && user != null)
          'user': (user as Input$OrderBulkCreateUserInput),
        if (billingAddress != _undefined && billingAddress != null)
          'billingAddress': (billingAddress as Input$AddressInput),
        if (shippingAddress != _undefined)
          'shippingAddress': (shippingAddress as Input$AddressInput?),
        if (currency != _undefined && currency != null)
          'currency': (currency as String),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (customerNote != _undefined)
          'customerNote': (customerNote as String?),
        if (notes != _undefined)
          'notes': (notes as List<Input$OrderBulkCreateNoteInput>?),
        if (languageCode != _undefined && languageCode != null)
          'languageCode': (languageCode as Enum$LanguageCodeEnum),
        if (displayGrossPrices != _undefined)
          'displayGrossPrices': (displayGrossPrices as bool?),
        if (weight != _undefined) 'weight': (weight as String?),
        if (redirectUrl != _undefined) 'redirectUrl': (redirectUrl as String?),
        if (lines != _undefined && lines != null)
          'lines': (lines as List<Input$OrderBulkCreateOrderLineInput>),
        if (deliveryMethod != _undefined)
          'deliveryMethod':
              (deliveryMethod as Input$OrderBulkCreateDeliveryMethodInput?),
        if (giftCards != _undefined) 'giftCards': (giftCards as List<String>?),
        if (voucherCode != _undefined) 'voucherCode': (voucherCode as String?),
        if (discounts != _undefined)
          'discounts': (discounts as List<Input$OrderDiscountCommonInput>?),
        if (fulfillments != _undefined)
          'fulfillments':
              (fulfillments as List<Input$OrderBulkCreateFulfillmentInput>?),
        if (transactions != _undefined)
          'transactions': (transactions as List<Input$TransactionCreateInput>?),
        if (invoices != _undefined)
          'invoices': (invoices as List<Input$OrderBulkCreateInvoiceInput>?),
      }));

  CopyWith$Input$OrderBulkCreateUserInput<TRes> get user {
    final local$user = _instance.user;
    return CopyWith$Input$OrderBulkCreateUserInput(
        local$user, (e) => call(user: e));
  }

  CopyWith$Input$AddressInput<TRes> get billingAddress {
    final local$billingAddress = _instance.billingAddress;
    return CopyWith$Input$AddressInput(
        local$billingAddress, (e) => call(billingAddress: e));
  }

  CopyWith$Input$AddressInput<TRes> get shippingAddress {
    final local$shippingAddress = _instance.shippingAddress;
    return local$shippingAddress == null
        ? CopyWith$Input$AddressInput.stub(_then(_instance))
        : CopyWith$Input$AddressInput(
            local$shippingAddress, (e) => call(shippingAddress: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes notes(
          Iterable<Input$OrderBulkCreateNoteInput>? Function(
                  Iterable<
                      CopyWith$Input$OrderBulkCreateNoteInput<
                          Input$OrderBulkCreateNoteInput>>?)
              _fn) =>
      call(
          notes: _fn(_instance.notes
              ?.map((e) => CopyWith$Input$OrderBulkCreateNoteInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes lines(
          Iterable<Input$OrderBulkCreateOrderLineInput> Function(
                  Iterable<
                      CopyWith$Input$OrderBulkCreateOrderLineInput<
                          Input$OrderBulkCreateOrderLineInput>>)
              _fn) =>
      call(
          lines: _fn(_instance.lines
              .map((e) => CopyWith$Input$OrderBulkCreateOrderLineInput(
                    e,
                    (i) => i,
                  ))).toList());

  CopyWith$Input$OrderBulkCreateDeliveryMethodInput<TRes> get deliveryMethod {
    final local$deliveryMethod = _instance.deliveryMethod;
    return local$deliveryMethod == null
        ? CopyWith$Input$OrderBulkCreateDeliveryMethodInput.stub(
            _then(_instance))
        : CopyWith$Input$OrderBulkCreateDeliveryMethodInput(
            local$deliveryMethod, (e) => call(deliveryMethod: e));
  }

  TRes discounts(
          Iterable<Input$OrderDiscountCommonInput>? Function(
                  Iterable<
                      CopyWith$Input$OrderDiscountCommonInput<
                          Input$OrderDiscountCommonInput>>?)
              _fn) =>
      call(
          discounts: _fn(_instance.discounts
              ?.map((e) => CopyWith$Input$OrderDiscountCommonInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes fulfillments(
          Iterable<Input$OrderBulkCreateFulfillmentInput>? Function(
                  Iterable<
                      CopyWith$Input$OrderBulkCreateFulfillmentInput<
                          Input$OrderBulkCreateFulfillmentInput>>?)
              _fn) =>
      call(
          fulfillments: _fn(_instance.fulfillments
              ?.map((e) => CopyWith$Input$OrderBulkCreateFulfillmentInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes transactions(
          Iterable<Input$TransactionCreateInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionCreateInput<
                          Input$TransactionCreateInput>>?)
              _fn) =>
      call(
          transactions: _fn(_instance.transactions
              ?.map((e) => CopyWith$Input$TransactionCreateInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes invoices(
          Iterable<Input$OrderBulkCreateInvoiceInput>? Function(
                  Iterable<
                      CopyWith$Input$OrderBulkCreateInvoiceInput<
                          Input$OrderBulkCreateInvoiceInput>>?)
              _fn) =>
      call(
          invoices: _fn(_instance.invoices
              ?.map((e) => CopyWith$Input$OrderBulkCreateInvoiceInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$OrderBulkCreateInput<TRes>
    implements CopyWith$Input$OrderBulkCreateInput<TRes> {
  _CopyWithStubImpl$Input$OrderBulkCreateInput(this._res);

  TRes _res;

  call({
    String? externalReference,
    String? channel,
    String? createdAt,
    Enum$OrderStatus? status,
    Input$OrderBulkCreateUserInput? user,
    Input$AddressInput? billingAddress,
    Input$AddressInput? shippingAddress,
    String? currency,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? customerNote,
    List<Input$OrderBulkCreateNoteInput>? notes,
    Enum$LanguageCodeEnum? languageCode,
    bool? displayGrossPrices,
    String? weight,
    String? redirectUrl,
    List<Input$OrderBulkCreateOrderLineInput>? lines,
    Input$OrderBulkCreateDeliveryMethodInput? deliveryMethod,
    List<String>? giftCards,
    String? voucherCode,
    List<Input$OrderDiscountCommonInput>? discounts,
    List<Input$OrderBulkCreateFulfillmentInput>? fulfillments,
    List<Input$TransactionCreateInput>? transactions,
    List<Input$OrderBulkCreateInvoiceInput>? invoices,
  }) =>
      _res;

  CopyWith$Input$OrderBulkCreateUserInput<TRes> get user =>
      CopyWith$Input$OrderBulkCreateUserInput.stub(_res);

  CopyWith$Input$AddressInput<TRes> get billingAddress =>
      CopyWith$Input$AddressInput.stub(_res);

  CopyWith$Input$AddressInput<TRes> get shippingAddress =>
      CopyWith$Input$AddressInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;

  notes(_fn) => _res;

  lines(_fn) => _res;

  CopyWith$Input$OrderBulkCreateDeliveryMethodInput<TRes> get deliveryMethod =>
      CopyWith$Input$OrderBulkCreateDeliveryMethodInput.stub(_res);

  discounts(_fn) => _res;

  fulfillments(_fn) => _res;

  transactions(_fn) => _res;

  invoices(_fn) => _res;
}

class Input$OrderBulkCreateInvoiceInput {
  factory Input$OrderBulkCreateInvoiceInput({
    required String createdAt,
    String? number,
    String? url,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  }) =>
      Input$OrderBulkCreateInvoiceInput._({
        r'createdAt': createdAt,
        if (number != null) r'number': number,
        if (url != null) r'url': url,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
      });

  Input$OrderBulkCreateInvoiceInput._(this._$data);

  factory Input$OrderBulkCreateInvoiceInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$createdAt = data['createdAt'];
    result$data['createdAt'] = (l$createdAt as String);
    if (data.containsKey('number')) {
      final l$number = data['number'];
      result$data['number'] = (l$number as String?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$OrderBulkCreateInvoiceInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get createdAt => (_$data['createdAt'] as String);

  String? get number => (_$data['number'] as String?);

  String? get url => (_$data['url'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$createdAt = createdAt;
    result$data['createdAt'] = l$createdAt;
    if (_$data.containsKey('number')) {
      final l$number = number;
      result$data['number'] = l$number;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$OrderBulkCreateInvoiceInput<Input$OrderBulkCreateInvoiceInput>
      get copyWith => CopyWith$Input$OrderBulkCreateInvoiceInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderBulkCreateInvoiceInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$number = number;
    final lOther$number = other.number;
    if (_$data.containsKey('number') != other._$data.containsKey('number')) {
      return false;
    }
    if (l$number != lOther$number) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$number = number;
    final l$url = url;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    return Object.hashAll([
      l$createdAt,
      _$data.containsKey('number') ? l$number : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderBulkCreateInvoiceInput<TRes> {
  factory CopyWith$Input$OrderBulkCreateInvoiceInput(
    Input$OrderBulkCreateInvoiceInput instance,
    TRes Function(Input$OrderBulkCreateInvoiceInput) then,
  ) = _CopyWithImpl$Input$OrderBulkCreateInvoiceInput;

  factory CopyWith$Input$OrderBulkCreateInvoiceInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderBulkCreateInvoiceInput;

  TRes call({
    String? createdAt,
    String? number,
    String? url,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  });
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$OrderBulkCreateInvoiceInput<TRes>
    implements CopyWith$Input$OrderBulkCreateInvoiceInput<TRes> {
  _CopyWithImpl$Input$OrderBulkCreateInvoiceInput(
    this._instance,
    this._then,
  );

  final Input$OrderBulkCreateInvoiceInput _instance;

  final TRes Function(Input$OrderBulkCreateInvoiceInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? number = _undefined,
    Object? url = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
  }) =>
      _then(Input$OrderBulkCreateInvoiceInput._({
        ..._instance._$data,
        if (createdAt != _undefined && createdAt != null)
          'createdAt': (createdAt as String),
        if (number != _undefined) 'number': (number as String?),
        if (url != _undefined) 'url': (url as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$OrderBulkCreateInvoiceInput<TRes>
    implements CopyWith$Input$OrderBulkCreateInvoiceInput<TRes> {
  _CopyWithStubImpl$Input$OrderBulkCreateInvoiceInput(this._res);

  TRes _res;

  call({
    String? createdAt,
    String? number,
    String? url,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  }) =>
      _res;

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$OrderBulkCreateNoteInput {
  factory Input$OrderBulkCreateNoteInput({
    required String message,
    String? date,
    String? userId,
    String? userEmail,
    String? userExternalReference,
    String? appId,
  }) =>
      Input$OrderBulkCreateNoteInput._({
        r'message': message,
        if (date != null) r'date': date,
        if (userId != null) r'userId': userId,
        if (userEmail != null) r'userEmail': userEmail,
        if (userExternalReference != null)
          r'userExternalReference': userExternalReference,
        if (appId != null) r'appId': appId,
      });

  Input$OrderBulkCreateNoteInput._(this._$data);

  factory Input$OrderBulkCreateNoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$message = data['message'];
    result$data['message'] = (l$message as String);
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = (l$date as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('userEmail')) {
      final l$userEmail = data['userEmail'];
      result$data['userEmail'] = (l$userEmail as String?);
    }
    if (data.containsKey('userExternalReference')) {
      final l$userExternalReference = data['userExternalReference'];
      result$data['userExternalReference'] =
          (l$userExternalReference as String?);
    }
    if (data.containsKey('appId')) {
      final l$appId = data['appId'];
      result$data['appId'] = (l$appId as String?);
    }
    return Input$OrderBulkCreateNoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get message => (_$data['message'] as String);

  String? get date => (_$data['date'] as String?);

  String? get userId => (_$data['userId'] as String?);

  String? get userEmail => (_$data['userEmail'] as String?);

  String? get userExternalReference =>
      (_$data['userExternalReference'] as String?);

  String? get appId => (_$data['appId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$message = message;
    result$data['message'] = l$message;
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('userEmail')) {
      final l$userEmail = userEmail;
      result$data['userEmail'] = l$userEmail;
    }
    if (_$data.containsKey('userExternalReference')) {
      final l$userExternalReference = userExternalReference;
      result$data['userExternalReference'] = l$userExternalReference;
    }
    if (_$data.containsKey('appId')) {
      final l$appId = appId;
      result$data['appId'] = l$appId;
    }
    return result$data;
  }

  CopyWith$Input$OrderBulkCreateNoteInput<Input$OrderBulkCreateNoteInput>
      get copyWith => CopyWith$Input$OrderBulkCreateNoteInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderBulkCreateNoteInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$userEmail = userEmail;
    final lOther$userEmail = other.userEmail;
    if (_$data.containsKey('userEmail') !=
        other._$data.containsKey('userEmail')) {
      return false;
    }
    if (l$userEmail != lOther$userEmail) {
      return false;
    }
    final l$userExternalReference = userExternalReference;
    final lOther$userExternalReference = other.userExternalReference;
    if (_$data.containsKey('userExternalReference') !=
        other._$data.containsKey('userExternalReference')) {
      return false;
    }
    if (l$userExternalReference != lOther$userExternalReference) {
      return false;
    }
    final l$appId = appId;
    final lOther$appId = other.appId;
    if (_$data.containsKey('appId') != other._$data.containsKey('appId')) {
      return false;
    }
    if (l$appId != lOther$appId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$message = message;
    final l$date = date;
    final l$userId = userId;
    final l$userEmail = userEmail;
    final l$userExternalReference = userExternalReference;
    final l$appId = appId;
    return Object.hashAll([
      l$message,
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('userEmail') ? l$userEmail : const {},
      _$data.containsKey('userExternalReference')
          ? l$userExternalReference
          : const {},
      _$data.containsKey('appId') ? l$appId : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderBulkCreateNoteInput<TRes> {
  factory CopyWith$Input$OrderBulkCreateNoteInput(
    Input$OrderBulkCreateNoteInput instance,
    TRes Function(Input$OrderBulkCreateNoteInput) then,
  ) = _CopyWithImpl$Input$OrderBulkCreateNoteInput;

  factory CopyWith$Input$OrderBulkCreateNoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderBulkCreateNoteInput;

  TRes call({
    String? message,
    String? date,
    String? userId,
    String? userEmail,
    String? userExternalReference,
    String? appId,
  });
}

class _CopyWithImpl$Input$OrderBulkCreateNoteInput<TRes>
    implements CopyWith$Input$OrderBulkCreateNoteInput<TRes> {
  _CopyWithImpl$Input$OrderBulkCreateNoteInput(
    this._instance,
    this._then,
  );

  final Input$OrderBulkCreateNoteInput _instance;

  final TRes Function(Input$OrderBulkCreateNoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? message = _undefined,
    Object? date = _undefined,
    Object? userId = _undefined,
    Object? userEmail = _undefined,
    Object? userExternalReference = _undefined,
    Object? appId = _undefined,
  }) =>
      _then(Input$OrderBulkCreateNoteInput._({
        ..._instance._$data,
        if (message != _undefined && message != null)
          'message': (message as String),
        if (date != _undefined) 'date': (date as String?),
        if (userId != _undefined) 'userId': (userId as String?),
        if (userEmail != _undefined) 'userEmail': (userEmail as String?),
        if (userExternalReference != _undefined)
          'userExternalReference': (userExternalReference as String?),
        if (appId != _undefined) 'appId': (appId as String?),
      }));
}

class _CopyWithStubImpl$Input$OrderBulkCreateNoteInput<TRes>
    implements CopyWith$Input$OrderBulkCreateNoteInput<TRes> {
  _CopyWithStubImpl$Input$OrderBulkCreateNoteInput(this._res);

  TRes _res;

  call({
    String? message,
    String? date,
    String? userId,
    String? userEmail,
    String? userExternalReference,
    String? appId,
  }) =>
      _res;
}

class Input$OrderBulkCreateOrderLineInput {
  factory Input$OrderBulkCreateOrderLineInput({
    String? variantId,
    String? variantSku,
    String? variantExternalReference,
    String? variantName,
    String? productName,
    String? productSku,
    String? translatedVariantName,
    String? translatedProductName,
    required String createdAt,
    required bool isShippingRequired,
    required bool isGiftCard,
    required int quantity,
    required Input$TaxedMoneyInput totalPrice,
    required Input$TaxedMoneyInput undiscountedTotalPrice,
    String? unitDiscountReason,
    Enum$DiscountValueTypeEnum? unitDiscountType,
    String? unitDiscountValue,
    required String warehouse,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? taxRate,
    String? taxClassId,
    String? taxClassName,
    List<Input$MetadataInput>? taxClassMetadata,
    List<Input$MetadataInput>? taxClassPrivateMetadata,
  }) =>
      Input$OrderBulkCreateOrderLineInput._({
        if (variantId != null) r'variantId': variantId,
        if (variantSku != null) r'variantSku': variantSku,
        if (variantExternalReference != null)
          r'variantExternalReference': variantExternalReference,
        if (variantName != null) r'variantName': variantName,
        if (productName != null) r'productName': productName,
        if (productSku != null) r'productSku': productSku,
        if (translatedVariantName != null)
          r'translatedVariantName': translatedVariantName,
        if (translatedProductName != null)
          r'translatedProductName': translatedProductName,
        r'createdAt': createdAt,
        r'isShippingRequired': isShippingRequired,
        r'isGiftCard': isGiftCard,
        r'quantity': quantity,
        r'totalPrice': totalPrice,
        r'undiscountedTotalPrice': undiscountedTotalPrice,
        if (unitDiscountReason != null)
          r'unitDiscountReason': unitDiscountReason,
        if (unitDiscountType != null) r'unitDiscountType': unitDiscountType,
        if (unitDiscountValue != null) r'unitDiscountValue': unitDiscountValue,
        r'warehouse': warehouse,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (taxRate != null) r'taxRate': taxRate,
        if (taxClassId != null) r'taxClassId': taxClassId,
        if (taxClassName != null) r'taxClassName': taxClassName,
        if (taxClassMetadata != null) r'taxClassMetadata': taxClassMetadata,
        if (taxClassPrivateMetadata != null)
          r'taxClassPrivateMetadata': taxClassPrivateMetadata,
      });

  Input$OrderBulkCreateOrderLineInput._(this._$data);

  factory Input$OrderBulkCreateOrderLineInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('variantId')) {
      final l$variantId = data['variantId'];
      result$data['variantId'] = (l$variantId as String?);
    }
    if (data.containsKey('variantSku')) {
      final l$variantSku = data['variantSku'];
      result$data['variantSku'] = (l$variantSku as String?);
    }
    if (data.containsKey('variantExternalReference')) {
      final l$variantExternalReference = data['variantExternalReference'];
      result$data['variantExternalReference'] =
          (l$variantExternalReference as String?);
    }
    if (data.containsKey('variantName')) {
      final l$variantName = data['variantName'];
      result$data['variantName'] = (l$variantName as String?);
    }
    if (data.containsKey('productName')) {
      final l$productName = data['productName'];
      result$data['productName'] = (l$productName as String?);
    }
    if (data.containsKey('productSku')) {
      final l$productSku = data['productSku'];
      result$data['productSku'] = (l$productSku as String?);
    }
    if (data.containsKey('translatedVariantName')) {
      final l$translatedVariantName = data['translatedVariantName'];
      result$data['translatedVariantName'] =
          (l$translatedVariantName as String?);
    }
    if (data.containsKey('translatedProductName')) {
      final l$translatedProductName = data['translatedProductName'];
      result$data['translatedProductName'] =
          (l$translatedProductName as String?);
    }
    final l$createdAt = data['createdAt'];
    result$data['createdAt'] = (l$createdAt as String);
    final l$isShippingRequired = data['isShippingRequired'];
    result$data['isShippingRequired'] = (l$isShippingRequired as bool);
    final l$isGiftCard = data['isGiftCard'];
    result$data['isGiftCard'] = (l$isGiftCard as bool);
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$totalPrice = data['totalPrice'];
    result$data['totalPrice'] =
        Input$TaxedMoneyInput.fromJson((l$totalPrice as Map<String, dynamic>));
    final l$undiscountedTotalPrice = data['undiscountedTotalPrice'];
    result$data['undiscountedTotalPrice'] = Input$TaxedMoneyInput.fromJson(
        (l$undiscountedTotalPrice as Map<String, dynamic>));
    if (data.containsKey('unitDiscountReason')) {
      final l$unitDiscountReason = data['unitDiscountReason'];
      result$data['unitDiscountReason'] = (l$unitDiscountReason as String?);
    }
    if (data.containsKey('unitDiscountType')) {
      final l$unitDiscountType = data['unitDiscountType'];
      result$data['unitDiscountType'] = l$unitDiscountType == null
          ? null
          : fromJson$Enum$DiscountValueTypeEnum((l$unitDiscountType as String));
    }
    if (data.containsKey('unitDiscountValue')) {
      final l$unitDiscountValue = data['unitDiscountValue'];
      result$data['unitDiscountValue'] = (l$unitDiscountValue as String?);
    }
    final l$warehouse = data['warehouse'];
    result$data['warehouse'] = (l$warehouse as String);
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('taxRate')) {
      final l$taxRate = data['taxRate'];
      result$data['taxRate'] = (l$taxRate as String?);
    }
    if (data.containsKey('taxClassId')) {
      final l$taxClassId = data['taxClassId'];
      result$data['taxClassId'] = (l$taxClassId as String?);
    }
    if (data.containsKey('taxClassName')) {
      final l$taxClassName = data['taxClassName'];
      result$data['taxClassName'] = (l$taxClassName as String?);
    }
    if (data.containsKey('taxClassMetadata')) {
      final l$taxClassMetadata = data['taxClassMetadata'];
      result$data['taxClassMetadata'] = (l$taxClassMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('taxClassPrivateMetadata')) {
      final l$taxClassPrivateMetadata = data['taxClassPrivateMetadata'];
      result$data['taxClassPrivateMetadata'] = (l$taxClassPrivateMetadata
              as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$OrderBulkCreateOrderLineInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get variantId => (_$data['variantId'] as String?);

  String? get variantSku => (_$data['variantSku'] as String?);

  String? get variantExternalReference =>
      (_$data['variantExternalReference'] as String?);

  String? get variantName => (_$data['variantName'] as String?);

  String? get productName => (_$data['productName'] as String?);

  String? get productSku => (_$data['productSku'] as String?);

  String? get translatedVariantName =>
      (_$data['translatedVariantName'] as String?);

  String? get translatedProductName =>
      (_$data['translatedProductName'] as String?);

  String get createdAt => (_$data['createdAt'] as String);

  bool get isShippingRequired => (_$data['isShippingRequired'] as bool);

  bool get isGiftCard => (_$data['isGiftCard'] as bool);

  int get quantity => (_$data['quantity'] as int);

  Input$TaxedMoneyInput get totalPrice =>
      (_$data['totalPrice'] as Input$TaxedMoneyInput);

  Input$TaxedMoneyInput get undiscountedTotalPrice =>
      (_$data['undiscountedTotalPrice'] as Input$TaxedMoneyInput);

  String? get unitDiscountReason => (_$data['unitDiscountReason'] as String?);

  Enum$DiscountValueTypeEnum? get unitDiscountType =>
      (_$data['unitDiscountType'] as Enum$DiscountValueTypeEnum?);

  String? get unitDiscountValue => (_$data['unitDiscountValue'] as String?);

  String get warehouse => (_$data['warehouse'] as String);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  String? get taxRate => (_$data['taxRate'] as String?);

  String? get taxClassId => (_$data['taxClassId'] as String?);

  String? get taxClassName => (_$data['taxClassName'] as String?);

  List<Input$MetadataInput>? get taxClassMetadata =>
      (_$data['taxClassMetadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get taxClassPrivateMetadata =>
      (_$data['taxClassPrivateMetadata'] as List<Input$MetadataInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('variantId')) {
      final l$variantId = variantId;
      result$data['variantId'] = l$variantId;
    }
    if (_$data.containsKey('variantSku')) {
      final l$variantSku = variantSku;
      result$data['variantSku'] = l$variantSku;
    }
    if (_$data.containsKey('variantExternalReference')) {
      final l$variantExternalReference = variantExternalReference;
      result$data['variantExternalReference'] = l$variantExternalReference;
    }
    if (_$data.containsKey('variantName')) {
      final l$variantName = variantName;
      result$data['variantName'] = l$variantName;
    }
    if (_$data.containsKey('productName')) {
      final l$productName = productName;
      result$data['productName'] = l$productName;
    }
    if (_$data.containsKey('productSku')) {
      final l$productSku = productSku;
      result$data['productSku'] = l$productSku;
    }
    if (_$data.containsKey('translatedVariantName')) {
      final l$translatedVariantName = translatedVariantName;
      result$data['translatedVariantName'] = l$translatedVariantName;
    }
    if (_$data.containsKey('translatedProductName')) {
      final l$translatedProductName = translatedProductName;
      result$data['translatedProductName'] = l$translatedProductName;
    }
    final l$createdAt = createdAt;
    result$data['createdAt'] = l$createdAt;
    final l$isShippingRequired = isShippingRequired;
    result$data['isShippingRequired'] = l$isShippingRequired;
    final l$isGiftCard = isGiftCard;
    result$data['isGiftCard'] = l$isGiftCard;
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$totalPrice = totalPrice;
    result$data['totalPrice'] = l$totalPrice.toJson();
    final l$undiscountedTotalPrice = undiscountedTotalPrice;
    result$data['undiscountedTotalPrice'] = l$undiscountedTotalPrice.toJson();
    if (_$data.containsKey('unitDiscountReason')) {
      final l$unitDiscountReason = unitDiscountReason;
      result$data['unitDiscountReason'] = l$unitDiscountReason;
    }
    if (_$data.containsKey('unitDiscountType')) {
      final l$unitDiscountType = unitDiscountType;
      result$data['unitDiscountType'] = l$unitDiscountType == null
          ? null
          : toJson$Enum$DiscountValueTypeEnum(l$unitDiscountType);
    }
    if (_$data.containsKey('unitDiscountValue')) {
      final l$unitDiscountValue = unitDiscountValue;
      result$data['unitDiscountValue'] = l$unitDiscountValue;
    }
    final l$warehouse = warehouse;
    result$data['warehouse'] = l$warehouse;
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('taxRate')) {
      final l$taxRate = taxRate;
      result$data['taxRate'] = l$taxRate;
    }
    if (_$data.containsKey('taxClassId')) {
      final l$taxClassId = taxClassId;
      result$data['taxClassId'] = l$taxClassId;
    }
    if (_$data.containsKey('taxClassName')) {
      final l$taxClassName = taxClassName;
      result$data['taxClassName'] = l$taxClassName;
    }
    if (_$data.containsKey('taxClassMetadata')) {
      final l$taxClassMetadata = taxClassMetadata;
      result$data['taxClassMetadata'] =
          l$taxClassMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('taxClassPrivateMetadata')) {
      final l$taxClassPrivateMetadata = taxClassPrivateMetadata;
      result$data['taxClassPrivateMetadata'] =
          l$taxClassPrivateMetadata?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$OrderBulkCreateOrderLineInput<
          Input$OrderBulkCreateOrderLineInput>
      get copyWith => CopyWith$Input$OrderBulkCreateOrderLineInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderBulkCreateOrderLineInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$variantId = variantId;
    final lOther$variantId = other.variantId;
    if (_$data.containsKey('variantId') !=
        other._$data.containsKey('variantId')) {
      return false;
    }
    if (l$variantId != lOther$variantId) {
      return false;
    }
    final l$variantSku = variantSku;
    final lOther$variantSku = other.variantSku;
    if (_$data.containsKey('variantSku') !=
        other._$data.containsKey('variantSku')) {
      return false;
    }
    if (l$variantSku != lOther$variantSku) {
      return false;
    }
    final l$variantExternalReference = variantExternalReference;
    final lOther$variantExternalReference = other.variantExternalReference;
    if (_$data.containsKey('variantExternalReference') !=
        other._$data.containsKey('variantExternalReference')) {
      return false;
    }
    if (l$variantExternalReference != lOther$variantExternalReference) {
      return false;
    }
    final l$variantName = variantName;
    final lOther$variantName = other.variantName;
    if (_$data.containsKey('variantName') !=
        other._$data.containsKey('variantName')) {
      return false;
    }
    if (l$variantName != lOther$variantName) {
      return false;
    }
    final l$productName = productName;
    final lOther$productName = other.productName;
    if (_$data.containsKey('productName') !=
        other._$data.containsKey('productName')) {
      return false;
    }
    if (l$productName != lOther$productName) {
      return false;
    }
    final l$productSku = productSku;
    final lOther$productSku = other.productSku;
    if (_$data.containsKey('productSku') !=
        other._$data.containsKey('productSku')) {
      return false;
    }
    if (l$productSku != lOther$productSku) {
      return false;
    }
    final l$translatedVariantName = translatedVariantName;
    final lOther$translatedVariantName = other.translatedVariantName;
    if (_$data.containsKey('translatedVariantName') !=
        other._$data.containsKey('translatedVariantName')) {
      return false;
    }
    if (l$translatedVariantName != lOther$translatedVariantName) {
      return false;
    }
    final l$translatedProductName = translatedProductName;
    final lOther$translatedProductName = other.translatedProductName;
    if (_$data.containsKey('translatedProductName') !=
        other._$data.containsKey('translatedProductName')) {
      return false;
    }
    if (l$translatedProductName != lOther$translatedProductName) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isShippingRequired = isShippingRequired;
    final lOther$isShippingRequired = other.isShippingRequired;
    if (l$isShippingRequired != lOther$isShippingRequired) {
      return false;
    }
    final l$isGiftCard = isGiftCard;
    final lOther$isGiftCard = other.isGiftCard;
    if (l$isGiftCard != lOther$isGiftCard) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$totalPrice = totalPrice;
    final lOther$totalPrice = other.totalPrice;
    if (l$totalPrice != lOther$totalPrice) {
      return false;
    }
    final l$undiscountedTotalPrice = undiscountedTotalPrice;
    final lOther$undiscountedTotalPrice = other.undiscountedTotalPrice;
    if (l$undiscountedTotalPrice != lOther$undiscountedTotalPrice) {
      return false;
    }
    final l$unitDiscountReason = unitDiscountReason;
    final lOther$unitDiscountReason = other.unitDiscountReason;
    if (_$data.containsKey('unitDiscountReason') !=
        other._$data.containsKey('unitDiscountReason')) {
      return false;
    }
    if (l$unitDiscountReason != lOther$unitDiscountReason) {
      return false;
    }
    final l$unitDiscountType = unitDiscountType;
    final lOther$unitDiscountType = other.unitDiscountType;
    if (_$data.containsKey('unitDiscountType') !=
        other._$data.containsKey('unitDiscountType')) {
      return false;
    }
    if (l$unitDiscountType != lOther$unitDiscountType) {
      return false;
    }
    final l$unitDiscountValue = unitDiscountValue;
    final lOther$unitDiscountValue = other.unitDiscountValue;
    if (_$data.containsKey('unitDiscountValue') !=
        other._$data.containsKey('unitDiscountValue')) {
      return false;
    }
    if (l$unitDiscountValue != lOther$unitDiscountValue) {
      return false;
    }
    final l$warehouse = warehouse;
    final lOther$warehouse = other.warehouse;
    if (l$warehouse != lOther$warehouse) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$taxRate = taxRate;
    final lOther$taxRate = other.taxRate;
    if (_$data.containsKey('taxRate') != other._$data.containsKey('taxRate')) {
      return false;
    }
    if (l$taxRate != lOther$taxRate) {
      return false;
    }
    final l$taxClassId = taxClassId;
    final lOther$taxClassId = other.taxClassId;
    if (_$data.containsKey('taxClassId') !=
        other._$data.containsKey('taxClassId')) {
      return false;
    }
    if (l$taxClassId != lOther$taxClassId) {
      return false;
    }
    final l$taxClassName = taxClassName;
    final lOther$taxClassName = other.taxClassName;
    if (_$data.containsKey('taxClassName') !=
        other._$data.containsKey('taxClassName')) {
      return false;
    }
    if (l$taxClassName != lOther$taxClassName) {
      return false;
    }
    final l$taxClassMetadata = taxClassMetadata;
    final lOther$taxClassMetadata = other.taxClassMetadata;
    if (_$data.containsKey('taxClassMetadata') !=
        other._$data.containsKey('taxClassMetadata')) {
      return false;
    }
    if (l$taxClassMetadata != null && lOther$taxClassMetadata != null) {
      if (l$taxClassMetadata.length != lOther$taxClassMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$taxClassMetadata.length; i++) {
        final l$taxClassMetadata$entry = l$taxClassMetadata[i];
        final lOther$taxClassMetadata$entry = lOther$taxClassMetadata[i];
        if (l$taxClassMetadata$entry != lOther$taxClassMetadata$entry) {
          return false;
        }
      }
    } else if (l$taxClassMetadata != lOther$taxClassMetadata) {
      return false;
    }
    final l$taxClassPrivateMetadata = taxClassPrivateMetadata;
    final lOther$taxClassPrivateMetadata = other.taxClassPrivateMetadata;
    if (_$data.containsKey('taxClassPrivateMetadata') !=
        other._$data.containsKey('taxClassPrivateMetadata')) {
      return false;
    }
    if (l$taxClassPrivateMetadata != null &&
        lOther$taxClassPrivateMetadata != null) {
      if (l$taxClassPrivateMetadata.length !=
          lOther$taxClassPrivateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$taxClassPrivateMetadata.length; i++) {
        final l$taxClassPrivateMetadata$entry = l$taxClassPrivateMetadata[i];
        final lOther$taxClassPrivateMetadata$entry =
            lOther$taxClassPrivateMetadata[i];
        if (l$taxClassPrivateMetadata$entry !=
            lOther$taxClassPrivateMetadata$entry) {
          return false;
        }
      }
    } else if (l$taxClassPrivateMetadata != lOther$taxClassPrivateMetadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$variantId = variantId;
    final l$variantSku = variantSku;
    final l$variantExternalReference = variantExternalReference;
    final l$variantName = variantName;
    final l$productName = productName;
    final l$productSku = productSku;
    final l$translatedVariantName = translatedVariantName;
    final l$translatedProductName = translatedProductName;
    final l$createdAt = createdAt;
    final l$isShippingRequired = isShippingRequired;
    final l$isGiftCard = isGiftCard;
    final l$quantity = quantity;
    final l$totalPrice = totalPrice;
    final l$undiscountedTotalPrice = undiscountedTotalPrice;
    final l$unitDiscountReason = unitDiscountReason;
    final l$unitDiscountType = unitDiscountType;
    final l$unitDiscountValue = unitDiscountValue;
    final l$warehouse = warehouse;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$taxRate = taxRate;
    final l$taxClassId = taxClassId;
    final l$taxClassName = taxClassName;
    final l$taxClassMetadata = taxClassMetadata;
    final l$taxClassPrivateMetadata = taxClassPrivateMetadata;
    return Object.hashAll([
      _$data.containsKey('variantId') ? l$variantId : const {},
      _$data.containsKey('variantSku') ? l$variantSku : const {},
      _$data.containsKey('variantExternalReference')
          ? l$variantExternalReference
          : const {},
      _$data.containsKey('variantName') ? l$variantName : const {},
      _$data.containsKey('productName') ? l$productName : const {},
      _$data.containsKey('productSku') ? l$productSku : const {},
      _$data.containsKey('translatedVariantName')
          ? l$translatedVariantName
          : const {},
      _$data.containsKey('translatedProductName')
          ? l$translatedProductName
          : const {},
      l$createdAt,
      l$isShippingRequired,
      l$isGiftCard,
      l$quantity,
      l$totalPrice,
      l$undiscountedTotalPrice,
      _$data.containsKey('unitDiscountReason')
          ? l$unitDiscountReason
          : const {},
      _$data.containsKey('unitDiscountType') ? l$unitDiscountType : const {},
      _$data.containsKey('unitDiscountValue') ? l$unitDiscountValue : const {},
      l$warehouse,
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('taxRate') ? l$taxRate : const {},
      _$data.containsKey('taxClassId') ? l$taxClassId : const {},
      _$data.containsKey('taxClassName') ? l$taxClassName : const {},
      _$data.containsKey('taxClassMetadata')
          ? l$taxClassMetadata == null
              ? null
              : Object.hashAll(l$taxClassMetadata.map((v) => v))
          : const {},
      _$data.containsKey('taxClassPrivateMetadata')
          ? l$taxClassPrivateMetadata == null
              ? null
              : Object.hashAll(l$taxClassPrivateMetadata.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderBulkCreateOrderLineInput<TRes> {
  factory CopyWith$Input$OrderBulkCreateOrderLineInput(
    Input$OrderBulkCreateOrderLineInput instance,
    TRes Function(Input$OrderBulkCreateOrderLineInput) then,
  ) = _CopyWithImpl$Input$OrderBulkCreateOrderLineInput;

  factory CopyWith$Input$OrderBulkCreateOrderLineInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderBulkCreateOrderLineInput;

  TRes call({
    String? variantId,
    String? variantSku,
    String? variantExternalReference,
    String? variantName,
    String? productName,
    String? productSku,
    String? translatedVariantName,
    String? translatedProductName,
    String? createdAt,
    bool? isShippingRequired,
    bool? isGiftCard,
    int? quantity,
    Input$TaxedMoneyInput? totalPrice,
    Input$TaxedMoneyInput? undiscountedTotalPrice,
    String? unitDiscountReason,
    Enum$DiscountValueTypeEnum? unitDiscountType,
    String? unitDiscountValue,
    String? warehouse,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? taxRate,
    String? taxClassId,
    String? taxClassName,
    List<Input$MetadataInput>? taxClassMetadata,
    List<Input$MetadataInput>? taxClassPrivateMetadata,
  });
  CopyWith$Input$TaxedMoneyInput<TRes> get totalPrice;
  CopyWith$Input$TaxedMoneyInput<TRes> get undiscountedTotalPrice;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes taxClassMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes taxClassPrivateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$OrderBulkCreateOrderLineInput<TRes>
    implements CopyWith$Input$OrderBulkCreateOrderLineInput<TRes> {
  _CopyWithImpl$Input$OrderBulkCreateOrderLineInput(
    this._instance,
    this._then,
  );

  final Input$OrderBulkCreateOrderLineInput _instance;

  final TRes Function(Input$OrderBulkCreateOrderLineInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? variantId = _undefined,
    Object? variantSku = _undefined,
    Object? variantExternalReference = _undefined,
    Object? variantName = _undefined,
    Object? productName = _undefined,
    Object? productSku = _undefined,
    Object? translatedVariantName = _undefined,
    Object? translatedProductName = _undefined,
    Object? createdAt = _undefined,
    Object? isShippingRequired = _undefined,
    Object? isGiftCard = _undefined,
    Object? quantity = _undefined,
    Object? totalPrice = _undefined,
    Object? undiscountedTotalPrice = _undefined,
    Object? unitDiscountReason = _undefined,
    Object? unitDiscountType = _undefined,
    Object? unitDiscountValue = _undefined,
    Object? warehouse = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? taxRate = _undefined,
    Object? taxClassId = _undefined,
    Object? taxClassName = _undefined,
    Object? taxClassMetadata = _undefined,
    Object? taxClassPrivateMetadata = _undefined,
  }) =>
      _then(Input$OrderBulkCreateOrderLineInput._({
        ..._instance._$data,
        if (variantId != _undefined) 'variantId': (variantId as String?),
        if (variantSku != _undefined) 'variantSku': (variantSku as String?),
        if (variantExternalReference != _undefined)
          'variantExternalReference': (variantExternalReference as String?),
        if (variantName != _undefined) 'variantName': (variantName as String?),
        if (productName != _undefined) 'productName': (productName as String?),
        if (productSku != _undefined) 'productSku': (productSku as String?),
        if (translatedVariantName != _undefined)
          'translatedVariantName': (translatedVariantName as String?),
        if (translatedProductName != _undefined)
          'translatedProductName': (translatedProductName as String?),
        if (createdAt != _undefined && createdAt != null)
          'createdAt': (createdAt as String),
        if (isShippingRequired != _undefined && isShippingRequired != null)
          'isShippingRequired': (isShippingRequired as bool),
        if (isGiftCard != _undefined && isGiftCard != null)
          'isGiftCard': (isGiftCard as bool),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (totalPrice != _undefined && totalPrice != null)
          'totalPrice': (totalPrice as Input$TaxedMoneyInput),
        if (undiscountedTotalPrice != _undefined &&
            undiscountedTotalPrice != null)
          'undiscountedTotalPrice':
              (undiscountedTotalPrice as Input$TaxedMoneyInput),
        if (unitDiscountReason != _undefined)
          'unitDiscountReason': (unitDiscountReason as String?),
        if (unitDiscountType != _undefined)
          'unitDiscountType': (unitDiscountType as Enum$DiscountValueTypeEnum?),
        if (unitDiscountValue != _undefined)
          'unitDiscountValue': (unitDiscountValue as String?),
        if (warehouse != _undefined && warehouse != null)
          'warehouse': (warehouse as String),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (taxRate != _undefined) 'taxRate': (taxRate as String?),
        if (taxClassId != _undefined) 'taxClassId': (taxClassId as String?),
        if (taxClassName != _undefined)
          'taxClassName': (taxClassName as String?),
        if (taxClassMetadata != _undefined)
          'taxClassMetadata': (taxClassMetadata as List<Input$MetadataInput>?),
        if (taxClassPrivateMetadata != _undefined)
          'taxClassPrivateMetadata':
              (taxClassPrivateMetadata as List<Input$MetadataInput>?),
      }));

  CopyWith$Input$TaxedMoneyInput<TRes> get totalPrice {
    final local$totalPrice = _instance.totalPrice;
    return CopyWith$Input$TaxedMoneyInput(
        local$totalPrice, (e) => call(totalPrice: e));
  }

  CopyWith$Input$TaxedMoneyInput<TRes> get undiscountedTotalPrice {
    final local$undiscountedTotalPrice = _instance.undiscountedTotalPrice;
    return CopyWith$Input$TaxedMoneyInput(
        local$undiscountedTotalPrice, (e) => call(undiscountedTotalPrice: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes taxClassMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          taxClassMetadata: _fn(_instance.taxClassMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes taxClassPrivateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          taxClassPrivateMetadata: _fn(_instance.taxClassPrivateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$OrderBulkCreateOrderLineInput<TRes>
    implements CopyWith$Input$OrderBulkCreateOrderLineInput<TRes> {
  _CopyWithStubImpl$Input$OrderBulkCreateOrderLineInput(this._res);

  TRes _res;

  call({
    String? variantId,
    String? variantSku,
    String? variantExternalReference,
    String? variantName,
    String? productName,
    String? productSku,
    String? translatedVariantName,
    String? translatedProductName,
    String? createdAt,
    bool? isShippingRequired,
    bool? isGiftCard,
    int? quantity,
    Input$TaxedMoneyInput? totalPrice,
    Input$TaxedMoneyInput? undiscountedTotalPrice,
    String? unitDiscountReason,
    Enum$DiscountValueTypeEnum? unitDiscountType,
    String? unitDiscountValue,
    String? warehouse,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? taxRate,
    String? taxClassId,
    String? taxClassName,
    List<Input$MetadataInput>? taxClassMetadata,
    List<Input$MetadataInput>? taxClassPrivateMetadata,
  }) =>
      _res;

  CopyWith$Input$TaxedMoneyInput<TRes> get totalPrice =>
      CopyWith$Input$TaxedMoneyInput.stub(_res);

  CopyWith$Input$TaxedMoneyInput<TRes> get undiscountedTotalPrice =>
      CopyWith$Input$TaxedMoneyInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;

  taxClassMetadata(_fn) => _res;

  taxClassPrivateMetadata(_fn) => _res;
}

class Input$OrderBulkCreateUserInput {
  factory Input$OrderBulkCreateUserInput({
    String? id,
    String? email,
    String? externalReference,
  }) =>
      Input$OrderBulkCreateUserInput._({
        if (id != null) r'id': id,
        if (email != null) r'email': email,
        if (externalReference != null) r'externalReference': externalReference,
      });

  Input$OrderBulkCreateUserInput._(this._$data);

  factory Input$OrderBulkCreateUserInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    return Input$OrderBulkCreateUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get email => (_$data['email'] as String?);

  String? get externalReference => (_$data['externalReference'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    return result$data;
  }

  CopyWith$Input$OrderBulkCreateUserInput<Input$OrderBulkCreateUserInput>
      get copyWith => CopyWith$Input$OrderBulkCreateUserInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderBulkCreateUserInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$externalReference = externalReference;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderBulkCreateUserInput<TRes> {
  factory CopyWith$Input$OrderBulkCreateUserInput(
    Input$OrderBulkCreateUserInput instance,
    TRes Function(Input$OrderBulkCreateUserInput) then,
  ) = _CopyWithImpl$Input$OrderBulkCreateUserInput;

  factory CopyWith$Input$OrderBulkCreateUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderBulkCreateUserInput;

  TRes call({
    String? id,
    String? email,
    String? externalReference,
  });
}

class _CopyWithImpl$Input$OrderBulkCreateUserInput<TRes>
    implements CopyWith$Input$OrderBulkCreateUserInput<TRes> {
  _CopyWithImpl$Input$OrderBulkCreateUserInput(
    this._instance,
    this._then,
  );

  final Input$OrderBulkCreateUserInput _instance;

  final TRes Function(Input$OrderBulkCreateUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? email = _undefined,
    Object? externalReference = _undefined,
  }) =>
      _then(Input$OrderBulkCreateUserInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (email != _undefined) 'email': (email as String?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
      }));
}

class _CopyWithStubImpl$Input$OrderBulkCreateUserInput<TRes>
    implements CopyWith$Input$OrderBulkCreateUserInput<TRes> {
  _CopyWithStubImpl$Input$OrderBulkCreateUserInput(this._res);

  TRes _res;

  call({
    String? id,
    String? email,
    String? externalReference,
  }) =>
      _res;
}

class Input$OrderChargeStatusEnumFilterInput {
  factory Input$OrderChargeStatusEnumFilterInput({
    Enum$OrderChargeStatusEnum? eq,
    List<Enum$OrderChargeStatusEnum>? oneOf,
  }) =>
      Input$OrderChargeStatusEnumFilterInput._({
        if (eq != null) r'eq': eq,
        if (oneOf != null) r'oneOf': oneOf,
      });

  Input$OrderChargeStatusEnumFilterInput._(this._$data);

  factory Input$OrderChargeStatusEnumFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$OrderChargeStatusEnum((l$eq as String));
    }
    if (data.containsKey('oneOf')) {
      final l$oneOf = data['oneOf'];
      result$data['oneOf'] = (l$oneOf as List<dynamic>?)
          ?.map((e) => fromJson$Enum$OrderChargeStatusEnum((e as String)))
          .toList();
    }
    return Input$OrderChargeStatusEnumFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderChargeStatusEnum? get eq =>
      (_$data['eq'] as Enum$OrderChargeStatusEnum?);

  List<Enum$OrderChargeStatusEnum>? get oneOf =>
      (_$data['oneOf'] as List<Enum$OrderChargeStatusEnum>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] =
          l$eq == null ? null : toJson$Enum$OrderChargeStatusEnum(l$eq);
    }
    if (_$data.containsKey('oneOf')) {
      final l$oneOf = oneOf;
      result$data['oneOf'] =
          l$oneOf?.map((e) => toJson$Enum$OrderChargeStatusEnum(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$OrderChargeStatusEnumFilterInput<
          Input$OrderChargeStatusEnumFilterInput>
      get copyWith => CopyWith$Input$OrderChargeStatusEnumFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderChargeStatusEnumFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$oneOf = oneOf;
    final lOther$oneOf = other.oneOf;
    if (_$data.containsKey('oneOf') != other._$data.containsKey('oneOf')) {
      return false;
    }
    if (l$oneOf != null && lOther$oneOf != null) {
      if (l$oneOf.length != lOther$oneOf.length) {
        return false;
      }
      for (int i = 0; i < l$oneOf.length; i++) {
        final l$oneOf$entry = l$oneOf[i];
        final lOther$oneOf$entry = lOther$oneOf[i];
        if (l$oneOf$entry != lOther$oneOf$entry) {
          return false;
        }
      }
    } else if (l$oneOf != lOther$oneOf) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$oneOf = oneOf;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('oneOf')
          ? l$oneOf == null
              ? null
              : Object.hashAll(l$oneOf.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderChargeStatusEnumFilterInput<TRes> {
  factory CopyWith$Input$OrderChargeStatusEnumFilterInput(
    Input$OrderChargeStatusEnumFilterInput instance,
    TRes Function(Input$OrderChargeStatusEnumFilterInput) then,
  ) = _CopyWithImpl$Input$OrderChargeStatusEnumFilterInput;

  factory CopyWith$Input$OrderChargeStatusEnumFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderChargeStatusEnumFilterInput;

  TRes call({
    Enum$OrderChargeStatusEnum? eq,
    List<Enum$OrderChargeStatusEnum>? oneOf,
  });
}

class _CopyWithImpl$Input$OrderChargeStatusEnumFilterInput<TRes>
    implements CopyWith$Input$OrderChargeStatusEnumFilterInput<TRes> {
  _CopyWithImpl$Input$OrderChargeStatusEnumFilterInput(
    this._instance,
    this._then,
  );

  final Input$OrderChargeStatusEnumFilterInput _instance;

  final TRes Function(Input$OrderChargeStatusEnumFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? oneOf = _undefined,
  }) =>
      _then(Input$OrderChargeStatusEnumFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as Enum$OrderChargeStatusEnum?),
        if (oneOf != _undefined)
          'oneOf': (oneOf as List<Enum$OrderChargeStatusEnum>?),
      }));
}

class _CopyWithStubImpl$Input$OrderChargeStatusEnumFilterInput<TRes>
    implements CopyWith$Input$OrderChargeStatusEnumFilterInput<TRes> {
  _CopyWithStubImpl$Input$OrderChargeStatusEnumFilterInput(this._res);

  TRes _res;

  call({
    Enum$OrderChargeStatusEnum? eq,
    List<Enum$OrderChargeStatusEnum>? oneOf,
  }) =>
      _res;
}

class Input$OrderDiscountCommonInput {
  factory Input$OrderDiscountCommonInput({
    required Enum$DiscountValueTypeEnum valueType,
    required String value,
    String? reason,
  }) =>
      Input$OrderDiscountCommonInput._({
        r'valueType': valueType,
        r'value': value,
        if (reason != null) r'reason': reason,
      });

  Input$OrderDiscountCommonInput._(this._$data);

  factory Input$OrderDiscountCommonInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$valueType = data['valueType'];
    result$data['valueType'] =
        fromJson$Enum$DiscountValueTypeEnum((l$valueType as String));
    final l$value = data['value'];
    result$data['value'] = (l$value as String);
    if (data.containsKey('reason')) {
      final l$reason = data['reason'];
      result$data['reason'] = (l$reason as String?);
    }
    return Input$OrderDiscountCommonInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$DiscountValueTypeEnum get valueType =>
      (_$data['valueType'] as Enum$DiscountValueTypeEnum);

  String get value => (_$data['value'] as String);

  String? get reason => (_$data['reason'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$valueType = valueType;
    result$data['valueType'] = toJson$Enum$DiscountValueTypeEnum(l$valueType);
    final l$value = value;
    result$data['value'] = l$value;
    if (_$data.containsKey('reason')) {
      final l$reason = reason;
      result$data['reason'] = l$reason;
    }
    return result$data;
  }

  CopyWith$Input$OrderDiscountCommonInput<Input$OrderDiscountCommonInput>
      get copyWith => CopyWith$Input$OrderDiscountCommonInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderDiscountCommonInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$valueType = valueType;
    final lOther$valueType = other.valueType;
    if (l$valueType != lOther$valueType) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (l$value != lOther$value) {
      return false;
    }
    final l$reason = reason;
    final lOther$reason = other.reason;
    if (_$data.containsKey('reason') != other._$data.containsKey('reason')) {
      return false;
    }
    if (l$reason != lOther$reason) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$valueType = valueType;
    final l$value = value;
    final l$reason = reason;
    return Object.hashAll([
      l$valueType,
      l$value,
      _$data.containsKey('reason') ? l$reason : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderDiscountCommonInput<TRes> {
  factory CopyWith$Input$OrderDiscountCommonInput(
    Input$OrderDiscountCommonInput instance,
    TRes Function(Input$OrderDiscountCommonInput) then,
  ) = _CopyWithImpl$Input$OrderDiscountCommonInput;

  factory CopyWith$Input$OrderDiscountCommonInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderDiscountCommonInput;

  TRes call({
    Enum$DiscountValueTypeEnum? valueType,
    String? value,
    String? reason,
  });
}

class _CopyWithImpl$Input$OrderDiscountCommonInput<TRes>
    implements CopyWith$Input$OrderDiscountCommonInput<TRes> {
  _CopyWithImpl$Input$OrderDiscountCommonInput(
    this._instance,
    this._then,
  );

  final Input$OrderDiscountCommonInput _instance;

  final TRes Function(Input$OrderDiscountCommonInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? valueType = _undefined,
    Object? value = _undefined,
    Object? reason = _undefined,
  }) =>
      _then(Input$OrderDiscountCommonInput._({
        ..._instance._$data,
        if (valueType != _undefined && valueType != null)
          'valueType': (valueType as Enum$DiscountValueTypeEnum),
        if (value != _undefined && value != null) 'value': (value as String),
        if (reason != _undefined) 'reason': (reason as String?),
      }));
}

class _CopyWithStubImpl$Input$OrderDiscountCommonInput<TRes>
    implements CopyWith$Input$OrderDiscountCommonInput<TRes> {
  _CopyWithStubImpl$Input$OrderDiscountCommonInput(this._res);

  TRes _res;

  call({
    Enum$DiscountValueTypeEnum? valueType,
    String? value,
    String? reason,
  }) =>
      _res;
}

class Input$OrderDraftFilterInput {
  factory Input$OrderDraftFilterInput({
    String? customer,
    Input$DateRangeInput? created,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? channels,
  }) =>
      Input$OrderDraftFilterInput._({
        if (customer != null) r'customer': customer,
        if (created != null) r'created': created,
        if (search != null) r'search': search,
        if (metadata != null) r'metadata': metadata,
        if (channels != null) r'channels': channels,
      });

  Input$OrderDraftFilterInput._(this._$data);

  factory Input$OrderDraftFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('customer')) {
      final l$customer = data['customer'];
      result$data['customer'] = (l$customer as String?);
    }
    if (data.containsKey('created')) {
      final l$created = data['created'];
      result$data['created'] = l$created == null
          ? null
          : Input$DateRangeInput.fromJson((l$created as Map<String, dynamic>));
    }
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('channels')) {
      final l$channels = data['channels'];
      result$data['channels'] =
          (l$channels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$OrderDraftFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get customer => (_$data['customer'] as String?);

  Input$DateRangeInput? get created =>
      (_$data['created'] as Input$DateRangeInput?);

  String? get search => (_$data['search'] as String?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get channels => (_$data['channels'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('customer')) {
      final l$customer = customer;
      result$data['customer'] = l$customer;
    }
    if (_$data.containsKey('created')) {
      final l$created = created;
      result$data['created'] = l$created?.toJson();
    }
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('channels')) {
      final l$channels = channels;
      result$data['channels'] = l$channels?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$OrderDraftFilterInput<Input$OrderDraftFilterInput>
      get copyWith => CopyWith$Input$OrderDraftFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderDraftFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$customer = customer;
    final lOther$customer = other.customer;
    if (_$data.containsKey('customer') !=
        other._$data.containsKey('customer')) {
      return false;
    }
    if (l$customer != lOther$customer) {
      return false;
    }
    final l$created = created;
    final lOther$created = other.created;
    if (_$data.containsKey('created') != other._$data.containsKey('created')) {
      return false;
    }
    if (l$created != lOther$created) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$channels = channels;
    final lOther$channels = other.channels;
    if (_$data.containsKey('channels') !=
        other._$data.containsKey('channels')) {
      return false;
    }
    if (l$channels != null && lOther$channels != null) {
      if (l$channels.length != lOther$channels.length) {
        return false;
      }
      for (int i = 0; i < l$channels.length; i++) {
        final l$channels$entry = l$channels[i];
        final lOther$channels$entry = lOther$channels[i];
        if (l$channels$entry != lOther$channels$entry) {
          return false;
        }
      }
    } else if (l$channels != lOther$channels) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$customer = customer;
    final l$created = created;
    final l$search = search;
    final l$metadata = metadata;
    final l$channels = channels;
    return Object.hashAll([
      _$data.containsKey('customer') ? l$customer : const {},
      _$data.containsKey('created') ? l$created : const {},
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('channels')
          ? l$channels == null
              ? null
              : Object.hashAll(l$channels.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderDraftFilterInput<TRes> {
  factory CopyWith$Input$OrderDraftFilterInput(
    Input$OrderDraftFilterInput instance,
    TRes Function(Input$OrderDraftFilterInput) then,
  ) = _CopyWithImpl$Input$OrderDraftFilterInput;

  factory CopyWith$Input$OrderDraftFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderDraftFilterInput;

  TRes call({
    String? customer,
    Input$DateRangeInput? created,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? channels,
  });
  CopyWith$Input$DateRangeInput<TRes> get created;
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
}

class _CopyWithImpl$Input$OrderDraftFilterInput<TRes>
    implements CopyWith$Input$OrderDraftFilterInput<TRes> {
  _CopyWithImpl$Input$OrderDraftFilterInput(
    this._instance,
    this._then,
  );

  final Input$OrderDraftFilterInput _instance;

  final TRes Function(Input$OrderDraftFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? customer = _undefined,
    Object? created = _undefined,
    Object? search = _undefined,
    Object? metadata = _undefined,
    Object? channels = _undefined,
  }) =>
      _then(Input$OrderDraftFilterInput._({
        ..._instance._$data,
        if (customer != _undefined) 'customer': (customer as String?),
        if (created != _undefined)
          'created': (created as Input$DateRangeInput?),
        if (search != _undefined) 'search': (search as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (channels != _undefined) 'channels': (channels as List<String>?),
      }));

  CopyWith$Input$DateRangeInput<TRes> get created {
    final local$created = _instance.created;
    return local$created == null
        ? CopyWith$Input$DateRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateRangeInput(local$created, (e) => call(created: e));
  }

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$OrderDraftFilterInput<TRes>
    implements CopyWith$Input$OrderDraftFilterInput<TRes> {
  _CopyWithStubImpl$Input$OrderDraftFilterInput(this._res);

  TRes _res;

  call({
    String? customer,
    Input$DateRangeInput? created,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? channels,
  }) =>
      _res;

  CopyWith$Input$DateRangeInput<TRes> get created =>
      CopyWith$Input$DateRangeInput.stub(_res);

  metadata(_fn) => _res;
}

class Input$OrderFilterInput {
  factory Input$OrderFilterInput({
    List<Enum$PaymentChargeStatusEnum>? paymentStatus,
    List<Enum$OrderStatusFilter>? status,
    String? customer,
    Input$DateRangeInput? created,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? channels,
    List<Enum$OrderAuthorizeStatusEnum>? authorizeStatus,
    List<Enum$OrderChargeStatusEnum>? chargeStatus,
    Input$DateTimeRangeInput? updatedAt,
    bool? isClickAndCollect,
    bool? isPreorder,
    List<String>? ids,
    List<String>? checkoutTokens,
    bool? giftCardUsed,
    bool? giftCardBought,
    List<String>? numbers,
    List<String>? checkoutIds,
  }) =>
      Input$OrderFilterInput._({
        if (paymentStatus != null) r'paymentStatus': paymentStatus,
        if (status != null) r'status': status,
        if (customer != null) r'customer': customer,
        if (created != null) r'created': created,
        if (search != null) r'search': search,
        if (metadata != null) r'metadata': metadata,
        if (channels != null) r'channels': channels,
        if (authorizeStatus != null) r'authorizeStatus': authorizeStatus,
        if (chargeStatus != null) r'chargeStatus': chargeStatus,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (isClickAndCollect != null) r'isClickAndCollect': isClickAndCollect,
        if (isPreorder != null) r'isPreorder': isPreorder,
        if (ids != null) r'ids': ids,
        if (checkoutTokens != null) r'checkoutTokens': checkoutTokens,
        if (giftCardUsed != null) r'giftCardUsed': giftCardUsed,
        if (giftCardBought != null) r'giftCardBought': giftCardBought,
        if (numbers != null) r'numbers': numbers,
        if (checkoutIds != null) r'checkoutIds': checkoutIds,
      });

  Input$OrderFilterInput._(this._$data);

  factory Input$OrderFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('paymentStatus')) {
      final l$paymentStatus = data['paymentStatus'];
      result$data['paymentStatus'] = (l$paymentStatus as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PaymentChargeStatusEnum((e as String)))
          .toList();
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as List<dynamic>?)
          ?.map((e) => fromJson$Enum$OrderStatusFilter((e as String)))
          .toList();
    }
    if (data.containsKey('customer')) {
      final l$customer = data['customer'];
      result$data['customer'] = (l$customer as String?);
    }
    if (data.containsKey('created')) {
      final l$created = data['created'];
      result$data['created'] = l$created == null
          ? null
          : Input$DateRangeInput.fromJson((l$created as Map<String, dynamic>));
    }
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('channels')) {
      final l$channels = data['channels'];
      result$data['channels'] =
          (l$channels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('authorizeStatus')) {
      final l$authorizeStatus = data['authorizeStatus'];
      result$data['authorizeStatus'] = (l$authorizeStatus as List<dynamic>?)
          ?.map((e) => fromJson$Enum$OrderAuthorizeStatusEnum((e as String)))
          .toList();
    }
    if (data.containsKey('chargeStatus')) {
      final l$chargeStatus = data['chargeStatus'];
      result$data['chargeStatus'] = (l$chargeStatus as List<dynamic>?)
          ?.map((e) => fromJson$Enum$OrderChargeStatusEnum((e as String)))
          .toList();
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeRangeInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('isClickAndCollect')) {
      final l$isClickAndCollect = data['isClickAndCollect'];
      result$data['isClickAndCollect'] = (l$isClickAndCollect as bool?);
    }
    if (data.containsKey('isPreorder')) {
      final l$isPreorder = data['isPreorder'];
      result$data['isPreorder'] = (l$isPreorder as bool?);
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('checkoutTokens')) {
      final l$checkoutTokens = data['checkoutTokens'];
      result$data['checkoutTokens'] = (l$checkoutTokens as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('giftCardUsed')) {
      final l$giftCardUsed = data['giftCardUsed'];
      result$data['giftCardUsed'] = (l$giftCardUsed as bool?);
    }
    if (data.containsKey('giftCardBought')) {
      final l$giftCardBought = data['giftCardBought'];
      result$data['giftCardBought'] = (l$giftCardBought as bool?);
    }
    if (data.containsKey('numbers')) {
      final l$numbers = data['numbers'];
      result$data['numbers'] =
          (l$numbers as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('checkoutIds')) {
      final l$checkoutIds = data['checkoutIds'];
      result$data['checkoutIds'] =
          (l$checkoutIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$OrderFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$PaymentChargeStatusEnum>? get paymentStatus =>
      (_$data['paymentStatus'] as List<Enum$PaymentChargeStatusEnum>?);

  List<Enum$OrderStatusFilter>? get status =>
      (_$data['status'] as List<Enum$OrderStatusFilter>?);

  String? get customer => (_$data['customer'] as String?);

  Input$DateRangeInput? get created =>
      (_$data['created'] as Input$DateRangeInput?);

  String? get search => (_$data['search'] as String?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get channels => (_$data['channels'] as List<String>?);

  List<Enum$OrderAuthorizeStatusEnum>? get authorizeStatus =>
      (_$data['authorizeStatus'] as List<Enum$OrderAuthorizeStatusEnum>?);

  List<Enum$OrderChargeStatusEnum>? get chargeStatus =>
      (_$data['chargeStatus'] as List<Enum$OrderChargeStatusEnum>?);

  Input$DateTimeRangeInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeRangeInput?);

  bool? get isClickAndCollect => (_$data['isClickAndCollect'] as bool?);

  bool? get isPreorder => (_$data['isPreorder'] as bool?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  List<String>? get checkoutTokens =>
      (_$data['checkoutTokens'] as List<String>?);

  bool? get giftCardUsed => (_$data['giftCardUsed'] as bool?);

  bool? get giftCardBought => (_$data['giftCardBought'] as bool?);

  List<String>? get numbers => (_$data['numbers'] as List<String>?);

  List<String>? get checkoutIds => (_$data['checkoutIds'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('paymentStatus')) {
      final l$paymentStatus = paymentStatus;
      result$data['paymentStatus'] = l$paymentStatus
          ?.map((e) => toJson$Enum$PaymentChargeStatusEnum(e))
          .toList();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status?.map((e) => toJson$Enum$OrderStatusFilter(e)).toList();
    }
    if (_$data.containsKey('customer')) {
      final l$customer = customer;
      result$data['customer'] = l$customer;
    }
    if (_$data.containsKey('created')) {
      final l$created = created;
      result$data['created'] = l$created?.toJson();
    }
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('channels')) {
      final l$channels = channels;
      result$data['channels'] = l$channels?.map((e) => e).toList();
    }
    if (_$data.containsKey('authorizeStatus')) {
      final l$authorizeStatus = authorizeStatus;
      result$data['authorizeStatus'] = l$authorizeStatus
          ?.map((e) => toJson$Enum$OrderAuthorizeStatusEnum(e))
          .toList();
    }
    if (_$data.containsKey('chargeStatus')) {
      final l$chargeStatus = chargeStatus;
      result$data['chargeStatus'] = l$chargeStatus
          ?.map((e) => toJson$Enum$OrderChargeStatusEnum(e))
          .toList();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('isClickAndCollect')) {
      final l$isClickAndCollect = isClickAndCollect;
      result$data['isClickAndCollect'] = l$isClickAndCollect;
    }
    if (_$data.containsKey('isPreorder')) {
      final l$isPreorder = isPreorder;
      result$data['isPreorder'] = l$isPreorder;
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('checkoutTokens')) {
      final l$checkoutTokens = checkoutTokens;
      result$data['checkoutTokens'] = l$checkoutTokens?.map((e) => e).toList();
    }
    if (_$data.containsKey('giftCardUsed')) {
      final l$giftCardUsed = giftCardUsed;
      result$data['giftCardUsed'] = l$giftCardUsed;
    }
    if (_$data.containsKey('giftCardBought')) {
      final l$giftCardBought = giftCardBought;
      result$data['giftCardBought'] = l$giftCardBought;
    }
    if (_$data.containsKey('numbers')) {
      final l$numbers = numbers;
      result$data['numbers'] = l$numbers?.map((e) => e).toList();
    }
    if (_$data.containsKey('checkoutIds')) {
      final l$checkoutIds = checkoutIds;
      result$data['checkoutIds'] = l$checkoutIds?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$OrderFilterInput<Input$OrderFilterInput> get copyWith =>
      CopyWith$Input$OrderFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$paymentStatus = paymentStatus;
    final lOther$paymentStatus = other.paymentStatus;
    if (_$data.containsKey('paymentStatus') !=
        other._$data.containsKey('paymentStatus')) {
      return false;
    }
    if (l$paymentStatus != null && lOther$paymentStatus != null) {
      if (l$paymentStatus.length != lOther$paymentStatus.length) {
        return false;
      }
      for (int i = 0; i < l$paymentStatus.length; i++) {
        final l$paymentStatus$entry = l$paymentStatus[i];
        final lOther$paymentStatus$entry = lOther$paymentStatus[i];
        if (l$paymentStatus$entry != lOther$paymentStatus$entry) {
          return false;
        }
      }
    } else if (l$paymentStatus != lOther$paymentStatus) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != null && lOther$status != null) {
      if (l$status.length != lOther$status.length) {
        return false;
      }
      for (int i = 0; i < l$status.length; i++) {
        final l$status$entry = l$status[i];
        final lOther$status$entry = lOther$status[i];
        if (l$status$entry != lOther$status$entry) {
          return false;
        }
      }
    } else if (l$status != lOther$status) {
      return false;
    }
    final l$customer = customer;
    final lOther$customer = other.customer;
    if (_$data.containsKey('customer') !=
        other._$data.containsKey('customer')) {
      return false;
    }
    if (l$customer != lOther$customer) {
      return false;
    }
    final l$created = created;
    final lOther$created = other.created;
    if (_$data.containsKey('created') != other._$data.containsKey('created')) {
      return false;
    }
    if (l$created != lOther$created) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$channels = channels;
    final lOther$channels = other.channels;
    if (_$data.containsKey('channels') !=
        other._$data.containsKey('channels')) {
      return false;
    }
    if (l$channels != null && lOther$channels != null) {
      if (l$channels.length != lOther$channels.length) {
        return false;
      }
      for (int i = 0; i < l$channels.length; i++) {
        final l$channels$entry = l$channels[i];
        final lOther$channels$entry = lOther$channels[i];
        if (l$channels$entry != lOther$channels$entry) {
          return false;
        }
      }
    } else if (l$channels != lOther$channels) {
      return false;
    }
    final l$authorizeStatus = authorizeStatus;
    final lOther$authorizeStatus = other.authorizeStatus;
    if (_$data.containsKey('authorizeStatus') !=
        other._$data.containsKey('authorizeStatus')) {
      return false;
    }
    if (l$authorizeStatus != null && lOther$authorizeStatus != null) {
      if (l$authorizeStatus.length != lOther$authorizeStatus.length) {
        return false;
      }
      for (int i = 0; i < l$authorizeStatus.length; i++) {
        final l$authorizeStatus$entry = l$authorizeStatus[i];
        final lOther$authorizeStatus$entry = lOther$authorizeStatus[i];
        if (l$authorizeStatus$entry != lOther$authorizeStatus$entry) {
          return false;
        }
      }
    } else if (l$authorizeStatus != lOther$authorizeStatus) {
      return false;
    }
    final l$chargeStatus = chargeStatus;
    final lOther$chargeStatus = other.chargeStatus;
    if (_$data.containsKey('chargeStatus') !=
        other._$data.containsKey('chargeStatus')) {
      return false;
    }
    if (l$chargeStatus != null && lOther$chargeStatus != null) {
      if (l$chargeStatus.length != lOther$chargeStatus.length) {
        return false;
      }
      for (int i = 0; i < l$chargeStatus.length; i++) {
        final l$chargeStatus$entry = l$chargeStatus[i];
        final lOther$chargeStatus$entry = lOther$chargeStatus[i];
        if (l$chargeStatus$entry != lOther$chargeStatus$entry) {
          return false;
        }
      }
    } else if (l$chargeStatus != lOther$chargeStatus) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$isClickAndCollect = isClickAndCollect;
    final lOther$isClickAndCollect = other.isClickAndCollect;
    if (_$data.containsKey('isClickAndCollect') !=
        other._$data.containsKey('isClickAndCollect')) {
      return false;
    }
    if (l$isClickAndCollect != lOther$isClickAndCollect) {
      return false;
    }
    final l$isPreorder = isPreorder;
    final lOther$isPreorder = other.isPreorder;
    if (_$data.containsKey('isPreorder') !=
        other._$data.containsKey('isPreorder')) {
      return false;
    }
    if (l$isPreorder != lOther$isPreorder) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$checkoutTokens = checkoutTokens;
    final lOther$checkoutTokens = other.checkoutTokens;
    if (_$data.containsKey('checkoutTokens') !=
        other._$data.containsKey('checkoutTokens')) {
      return false;
    }
    if (l$checkoutTokens != null && lOther$checkoutTokens != null) {
      if (l$checkoutTokens.length != lOther$checkoutTokens.length) {
        return false;
      }
      for (int i = 0; i < l$checkoutTokens.length; i++) {
        final l$checkoutTokens$entry = l$checkoutTokens[i];
        final lOther$checkoutTokens$entry = lOther$checkoutTokens[i];
        if (l$checkoutTokens$entry != lOther$checkoutTokens$entry) {
          return false;
        }
      }
    } else if (l$checkoutTokens != lOther$checkoutTokens) {
      return false;
    }
    final l$giftCardUsed = giftCardUsed;
    final lOther$giftCardUsed = other.giftCardUsed;
    if (_$data.containsKey('giftCardUsed') !=
        other._$data.containsKey('giftCardUsed')) {
      return false;
    }
    if (l$giftCardUsed != lOther$giftCardUsed) {
      return false;
    }
    final l$giftCardBought = giftCardBought;
    final lOther$giftCardBought = other.giftCardBought;
    if (_$data.containsKey('giftCardBought') !=
        other._$data.containsKey('giftCardBought')) {
      return false;
    }
    if (l$giftCardBought != lOther$giftCardBought) {
      return false;
    }
    final l$numbers = numbers;
    final lOther$numbers = other.numbers;
    if (_$data.containsKey('numbers') != other._$data.containsKey('numbers')) {
      return false;
    }
    if (l$numbers != null && lOther$numbers != null) {
      if (l$numbers.length != lOther$numbers.length) {
        return false;
      }
      for (int i = 0; i < l$numbers.length; i++) {
        final l$numbers$entry = l$numbers[i];
        final lOther$numbers$entry = lOther$numbers[i];
        if (l$numbers$entry != lOther$numbers$entry) {
          return false;
        }
      }
    } else if (l$numbers != lOther$numbers) {
      return false;
    }
    final l$checkoutIds = checkoutIds;
    final lOther$checkoutIds = other.checkoutIds;
    if (_$data.containsKey('checkoutIds') !=
        other._$data.containsKey('checkoutIds')) {
      return false;
    }
    if (l$checkoutIds != null && lOther$checkoutIds != null) {
      if (l$checkoutIds.length != lOther$checkoutIds.length) {
        return false;
      }
      for (int i = 0; i < l$checkoutIds.length; i++) {
        final l$checkoutIds$entry = l$checkoutIds[i];
        final lOther$checkoutIds$entry = lOther$checkoutIds[i];
        if (l$checkoutIds$entry != lOther$checkoutIds$entry) {
          return false;
        }
      }
    } else if (l$checkoutIds != lOther$checkoutIds) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$paymentStatus = paymentStatus;
    final l$status = status;
    final l$customer = customer;
    final l$created = created;
    final l$search = search;
    final l$metadata = metadata;
    final l$channels = channels;
    final l$authorizeStatus = authorizeStatus;
    final l$chargeStatus = chargeStatus;
    final l$updatedAt = updatedAt;
    final l$isClickAndCollect = isClickAndCollect;
    final l$isPreorder = isPreorder;
    final l$ids = ids;
    final l$checkoutTokens = checkoutTokens;
    final l$giftCardUsed = giftCardUsed;
    final l$giftCardBought = giftCardBought;
    final l$numbers = numbers;
    final l$checkoutIds = checkoutIds;
    return Object.hashAll([
      _$data.containsKey('paymentStatus')
          ? l$paymentStatus == null
              ? null
              : Object.hashAll(l$paymentStatus.map((v) => v))
          : const {},
      _$data.containsKey('status')
          ? l$status == null
              ? null
              : Object.hashAll(l$status.map((v) => v))
          : const {},
      _$data.containsKey('customer') ? l$customer : const {},
      _$data.containsKey('created') ? l$created : const {},
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('channels')
          ? l$channels == null
              ? null
              : Object.hashAll(l$channels.map((v) => v))
          : const {},
      _$data.containsKey('authorizeStatus')
          ? l$authorizeStatus == null
              ? null
              : Object.hashAll(l$authorizeStatus.map((v) => v))
          : const {},
      _$data.containsKey('chargeStatus')
          ? l$chargeStatus == null
              ? null
              : Object.hashAll(l$chargeStatus.map((v) => v))
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('isClickAndCollect') ? l$isClickAndCollect : const {},
      _$data.containsKey('isPreorder') ? l$isPreorder : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('checkoutTokens')
          ? l$checkoutTokens == null
              ? null
              : Object.hashAll(l$checkoutTokens.map((v) => v))
          : const {},
      _$data.containsKey('giftCardUsed') ? l$giftCardUsed : const {},
      _$data.containsKey('giftCardBought') ? l$giftCardBought : const {},
      _$data.containsKey('numbers')
          ? l$numbers == null
              ? null
              : Object.hashAll(l$numbers.map((v) => v))
          : const {},
      _$data.containsKey('checkoutIds')
          ? l$checkoutIds == null
              ? null
              : Object.hashAll(l$checkoutIds.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderFilterInput<TRes> {
  factory CopyWith$Input$OrderFilterInput(
    Input$OrderFilterInput instance,
    TRes Function(Input$OrderFilterInput) then,
  ) = _CopyWithImpl$Input$OrderFilterInput;

  factory CopyWith$Input$OrderFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderFilterInput;

  TRes call({
    List<Enum$PaymentChargeStatusEnum>? paymentStatus,
    List<Enum$OrderStatusFilter>? status,
    String? customer,
    Input$DateRangeInput? created,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? channels,
    List<Enum$OrderAuthorizeStatusEnum>? authorizeStatus,
    List<Enum$OrderChargeStatusEnum>? chargeStatus,
    Input$DateTimeRangeInput? updatedAt,
    bool? isClickAndCollect,
    bool? isPreorder,
    List<String>? ids,
    List<String>? checkoutTokens,
    bool? giftCardUsed,
    bool? giftCardBought,
    List<String>? numbers,
    List<String>? checkoutIds,
  });
  CopyWith$Input$DateRangeInput<TRes> get created;
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$OrderFilterInput<TRes>
    implements CopyWith$Input$OrderFilterInput<TRes> {
  _CopyWithImpl$Input$OrderFilterInput(
    this._instance,
    this._then,
  );

  final Input$OrderFilterInput _instance;

  final TRes Function(Input$OrderFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? paymentStatus = _undefined,
    Object? status = _undefined,
    Object? customer = _undefined,
    Object? created = _undefined,
    Object? search = _undefined,
    Object? metadata = _undefined,
    Object? channels = _undefined,
    Object? authorizeStatus = _undefined,
    Object? chargeStatus = _undefined,
    Object? updatedAt = _undefined,
    Object? isClickAndCollect = _undefined,
    Object? isPreorder = _undefined,
    Object? ids = _undefined,
    Object? checkoutTokens = _undefined,
    Object? giftCardUsed = _undefined,
    Object? giftCardBought = _undefined,
    Object? numbers = _undefined,
    Object? checkoutIds = _undefined,
  }) =>
      _then(Input$OrderFilterInput._({
        ..._instance._$data,
        if (paymentStatus != _undefined)
          'paymentStatus':
              (paymentStatus as List<Enum$PaymentChargeStatusEnum>?),
        if (status != _undefined)
          'status': (status as List<Enum$OrderStatusFilter>?),
        if (customer != _undefined) 'customer': (customer as String?),
        if (created != _undefined)
          'created': (created as Input$DateRangeInput?),
        if (search != _undefined) 'search': (search as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (channels != _undefined) 'channels': (channels as List<String>?),
        if (authorizeStatus != _undefined)
          'authorizeStatus':
              (authorizeStatus as List<Enum$OrderAuthorizeStatusEnum>?),
        if (chargeStatus != _undefined)
          'chargeStatus': (chargeStatus as List<Enum$OrderChargeStatusEnum>?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeRangeInput?),
        if (isClickAndCollect != _undefined)
          'isClickAndCollect': (isClickAndCollect as bool?),
        if (isPreorder != _undefined) 'isPreorder': (isPreorder as bool?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (checkoutTokens != _undefined)
          'checkoutTokens': (checkoutTokens as List<String>?),
        if (giftCardUsed != _undefined) 'giftCardUsed': (giftCardUsed as bool?),
        if (giftCardBought != _undefined)
          'giftCardBought': (giftCardBought as bool?),
        if (numbers != _undefined) 'numbers': (numbers as List<String>?),
        if (checkoutIds != _undefined)
          'checkoutIds': (checkoutIds as List<String>?),
      }));

  CopyWith$Input$DateRangeInput<TRes> get created {
    final local$created = _instance.created;
    return local$created == null
        ? CopyWith$Input$DateRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateRangeInput(local$created, (e) => call(created: e));
  }

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeRangeInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }
}

class _CopyWithStubImpl$Input$OrderFilterInput<TRes>
    implements CopyWith$Input$OrderFilterInput<TRes> {
  _CopyWithStubImpl$Input$OrderFilterInput(this._res);

  TRes _res;

  call({
    List<Enum$PaymentChargeStatusEnum>? paymentStatus,
    List<Enum$OrderStatusFilter>? status,
    String? customer,
    Input$DateRangeInput? created,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? channels,
    List<Enum$OrderAuthorizeStatusEnum>? authorizeStatus,
    List<Enum$OrderChargeStatusEnum>? chargeStatus,
    Input$DateTimeRangeInput? updatedAt,
    bool? isClickAndCollect,
    bool? isPreorder,
    List<String>? ids,
    List<String>? checkoutTokens,
    bool? giftCardUsed,
    bool? giftCardBought,
    List<String>? numbers,
    List<String>? checkoutIds,
  }) =>
      _res;

  CopyWith$Input$DateRangeInput<TRes> get created =>
      CopyWith$Input$DateRangeInput.stub(_res);

  metadata(_fn) => _res;

  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeRangeInput.stub(_res);
}

class Input$OrderFulfillInput {
  factory Input$OrderFulfillInput({
    required List<Input$OrderFulfillLineInput> lines,
    bool? notifyCustomer,
    bool? allowStockToBeExceeded,
    String? trackingNumber,
  }) =>
      Input$OrderFulfillInput._({
        r'lines': lines,
        if (notifyCustomer != null) r'notifyCustomer': notifyCustomer,
        if (allowStockToBeExceeded != null)
          r'allowStockToBeExceeded': allowStockToBeExceeded,
        if (trackingNumber != null) r'trackingNumber': trackingNumber,
      });

  Input$OrderFulfillInput._(this._$data);

  factory Input$OrderFulfillInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$lines = data['lines'];
    result$data['lines'] = (l$lines as List<dynamic>)
        .map((e) =>
            Input$OrderFulfillLineInput.fromJson((e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('notifyCustomer')) {
      final l$notifyCustomer = data['notifyCustomer'];
      result$data['notifyCustomer'] = (l$notifyCustomer as bool?);
    }
    if (data.containsKey('allowStockToBeExceeded')) {
      final l$allowStockToBeExceeded = data['allowStockToBeExceeded'];
      result$data['allowStockToBeExceeded'] =
          (l$allowStockToBeExceeded as bool?);
    }
    if (data.containsKey('trackingNumber')) {
      final l$trackingNumber = data['trackingNumber'];
      result$data['trackingNumber'] = (l$trackingNumber as String?);
    }
    return Input$OrderFulfillInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$OrderFulfillLineInput> get lines =>
      (_$data['lines'] as List<Input$OrderFulfillLineInput>);

  bool? get notifyCustomer => (_$data['notifyCustomer'] as bool?);

  bool? get allowStockToBeExceeded =>
      (_$data['allowStockToBeExceeded'] as bool?);

  String? get trackingNumber => (_$data['trackingNumber'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$lines = lines;
    result$data['lines'] = l$lines.map((e) => e.toJson()).toList();
    if (_$data.containsKey('notifyCustomer')) {
      final l$notifyCustomer = notifyCustomer;
      result$data['notifyCustomer'] = l$notifyCustomer;
    }
    if (_$data.containsKey('allowStockToBeExceeded')) {
      final l$allowStockToBeExceeded = allowStockToBeExceeded;
      result$data['allowStockToBeExceeded'] = l$allowStockToBeExceeded;
    }
    if (_$data.containsKey('trackingNumber')) {
      final l$trackingNumber = trackingNumber;
      result$data['trackingNumber'] = l$trackingNumber;
    }
    return result$data;
  }

  CopyWith$Input$OrderFulfillInput<Input$OrderFulfillInput> get copyWith =>
      CopyWith$Input$OrderFulfillInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderFulfillInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$lines = lines;
    final lOther$lines = other.lines;
    if (l$lines.length != lOther$lines.length) {
      return false;
    }
    for (int i = 0; i < l$lines.length; i++) {
      final l$lines$entry = l$lines[i];
      final lOther$lines$entry = lOther$lines[i];
      if (l$lines$entry != lOther$lines$entry) {
        return false;
      }
    }
    final l$notifyCustomer = notifyCustomer;
    final lOther$notifyCustomer = other.notifyCustomer;
    if (_$data.containsKey('notifyCustomer') !=
        other._$data.containsKey('notifyCustomer')) {
      return false;
    }
    if (l$notifyCustomer != lOther$notifyCustomer) {
      return false;
    }
    final l$allowStockToBeExceeded = allowStockToBeExceeded;
    final lOther$allowStockToBeExceeded = other.allowStockToBeExceeded;
    if (_$data.containsKey('allowStockToBeExceeded') !=
        other._$data.containsKey('allowStockToBeExceeded')) {
      return false;
    }
    if (l$allowStockToBeExceeded != lOther$allowStockToBeExceeded) {
      return false;
    }
    final l$trackingNumber = trackingNumber;
    final lOther$trackingNumber = other.trackingNumber;
    if (_$data.containsKey('trackingNumber') !=
        other._$data.containsKey('trackingNumber')) {
      return false;
    }
    if (l$trackingNumber != lOther$trackingNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$lines = lines;
    final l$notifyCustomer = notifyCustomer;
    final l$allowStockToBeExceeded = allowStockToBeExceeded;
    final l$trackingNumber = trackingNumber;
    return Object.hashAll([
      Object.hashAll(l$lines.map((v) => v)),
      _$data.containsKey('notifyCustomer') ? l$notifyCustomer : const {},
      _$data.containsKey('allowStockToBeExceeded')
          ? l$allowStockToBeExceeded
          : const {},
      _$data.containsKey('trackingNumber') ? l$trackingNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderFulfillInput<TRes> {
  factory CopyWith$Input$OrderFulfillInput(
    Input$OrderFulfillInput instance,
    TRes Function(Input$OrderFulfillInput) then,
  ) = _CopyWithImpl$Input$OrderFulfillInput;

  factory CopyWith$Input$OrderFulfillInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderFulfillInput;

  TRes call({
    List<Input$OrderFulfillLineInput>? lines,
    bool? notifyCustomer,
    bool? allowStockToBeExceeded,
    String? trackingNumber,
  });
  TRes lines(
      Iterable<Input$OrderFulfillLineInput> Function(
              Iterable<
                  CopyWith$Input$OrderFulfillLineInput<
                      Input$OrderFulfillLineInput>>)
          _fn);
}

class _CopyWithImpl$Input$OrderFulfillInput<TRes>
    implements CopyWith$Input$OrderFulfillInput<TRes> {
  _CopyWithImpl$Input$OrderFulfillInput(
    this._instance,
    this._then,
  );

  final Input$OrderFulfillInput _instance;

  final TRes Function(Input$OrderFulfillInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? lines = _undefined,
    Object? notifyCustomer = _undefined,
    Object? allowStockToBeExceeded = _undefined,
    Object? trackingNumber = _undefined,
  }) =>
      _then(Input$OrderFulfillInput._({
        ..._instance._$data,
        if (lines != _undefined && lines != null)
          'lines': (lines as List<Input$OrderFulfillLineInput>),
        if (notifyCustomer != _undefined)
          'notifyCustomer': (notifyCustomer as bool?),
        if (allowStockToBeExceeded != _undefined)
          'allowStockToBeExceeded': (allowStockToBeExceeded as bool?),
        if (trackingNumber != _undefined)
          'trackingNumber': (trackingNumber as String?),
      }));

  TRes lines(
          Iterable<Input$OrderFulfillLineInput> Function(
                  Iterable<
                      CopyWith$Input$OrderFulfillLineInput<
                          Input$OrderFulfillLineInput>>)
              _fn) =>
      call(
          lines: _fn(
              _instance.lines.map((e) => CopyWith$Input$OrderFulfillLineInput(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$OrderFulfillInput<TRes>
    implements CopyWith$Input$OrderFulfillInput<TRes> {
  _CopyWithStubImpl$Input$OrderFulfillInput(this._res);

  TRes _res;

  call({
    List<Input$OrderFulfillLineInput>? lines,
    bool? notifyCustomer,
    bool? allowStockToBeExceeded,
    String? trackingNumber,
  }) =>
      _res;

  lines(_fn) => _res;
}

class Input$OrderFulfillLineInput {
  factory Input$OrderFulfillLineInput({
    String? orderLineId,
    required List<Input$OrderFulfillStockInput> stocks,
  }) =>
      Input$OrderFulfillLineInput._({
        if (orderLineId != null) r'orderLineId': orderLineId,
        r'stocks': stocks,
      });

  Input$OrderFulfillLineInput._(this._$data);

  factory Input$OrderFulfillLineInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('orderLineId')) {
      final l$orderLineId = data['orderLineId'];
      result$data['orderLineId'] = (l$orderLineId as String?);
    }
    final l$stocks = data['stocks'];
    result$data['stocks'] = (l$stocks as List<dynamic>)
        .map((e) =>
            Input$OrderFulfillStockInput.fromJson((e as Map<String, dynamic>)))
        .toList();
    return Input$OrderFulfillLineInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get orderLineId => (_$data['orderLineId'] as String?);

  List<Input$OrderFulfillStockInput> get stocks =>
      (_$data['stocks'] as List<Input$OrderFulfillStockInput>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('orderLineId')) {
      final l$orderLineId = orderLineId;
      result$data['orderLineId'] = l$orderLineId;
    }
    final l$stocks = stocks;
    result$data['stocks'] = l$stocks.map((e) => e.toJson()).toList();
    return result$data;
  }

  CopyWith$Input$OrderFulfillLineInput<Input$OrderFulfillLineInput>
      get copyWith => CopyWith$Input$OrderFulfillLineInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderFulfillLineInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$orderLineId = orderLineId;
    final lOther$orderLineId = other.orderLineId;
    if (_$data.containsKey('orderLineId') !=
        other._$data.containsKey('orderLineId')) {
      return false;
    }
    if (l$orderLineId != lOther$orderLineId) {
      return false;
    }
    final l$stocks = stocks;
    final lOther$stocks = other.stocks;
    if (l$stocks.length != lOther$stocks.length) {
      return false;
    }
    for (int i = 0; i < l$stocks.length; i++) {
      final l$stocks$entry = l$stocks[i];
      final lOther$stocks$entry = lOther$stocks[i];
      if (l$stocks$entry != lOther$stocks$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$orderLineId = orderLineId;
    final l$stocks = stocks;
    return Object.hashAll([
      _$data.containsKey('orderLineId') ? l$orderLineId : const {},
      Object.hashAll(l$stocks.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$OrderFulfillLineInput<TRes> {
  factory CopyWith$Input$OrderFulfillLineInput(
    Input$OrderFulfillLineInput instance,
    TRes Function(Input$OrderFulfillLineInput) then,
  ) = _CopyWithImpl$Input$OrderFulfillLineInput;

  factory CopyWith$Input$OrderFulfillLineInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderFulfillLineInput;

  TRes call({
    String? orderLineId,
    List<Input$OrderFulfillStockInput>? stocks,
  });
  TRes stocks(
      Iterable<Input$OrderFulfillStockInput> Function(
              Iterable<
                  CopyWith$Input$OrderFulfillStockInput<
                      Input$OrderFulfillStockInput>>)
          _fn);
}

class _CopyWithImpl$Input$OrderFulfillLineInput<TRes>
    implements CopyWith$Input$OrderFulfillLineInput<TRes> {
  _CopyWithImpl$Input$OrderFulfillLineInput(
    this._instance,
    this._then,
  );

  final Input$OrderFulfillLineInput _instance;

  final TRes Function(Input$OrderFulfillLineInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? orderLineId = _undefined,
    Object? stocks = _undefined,
  }) =>
      _then(Input$OrderFulfillLineInput._({
        ..._instance._$data,
        if (orderLineId != _undefined) 'orderLineId': (orderLineId as String?),
        if (stocks != _undefined && stocks != null)
          'stocks': (stocks as List<Input$OrderFulfillStockInput>),
      }));

  TRes stocks(
          Iterable<Input$OrderFulfillStockInput> Function(
                  Iterable<
                      CopyWith$Input$OrderFulfillStockInput<
                          Input$OrderFulfillStockInput>>)
              _fn) =>
      call(
          stocks: _fn(
              _instance.stocks.map((e) => CopyWith$Input$OrderFulfillStockInput(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$OrderFulfillLineInput<TRes>
    implements CopyWith$Input$OrderFulfillLineInput<TRes> {
  _CopyWithStubImpl$Input$OrderFulfillLineInput(this._res);

  TRes _res;

  call({
    String? orderLineId,
    List<Input$OrderFulfillStockInput>? stocks,
  }) =>
      _res;

  stocks(_fn) => _res;
}

class Input$OrderFulfillStockInput {
  factory Input$OrderFulfillStockInput({
    required int quantity,
    required String warehouse,
  }) =>
      Input$OrderFulfillStockInput._({
        r'quantity': quantity,
        r'warehouse': warehouse,
      });

  Input$OrderFulfillStockInput._(this._$data);

  factory Input$OrderFulfillStockInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$warehouse = data['warehouse'];
    result$data['warehouse'] = (l$warehouse as String);
    return Input$OrderFulfillStockInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get quantity => (_$data['quantity'] as int);

  String get warehouse => (_$data['warehouse'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$warehouse = warehouse;
    result$data['warehouse'] = l$warehouse;
    return result$data;
  }

  CopyWith$Input$OrderFulfillStockInput<Input$OrderFulfillStockInput>
      get copyWith => CopyWith$Input$OrderFulfillStockInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderFulfillStockInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$warehouse = warehouse;
    final lOther$warehouse = other.warehouse;
    if (l$warehouse != lOther$warehouse) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$warehouse = warehouse;
    return Object.hashAll([
      l$quantity,
      l$warehouse,
    ]);
  }
}

abstract class CopyWith$Input$OrderFulfillStockInput<TRes> {
  factory CopyWith$Input$OrderFulfillStockInput(
    Input$OrderFulfillStockInput instance,
    TRes Function(Input$OrderFulfillStockInput) then,
  ) = _CopyWithImpl$Input$OrderFulfillStockInput;

  factory CopyWith$Input$OrderFulfillStockInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderFulfillStockInput;

  TRes call({
    int? quantity,
    String? warehouse,
  });
}

class _CopyWithImpl$Input$OrderFulfillStockInput<TRes>
    implements CopyWith$Input$OrderFulfillStockInput<TRes> {
  _CopyWithImpl$Input$OrderFulfillStockInput(
    this._instance,
    this._then,
  );

  final Input$OrderFulfillStockInput _instance;

  final TRes Function(Input$OrderFulfillStockInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? warehouse = _undefined,
  }) =>
      _then(Input$OrderFulfillStockInput._({
        ..._instance._$data,
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (warehouse != _undefined && warehouse != null)
          'warehouse': (warehouse as String),
      }));
}

class _CopyWithStubImpl$Input$OrderFulfillStockInput<TRes>
    implements CopyWith$Input$OrderFulfillStockInput<TRes> {
  _CopyWithStubImpl$Input$OrderFulfillStockInput(this._res);

  TRes _res;

  call({
    int? quantity,
    String? warehouse,
  }) =>
      _res;
}

class Input$OrderGrantRefundCreateInput {
  factory Input$OrderGrantRefundCreateInput({
    String? amount,
    String? reason,
    List<Input$OrderGrantRefundCreateLineInput>? lines,
    bool? grantRefundForShipping,
    required String transactionId,
  }) =>
      Input$OrderGrantRefundCreateInput._({
        if (amount != null) r'amount': amount,
        if (reason != null) r'reason': reason,
        if (lines != null) r'lines': lines,
        if (grantRefundForShipping != null)
          r'grantRefundForShipping': grantRefundForShipping,
        r'transactionId': transactionId,
      });

  Input$OrderGrantRefundCreateInput._(this._$data);

  factory Input$OrderGrantRefundCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = (l$amount as String?);
    }
    if (data.containsKey('reason')) {
      final l$reason = data['reason'];
      result$data['reason'] = (l$reason as String?);
    }
    if (data.containsKey('lines')) {
      final l$lines = data['lines'];
      result$data['lines'] = (l$lines as List<dynamic>?)
          ?.map((e) => Input$OrderGrantRefundCreateLineInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('grantRefundForShipping')) {
      final l$grantRefundForShipping = data['grantRefundForShipping'];
      result$data['grantRefundForShipping'] =
          (l$grantRefundForShipping as bool?);
    }
    final l$transactionId = data['transactionId'];
    result$data['transactionId'] = (l$transactionId as String);
    return Input$OrderGrantRefundCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get amount => (_$data['amount'] as String?);

  String? get reason => (_$data['reason'] as String?);

  List<Input$OrderGrantRefundCreateLineInput>? get lines =>
      (_$data['lines'] as List<Input$OrderGrantRefundCreateLineInput>?);

  bool? get grantRefundForShipping =>
      (_$data['grantRefundForShipping'] as bool?);

  String get transactionId => (_$data['transactionId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount;
    }
    if (_$data.containsKey('reason')) {
      final l$reason = reason;
      result$data['reason'] = l$reason;
    }
    if (_$data.containsKey('lines')) {
      final l$lines = lines;
      result$data['lines'] = l$lines?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('grantRefundForShipping')) {
      final l$grantRefundForShipping = grantRefundForShipping;
      result$data['grantRefundForShipping'] = l$grantRefundForShipping;
    }
    final l$transactionId = transactionId;
    result$data['transactionId'] = l$transactionId;
    return result$data;
  }

  CopyWith$Input$OrderGrantRefundCreateInput<Input$OrderGrantRefundCreateInput>
      get copyWith => CopyWith$Input$OrderGrantRefundCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderGrantRefundCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$reason = reason;
    final lOther$reason = other.reason;
    if (_$data.containsKey('reason') != other._$data.containsKey('reason')) {
      return false;
    }
    if (l$reason != lOther$reason) {
      return false;
    }
    final l$lines = lines;
    final lOther$lines = other.lines;
    if (_$data.containsKey('lines') != other._$data.containsKey('lines')) {
      return false;
    }
    if (l$lines != null && lOther$lines != null) {
      if (l$lines.length != lOther$lines.length) {
        return false;
      }
      for (int i = 0; i < l$lines.length; i++) {
        final l$lines$entry = l$lines[i];
        final lOther$lines$entry = lOther$lines[i];
        if (l$lines$entry != lOther$lines$entry) {
          return false;
        }
      }
    } else if (l$lines != lOther$lines) {
      return false;
    }
    final l$grantRefundForShipping = grantRefundForShipping;
    final lOther$grantRefundForShipping = other.grantRefundForShipping;
    if (_$data.containsKey('grantRefundForShipping') !=
        other._$data.containsKey('grantRefundForShipping')) {
      return false;
    }
    if (l$grantRefundForShipping != lOther$grantRefundForShipping) {
      return false;
    }
    final l$transactionId = transactionId;
    final lOther$transactionId = other.transactionId;
    if (l$transactionId != lOther$transactionId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$reason = reason;
    final l$lines = lines;
    final l$grantRefundForShipping = grantRefundForShipping;
    final l$transactionId = transactionId;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('reason') ? l$reason : const {},
      _$data.containsKey('lines')
          ? l$lines == null
              ? null
              : Object.hashAll(l$lines.map((v) => v))
          : const {},
      _$data.containsKey('grantRefundForShipping')
          ? l$grantRefundForShipping
          : const {},
      l$transactionId,
    ]);
  }
}

abstract class CopyWith$Input$OrderGrantRefundCreateInput<TRes> {
  factory CopyWith$Input$OrderGrantRefundCreateInput(
    Input$OrderGrantRefundCreateInput instance,
    TRes Function(Input$OrderGrantRefundCreateInput) then,
  ) = _CopyWithImpl$Input$OrderGrantRefundCreateInput;

  factory CopyWith$Input$OrderGrantRefundCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderGrantRefundCreateInput;

  TRes call({
    String? amount,
    String? reason,
    List<Input$OrderGrantRefundCreateLineInput>? lines,
    bool? grantRefundForShipping,
    String? transactionId,
  });
  TRes lines(
      Iterable<Input$OrderGrantRefundCreateLineInput>? Function(
              Iterable<
                  CopyWith$Input$OrderGrantRefundCreateLineInput<
                      Input$OrderGrantRefundCreateLineInput>>?)
          _fn);
}

class _CopyWithImpl$Input$OrderGrantRefundCreateInput<TRes>
    implements CopyWith$Input$OrderGrantRefundCreateInput<TRes> {
  _CopyWithImpl$Input$OrderGrantRefundCreateInput(
    this._instance,
    this._then,
  );

  final Input$OrderGrantRefundCreateInput _instance;

  final TRes Function(Input$OrderGrantRefundCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? reason = _undefined,
    Object? lines = _undefined,
    Object? grantRefundForShipping = _undefined,
    Object? transactionId = _undefined,
  }) =>
      _then(Input$OrderGrantRefundCreateInput._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as String?),
        if (reason != _undefined) 'reason': (reason as String?),
        if (lines != _undefined)
          'lines': (lines as List<Input$OrderGrantRefundCreateLineInput>?),
        if (grantRefundForShipping != _undefined)
          'grantRefundForShipping': (grantRefundForShipping as bool?),
        if (transactionId != _undefined && transactionId != null)
          'transactionId': (transactionId as String),
      }));

  TRes lines(
          Iterable<Input$OrderGrantRefundCreateLineInput>? Function(
                  Iterable<
                      CopyWith$Input$OrderGrantRefundCreateLineInput<
                          Input$OrderGrantRefundCreateLineInput>>?)
              _fn) =>
      call(
          lines: _fn(_instance.lines
              ?.map((e) => CopyWith$Input$OrderGrantRefundCreateLineInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$OrderGrantRefundCreateInput<TRes>
    implements CopyWith$Input$OrderGrantRefundCreateInput<TRes> {
  _CopyWithStubImpl$Input$OrderGrantRefundCreateInput(this._res);

  TRes _res;

  call({
    String? amount,
    String? reason,
    List<Input$OrderGrantRefundCreateLineInput>? lines,
    bool? grantRefundForShipping,
    String? transactionId,
  }) =>
      _res;

  lines(_fn) => _res;
}

class Input$OrderGrantRefundCreateLineInput {
  factory Input$OrderGrantRefundCreateLineInput({
    required String id,
    required int quantity,
    String? reason,
  }) =>
      Input$OrderGrantRefundCreateLineInput._({
        r'id': id,
        r'quantity': quantity,
        if (reason != null) r'reason': reason,
      });

  Input$OrderGrantRefundCreateLineInput._(this._$data);

  factory Input$OrderGrantRefundCreateLineInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    if (data.containsKey('reason')) {
      final l$reason = data['reason'];
      result$data['reason'] = (l$reason as String?);
    }
    return Input$OrderGrantRefundCreateLineInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);

  int get quantity => (_$data['quantity'] as int);

  String? get reason => (_$data['reason'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    if (_$data.containsKey('reason')) {
      final l$reason = reason;
      result$data['reason'] = l$reason;
    }
    return result$data;
  }

  CopyWith$Input$OrderGrantRefundCreateLineInput<
          Input$OrderGrantRefundCreateLineInput>
      get copyWith => CopyWith$Input$OrderGrantRefundCreateLineInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderGrantRefundCreateLineInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$reason = reason;
    final lOther$reason = other.reason;
    if (_$data.containsKey('reason') != other._$data.containsKey('reason')) {
      return false;
    }
    if (l$reason != lOther$reason) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$quantity = quantity;
    final l$reason = reason;
    return Object.hashAll([
      l$id,
      l$quantity,
      _$data.containsKey('reason') ? l$reason : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderGrantRefundCreateLineInput<TRes> {
  factory CopyWith$Input$OrderGrantRefundCreateLineInput(
    Input$OrderGrantRefundCreateLineInput instance,
    TRes Function(Input$OrderGrantRefundCreateLineInput) then,
  ) = _CopyWithImpl$Input$OrderGrantRefundCreateLineInput;

  factory CopyWith$Input$OrderGrantRefundCreateLineInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderGrantRefundCreateLineInput;

  TRes call({
    String? id,
    int? quantity,
    String? reason,
  });
}

class _CopyWithImpl$Input$OrderGrantRefundCreateLineInput<TRes>
    implements CopyWith$Input$OrderGrantRefundCreateLineInput<TRes> {
  _CopyWithImpl$Input$OrderGrantRefundCreateLineInput(
    this._instance,
    this._then,
  );

  final Input$OrderGrantRefundCreateLineInput _instance;

  final TRes Function(Input$OrderGrantRefundCreateLineInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? quantity = _undefined,
    Object? reason = _undefined,
  }) =>
      _then(Input$OrderGrantRefundCreateLineInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (reason != _undefined) 'reason': (reason as String?),
      }));
}

class _CopyWithStubImpl$Input$OrderGrantRefundCreateLineInput<TRes>
    implements CopyWith$Input$OrderGrantRefundCreateLineInput<TRes> {
  _CopyWithStubImpl$Input$OrderGrantRefundCreateLineInput(this._res);

  TRes _res;

  call({
    String? id,
    int? quantity,
    String? reason,
  }) =>
      _res;
}

class Input$OrderGrantRefundUpdateInput {
  factory Input$OrderGrantRefundUpdateInput({
    String? amount,
    String? reason,
    List<Input$OrderGrantRefundUpdateLineAddInput>? addLines,
    List<String>? removeLines,
    bool? grantRefundForShipping,
    String? transactionId,
  }) =>
      Input$OrderGrantRefundUpdateInput._({
        if (amount != null) r'amount': amount,
        if (reason != null) r'reason': reason,
        if (addLines != null) r'addLines': addLines,
        if (removeLines != null) r'removeLines': removeLines,
        if (grantRefundForShipping != null)
          r'grantRefundForShipping': grantRefundForShipping,
        if (transactionId != null) r'transactionId': transactionId,
      });

  Input$OrderGrantRefundUpdateInput._(this._$data);

  factory Input$OrderGrantRefundUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = (l$amount as String?);
    }
    if (data.containsKey('reason')) {
      final l$reason = data['reason'];
      result$data['reason'] = (l$reason as String?);
    }
    if (data.containsKey('addLines')) {
      final l$addLines = data['addLines'];
      result$data['addLines'] = (l$addLines as List<dynamic>?)
          ?.map((e) => Input$OrderGrantRefundUpdateLineAddInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('removeLines')) {
      final l$removeLines = data['removeLines'];
      result$data['removeLines'] =
          (l$removeLines as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('grantRefundForShipping')) {
      final l$grantRefundForShipping = data['grantRefundForShipping'];
      result$data['grantRefundForShipping'] =
          (l$grantRefundForShipping as bool?);
    }
    if (data.containsKey('transactionId')) {
      final l$transactionId = data['transactionId'];
      result$data['transactionId'] = (l$transactionId as String?);
    }
    return Input$OrderGrantRefundUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get amount => (_$data['amount'] as String?);

  String? get reason => (_$data['reason'] as String?);

  List<Input$OrderGrantRefundUpdateLineAddInput>? get addLines =>
      (_$data['addLines'] as List<Input$OrderGrantRefundUpdateLineAddInput>?);

  List<String>? get removeLines => (_$data['removeLines'] as List<String>?);

  bool? get grantRefundForShipping =>
      (_$data['grantRefundForShipping'] as bool?);

  String? get transactionId => (_$data['transactionId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount;
    }
    if (_$data.containsKey('reason')) {
      final l$reason = reason;
      result$data['reason'] = l$reason;
    }
    if (_$data.containsKey('addLines')) {
      final l$addLines = addLines;
      result$data['addLines'] = l$addLines?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('removeLines')) {
      final l$removeLines = removeLines;
      result$data['removeLines'] = l$removeLines?.map((e) => e).toList();
    }
    if (_$data.containsKey('grantRefundForShipping')) {
      final l$grantRefundForShipping = grantRefundForShipping;
      result$data['grantRefundForShipping'] = l$grantRefundForShipping;
    }
    if (_$data.containsKey('transactionId')) {
      final l$transactionId = transactionId;
      result$data['transactionId'] = l$transactionId;
    }
    return result$data;
  }

  CopyWith$Input$OrderGrantRefundUpdateInput<Input$OrderGrantRefundUpdateInput>
      get copyWith => CopyWith$Input$OrderGrantRefundUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderGrantRefundUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$reason = reason;
    final lOther$reason = other.reason;
    if (_$data.containsKey('reason') != other._$data.containsKey('reason')) {
      return false;
    }
    if (l$reason != lOther$reason) {
      return false;
    }
    final l$addLines = addLines;
    final lOther$addLines = other.addLines;
    if (_$data.containsKey('addLines') !=
        other._$data.containsKey('addLines')) {
      return false;
    }
    if (l$addLines != null && lOther$addLines != null) {
      if (l$addLines.length != lOther$addLines.length) {
        return false;
      }
      for (int i = 0; i < l$addLines.length; i++) {
        final l$addLines$entry = l$addLines[i];
        final lOther$addLines$entry = lOther$addLines[i];
        if (l$addLines$entry != lOther$addLines$entry) {
          return false;
        }
      }
    } else if (l$addLines != lOther$addLines) {
      return false;
    }
    final l$removeLines = removeLines;
    final lOther$removeLines = other.removeLines;
    if (_$data.containsKey('removeLines') !=
        other._$data.containsKey('removeLines')) {
      return false;
    }
    if (l$removeLines != null && lOther$removeLines != null) {
      if (l$removeLines.length != lOther$removeLines.length) {
        return false;
      }
      for (int i = 0; i < l$removeLines.length; i++) {
        final l$removeLines$entry = l$removeLines[i];
        final lOther$removeLines$entry = lOther$removeLines[i];
        if (l$removeLines$entry != lOther$removeLines$entry) {
          return false;
        }
      }
    } else if (l$removeLines != lOther$removeLines) {
      return false;
    }
    final l$grantRefundForShipping = grantRefundForShipping;
    final lOther$grantRefundForShipping = other.grantRefundForShipping;
    if (_$data.containsKey('grantRefundForShipping') !=
        other._$data.containsKey('grantRefundForShipping')) {
      return false;
    }
    if (l$grantRefundForShipping != lOther$grantRefundForShipping) {
      return false;
    }
    final l$transactionId = transactionId;
    final lOther$transactionId = other.transactionId;
    if (_$data.containsKey('transactionId') !=
        other._$data.containsKey('transactionId')) {
      return false;
    }
    if (l$transactionId != lOther$transactionId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$reason = reason;
    final l$addLines = addLines;
    final l$removeLines = removeLines;
    final l$grantRefundForShipping = grantRefundForShipping;
    final l$transactionId = transactionId;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('reason') ? l$reason : const {},
      _$data.containsKey('addLines')
          ? l$addLines == null
              ? null
              : Object.hashAll(l$addLines.map((v) => v))
          : const {},
      _$data.containsKey('removeLines')
          ? l$removeLines == null
              ? null
              : Object.hashAll(l$removeLines.map((v) => v))
          : const {},
      _$data.containsKey('grantRefundForShipping')
          ? l$grantRefundForShipping
          : const {},
      _$data.containsKey('transactionId') ? l$transactionId : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderGrantRefundUpdateInput<TRes> {
  factory CopyWith$Input$OrderGrantRefundUpdateInput(
    Input$OrderGrantRefundUpdateInput instance,
    TRes Function(Input$OrderGrantRefundUpdateInput) then,
  ) = _CopyWithImpl$Input$OrderGrantRefundUpdateInput;

  factory CopyWith$Input$OrderGrantRefundUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderGrantRefundUpdateInput;

  TRes call({
    String? amount,
    String? reason,
    List<Input$OrderGrantRefundUpdateLineAddInput>? addLines,
    List<String>? removeLines,
    bool? grantRefundForShipping,
    String? transactionId,
  });
  TRes addLines(
      Iterable<Input$OrderGrantRefundUpdateLineAddInput>? Function(
              Iterable<
                  CopyWith$Input$OrderGrantRefundUpdateLineAddInput<
                      Input$OrderGrantRefundUpdateLineAddInput>>?)
          _fn);
}

class _CopyWithImpl$Input$OrderGrantRefundUpdateInput<TRes>
    implements CopyWith$Input$OrderGrantRefundUpdateInput<TRes> {
  _CopyWithImpl$Input$OrderGrantRefundUpdateInput(
    this._instance,
    this._then,
  );

  final Input$OrderGrantRefundUpdateInput _instance;

  final TRes Function(Input$OrderGrantRefundUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? reason = _undefined,
    Object? addLines = _undefined,
    Object? removeLines = _undefined,
    Object? grantRefundForShipping = _undefined,
    Object? transactionId = _undefined,
  }) =>
      _then(Input$OrderGrantRefundUpdateInput._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as String?),
        if (reason != _undefined) 'reason': (reason as String?),
        if (addLines != _undefined)
          'addLines':
              (addLines as List<Input$OrderGrantRefundUpdateLineAddInput>?),
        if (removeLines != _undefined)
          'removeLines': (removeLines as List<String>?),
        if (grantRefundForShipping != _undefined)
          'grantRefundForShipping': (grantRefundForShipping as bool?),
        if (transactionId != _undefined)
          'transactionId': (transactionId as String?),
      }));

  TRes addLines(
          Iterable<Input$OrderGrantRefundUpdateLineAddInput>? Function(
                  Iterable<
                      CopyWith$Input$OrderGrantRefundUpdateLineAddInput<
                          Input$OrderGrantRefundUpdateLineAddInput>>?)
              _fn) =>
      call(
          addLines: _fn(_instance.addLines
              ?.map((e) => CopyWith$Input$OrderGrantRefundUpdateLineAddInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$OrderGrantRefundUpdateInput<TRes>
    implements CopyWith$Input$OrderGrantRefundUpdateInput<TRes> {
  _CopyWithStubImpl$Input$OrderGrantRefundUpdateInput(this._res);

  TRes _res;

  call({
    String? amount,
    String? reason,
    List<Input$OrderGrantRefundUpdateLineAddInput>? addLines,
    List<String>? removeLines,
    bool? grantRefundForShipping,
    String? transactionId,
  }) =>
      _res;

  addLines(_fn) => _res;
}

class Input$OrderGrantRefundUpdateLineAddInput {
  factory Input$OrderGrantRefundUpdateLineAddInput({
    required String id,
    required int quantity,
    String? reason,
  }) =>
      Input$OrderGrantRefundUpdateLineAddInput._({
        r'id': id,
        r'quantity': quantity,
        if (reason != null) r'reason': reason,
      });

  Input$OrderGrantRefundUpdateLineAddInput._(this._$data);

  factory Input$OrderGrantRefundUpdateLineAddInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    if (data.containsKey('reason')) {
      final l$reason = data['reason'];
      result$data['reason'] = (l$reason as String?);
    }
    return Input$OrderGrantRefundUpdateLineAddInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);

  int get quantity => (_$data['quantity'] as int);

  String? get reason => (_$data['reason'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    if (_$data.containsKey('reason')) {
      final l$reason = reason;
      result$data['reason'] = l$reason;
    }
    return result$data;
  }

  CopyWith$Input$OrderGrantRefundUpdateLineAddInput<
          Input$OrderGrantRefundUpdateLineAddInput>
      get copyWith => CopyWith$Input$OrderGrantRefundUpdateLineAddInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderGrantRefundUpdateLineAddInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$reason = reason;
    final lOther$reason = other.reason;
    if (_$data.containsKey('reason') != other._$data.containsKey('reason')) {
      return false;
    }
    if (l$reason != lOther$reason) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$quantity = quantity;
    final l$reason = reason;
    return Object.hashAll([
      l$id,
      l$quantity,
      _$data.containsKey('reason') ? l$reason : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderGrantRefundUpdateLineAddInput<TRes> {
  factory CopyWith$Input$OrderGrantRefundUpdateLineAddInput(
    Input$OrderGrantRefundUpdateLineAddInput instance,
    TRes Function(Input$OrderGrantRefundUpdateLineAddInput) then,
  ) = _CopyWithImpl$Input$OrderGrantRefundUpdateLineAddInput;

  factory CopyWith$Input$OrderGrantRefundUpdateLineAddInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderGrantRefundUpdateLineAddInput;

  TRes call({
    String? id,
    int? quantity,
    String? reason,
  });
}

class _CopyWithImpl$Input$OrderGrantRefundUpdateLineAddInput<TRes>
    implements CopyWith$Input$OrderGrantRefundUpdateLineAddInput<TRes> {
  _CopyWithImpl$Input$OrderGrantRefundUpdateLineAddInput(
    this._instance,
    this._then,
  );

  final Input$OrderGrantRefundUpdateLineAddInput _instance;

  final TRes Function(Input$OrderGrantRefundUpdateLineAddInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? quantity = _undefined,
    Object? reason = _undefined,
  }) =>
      _then(Input$OrderGrantRefundUpdateLineAddInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (reason != _undefined) 'reason': (reason as String?),
      }));
}

class _CopyWithStubImpl$Input$OrderGrantRefundUpdateLineAddInput<TRes>
    implements CopyWith$Input$OrderGrantRefundUpdateLineAddInput<TRes> {
  _CopyWithStubImpl$Input$OrderGrantRefundUpdateLineAddInput(this._res);

  TRes _res;

  call({
    String? id,
    int? quantity,
    String? reason,
  }) =>
      _res;
}

class Input$OrderLineCreateInput {
  factory Input$OrderLineCreateInput({
    required int quantity,
    required String variantId,
    bool? forceNewLine,
    String? price,
  }) =>
      Input$OrderLineCreateInput._({
        r'quantity': quantity,
        r'variantId': variantId,
        if (forceNewLine != null) r'forceNewLine': forceNewLine,
        if (price != null) r'price': price,
      });

  Input$OrderLineCreateInput._(this._$data);

  factory Input$OrderLineCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$variantId = data['variantId'];
    result$data['variantId'] = (l$variantId as String);
    if (data.containsKey('forceNewLine')) {
      final l$forceNewLine = data['forceNewLine'];
      result$data['forceNewLine'] = (l$forceNewLine as bool?);
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] = (l$price as String?);
    }
    return Input$OrderLineCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get quantity => (_$data['quantity'] as int);

  String get variantId => (_$data['variantId'] as String);

  bool? get forceNewLine => (_$data['forceNewLine'] as bool?);

  String? get price => (_$data['price'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$variantId = variantId;
    result$data['variantId'] = l$variantId;
    if (_$data.containsKey('forceNewLine')) {
      final l$forceNewLine = forceNewLine;
      result$data['forceNewLine'] = l$forceNewLine;
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] = l$price;
    }
    return result$data;
  }

  CopyWith$Input$OrderLineCreateInput<Input$OrderLineCreateInput>
      get copyWith => CopyWith$Input$OrderLineCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderLineCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$variantId = variantId;
    final lOther$variantId = other.variantId;
    if (l$variantId != lOther$variantId) {
      return false;
    }
    final l$forceNewLine = forceNewLine;
    final lOther$forceNewLine = other.forceNewLine;
    if (_$data.containsKey('forceNewLine') !=
        other._$data.containsKey('forceNewLine')) {
      return false;
    }
    if (l$forceNewLine != lOther$forceNewLine) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$variantId = variantId;
    final l$forceNewLine = forceNewLine;
    final l$price = price;
    return Object.hashAll([
      l$quantity,
      l$variantId,
      _$data.containsKey('forceNewLine') ? l$forceNewLine : const {},
      _$data.containsKey('price') ? l$price : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderLineCreateInput<TRes> {
  factory CopyWith$Input$OrderLineCreateInput(
    Input$OrderLineCreateInput instance,
    TRes Function(Input$OrderLineCreateInput) then,
  ) = _CopyWithImpl$Input$OrderLineCreateInput;

  factory CopyWith$Input$OrderLineCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderLineCreateInput;

  TRes call({
    int? quantity,
    String? variantId,
    bool? forceNewLine,
    String? price,
  });
}

class _CopyWithImpl$Input$OrderLineCreateInput<TRes>
    implements CopyWith$Input$OrderLineCreateInput<TRes> {
  _CopyWithImpl$Input$OrderLineCreateInput(
    this._instance,
    this._then,
  );

  final Input$OrderLineCreateInput _instance;

  final TRes Function(Input$OrderLineCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? variantId = _undefined,
    Object? forceNewLine = _undefined,
    Object? price = _undefined,
  }) =>
      _then(Input$OrderLineCreateInput._({
        ..._instance._$data,
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (variantId != _undefined && variantId != null)
          'variantId': (variantId as String),
        if (forceNewLine != _undefined) 'forceNewLine': (forceNewLine as bool?),
        if (price != _undefined) 'price': (price as String?),
      }));
}

class _CopyWithStubImpl$Input$OrderLineCreateInput<TRes>
    implements CopyWith$Input$OrderLineCreateInput<TRes> {
  _CopyWithStubImpl$Input$OrderLineCreateInput(this._res);

  TRes _res;

  call({
    int? quantity,
    String? variantId,
    bool? forceNewLine,
    String? price,
  }) =>
      _res;
}

class Input$OrderLineInput {
  factory Input$OrderLineInput({required int quantity}) =>
      Input$OrderLineInput._({
        r'quantity': quantity,
      });

  Input$OrderLineInput._(this._$data);

  factory Input$OrderLineInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    return Input$OrderLineInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get quantity => (_$data['quantity'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    return result$data;
  }

  CopyWith$Input$OrderLineInput<Input$OrderLineInput> get copyWith =>
      CopyWith$Input$OrderLineInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderLineInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    return Object.hashAll([l$quantity]);
  }
}

abstract class CopyWith$Input$OrderLineInput<TRes> {
  factory CopyWith$Input$OrderLineInput(
    Input$OrderLineInput instance,
    TRes Function(Input$OrderLineInput) then,
  ) = _CopyWithImpl$Input$OrderLineInput;

  factory CopyWith$Input$OrderLineInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderLineInput;

  TRes call({int? quantity});
}

class _CopyWithImpl$Input$OrderLineInput<TRes>
    implements CopyWith$Input$OrderLineInput<TRes> {
  _CopyWithImpl$Input$OrderLineInput(
    this._instance,
    this._then,
  );

  final Input$OrderLineInput _instance;

  final TRes Function(Input$OrderLineInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? quantity = _undefined}) => _then(Input$OrderLineInput._({
        ..._instance._$data,
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
      }));
}

class _CopyWithStubImpl$Input$OrderLineInput<TRes>
    implements CopyWith$Input$OrderLineInput<TRes> {
  _CopyWithStubImpl$Input$OrderLineInput(this._res);

  TRes _res;

  call({int? quantity}) => _res;
}

class Input$OrderNoteInput {
  factory Input$OrderNoteInput({required String message}) =>
      Input$OrderNoteInput._({
        r'message': message,
      });

  Input$OrderNoteInput._(this._$data);

  factory Input$OrderNoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$message = data['message'];
    result$data['message'] = (l$message as String);
    return Input$OrderNoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get message => (_$data['message'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$message = message;
    result$data['message'] = l$message;
    return result$data;
  }

  CopyWith$Input$OrderNoteInput<Input$OrderNoteInput> get copyWith =>
      CopyWith$Input$OrderNoteInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderNoteInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$message = message;
    return Object.hashAll([l$message]);
  }
}

abstract class CopyWith$Input$OrderNoteInput<TRes> {
  factory CopyWith$Input$OrderNoteInput(
    Input$OrderNoteInput instance,
    TRes Function(Input$OrderNoteInput) then,
  ) = _CopyWithImpl$Input$OrderNoteInput;

  factory CopyWith$Input$OrderNoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderNoteInput;

  TRes call({String? message});
}

class _CopyWithImpl$Input$OrderNoteInput<TRes>
    implements CopyWith$Input$OrderNoteInput<TRes> {
  _CopyWithImpl$Input$OrderNoteInput(
    this._instance,
    this._then,
  );

  final Input$OrderNoteInput _instance;

  final TRes Function(Input$OrderNoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? message = _undefined}) => _then(Input$OrderNoteInput._({
        ..._instance._$data,
        if (message != _undefined && message != null)
          'message': (message as String),
      }));
}

class _CopyWithStubImpl$Input$OrderNoteInput<TRes>
    implements CopyWith$Input$OrderNoteInput<TRes> {
  _CopyWithStubImpl$Input$OrderNoteInput(this._res);

  TRes _res;

  call({String? message}) => _res;
}

class Input$OrderPredicateInput {
  factory Input$OrderPredicateInput({
    Input$DiscountedObjectWhereInput? discountedObjectPredicate,
    List<Input$OrderPredicateInput>? AND,
    List<Input$OrderPredicateInput>? OR,
  }) =>
      Input$OrderPredicateInput._({
        if (discountedObjectPredicate != null)
          r'discountedObjectPredicate': discountedObjectPredicate,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
      });

  Input$OrderPredicateInput._(this._$data);

  factory Input$OrderPredicateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('discountedObjectPredicate')) {
      final l$discountedObjectPredicate = data['discountedObjectPredicate'];
      result$data['discountedObjectPredicate'] =
          l$discountedObjectPredicate == null
              ? null
              : Input$DiscountedObjectWhereInput.fromJson(
                  (l$discountedObjectPredicate as Map<String, dynamic>));
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$OrderPredicateInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$OrderPredicateInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$OrderPredicateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$DiscountedObjectWhereInput? get discountedObjectPredicate =>
      (_$data['discountedObjectPredicate']
          as Input$DiscountedObjectWhereInput?);

  List<Input$OrderPredicateInput>? get AND =>
      (_$data['AND'] as List<Input$OrderPredicateInput>?);

  List<Input$OrderPredicateInput>? get OR =>
      (_$data['OR'] as List<Input$OrderPredicateInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('discountedObjectPredicate')) {
      final l$discountedObjectPredicate = discountedObjectPredicate;
      result$data['discountedObjectPredicate'] =
          l$discountedObjectPredicate?.toJson();
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$OrderPredicateInput<Input$OrderPredicateInput> get copyWith =>
      CopyWith$Input$OrderPredicateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderPredicateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$discountedObjectPredicate = discountedObjectPredicate;
    final lOther$discountedObjectPredicate = other.discountedObjectPredicate;
    if (_$data.containsKey('discountedObjectPredicate') !=
        other._$data.containsKey('discountedObjectPredicate')) {
      return false;
    }
    if (l$discountedObjectPredicate != lOther$discountedObjectPredicate) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$discountedObjectPredicate = discountedObjectPredicate;
    final l$AND = AND;
    final l$OR = OR;
    return Object.hashAll([
      _$data.containsKey('discountedObjectPredicate')
          ? l$discountedObjectPredicate
          : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderPredicateInput<TRes> {
  factory CopyWith$Input$OrderPredicateInput(
    Input$OrderPredicateInput instance,
    TRes Function(Input$OrderPredicateInput) then,
  ) = _CopyWithImpl$Input$OrderPredicateInput;

  factory CopyWith$Input$OrderPredicateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderPredicateInput;

  TRes call({
    Input$DiscountedObjectWhereInput? discountedObjectPredicate,
    List<Input$OrderPredicateInput>? AND,
    List<Input$OrderPredicateInput>? OR,
  });
  CopyWith$Input$DiscountedObjectWhereInput<TRes> get discountedObjectPredicate;
  TRes AND(
      Iterable<Input$OrderPredicateInput>? Function(
              Iterable<
                  CopyWith$Input$OrderPredicateInput<
                      Input$OrderPredicateInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$OrderPredicateInput>? Function(
              Iterable<
                  CopyWith$Input$OrderPredicateInput<
                      Input$OrderPredicateInput>>?)
          _fn);
}

class _CopyWithImpl$Input$OrderPredicateInput<TRes>
    implements CopyWith$Input$OrderPredicateInput<TRes> {
  _CopyWithImpl$Input$OrderPredicateInput(
    this._instance,
    this._then,
  );

  final Input$OrderPredicateInput _instance;

  final TRes Function(Input$OrderPredicateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? discountedObjectPredicate = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
  }) =>
      _then(Input$OrderPredicateInput._({
        ..._instance._$data,
        if (discountedObjectPredicate != _undefined)
          'discountedObjectPredicate':
              (discountedObjectPredicate as Input$DiscountedObjectWhereInput?),
        if (AND != _undefined) 'AND': (AND as List<Input$OrderPredicateInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$OrderPredicateInput>?),
      }));

  CopyWith$Input$DiscountedObjectWhereInput<TRes>
      get discountedObjectPredicate {
    final local$discountedObjectPredicate = _instance.discountedObjectPredicate;
    return local$discountedObjectPredicate == null
        ? CopyWith$Input$DiscountedObjectWhereInput.stub(_then(_instance))
        : CopyWith$Input$DiscountedObjectWhereInput(
            local$discountedObjectPredicate,
            (e) => call(discountedObjectPredicate: e));
  }

  TRes AND(
          Iterable<Input$OrderPredicateInput>? Function(
                  Iterable<
                      CopyWith$Input$OrderPredicateInput<
                          Input$OrderPredicateInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$OrderPredicateInput(
                e,
                (i) => i,
              )))?.toList());

  TRes OR(
          Iterable<Input$OrderPredicateInput>? Function(
                  Iterable<
                      CopyWith$Input$OrderPredicateInput<
                          Input$OrderPredicateInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$OrderPredicateInput(
                e,
                (i) => i,
              )))?.toList());
}

class _CopyWithStubImpl$Input$OrderPredicateInput<TRes>
    implements CopyWith$Input$OrderPredicateInput<TRes> {
  _CopyWithStubImpl$Input$OrderPredicateInput(this._res);

  TRes _res;

  call({
    Input$DiscountedObjectWhereInput? discountedObjectPredicate,
    List<Input$OrderPredicateInput>? AND,
    List<Input$OrderPredicateInput>? OR,
  }) =>
      _res;

  CopyWith$Input$DiscountedObjectWhereInput<TRes>
      get discountedObjectPredicate =>
          CopyWith$Input$DiscountedObjectWhereInput.stub(_res);

  AND(_fn) => _res;

  OR(_fn) => _res;
}

class Input$OrderRefundFulfillmentLineInput {
  factory Input$OrderRefundFulfillmentLineInput({
    required String fulfillmentLineId,
    required int quantity,
  }) =>
      Input$OrderRefundFulfillmentLineInput._({
        r'fulfillmentLineId': fulfillmentLineId,
        r'quantity': quantity,
      });

  Input$OrderRefundFulfillmentLineInput._(this._$data);

  factory Input$OrderRefundFulfillmentLineInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$fulfillmentLineId = data['fulfillmentLineId'];
    result$data['fulfillmentLineId'] = (l$fulfillmentLineId as String);
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    return Input$OrderRefundFulfillmentLineInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get fulfillmentLineId => (_$data['fulfillmentLineId'] as String);

  int get quantity => (_$data['quantity'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$fulfillmentLineId = fulfillmentLineId;
    result$data['fulfillmentLineId'] = l$fulfillmentLineId;
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    return result$data;
  }

  CopyWith$Input$OrderRefundFulfillmentLineInput<
          Input$OrderRefundFulfillmentLineInput>
      get copyWith => CopyWith$Input$OrderRefundFulfillmentLineInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderRefundFulfillmentLineInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$fulfillmentLineId = fulfillmentLineId;
    final lOther$fulfillmentLineId = other.fulfillmentLineId;
    if (l$fulfillmentLineId != lOther$fulfillmentLineId) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$fulfillmentLineId = fulfillmentLineId;
    final l$quantity = quantity;
    return Object.hashAll([
      l$fulfillmentLineId,
      l$quantity,
    ]);
  }
}

abstract class CopyWith$Input$OrderRefundFulfillmentLineInput<TRes> {
  factory CopyWith$Input$OrderRefundFulfillmentLineInput(
    Input$OrderRefundFulfillmentLineInput instance,
    TRes Function(Input$OrderRefundFulfillmentLineInput) then,
  ) = _CopyWithImpl$Input$OrderRefundFulfillmentLineInput;

  factory CopyWith$Input$OrderRefundFulfillmentLineInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderRefundFulfillmentLineInput;

  TRes call({
    String? fulfillmentLineId,
    int? quantity,
  });
}

class _CopyWithImpl$Input$OrderRefundFulfillmentLineInput<TRes>
    implements CopyWith$Input$OrderRefundFulfillmentLineInput<TRes> {
  _CopyWithImpl$Input$OrderRefundFulfillmentLineInput(
    this._instance,
    this._then,
  );

  final Input$OrderRefundFulfillmentLineInput _instance;

  final TRes Function(Input$OrderRefundFulfillmentLineInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? fulfillmentLineId = _undefined,
    Object? quantity = _undefined,
  }) =>
      _then(Input$OrderRefundFulfillmentLineInput._({
        ..._instance._$data,
        if (fulfillmentLineId != _undefined && fulfillmentLineId != null)
          'fulfillmentLineId': (fulfillmentLineId as String),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
      }));
}

class _CopyWithStubImpl$Input$OrderRefundFulfillmentLineInput<TRes>
    implements CopyWith$Input$OrderRefundFulfillmentLineInput<TRes> {
  _CopyWithStubImpl$Input$OrderRefundFulfillmentLineInput(this._res);

  TRes _res;

  call({
    String? fulfillmentLineId,
    int? quantity,
  }) =>
      _res;
}

class Input$OrderRefundLineInput {
  factory Input$OrderRefundLineInput({
    required String orderLineId,
    required int quantity,
  }) =>
      Input$OrderRefundLineInput._({
        r'orderLineId': orderLineId,
        r'quantity': quantity,
      });

  Input$OrderRefundLineInput._(this._$data);

  factory Input$OrderRefundLineInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$orderLineId = data['orderLineId'];
    result$data['orderLineId'] = (l$orderLineId as String);
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    return Input$OrderRefundLineInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get orderLineId => (_$data['orderLineId'] as String);

  int get quantity => (_$data['quantity'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$orderLineId = orderLineId;
    result$data['orderLineId'] = l$orderLineId;
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    return result$data;
  }

  CopyWith$Input$OrderRefundLineInput<Input$OrderRefundLineInput>
      get copyWith => CopyWith$Input$OrderRefundLineInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderRefundLineInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$orderLineId = orderLineId;
    final lOther$orderLineId = other.orderLineId;
    if (l$orderLineId != lOther$orderLineId) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$orderLineId = orderLineId;
    final l$quantity = quantity;
    return Object.hashAll([
      l$orderLineId,
      l$quantity,
    ]);
  }
}

abstract class CopyWith$Input$OrderRefundLineInput<TRes> {
  factory CopyWith$Input$OrderRefundLineInput(
    Input$OrderRefundLineInput instance,
    TRes Function(Input$OrderRefundLineInput) then,
  ) = _CopyWithImpl$Input$OrderRefundLineInput;

  factory CopyWith$Input$OrderRefundLineInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderRefundLineInput;

  TRes call({
    String? orderLineId,
    int? quantity,
  });
}

class _CopyWithImpl$Input$OrderRefundLineInput<TRes>
    implements CopyWith$Input$OrderRefundLineInput<TRes> {
  _CopyWithImpl$Input$OrderRefundLineInput(
    this._instance,
    this._then,
  );

  final Input$OrderRefundLineInput _instance;

  final TRes Function(Input$OrderRefundLineInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? orderLineId = _undefined,
    Object? quantity = _undefined,
  }) =>
      _then(Input$OrderRefundLineInput._({
        ..._instance._$data,
        if (orderLineId != _undefined && orderLineId != null)
          'orderLineId': (orderLineId as String),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
      }));
}

class _CopyWithStubImpl$Input$OrderRefundLineInput<TRes>
    implements CopyWith$Input$OrderRefundLineInput<TRes> {
  _CopyWithStubImpl$Input$OrderRefundLineInput(this._res);

  TRes _res;

  call({
    String? orderLineId,
    int? quantity,
  }) =>
      _res;
}

class Input$OrderRefundProductsInput {
  factory Input$OrderRefundProductsInput({
    List<Input$OrderRefundLineInput>? orderLines,
    List<Input$OrderRefundFulfillmentLineInput>? fulfillmentLines,
    String? amountToRefund,
    bool? includeShippingCosts,
  }) =>
      Input$OrderRefundProductsInput._({
        if (orderLines != null) r'orderLines': orderLines,
        if (fulfillmentLines != null) r'fulfillmentLines': fulfillmentLines,
        if (amountToRefund != null) r'amountToRefund': amountToRefund,
        if (includeShippingCosts != null)
          r'includeShippingCosts': includeShippingCosts,
      });

  Input$OrderRefundProductsInput._(this._$data);

  factory Input$OrderRefundProductsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('orderLines')) {
      final l$orderLines = data['orderLines'];
      result$data['orderLines'] = (l$orderLines as List<dynamic>?)
          ?.map((e) =>
              Input$OrderRefundLineInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('fulfillmentLines')) {
      final l$fulfillmentLines = data['fulfillmentLines'];
      result$data['fulfillmentLines'] = (l$fulfillmentLines as List<dynamic>?)
          ?.map((e) => Input$OrderRefundFulfillmentLineInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('amountToRefund')) {
      final l$amountToRefund = data['amountToRefund'];
      result$data['amountToRefund'] = (l$amountToRefund as String?);
    }
    if (data.containsKey('includeShippingCosts')) {
      final l$includeShippingCosts = data['includeShippingCosts'];
      result$data['includeShippingCosts'] = (l$includeShippingCosts as bool?);
    }
    return Input$OrderRefundProductsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$OrderRefundLineInput>? get orderLines =>
      (_$data['orderLines'] as List<Input$OrderRefundLineInput>?);

  List<Input$OrderRefundFulfillmentLineInput>? get fulfillmentLines =>
      (_$data['fulfillmentLines']
          as List<Input$OrderRefundFulfillmentLineInput>?);

  String? get amountToRefund => (_$data['amountToRefund'] as String?);

  bool? get includeShippingCosts => (_$data['includeShippingCosts'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('orderLines')) {
      final l$orderLines = orderLines;
      result$data['orderLines'] = l$orderLines?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('fulfillmentLines')) {
      final l$fulfillmentLines = fulfillmentLines;
      result$data['fulfillmentLines'] =
          l$fulfillmentLines?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('amountToRefund')) {
      final l$amountToRefund = amountToRefund;
      result$data['amountToRefund'] = l$amountToRefund;
    }
    if (_$data.containsKey('includeShippingCosts')) {
      final l$includeShippingCosts = includeShippingCosts;
      result$data['includeShippingCosts'] = l$includeShippingCosts;
    }
    return result$data;
  }

  CopyWith$Input$OrderRefundProductsInput<Input$OrderRefundProductsInput>
      get copyWith => CopyWith$Input$OrderRefundProductsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderRefundProductsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$orderLines = orderLines;
    final lOther$orderLines = other.orderLines;
    if (_$data.containsKey('orderLines') !=
        other._$data.containsKey('orderLines')) {
      return false;
    }
    if (l$orderLines != null && lOther$orderLines != null) {
      if (l$orderLines.length != lOther$orderLines.length) {
        return false;
      }
      for (int i = 0; i < l$orderLines.length; i++) {
        final l$orderLines$entry = l$orderLines[i];
        final lOther$orderLines$entry = lOther$orderLines[i];
        if (l$orderLines$entry != lOther$orderLines$entry) {
          return false;
        }
      }
    } else if (l$orderLines != lOther$orderLines) {
      return false;
    }
    final l$fulfillmentLines = fulfillmentLines;
    final lOther$fulfillmentLines = other.fulfillmentLines;
    if (_$data.containsKey('fulfillmentLines') !=
        other._$data.containsKey('fulfillmentLines')) {
      return false;
    }
    if (l$fulfillmentLines != null && lOther$fulfillmentLines != null) {
      if (l$fulfillmentLines.length != lOther$fulfillmentLines.length) {
        return false;
      }
      for (int i = 0; i < l$fulfillmentLines.length; i++) {
        final l$fulfillmentLines$entry = l$fulfillmentLines[i];
        final lOther$fulfillmentLines$entry = lOther$fulfillmentLines[i];
        if (l$fulfillmentLines$entry != lOther$fulfillmentLines$entry) {
          return false;
        }
      }
    } else if (l$fulfillmentLines != lOther$fulfillmentLines) {
      return false;
    }
    final l$amountToRefund = amountToRefund;
    final lOther$amountToRefund = other.amountToRefund;
    if (_$data.containsKey('amountToRefund') !=
        other._$data.containsKey('amountToRefund')) {
      return false;
    }
    if (l$amountToRefund != lOther$amountToRefund) {
      return false;
    }
    final l$includeShippingCosts = includeShippingCosts;
    final lOther$includeShippingCosts = other.includeShippingCosts;
    if (_$data.containsKey('includeShippingCosts') !=
        other._$data.containsKey('includeShippingCosts')) {
      return false;
    }
    if (l$includeShippingCosts != lOther$includeShippingCosts) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$orderLines = orderLines;
    final l$fulfillmentLines = fulfillmentLines;
    final l$amountToRefund = amountToRefund;
    final l$includeShippingCosts = includeShippingCosts;
    return Object.hashAll([
      _$data.containsKey('orderLines')
          ? l$orderLines == null
              ? null
              : Object.hashAll(l$orderLines.map((v) => v))
          : const {},
      _$data.containsKey('fulfillmentLines')
          ? l$fulfillmentLines == null
              ? null
              : Object.hashAll(l$fulfillmentLines.map((v) => v))
          : const {},
      _$data.containsKey('amountToRefund') ? l$amountToRefund : const {},
      _$data.containsKey('includeShippingCosts')
          ? l$includeShippingCosts
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderRefundProductsInput<TRes> {
  factory CopyWith$Input$OrderRefundProductsInput(
    Input$OrderRefundProductsInput instance,
    TRes Function(Input$OrderRefundProductsInput) then,
  ) = _CopyWithImpl$Input$OrderRefundProductsInput;

  factory CopyWith$Input$OrderRefundProductsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderRefundProductsInput;

  TRes call({
    List<Input$OrderRefundLineInput>? orderLines,
    List<Input$OrderRefundFulfillmentLineInput>? fulfillmentLines,
    String? amountToRefund,
    bool? includeShippingCosts,
  });
  TRes orderLines(
      Iterable<Input$OrderRefundLineInput>? Function(
              Iterable<
                  CopyWith$Input$OrderRefundLineInput<
                      Input$OrderRefundLineInput>>?)
          _fn);
  TRes fulfillmentLines(
      Iterable<Input$OrderRefundFulfillmentLineInput>? Function(
              Iterable<
                  CopyWith$Input$OrderRefundFulfillmentLineInput<
                      Input$OrderRefundFulfillmentLineInput>>?)
          _fn);
}

class _CopyWithImpl$Input$OrderRefundProductsInput<TRes>
    implements CopyWith$Input$OrderRefundProductsInput<TRes> {
  _CopyWithImpl$Input$OrderRefundProductsInput(
    this._instance,
    this._then,
  );

  final Input$OrderRefundProductsInput _instance;

  final TRes Function(Input$OrderRefundProductsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? orderLines = _undefined,
    Object? fulfillmentLines = _undefined,
    Object? amountToRefund = _undefined,
    Object? includeShippingCosts = _undefined,
  }) =>
      _then(Input$OrderRefundProductsInput._({
        ..._instance._$data,
        if (orderLines != _undefined)
          'orderLines': (orderLines as List<Input$OrderRefundLineInput>?),
        if (fulfillmentLines != _undefined)
          'fulfillmentLines': (fulfillmentLines
              as List<Input$OrderRefundFulfillmentLineInput>?),
        if (amountToRefund != _undefined)
          'amountToRefund': (amountToRefund as String?),
        if (includeShippingCosts != _undefined)
          'includeShippingCosts': (includeShippingCosts as bool?),
      }));

  TRes orderLines(
          Iterable<Input$OrderRefundLineInput>? Function(
                  Iterable<
                      CopyWith$Input$OrderRefundLineInput<
                          Input$OrderRefundLineInput>>?)
              _fn) =>
      call(
          orderLines: _fn(_instance.orderLines
              ?.map((e) => CopyWith$Input$OrderRefundLineInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes fulfillmentLines(
          Iterable<Input$OrderRefundFulfillmentLineInput>? Function(
                  Iterable<
                      CopyWith$Input$OrderRefundFulfillmentLineInput<
                          Input$OrderRefundFulfillmentLineInput>>?)
              _fn) =>
      call(
          fulfillmentLines: _fn(_instance.fulfillmentLines
              ?.map((e) => CopyWith$Input$OrderRefundFulfillmentLineInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$OrderRefundProductsInput<TRes>
    implements CopyWith$Input$OrderRefundProductsInput<TRes> {
  _CopyWithStubImpl$Input$OrderRefundProductsInput(this._res);

  TRes _res;

  call({
    List<Input$OrderRefundLineInput>? orderLines,
    List<Input$OrderRefundFulfillmentLineInput>? fulfillmentLines,
    String? amountToRefund,
    bool? includeShippingCosts,
  }) =>
      _res;

  orderLines(_fn) => _res;

  fulfillmentLines(_fn) => _res;
}

class Input$OrderReturnFulfillmentLineInput {
  factory Input$OrderReturnFulfillmentLineInput({
    required String fulfillmentLineId,
    required int quantity,
    bool? replace,
  }) =>
      Input$OrderReturnFulfillmentLineInput._({
        r'fulfillmentLineId': fulfillmentLineId,
        r'quantity': quantity,
        if (replace != null) r'replace': replace,
      });

  Input$OrderReturnFulfillmentLineInput._(this._$data);

  factory Input$OrderReturnFulfillmentLineInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$fulfillmentLineId = data['fulfillmentLineId'];
    result$data['fulfillmentLineId'] = (l$fulfillmentLineId as String);
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    if (data.containsKey('replace')) {
      final l$replace = data['replace'];
      result$data['replace'] = (l$replace as bool?);
    }
    return Input$OrderReturnFulfillmentLineInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get fulfillmentLineId => (_$data['fulfillmentLineId'] as String);

  int get quantity => (_$data['quantity'] as int);

  bool? get replace => (_$data['replace'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$fulfillmentLineId = fulfillmentLineId;
    result$data['fulfillmentLineId'] = l$fulfillmentLineId;
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    if (_$data.containsKey('replace')) {
      final l$replace = replace;
      result$data['replace'] = l$replace;
    }
    return result$data;
  }

  CopyWith$Input$OrderReturnFulfillmentLineInput<
          Input$OrderReturnFulfillmentLineInput>
      get copyWith => CopyWith$Input$OrderReturnFulfillmentLineInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderReturnFulfillmentLineInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$fulfillmentLineId = fulfillmentLineId;
    final lOther$fulfillmentLineId = other.fulfillmentLineId;
    if (l$fulfillmentLineId != lOther$fulfillmentLineId) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$replace = replace;
    final lOther$replace = other.replace;
    if (_$data.containsKey('replace') != other._$data.containsKey('replace')) {
      return false;
    }
    if (l$replace != lOther$replace) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$fulfillmentLineId = fulfillmentLineId;
    final l$quantity = quantity;
    final l$replace = replace;
    return Object.hashAll([
      l$fulfillmentLineId,
      l$quantity,
      _$data.containsKey('replace') ? l$replace : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderReturnFulfillmentLineInput<TRes> {
  factory CopyWith$Input$OrderReturnFulfillmentLineInput(
    Input$OrderReturnFulfillmentLineInput instance,
    TRes Function(Input$OrderReturnFulfillmentLineInput) then,
  ) = _CopyWithImpl$Input$OrderReturnFulfillmentLineInput;

  factory CopyWith$Input$OrderReturnFulfillmentLineInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderReturnFulfillmentLineInput;

  TRes call({
    String? fulfillmentLineId,
    int? quantity,
    bool? replace,
  });
}

class _CopyWithImpl$Input$OrderReturnFulfillmentLineInput<TRes>
    implements CopyWith$Input$OrderReturnFulfillmentLineInput<TRes> {
  _CopyWithImpl$Input$OrderReturnFulfillmentLineInput(
    this._instance,
    this._then,
  );

  final Input$OrderReturnFulfillmentLineInput _instance;

  final TRes Function(Input$OrderReturnFulfillmentLineInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? fulfillmentLineId = _undefined,
    Object? quantity = _undefined,
    Object? replace = _undefined,
  }) =>
      _then(Input$OrderReturnFulfillmentLineInput._({
        ..._instance._$data,
        if (fulfillmentLineId != _undefined && fulfillmentLineId != null)
          'fulfillmentLineId': (fulfillmentLineId as String),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (replace != _undefined) 'replace': (replace as bool?),
      }));
}

class _CopyWithStubImpl$Input$OrderReturnFulfillmentLineInput<TRes>
    implements CopyWith$Input$OrderReturnFulfillmentLineInput<TRes> {
  _CopyWithStubImpl$Input$OrderReturnFulfillmentLineInput(this._res);

  TRes _res;

  call({
    String? fulfillmentLineId,
    int? quantity,
    bool? replace,
  }) =>
      _res;
}

class Input$OrderReturnLineInput {
  factory Input$OrderReturnLineInput({
    required String orderLineId,
    required int quantity,
    bool? replace,
  }) =>
      Input$OrderReturnLineInput._({
        r'orderLineId': orderLineId,
        r'quantity': quantity,
        if (replace != null) r'replace': replace,
      });

  Input$OrderReturnLineInput._(this._$data);

  factory Input$OrderReturnLineInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$orderLineId = data['orderLineId'];
    result$data['orderLineId'] = (l$orderLineId as String);
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    if (data.containsKey('replace')) {
      final l$replace = data['replace'];
      result$data['replace'] = (l$replace as bool?);
    }
    return Input$OrderReturnLineInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get orderLineId => (_$data['orderLineId'] as String);

  int get quantity => (_$data['quantity'] as int);

  bool? get replace => (_$data['replace'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$orderLineId = orderLineId;
    result$data['orderLineId'] = l$orderLineId;
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    if (_$data.containsKey('replace')) {
      final l$replace = replace;
      result$data['replace'] = l$replace;
    }
    return result$data;
  }

  CopyWith$Input$OrderReturnLineInput<Input$OrderReturnLineInput>
      get copyWith => CopyWith$Input$OrderReturnLineInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderReturnLineInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$orderLineId = orderLineId;
    final lOther$orderLineId = other.orderLineId;
    if (l$orderLineId != lOther$orderLineId) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$replace = replace;
    final lOther$replace = other.replace;
    if (_$data.containsKey('replace') != other._$data.containsKey('replace')) {
      return false;
    }
    if (l$replace != lOther$replace) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$orderLineId = orderLineId;
    final l$quantity = quantity;
    final l$replace = replace;
    return Object.hashAll([
      l$orderLineId,
      l$quantity,
      _$data.containsKey('replace') ? l$replace : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderReturnLineInput<TRes> {
  factory CopyWith$Input$OrderReturnLineInput(
    Input$OrderReturnLineInput instance,
    TRes Function(Input$OrderReturnLineInput) then,
  ) = _CopyWithImpl$Input$OrderReturnLineInput;

  factory CopyWith$Input$OrderReturnLineInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderReturnLineInput;

  TRes call({
    String? orderLineId,
    int? quantity,
    bool? replace,
  });
}

class _CopyWithImpl$Input$OrderReturnLineInput<TRes>
    implements CopyWith$Input$OrderReturnLineInput<TRes> {
  _CopyWithImpl$Input$OrderReturnLineInput(
    this._instance,
    this._then,
  );

  final Input$OrderReturnLineInput _instance;

  final TRes Function(Input$OrderReturnLineInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? orderLineId = _undefined,
    Object? quantity = _undefined,
    Object? replace = _undefined,
  }) =>
      _then(Input$OrderReturnLineInput._({
        ..._instance._$data,
        if (orderLineId != _undefined && orderLineId != null)
          'orderLineId': (orderLineId as String),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (replace != _undefined) 'replace': (replace as bool?),
      }));
}

class _CopyWithStubImpl$Input$OrderReturnLineInput<TRes>
    implements CopyWith$Input$OrderReturnLineInput<TRes> {
  _CopyWithStubImpl$Input$OrderReturnLineInput(this._res);

  TRes _res;

  call({
    String? orderLineId,
    int? quantity,
    bool? replace,
  }) =>
      _res;
}

class Input$OrderReturnProductsInput {
  factory Input$OrderReturnProductsInput({
    List<Input$OrderReturnLineInput>? orderLines,
    List<Input$OrderReturnFulfillmentLineInput>? fulfillmentLines,
    String? amountToRefund,
    bool? includeShippingCosts,
    bool? refund,
  }) =>
      Input$OrderReturnProductsInput._({
        if (orderLines != null) r'orderLines': orderLines,
        if (fulfillmentLines != null) r'fulfillmentLines': fulfillmentLines,
        if (amountToRefund != null) r'amountToRefund': amountToRefund,
        if (includeShippingCosts != null)
          r'includeShippingCosts': includeShippingCosts,
        if (refund != null) r'refund': refund,
      });

  Input$OrderReturnProductsInput._(this._$data);

  factory Input$OrderReturnProductsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('orderLines')) {
      final l$orderLines = data['orderLines'];
      result$data['orderLines'] = (l$orderLines as List<dynamic>?)
          ?.map((e) =>
              Input$OrderReturnLineInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('fulfillmentLines')) {
      final l$fulfillmentLines = data['fulfillmentLines'];
      result$data['fulfillmentLines'] = (l$fulfillmentLines as List<dynamic>?)
          ?.map((e) => Input$OrderReturnFulfillmentLineInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('amountToRefund')) {
      final l$amountToRefund = data['amountToRefund'];
      result$data['amountToRefund'] = (l$amountToRefund as String?);
    }
    if (data.containsKey('includeShippingCosts')) {
      final l$includeShippingCosts = data['includeShippingCosts'];
      result$data['includeShippingCosts'] = (l$includeShippingCosts as bool?);
    }
    if (data.containsKey('refund')) {
      final l$refund = data['refund'];
      result$data['refund'] = (l$refund as bool?);
    }
    return Input$OrderReturnProductsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$OrderReturnLineInput>? get orderLines =>
      (_$data['orderLines'] as List<Input$OrderReturnLineInput>?);

  List<Input$OrderReturnFulfillmentLineInput>? get fulfillmentLines =>
      (_$data['fulfillmentLines']
          as List<Input$OrderReturnFulfillmentLineInput>?);

  String? get amountToRefund => (_$data['amountToRefund'] as String?);

  bool? get includeShippingCosts => (_$data['includeShippingCosts'] as bool?);

  bool? get refund => (_$data['refund'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('orderLines')) {
      final l$orderLines = orderLines;
      result$data['orderLines'] = l$orderLines?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('fulfillmentLines')) {
      final l$fulfillmentLines = fulfillmentLines;
      result$data['fulfillmentLines'] =
          l$fulfillmentLines?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('amountToRefund')) {
      final l$amountToRefund = amountToRefund;
      result$data['amountToRefund'] = l$amountToRefund;
    }
    if (_$data.containsKey('includeShippingCosts')) {
      final l$includeShippingCosts = includeShippingCosts;
      result$data['includeShippingCosts'] = l$includeShippingCosts;
    }
    if (_$data.containsKey('refund')) {
      final l$refund = refund;
      result$data['refund'] = l$refund;
    }
    return result$data;
  }

  CopyWith$Input$OrderReturnProductsInput<Input$OrderReturnProductsInput>
      get copyWith => CopyWith$Input$OrderReturnProductsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderReturnProductsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$orderLines = orderLines;
    final lOther$orderLines = other.orderLines;
    if (_$data.containsKey('orderLines') !=
        other._$data.containsKey('orderLines')) {
      return false;
    }
    if (l$orderLines != null && lOther$orderLines != null) {
      if (l$orderLines.length != lOther$orderLines.length) {
        return false;
      }
      for (int i = 0; i < l$orderLines.length; i++) {
        final l$orderLines$entry = l$orderLines[i];
        final lOther$orderLines$entry = lOther$orderLines[i];
        if (l$orderLines$entry != lOther$orderLines$entry) {
          return false;
        }
      }
    } else if (l$orderLines != lOther$orderLines) {
      return false;
    }
    final l$fulfillmentLines = fulfillmentLines;
    final lOther$fulfillmentLines = other.fulfillmentLines;
    if (_$data.containsKey('fulfillmentLines') !=
        other._$data.containsKey('fulfillmentLines')) {
      return false;
    }
    if (l$fulfillmentLines != null && lOther$fulfillmentLines != null) {
      if (l$fulfillmentLines.length != lOther$fulfillmentLines.length) {
        return false;
      }
      for (int i = 0; i < l$fulfillmentLines.length; i++) {
        final l$fulfillmentLines$entry = l$fulfillmentLines[i];
        final lOther$fulfillmentLines$entry = lOther$fulfillmentLines[i];
        if (l$fulfillmentLines$entry != lOther$fulfillmentLines$entry) {
          return false;
        }
      }
    } else if (l$fulfillmentLines != lOther$fulfillmentLines) {
      return false;
    }
    final l$amountToRefund = amountToRefund;
    final lOther$amountToRefund = other.amountToRefund;
    if (_$data.containsKey('amountToRefund') !=
        other._$data.containsKey('amountToRefund')) {
      return false;
    }
    if (l$amountToRefund != lOther$amountToRefund) {
      return false;
    }
    final l$includeShippingCosts = includeShippingCosts;
    final lOther$includeShippingCosts = other.includeShippingCosts;
    if (_$data.containsKey('includeShippingCosts') !=
        other._$data.containsKey('includeShippingCosts')) {
      return false;
    }
    if (l$includeShippingCosts != lOther$includeShippingCosts) {
      return false;
    }
    final l$refund = refund;
    final lOther$refund = other.refund;
    if (_$data.containsKey('refund') != other._$data.containsKey('refund')) {
      return false;
    }
    if (l$refund != lOther$refund) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$orderLines = orderLines;
    final l$fulfillmentLines = fulfillmentLines;
    final l$amountToRefund = amountToRefund;
    final l$includeShippingCosts = includeShippingCosts;
    final l$refund = refund;
    return Object.hashAll([
      _$data.containsKey('orderLines')
          ? l$orderLines == null
              ? null
              : Object.hashAll(l$orderLines.map((v) => v))
          : const {},
      _$data.containsKey('fulfillmentLines')
          ? l$fulfillmentLines == null
              ? null
              : Object.hashAll(l$fulfillmentLines.map((v) => v))
          : const {},
      _$data.containsKey('amountToRefund') ? l$amountToRefund : const {},
      _$data.containsKey('includeShippingCosts')
          ? l$includeShippingCosts
          : const {},
      _$data.containsKey('refund') ? l$refund : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderReturnProductsInput<TRes> {
  factory CopyWith$Input$OrderReturnProductsInput(
    Input$OrderReturnProductsInput instance,
    TRes Function(Input$OrderReturnProductsInput) then,
  ) = _CopyWithImpl$Input$OrderReturnProductsInput;

  factory CopyWith$Input$OrderReturnProductsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderReturnProductsInput;

  TRes call({
    List<Input$OrderReturnLineInput>? orderLines,
    List<Input$OrderReturnFulfillmentLineInput>? fulfillmentLines,
    String? amountToRefund,
    bool? includeShippingCosts,
    bool? refund,
  });
  TRes orderLines(
      Iterable<Input$OrderReturnLineInput>? Function(
              Iterable<
                  CopyWith$Input$OrderReturnLineInput<
                      Input$OrderReturnLineInput>>?)
          _fn);
  TRes fulfillmentLines(
      Iterable<Input$OrderReturnFulfillmentLineInput>? Function(
              Iterable<
                  CopyWith$Input$OrderReturnFulfillmentLineInput<
                      Input$OrderReturnFulfillmentLineInput>>?)
          _fn);
}

class _CopyWithImpl$Input$OrderReturnProductsInput<TRes>
    implements CopyWith$Input$OrderReturnProductsInput<TRes> {
  _CopyWithImpl$Input$OrderReturnProductsInput(
    this._instance,
    this._then,
  );

  final Input$OrderReturnProductsInput _instance;

  final TRes Function(Input$OrderReturnProductsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? orderLines = _undefined,
    Object? fulfillmentLines = _undefined,
    Object? amountToRefund = _undefined,
    Object? includeShippingCosts = _undefined,
    Object? refund = _undefined,
  }) =>
      _then(Input$OrderReturnProductsInput._({
        ..._instance._$data,
        if (orderLines != _undefined)
          'orderLines': (orderLines as List<Input$OrderReturnLineInput>?),
        if (fulfillmentLines != _undefined)
          'fulfillmentLines': (fulfillmentLines
              as List<Input$OrderReturnFulfillmentLineInput>?),
        if (amountToRefund != _undefined)
          'amountToRefund': (amountToRefund as String?),
        if (includeShippingCosts != _undefined)
          'includeShippingCosts': (includeShippingCosts as bool?),
        if (refund != _undefined) 'refund': (refund as bool?),
      }));

  TRes orderLines(
          Iterable<Input$OrderReturnLineInput>? Function(
                  Iterable<
                      CopyWith$Input$OrderReturnLineInput<
                          Input$OrderReturnLineInput>>?)
              _fn) =>
      call(
          orderLines: _fn(_instance.orderLines
              ?.map((e) => CopyWith$Input$OrderReturnLineInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes fulfillmentLines(
          Iterable<Input$OrderReturnFulfillmentLineInput>? Function(
                  Iterable<
                      CopyWith$Input$OrderReturnFulfillmentLineInput<
                          Input$OrderReturnFulfillmentLineInput>>?)
              _fn) =>
      call(
          fulfillmentLines: _fn(_instance.fulfillmentLines
              ?.map((e) => CopyWith$Input$OrderReturnFulfillmentLineInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$OrderReturnProductsInput<TRes>
    implements CopyWith$Input$OrderReturnProductsInput<TRes> {
  _CopyWithStubImpl$Input$OrderReturnProductsInput(this._res);

  TRes _res;

  call({
    List<Input$OrderReturnLineInput>? orderLines,
    List<Input$OrderReturnFulfillmentLineInput>? fulfillmentLines,
    String? amountToRefund,
    bool? includeShippingCosts,
    bool? refund,
  }) =>
      _res;

  orderLines(_fn) => _res;

  fulfillmentLines(_fn) => _res;
}

class Input$OrderSettingsInput {
  factory Input$OrderSettingsInput({
    bool? automaticallyConfirmAllNewOrders,
    bool? automaticallyFulfillNonShippableGiftCard,
    String? expireOrdersAfter,
    String? deleteExpiredOrdersAfter,
    Enum$MarkAsPaidStrategyEnum? markAsPaidStrategy,
    bool? allowUnpaidOrders,
    bool? includeDraftOrderInVoucherUsage,
    String? draftOrderLinePriceFreezePeriod,
    bool? useLegacyLineDiscountPropagation,
  }) =>
      Input$OrderSettingsInput._({
        if (automaticallyConfirmAllNewOrders != null)
          r'automaticallyConfirmAllNewOrders': automaticallyConfirmAllNewOrders,
        if (automaticallyFulfillNonShippableGiftCard != null)
          r'automaticallyFulfillNonShippableGiftCard':
              automaticallyFulfillNonShippableGiftCard,
        if (expireOrdersAfter != null) r'expireOrdersAfter': expireOrdersAfter,
        if (deleteExpiredOrdersAfter != null)
          r'deleteExpiredOrdersAfter': deleteExpiredOrdersAfter,
        if (markAsPaidStrategy != null)
          r'markAsPaidStrategy': markAsPaidStrategy,
        if (allowUnpaidOrders != null) r'allowUnpaidOrders': allowUnpaidOrders,
        if (includeDraftOrderInVoucherUsage != null)
          r'includeDraftOrderInVoucherUsage': includeDraftOrderInVoucherUsage,
        if (draftOrderLinePriceFreezePeriod != null)
          r'draftOrderLinePriceFreezePeriod': draftOrderLinePriceFreezePeriod,
        if (useLegacyLineDiscountPropagation != null)
          r'useLegacyLineDiscountPropagation': useLegacyLineDiscountPropagation,
      });

  Input$OrderSettingsInput._(this._$data);

  factory Input$OrderSettingsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('automaticallyConfirmAllNewOrders')) {
      final l$automaticallyConfirmAllNewOrders =
          data['automaticallyConfirmAllNewOrders'];
      result$data['automaticallyConfirmAllNewOrders'] =
          (l$automaticallyConfirmAllNewOrders as bool?);
    }
    if (data.containsKey('automaticallyFulfillNonShippableGiftCard')) {
      final l$automaticallyFulfillNonShippableGiftCard =
          data['automaticallyFulfillNonShippableGiftCard'];
      result$data['automaticallyFulfillNonShippableGiftCard'] =
          (l$automaticallyFulfillNonShippableGiftCard as bool?);
    }
    if (data.containsKey('expireOrdersAfter')) {
      final l$expireOrdersAfter = data['expireOrdersAfter'];
      result$data['expireOrdersAfter'] = (l$expireOrdersAfter as String?);
    }
    if (data.containsKey('deleteExpiredOrdersAfter')) {
      final l$deleteExpiredOrdersAfter = data['deleteExpiredOrdersAfter'];
      result$data['deleteExpiredOrdersAfter'] =
          (l$deleteExpiredOrdersAfter as String?);
    }
    if (data.containsKey('markAsPaidStrategy')) {
      final l$markAsPaidStrategy = data['markAsPaidStrategy'];
      result$data['markAsPaidStrategy'] = l$markAsPaidStrategy == null
          ? null
          : fromJson$Enum$MarkAsPaidStrategyEnum(
              (l$markAsPaidStrategy as String));
    }
    if (data.containsKey('allowUnpaidOrders')) {
      final l$allowUnpaidOrders = data['allowUnpaidOrders'];
      result$data['allowUnpaidOrders'] = (l$allowUnpaidOrders as bool?);
    }
    if (data.containsKey('includeDraftOrderInVoucherUsage')) {
      final l$includeDraftOrderInVoucherUsage =
          data['includeDraftOrderInVoucherUsage'];
      result$data['includeDraftOrderInVoucherUsage'] =
          (l$includeDraftOrderInVoucherUsage as bool?);
    }
    if (data.containsKey('draftOrderLinePriceFreezePeriod')) {
      final l$draftOrderLinePriceFreezePeriod =
          data['draftOrderLinePriceFreezePeriod'];
      result$data['draftOrderLinePriceFreezePeriod'] =
          (l$draftOrderLinePriceFreezePeriod as String?);
    }
    if (data.containsKey('useLegacyLineDiscountPropagation')) {
      final l$useLegacyLineDiscountPropagation =
          data['useLegacyLineDiscountPropagation'];
      result$data['useLegacyLineDiscountPropagation'] =
          (l$useLegacyLineDiscountPropagation as bool?);
    }
    return Input$OrderSettingsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get automaticallyConfirmAllNewOrders =>
      (_$data['automaticallyConfirmAllNewOrders'] as bool?);

  bool? get automaticallyFulfillNonShippableGiftCard =>
      (_$data['automaticallyFulfillNonShippableGiftCard'] as bool?);

  String? get expireOrdersAfter => (_$data['expireOrdersAfter'] as String?);

  String? get deleteExpiredOrdersAfter =>
      (_$data['deleteExpiredOrdersAfter'] as String?);

  Enum$MarkAsPaidStrategyEnum? get markAsPaidStrategy =>
      (_$data['markAsPaidStrategy'] as Enum$MarkAsPaidStrategyEnum?);

  bool? get allowUnpaidOrders => (_$data['allowUnpaidOrders'] as bool?);

  bool? get includeDraftOrderInVoucherUsage =>
      (_$data['includeDraftOrderInVoucherUsage'] as bool?);

  String? get draftOrderLinePriceFreezePeriod =>
      (_$data['draftOrderLinePriceFreezePeriod'] as String?);

  bool? get useLegacyLineDiscountPropagation =>
      (_$data['useLegacyLineDiscountPropagation'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('automaticallyConfirmAllNewOrders')) {
      final l$automaticallyConfirmAllNewOrders =
          automaticallyConfirmAllNewOrders;
      result$data['automaticallyConfirmAllNewOrders'] =
          l$automaticallyConfirmAllNewOrders;
    }
    if (_$data.containsKey('automaticallyFulfillNonShippableGiftCard')) {
      final l$automaticallyFulfillNonShippableGiftCard =
          automaticallyFulfillNonShippableGiftCard;
      result$data['automaticallyFulfillNonShippableGiftCard'] =
          l$automaticallyFulfillNonShippableGiftCard;
    }
    if (_$data.containsKey('expireOrdersAfter')) {
      final l$expireOrdersAfter = expireOrdersAfter;
      result$data['expireOrdersAfter'] = l$expireOrdersAfter;
    }
    if (_$data.containsKey('deleteExpiredOrdersAfter')) {
      final l$deleteExpiredOrdersAfter = deleteExpiredOrdersAfter;
      result$data['deleteExpiredOrdersAfter'] = l$deleteExpiredOrdersAfter;
    }
    if (_$data.containsKey('markAsPaidStrategy')) {
      final l$markAsPaidStrategy = markAsPaidStrategy;
      result$data['markAsPaidStrategy'] = l$markAsPaidStrategy == null
          ? null
          : toJson$Enum$MarkAsPaidStrategyEnum(l$markAsPaidStrategy);
    }
    if (_$data.containsKey('allowUnpaidOrders')) {
      final l$allowUnpaidOrders = allowUnpaidOrders;
      result$data['allowUnpaidOrders'] = l$allowUnpaidOrders;
    }
    if (_$data.containsKey('includeDraftOrderInVoucherUsage')) {
      final l$includeDraftOrderInVoucherUsage = includeDraftOrderInVoucherUsage;
      result$data['includeDraftOrderInVoucherUsage'] =
          l$includeDraftOrderInVoucherUsage;
    }
    if (_$data.containsKey('draftOrderLinePriceFreezePeriod')) {
      final l$draftOrderLinePriceFreezePeriod = draftOrderLinePriceFreezePeriod;
      result$data['draftOrderLinePriceFreezePeriod'] =
          l$draftOrderLinePriceFreezePeriod;
    }
    if (_$data.containsKey('useLegacyLineDiscountPropagation')) {
      final l$useLegacyLineDiscountPropagation =
          useLegacyLineDiscountPropagation;
      result$data['useLegacyLineDiscountPropagation'] =
          l$useLegacyLineDiscountPropagation;
    }
    return result$data;
  }

  CopyWith$Input$OrderSettingsInput<Input$OrderSettingsInput> get copyWith =>
      CopyWith$Input$OrderSettingsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderSettingsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$automaticallyConfirmAllNewOrders = automaticallyConfirmAllNewOrders;
    final lOther$automaticallyConfirmAllNewOrders =
        other.automaticallyConfirmAllNewOrders;
    if (_$data.containsKey('automaticallyConfirmAllNewOrders') !=
        other._$data.containsKey('automaticallyConfirmAllNewOrders')) {
      return false;
    }
    if (l$automaticallyConfirmAllNewOrders !=
        lOther$automaticallyConfirmAllNewOrders) {
      return false;
    }
    final l$automaticallyFulfillNonShippableGiftCard =
        automaticallyFulfillNonShippableGiftCard;
    final lOther$automaticallyFulfillNonShippableGiftCard =
        other.automaticallyFulfillNonShippableGiftCard;
    if (_$data.containsKey('automaticallyFulfillNonShippableGiftCard') !=
        other._$data.containsKey('automaticallyFulfillNonShippableGiftCard')) {
      return false;
    }
    if (l$automaticallyFulfillNonShippableGiftCard !=
        lOther$automaticallyFulfillNonShippableGiftCard) {
      return false;
    }
    final l$expireOrdersAfter = expireOrdersAfter;
    final lOther$expireOrdersAfter = other.expireOrdersAfter;
    if (_$data.containsKey('expireOrdersAfter') !=
        other._$data.containsKey('expireOrdersAfter')) {
      return false;
    }
    if (l$expireOrdersAfter != lOther$expireOrdersAfter) {
      return false;
    }
    final l$deleteExpiredOrdersAfter = deleteExpiredOrdersAfter;
    final lOther$deleteExpiredOrdersAfter = other.deleteExpiredOrdersAfter;
    if (_$data.containsKey('deleteExpiredOrdersAfter') !=
        other._$data.containsKey('deleteExpiredOrdersAfter')) {
      return false;
    }
    if (l$deleteExpiredOrdersAfter != lOther$deleteExpiredOrdersAfter) {
      return false;
    }
    final l$markAsPaidStrategy = markAsPaidStrategy;
    final lOther$markAsPaidStrategy = other.markAsPaidStrategy;
    if (_$data.containsKey('markAsPaidStrategy') !=
        other._$data.containsKey('markAsPaidStrategy')) {
      return false;
    }
    if (l$markAsPaidStrategy != lOther$markAsPaidStrategy) {
      return false;
    }
    final l$allowUnpaidOrders = allowUnpaidOrders;
    final lOther$allowUnpaidOrders = other.allowUnpaidOrders;
    if (_$data.containsKey('allowUnpaidOrders') !=
        other._$data.containsKey('allowUnpaidOrders')) {
      return false;
    }
    if (l$allowUnpaidOrders != lOther$allowUnpaidOrders) {
      return false;
    }
    final l$includeDraftOrderInVoucherUsage = includeDraftOrderInVoucherUsage;
    final lOther$includeDraftOrderInVoucherUsage =
        other.includeDraftOrderInVoucherUsage;
    if (_$data.containsKey('includeDraftOrderInVoucherUsage') !=
        other._$data.containsKey('includeDraftOrderInVoucherUsage')) {
      return false;
    }
    if (l$includeDraftOrderInVoucherUsage !=
        lOther$includeDraftOrderInVoucherUsage) {
      return false;
    }
    final l$draftOrderLinePriceFreezePeriod = draftOrderLinePriceFreezePeriod;
    final lOther$draftOrderLinePriceFreezePeriod =
        other.draftOrderLinePriceFreezePeriod;
    if (_$data.containsKey('draftOrderLinePriceFreezePeriod') !=
        other._$data.containsKey('draftOrderLinePriceFreezePeriod')) {
      return false;
    }
    if (l$draftOrderLinePriceFreezePeriod !=
        lOther$draftOrderLinePriceFreezePeriod) {
      return false;
    }
    final l$useLegacyLineDiscountPropagation = useLegacyLineDiscountPropagation;
    final lOther$useLegacyLineDiscountPropagation =
        other.useLegacyLineDiscountPropagation;
    if (_$data.containsKey('useLegacyLineDiscountPropagation') !=
        other._$data.containsKey('useLegacyLineDiscountPropagation')) {
      return false;
    }
    if (l$useLegacyLineDiscountPropagation !=
        lOther$useLegacyLineDiscountPropagation) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$automaticallyConfirmAllNewOrders = automaticallyConfirmAllNewOrders;
    final l$automaticallyFulfillNonShippableGiftCard =
        automaticallyFulfillNonShippableGiftCard;
    final l$expireOrdersAfter = expireOrdersAfter;
    final l$deleteExpiredOrdersAfter = deleteExpiredOrdersAfter;
    final l$markAsPaidStrategy = markAsPaidStrategy;
    final l$allowUnpaidOrders = allowUnpaidOrders;
    final l$includeDraftOrderInVoucherUsage = includeDraftOrderInVoucherUsage;
    final l$draftOrderLinePriceFreezePeriod = draftOrderLinePriceFreezePeriod;
    final l$useLegacyLineDiscountPropagation = useLegacyLineDiscountPropagation;
    return Object.hashAll([
      _$data.containsKey('automaticallyConfirmAllNewOrders')
          ? l$automaticallyConfirmAllNewOrders
          : const {},
      _$data.containsKey('automaticallyFulfillNonShippableGiftCard')
          ? l$automaticallyFulfillNonShippableGiftCard
          : const {},
      _$data.containsKey('expireOrdersAfter') ? l$expireOrdersAfter : const {},
      _$data.containsKey('deleteExpiredOrdersAfter')
          ? l$deleteExpiredOrdersAfter
          : const {},
      _$data.containsKey('markAsPaidStrategy')
          ? l$markAsPaidStrategy
          : const {},
      _$data.containsKey('allowUnpaidOrders') ? l$allowUnpaidOrders : const {},
      _$data.containsKey('includeDraftOrderInVoucherUsage')
          ? l$includeDraftOrderInVoucherUsage
          : const {},
      _$data.containsKey('draftOrderLinePriceFreezePeriod')
          ? l$draftOrderLinePriceFreezePeriod
          : const {},
      _$data.containsKey('useLegacyLineDiscountPropagation')
          ? l$useLegacyLineDiscountPropagation
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderSettingsInput<TRes> {
  factory CopyWith$Input$OrderSettingsInput(
    Input$OrderSettingsInput instance,
    TRes Function(Input$OrderSettingsInput) then,
  ) = _CopyWithImpl$Input$OrderSettingsInput;

  factory CopyWith$Input$OrderSettingsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderSettingsInput;

  TRes call({
    bool? automaticallyConfirmAllNewOrders,
    bool? automaticallyFulfillNonShippableGiftCard,
    String? expireOrdersAfter,
    String? deleteExpiredOrdersAfter,
    Enum$MarkAsPaidStrategyEnum? markAsPaidStrategy,
    bool? allowUnpaidOrders,
    bool? includeDraftOrderInVoucherUsage,
    String? draftOrderLinePriceFreezePeriod,
    bool? useLegacyLineDiscountPropagation,
  });
}

class _CopyWithImpl$Input$OrderSettingsInput<TRes>
    implements CopyWith$Input$OrderSettingsInput<TRes> {
  _CopyWithImpl$Input$OrderSettingsInput(
    this._instance,
    this._then,
  );

  final Input$OrderSettingsInput _instance;

  final TRes Function(Input$OrderSettingsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? automaticallyConfirmAllNewOrders = _undefined,
    Object? automaticallyFulfillNonShippableGiftCard = _undefined,
    Object? expireOrdersAfter = _undefined,
    Object? deleteExpiredOrdersAfter = _undefined,
    Object? markAsPaidStrategy = _undefined,
    Object? allowUnpaidOrders = _undefined,
    Object? includeDraftOrderInVoucherUsage = _undefined,
    Object? draftOrderLinePriceFreezePeriod = _undefined,
    Object? useLegacyLineDiscountPropagation = _undefined,
  }) =>
      _then(Input$OrderSettingsInput._({
        ..._instance._$data,
        if (automaticallyConfirmAllNewOrders != _undefined)
          'automaticallyConfirmAllNewOrders':
              (automaticallyConfirmAllNewOrders as bool?),
        if (automaticallyFulfillNonShippableGiftCard != _undefined)
          'automaticallyFulfillNonShippableGiftCard':
              (automaticallyFulfillNonShippableGiftCard as bool?),
        if (expireOrdersAfter != _undefined)
          'expireOrdersAfter': (expireOrdersAfter as String?),
        if (deleteExpiredOrdersAfter != _undefined)
          'deleteExpiredOrdersAfter': (deleteExpiredOrdersAfter as String?),
        if (markAsPaidStrategy != _undefined)
          'markAsPaidStrategy':
              (markAsPaidStrategy as Enum$MarkAsPaidStrategyEnum?),
        if (allowUnpaidOrders != _undefined)
          'allowUnpaidOrders': (allowUnpaidOrders as bool?),
        if (includeDraftOrderInVoucherUsage != _undefined)
          'includeDraftOrderInVoucherUsage':
              (includeDraftOrderInVoucherUsage as bool?),
        if (draftOrderLinePriceFreezePeriod != _undefined)
          'draftOrderLinePriceFreezePeriod':
              (draftOrderLinePriceFreezePeriod as String?),
        if (useLegacyLineDiscountPropagation != _undefined)
          'useLegacyLineDiscountPropagation':
              (useLegacyLineDiscountPropagation as bool?),
      }));
}

class _CopyWithStubImpl$Input$OrderSettingsInput<TRes>
    implements CopyWith$Input$OrderSettingsInput<TRes> {
  _CopyWithStubImpl$Input$OrderSettingsInput(this._res);

  TRes _res;

  call({
    bool? automaticallyConfirmAllNewOrders,
    bool? automaticallyFulfillNonShippableGiftCard,
    String? expireOrdersAfter,
    String? deleteExpiredOrdersAfter,
    Enum$MarkAsPaidStrategyEnum? markAsPaidStrategy,
    bool? allowUnpaidOrders,
    bool? includeDraftOrderInVoucherUsage,
    String? draftOrderLinePriceFreezePeriod,
    bool? useLegacyLineDiscountPropagation,
  }) =>
      _res;
}

class Input$OrderSettingsUpdateInput {
  factory Input$OrderSettingsUpdateInput({
    bool? automaticallyConfirmAllNewOrders,
    bool? automaticallyFulfillNonShippableGiftCard,
  }) =>
      Input$OrderSettingsUpdateInput._({
        if (automaticallyConfirmAllNewOrders != null)
          r'automaticallyConfirmAllNewOrders': automaticallyConfirmAllNewOrders,
        if (automaticallyFulfillNonShippableGiftCard != null)
          r'automaticallyFulfillNonShippableGiftCard':
              automaticallyFulfillNonShippableGiftCard,
      });

  Input$OrderSettingsUpdateInput._(this._$data);

  factory Input$OrderSettingsUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('automaticallyConfirmAllNewOrders')) {
      final l$automaticallyConfirmAllNewOrders =
          data['automaticallyConfirmAllNewOrders'];
      result$data['automaticallyConfirmAllNewOrders'] =
          (l$automaticallyConfirmAllNewOrders as bool?);
    }
    if (data.containsKey('automaticallyFulfillNonShippableGiftCard')) {
      final l$automaticallyFulfillNonShippableGiftCard =
          data['automaticallyFulfillNonShippableGiftCard'];
      result$data['automaticallyFulfillNonShippableGiftCard'] =
          (l$automaticallyFulfillNonShippableGiftCard as bool?);
    }
    return Input$OrderSettingsUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get automaticallyConfirmAllNewOrders =>
      (_$data['automaticallyConfirmAllNewOrders'] as bool?);

  bool? get automaticallyFulfillNonShippableGiftCard =>
      (_$data['automaticallyFulfillNonShippableGiftCard'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('automaticallyConfirmAllNewOrders')) {
      final l$automaticallyConfirmAllNewOrders =
          automaticallyConfirmAllNewOrders;
      result$data['automaticallyConfirmAllNewOrders'] =
          l$automaticallyConfirmAllNewOrders;
    }
    if (_$data.containsKey('automaticallyFulfillNonShippableGiftCard')) {
      final l$automaticallyFulfillNonShippableGiftCard =
          automaticallyFulfillNonShippableGiftCard;
      result$data['automaticallyFulfillNonShippableGiftCard'] =
          l$automaticallyFulfillNonShippableGiftCard;
    }
    return result$data;
  }

  CopyWith$Input$OrderSettingsUpdateInput<Input$OrderSettingsUpdateInput>
      get copyWith => CopyWith$Input$OrderSettingsUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderSettingsUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$automaticallyConfirmAllNewOrders = automaticallyConfirmAllNewOrders;
    final lOther$automaticallyConfirmAllNewOrders =
        other.automaticallyConfirmAllNewOrders;
    if (_$data.containsKey('automaticallyConfirmAllNewOrders') !=
        other._$data.containsKey('automaticallyConfirmAllNewOrders')) {
      return false;
    }
    if (l$automaticallyConfirmAllNewOrders !=
        lOther$automaticallyConfirmAllNewOrders) {
      return false;
    }
    final l$automaticallyFulfillNonShippableGiftCard =
        automaticallyFulfillNonShippableGiftCard;
    final lOther$automaticallyFulfillNonShippableGiftCard =
        other.automaticallyFulfillNonShippableGiftCard;
    if (_$data.containsKey('automaticallyFulfillNonShippableGiftCard') !=
        other._$data.containsKey('automaticallyFulfillNonShippableGiftCard')) {
      return false;
    }
    if (l$automaticallyFulfillNonShippableGiftCard !=
        lOther$automaticallyFulfillNonShippableGiftCard) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$automaticallyConfirmAllNewOrders = automaticallyConfirmAllNewOrders;
    final l$automaticallyFulfillNonShippableGiftCard =
        automaticallyFulfillNonShippableGiftCard;
    return Object.hashAll([
      _$data.containsKey('automaticallyConfirmAllNewOrders')
          ? l$automaticallyConfirmAllNewOrders
          : const {},
      _$data.containsKey('automaticallyFulfillNonShippableGiftCard')
          ? l$automaticallyFulfillNonShippableGiftCard
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderSettingsUpdateInput<TRes> {
  factory CopyWith$Input$OrderSettingsUpdateInput(
    Input$OrderSettingsUpdateInput instance,
    TRes Function(Input$OrderSettingsUpdateInput) then,
  ) = _CopyWithImpl$Input$OrderSettingsUpdateInput;

  factory CopyWith$Input$OrderSettingsUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderSettingsUpdateInput;

  TRes call({
    bool? automaticallyConfirmAllNewOrders,
    bool? automaticallyFulfillNonShippableGiftCard,
  });
}

class _CopyWithImpl$Input$OrderSettingsUpdateInput<TRes>
    implements CopyWith$Input$OrderSettingsUpdateInput<TRes> {
  _CopyWithImpl$Input$OrderSettingsUpdateInput(
    this._instance,
    this._then,
  );

  final Input$OrderSettingsUpdateInput _instance;

  final TRes Function(Input$OrderSettingsUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? automaticallyConfirmAllNewOrders = _undefined,
    Object? automaticallyFulfillNonShippableGiftCard = _undefined,
  }) =>
      _then(Input$OrderSettingsUpdateInput._({
        ..._instance._$data,
        if (automaticallyConfirmAllNewOrders != _undefined)
          'automaticallyConfirmAllNewOrders':
              (automaticallyConfirmAllNewOrders as bool?),
        if (automaticallyFulfillNonShippableGiftCard != _undefined)
          'automaticallyFulfillNonShippableGiftCard':
              (automaticallyFulfillNonShippableGiftCard as bool?),
      }));
}

class _CopyWithStubImpl$Input$OrderSettingsUpdateInput<TRes>
    implements CopyWith$Input$OrderSettingsUpdateInput<TRes> {
  _CopyWithStubImpl$Input$OrderSettingsUpdateInput(this._res);

  TRes _res;

  call({
    bool? automaticallyConfirmAllNewOrders,
    bool? automaticallyFulfillNonShippableGiftCard,
  }) =>
      _res;
}

class Input$OrderSortingInput {
  factory Input$OrderSortingInput({
    required Enum$OrderDirection direction,
    required Enum$OrderSortField field,
  }) =>
      Input$OrderSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$OrderSortingInput._(this._$data);

  factory Input$OrderSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$OrderSortField((l$field as String));
    return Input$OrderSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$OrderSortField get field => (_$data['field'] as Enum$OrderSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$OrderSortField(l$field);
    return result$data;
  }

  CopyWith$Input$OrderSortingInput<Input$OrderSortingInput> get copyWith =>
      CopyWith$Input$OrderSortingInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderSortingInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$OrderSortingInput<TRes> {
  factory CopyWith$Input$OrderSortingInput(
    Input$OrderSortingInput instance,
    TRes Function(Input$OrderSortingInput) then,
  ) = _CopyWithImpl$Input$OrderSortingInput;

  factory CopyWith$Input$OrderSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$OrderSortField? field,
  });
}

class _CopyWithImpl$Input$OrderSortingInput<TRes>
    implements CopyWith$Input$OrderSortingInput<TRes> {
  _CopyWithImpl$Input$OrderSortingInput(
    this._instance,
    this._then,
  );

  final Input$OrderSortingInput _instance;

  final TRes Function(Input$OrderSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$OrderSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$OrderSortField),
      }));
}

class _CopyWithStubImpl$Input$OrderSortingInput<TRes>
    implements CopyWith$Input$OrderSortingInput<TRes> {
  _CopyWithStubImpl$Input$OrderSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$OrderSortField? field,
  }) =>
      _res;
}

class Input$OrderStatusEnumFilterInput {
  factory Input$OrderStatusEnumFilterInput({
    Enum$OrderStatus? eq,
    List<Enum$OrderStatus>? oneOf,
  }) =>
      Input$OrderStatusEnumFilterInput._({
        if (eq != null) r'eq': eq,
        if (oneOf != null) r'oneOf': oneOf,
      });

  Input$OrderStatusEnumFilterInput._(this._$data);

  factory Input$OrderStatusEnumFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] =
          l$eq == null ? null : fromJson$Enum$OrderStatus((l$eq as String));
    }
    if (data.containsKey('oneOf')) {
      final l$oneOf = data['oneOf'];
      result$data['oneOf'] = (l$oneOf as List<dynamic>?)
          ?.map((e) => fromJson$Enum$OrderStatus((e as String)))
          .toList();
    }
    return Input$OrderStatusEnumFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderStatus? get eq => (_$data['eq'] as Enum$OrderStatus?);

  List<Enum$OrderStatus>? get oneOf =>
      (_$data['oneOf'] as List<Enum$OrderStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$OrderStatus(l$eq);
    }
    if (_$data.containsKey('oneOf')) {
      final l$oneOf = oneOf;
      result$data['oneOf'] =
          l$oneOf?.map((e) => toJson$Enum$OrderStatus(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$OrderStatusEnumFilterInput<Input$OrderStatusEnumFilterInput>
      get copyWith => CopyWith$Input$OrderStatusEnumFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderStatusEnumFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$oneOf = oneOf;
    final lOther$oneOf = other.oneOf;
    if (_$data.containsKey('oneOf') != other._$data.containsKey('oneOf')) {
      return false;
    }
    if (l$oneOf != null && lOther$oneOf != null) {
      if (l$oneOf.length != lOther$oneOf.length) {
        return false;
      }
      for (int i = 0; i < l$oneOf.length; i++) {
        final l$oneOf$entry = l$oneOf[i];
        final lOther$oneOf$entry = lOther$oneOf[i];
        if (l$oneOf$entry != lOther$oneOf$entry) {
          return false;
        }
      }
    } else if (l$oneOf != lOther$oneOf) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$oneOf = oneOf;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('oneOf')
          ? l$oneOf == null
              ? null
              : Object.hashAll(l$oneOf.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderStatusEnumFilterInput<TRes> {
  factory CopyWith$Input$OrderStatusEnumFilterInput(
    Input$OrderStatusEnumFilterInput instance,
    TRes Function(Input$OrderStatusEnumFilterInput) then,
  ) = _CopyWithImpl$Input$OrderStatusEnumFilterInput;

  factory CopyWith$Input$OrderStatusEnumFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderStatusEnumFilterInput;

  TRes call({
    Enum$OrderStatus? eq,
    List<Enum$OrderStatus>? oneOf,
  });
}

class _CopyWithImpl$Input$OrderStatusEnumFilterInput<TRes>
    implements CopyWith$Input$OrderStatusEnumFilterInput<TRes> {
  _CopyWithImpl$Input$OrderStatusEnumFilterInput(
    this._instance,
    this._then,
  );

  final Input$OrderStatusEnumFilterInput _instance;

  final TRes Function(Input$OrderStatusEnumFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? oneOf = _undefined,
  }) =>
      _then(Input$OrderStatusEnumFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as Enum$OrderStatus?),
        if (oneOf != _undefined) 'oneOf': (oneOf as List<Enum$OrderStatus>?),
      }));
}

class _CopyWithStubImpl$Input$OrderStatusEnumFilterInput<TRes>
    implements CopyWith$Input$OrderStatusEnumFilterInput<TRes> {
  _CopyWithStubImpl$Input$OrderStatusEnumFilterInput(this._res);

  TRes _res;

  call({
    Enum$OrderStatus? eq,
    List<Enum$OrderStatus>? oneOf,
  }) =>
      _res;
}

class Input$OrderUpdateInput {
  factory Input$OrderUpdateInput({
    Input$AddressInput? billingAddress,
    String? userEmail,
    Input$AddressInput? shippingAddress,
    String? externalReference,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Enum$LanguageCodeEnum? languageCode,
  }) =>
      Input$OrderUpdateInput._({
        if (billingAddress != null) r'billingAddress': billingAddress,
        if (userEmail != null) r'userEmail': userEmail,
        if (shippingAddress != null) r'shippingAddress': shippingAddress,
        if (externalReference != null) r'externalReference': externalReference,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (languageCode != null) r'languageCode': languageCode,
      });

  Input$OrderUpdateInput._(this._$data);

  factory Input$OrderUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('billingAddress')) {
      final l$billingAddress = data['billingAddress'];
      result$data['billingAddress'] = l$billingAddress == null
          ? null
          : Input$AddressInput.fromJson(
              (l$billingAddress as Map<String, dynamic>));
    }
    if (data.containsKey('userEmail')) {
      final l$userEmail = data['userEmail'];
      result$data['userEmail'] = (l$userEmail as String?);
    }
    if (data.containsKey('shippingAddress')) {
      final l$shippingAddress = data['shippingAddress'];
      result$data['shippingAddress'] = l$shippingAddress == null
          ? null
          : Input$AddressInput.fromJson(
              (l$shippingAddress as Map<String, dynamic>));
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('languageCode')) {
      final l$languageCode = data['languageCode'];
      result$data['languageCode'] = l$languageCode == null
          ? null
          : fromJson$Enum$LanguageCodeEnum((l$languageCode as String));
    }
    return Input$OrderUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$AddressInput? get billingAddress =>
      (_$data['billingAddress'] as Input$AddressInput?);

  String? get userEmail => (_$data['userEmail'] as String?);

  Input$AddressInput? get shippingAddress =>
      (_$data['shippingAddress'] as Input$AddressInput?);

  String? get externalReference => (_$data['externalReference'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  Enum$LanguageCodeEnum? get languageCode =>
      (_$data['languageCode'] as Enum$LanguageCodeEnum?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('billingAddress')) {
      final l$billingAddress = billingAddress;
      result$data['billingAddress'] = l$billingAddress?.toJson();
    }
    if (_$data.containsKey('userEmail')) {
      final l$userEmail = userEmail;
      result$data['userEmail'] = l$userEmail;
    }
    if (_$data.containsKey('shippingAddress')) {
      final l$shippingAddress = shippingAddress;
      result$data['shippingAddress'] = l$shippingAddress?.toJson();
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('languageCode')) {
      final l$languageCode = languageCode;
      result$data['languageCode'] = l$languageCode == null
          ? null
          : toJson$Enum$LanguageCodeEnum(l$languageCode);
    }
    return result$data;
  }

  CopyWith$Input$OrderUpdateInput<Input$OrderUpdateInput> get copyWith =>
      CopyWith$Input$OrderUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderUpdateInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$billingAddress = billingAddress;
    final lOther$billingAddress = other.billingAddress;
    if (_$data.containsKey('billingAddress') !=
        other._$data.containsKey('billingAddress')) {
      return false;
    }
    if (l$billingAddress != lOther$billingAddress) {
      return false;
    }
    final l$userEmail = userEmail;
    final lOther$userEmail = other.userEmail;
    if (_$data.containsKey('userEmail') !=
        other._$data.containsKey('userEmail')) {
      return false;
    }
    if (l$userEmail != lOther$userEmail) {
      return false;
    }
    final l$shippingAddress = shippingAddress;
    final lOther$shippingAddress = other.shippingAddress;
    if (_$data.containsKey('shippingAddress') !=
        other._$data.containsKey('shippingAddress')) {
      return false;
    }
    if (l$shippingAddress != lOther$shippingAddress) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$languageCode = languageCode;
    final lOther$languageCode = other.languageCode;
    if (_$data.containsKey('languageCode') !=
        other._$data.containsKey('languageCode')) {
      return false;
    }
    if (l$languageCode != lOther$languageCode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$billingAddress = billingAddress;
    final l$userEmail = userEmail;
    final l$shippingAddress = shippingAddress;
    final l$externalReference = externalReference;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$languageCode = languageCode;
    return Object.hashAll([
      _$data.containsKey('billingAddress') ? l$billingAddress : const {},
      _$data.containsKey('userEmail') ? l$userEmail : const {},
      _$data.containsKey('shippingAddress') ? l$shippingAddress : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('languageCode') ? l$languageCode : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderUpdateInput<TRes> {
  factory CopyWith$Input$OrderUpdateInput(
    Input$OrderUpdateInput instance,
    TRes Function(Input$OrderUpdateInput) then,
  ) = _CopyWithImpl$Input$OrderUpdateInput;

  factory CopyWith$Input$OrderUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderUpdateInput;

  TRes call({
    Input$AddressInput? billingAddress,
    String? userEmail,
    Input$AddressInput? shippingAddress,
    String? externalReference,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Enum$LanguageCodeEnum? languageCode,
  });
  CopyWith$Input$AddressInput<TRes> get billingAddress;
  CopyWith$Input$AddressInput<TRes> get shippingAddress;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$OrderUpdateInput<TRes>
    implements CopyWith$Input$OrderUpdateInput<TRes> {
  _CopyWithImpl$Input$OrderUpdateInput(
    this._instance,
    this._then,
  );

  final Input$OrderUpdateInput _instance;

  final TRes Function(Input$OrderUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? billingAddress = _undefined,
    Object? userEmail = _undefined,
    Object? shippingAddress = _undefined,
    Object? externalReference = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? languageCode = _undefined,
  }) =>
      _then(Input$OrderUpdateInput._({
        ..._instance._$data,
        if (billingAddress != _undefined)
          'billingAddress': (billingAddress as Input$AddressInput?),
        if (userEmail != _undefined) 'userEmail': (userEmail as String?),
        if (shippingAddress != _undefined)
          'shippingAddress': (shippingAddress as Input$AddressInput?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (languageCode != _undefined)
          'languageCode': (languageCode as Enum$LanguageCodeEnum?),
      }));

  CopyWith$Input$AddressInput<TRes> get billingAddress {
    final local$billingAddress = _instance.billingAddress;
    return local$billingAddress == null
        ? CopyWith$Input$AddressInput.stub(_then(_instance))
        : CopyWith$Input$AddressInput(
            local$billingAddress, (e) => call(billingAddress: e));
  }

  CopyWith$Input$AddressInput<TRes> get shippingAddress {
    final local$shippingAddress = _instance.shippingAddress;
    return local$shippingAddress == null
        ? CopyWith$Input$AddressInput.stub(_then(_instance))
        : CopyWith$Input$AddressInput(
            local$shippingAddress, (e) => call(shippingAddress: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$OrderUpdateInput<TRes>
    implements CopyWith$Input$OrderUpdateInput<TRes> {
  _CopyWithStubImpl$Input$OrderUpdateInput(this._res);

  TRes _res;

  call({
    Input$AddressInput? billingAddress,
    String? userEmail,
    Input$AddressInput? shippingAddress,
    String? externalReference,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Enum$LanguageCodeEnum? languageCode,
  }) =>
      _res;

  CopyWith$Input$AddressInput<TRes> get billingAddress =>
      CopyWith$Input$AddressInput.stub(_res);

  CopyWith$Input$AddressInput<TRes> get shippingAddress =>
      CopyWith$Input$AddressInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$OrderUpdateShippingInput {
  factory Input$OrderUpdateShippingInput({String? shippingMethod}) =>
      Input$OrderUpdateShippingInput._({
        if (shippingMethod != null) r'shippingMethod': shippingMethod,
      });

  Input$OrderUpdateShippingInput._(this._$data);

  factory Input$OrderUpdateShippingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('shippingMethod')) {
      final l$shippingMethod = data['shippingMethod'];
      result$data['shippingMethod'] = (l$shippingMethod as String?);
    }
    return Input$OrderUpdateShippingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get shippingMethod => (_$data['shippingMethod'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('shippingMethod')) {
      final l$shippingMethod = shippingMethod;
      result$data['shippingMethod'] = l$shippingMethod;
    }
    return result$data;
  }

  CopyWith$Input$OrderUpdateShippingInput<Input$OrderUpdateShippingInput>
      get copyWith => CopyWith$Input$OrderUpdateShippingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderUpdateShippingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$shippingMethod = shippingMethod;
    final lOther$shippingMethod = other.shippingMethod;
    if (_$data.containsKey('shippingMethod') !=
        other._$data.containsKey('shippingMethod')) {
      return false;
    }
    if (l$shippingMethod != lOther$shippingMethod) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$shippingMethod = shippingMethod;
    return Object.hashAll(
        [_$data.containsKey('shippingMethod') ? l$shippingMethod : const {}]);
  }
}

abstract class CopyWith$Input$OrderUpdateShippingInput<TRes> {
  factory CopyWith$Input$OrderUpdateShippingInput(
    Input$OrderUpdateShippingInput instance,
    TRes Function(Input$OrderUpdateShippingInput) then,
  ) = _CopyWithImpl$Input$OrderUpdateShippingInput;

  factory CopyWith$Input$OrderUpdateShippingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderUpdateShippingInput;

  TRes call({String? shippingMethod});
}

class _CopyWithImpl$Input$OrderUpdateShippingInput<TRes>
    implements CopyWith$Input$OrderUpdateShippingInput<TRes> {
  _CopyWithImpl$Input$OrderUpdateShippingInput(
    this._instance,
    this._then,
  );

  final Input$OrderUpdateShippingInput _instance;

  final TRes Function(Input$OrderUpdateShippingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? shippingMethod = _undefined}) =>
      _then(Input$OrderUpdateShippingInput._({
        ..._instance._$data,
        if (shippingMethod != _undefined)
          'shippingMethod': (shippingMethod as String?),
      }));
}

class _CopyWithStubImpl$Input$OrderUpdateShippingInput<TRes>
    implements CopyWith$Input$OrderUpdateShippingInput<TRes> {
  _CopyWithStubImpl$Input$OrderUpdateShippingInput(this._res);

  TRes _res;

  call({String? shippingMethod}) => _res;
}

class Input$OrderWhereInput {
  factory Input$OrderWhereInput({
    Input$MetadataFilterInput? metadata,
    List<String>? ids,
    Input$IntFilterInput? number,
    Input$GlobalIDFilterInput? channelId,
    Input$DateTimeRangeInput? createdAt,
    Input$DateTimeRangeInput? updatedAt,
    Input$GlobalIDFilterInput? user,
    Input$StringFilterInput? userEmail,
    Input$OrderAuthorizeStatusEnumFilterInput? authorizeStatus,
    Input$OrderChargeStatusEnumFilterInput? chargeStatus,
    Input$OrderStatusEnumFilterInput? status,
    Input$UUIDFilterInput? checkoutToken,
    Input$GlobalIDFilterInput? checkoutId,
    bool? isClickAndCollect,
    bool? isPreorder,
    bool? isGiftCardUsed,
    bool? isGiftCardBought,
    Input$StringFilterInput? voucherCode,
    bool? hasInvoices,
    Input$InvoiceFilterInput? invoices,
    bool? hasFulfillments,
    Input$FulfillmentFilterInput? fulfillments,
    Input$LinesFilterInput? lines,
    Input$IntFilterInput? linesCount,
    Input$PriceFilterInput? totalGross,
    Input$PriceFilterInput? totalNet,
    Input$GlobalIDFilterInput? productTypeId,
    List<Input$OrderWhereInput>? AND,
    List<Input$OrderWhereInput>? OR,
  }) =>
      Input$OrderWhereInput._({
        if (metadata != null) r'metadata': metadata,
        if (ids != null) r'ids': ids,
        if (number != null) r'number': number,
        if (channelId != null) r'channelId': channelId,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (user != null) r'user': user,
        if (userEmail != null) r'userEmail': userEmail,
        if (authorizeStatus != null) r'authorizeStatus': authorizeStatus,
        if (chargeStatus != null) r'chargeStatus': chargeStatus,
        if (status != null) r'status': status,
        if (checkoutToken != null) r'checkoutToken': checkoutToken,
        if (checkoutId != null) r'checkoutId': checkoutId,
        if (isClickAndCollect != null) r'isClickAndCollect': isClickAndCollect,
        if (isPreorder != null) r'isPreorder': isPreorder,
        if (isGiftCardUsed != null) r'isGiftCardUsed': isGiftCardUsed,
        if (isGiftCardBought != null) r'isGiftCardBought': isGiftCardBought,
        if (voucherCode != null) r'voucherCode': voucherCode,
        if (hasInvoices != null) r'hasInvoices': hasInvoices,
        if (invoices != null) r'invoices': invoices,
        if (hasFulfillments != null) r'hasFulfillments': hasFulfillments,
        if (fulfillments != null) r'fulfillments': fulfillments,
        if (lines != null) r'lines': lines,
        if (linesCount != null) r'linesCount': linesCount,
        if (totalGross != null) r'totalGross': totalGross,
        if (totalNet != null) r'totalNet': totalNet,
        if (productTypeId != null) r'productTypeId': productTypeId,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
      });

  Input$OrderWhereInput._(this._$data);

  factory Input$OrderWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = l$metadata == null
          ? null
          : Input$MetadataFilterInput.fromJson(
              (l$metadata as Map<String, dynamic>));
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('number')) {
      final l$number = data['number'];
      result$data['number'] = l$number == null
          ? null
          : Input$IntFilterInput.fromJson((l$number as Map<String, dynamic>));
    }
    if (data.containsKey('channelId')) {
      final l$channelId = data['channelId'];
      result$data['channelId'] = l$channelId == null
          ? null
          : Input$GlobalIDFilterInput.fromJson(
              (l$channelId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeRangeInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeRangeInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : Input$GlobalIDFilterInput.fromJson(
              (l$user as Map<String, dynamic>));
    }
    if (data.containsKey('userEmail')) {
      final l$userEmail = data['userEmail'];
      result$data['userEmail'] = l$userEmail == null
          ? null
          : Input$StringFilterInput.fromJson(
              (l$userEmail as Map<String, dynamic>));
    }
    if (data.containsKey('authorizeStatus')) {
      final l$authorizeStatus = data['authorizeStatus'];
      result$data['authorizeStatus'] = l$authorizeStatus == null
          ? null
          : Input$OrderAuthorizeStatusEnumFilterInput.fromJson(
              (l$authorizeStatus as Map<String, dynamic>));
    }
    if (data.containsKey('chargeStatus')) {
      final l$chargeStatus = data['chargeStatus'];
      result$data['chargeStatus'] = l$chargeStatus == null
          ? null
          : Input$OrderChargeStatusEnumFilterInput.fromJson(
              (l$chargeStatus as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$OrderStatusEnumFilterInput.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('checkoutToken')) {
      final l$checkoutToken = data['checkoutToken'];
      result$data['checkoutToken'] = l$checkoutToken == null
          ? null
          : Input$UUIDFilterInput.fromJson(
              (l$checkoutToken as Map<String, dynamic>));
    }
    if (data.containsKey('checkoutId')) {
      final l$checkoutId = data['checkoutId'];
      result$data['checkoutId'] = l$checkoutId == null
          ? null
          : Input$GlobalIDFilterInput.fromJson(
              (l$checkoutId as Map<String, dynamic>));
    }
    if (data.containsKey('isClickAndCollect')) {
      final l$isClickAndCollect = data['isClickAndCollect'];
      result$data['isClickAndCollect'] = (l$isClickAndCollect as bool?);
    }
    if (data.containsKey('isPreorder')) {
      final l$isPreorder = data['isPreorder'];
      result$data['isPreorder'] = (l$isPreorder as bool?);
    }
    if (data.containsKey('isGiftCardUsed')) {
      final l$isGiftCardUsed = data['isGiftCardUsed'];
      result$data['isGiftCardUsed'] = (l$isGiftCardUsed as bool?);
    }
    if (data.containsKey('isGiftCardBought')) {
      final l$isGiftCardBought = data['isGiftCardBought'];
      result$data['isGiftCardBought'] = (l$isGiftCardBought as bool?);
    }
    if (data.containsKey('voucherCode')) {
      final l$voucherCode = data['voucherCode'];
      result$data['voucherCode'] = l$voucherCode == null
          ? null
          : Input$StringFilterInput.fromJson(
              (l$voucherCode as Map<String, dynamic>));
    }
    if (data.containsKey('hasInvoices')) {
      final l$hasInvoices = data['hasInvoices'];
      result$data['hasInvoices'] = (l$hasInvoices as bool?);
    }
    if (data.containsKey('invoices')) {
      final l$invoices = data['invoices'];
      result$data['invoices'] = l$invoices == null
          ? null
          : Input$InvoiceFilterInput.fromJson(
              (l$invoices as Map<String, dynamic>));
    }
    if (data.containsKey('hasFulfillments')) {
      final l$hasFulfillments = data['hasFulfillments'];
      result$data['hasFulfillments'] = (l$hasFulfillments as bool?);
    }
    if (data.containsKey('fulfillments')) {
      final l$fulfillments = data['fulfillments'];
      result$data['fulfillments'] = l$fulfillments == null
          ? null
          : Input$FulfillmentFilterInput.fromJson(
              (l$fulfillments as Map<String, dynamic>));
    }
    if (data.containsKey('lines')) {
      final l$lines = data['lines'];
      result$data['lines'] = l$lines == null
          ? null
          : Input$LinesFilterInput.fromJson((l$lines as Map<String, dynamic>));
    }
    if (data.containsKey('linesCount')) {
      final l$linesCount = data['linesCount'];
      result$data['linesCount'] = l$linesCount == null
          ? null
          : Input$IntFilterInput.fromJson(
              (l$linesCount as Map<String, dynamic>));
    }
    if (data.containsKey('totalGross')) {
      final l$totalGross = data['totalGross'];
      result$data['totalGross'] = l$totalGross == null
          ? null
          : Input$PriceFilterInput.fromJson(
              (l$totalGross as Map<String, dynamic>));
    }
    if (data.containsKey('totalNet')) {
      final l$totalNet = data['totalNet'];
      result$data['totalNet'] = l$totalNet == null
          ? null
          : Input$PriceFilterInput.fromJson(
              (l$totalNet as Map<String, dynamic>));
    }
    if (data.containsKey('productTypeId')) {
      final l$productTypeId = data['productTypeId'];
      result$data['productTypeId'] = l$productTypeId == null
          ? null
          : Input$GlobalIDFilterInput.fromJson(
              (l$productTypeId as Map<String, dynamic>));
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$OrderWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$OrderWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$OrderWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$MetadataFilterInput? get metadata =>
      (_$data['metadata'] as Input$MetadataFilterInput?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  Input$IntFilterInput? get number =>
      (_$data['number'] as Input$IntFilterInput?);

  Input$GlobalIDFilterInput? get channelId =>
      (_$data['channelId'] as Input$GlobalIDFilterInput?);

  Input$DateTimeRangeInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeRangeInput?);

  Input$DateTimeRangeInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeRangeInput?);

  Input$GlobalIDFilterInput? get user =>
      (_$data['user'] as Input$GlobalIDFilterInput?);

  Input$StringFilterInput? get userEmail =>
      (_$data['userEmail'] as Input$StringFilterInput?);

  Input$OrderAuthorizeStatusEnumFilterInput? get authorizeStatus =>
      (_$data['authorizeStatus'] as Input$OrderAuthorizeStatusEnumFilterInput?);

  Input$OrderChargeStatusEnumFilterInput? get chargeStatus =>
      (_$data['chargeStatus'] as Input$OrderChargeStatusEnumFilterInput?);

  Input$OrderStatusEnumFilterInput? get status =>
      (_$data['status'] as Input$OrderStatusEnumFilterInput?);

  Input$UUIDFilterInput? get checkoutToken =>
      (_$data['checkoutToken'] as Input$UUIDFilterInput?);

  Input$GlobalIDFilterInput? get checkoutId =>
      (_$data['checkoutId'] as Input$GlobalIDFilterInput?);

  bool? get isClickAndCollect => (_$data['isClickAndCollect'] as bool?);

  bool? get isPreorder => (_$data['isPreorder'] as bool?);

  bool? get isGiftCardUsed => (_$data['isGiftCardUsed'] as bool?);

  bool? get isGiftCardBought => (_$data['isGiftCardBought'] as bool?);

  Input$StringFilterInput? get voucherCode =>
      (_$data['voucherCode'] as Input$StringFilterInput?);

  bool? get hasInvoices => (_$data['hasInvoices'] as bool?);

  Input$InvoiceFilterInput? get invoices =>
      (_$data['invoices'] as Input$InvoiceFilterInput?);

  bool? get hasFulfillments => (_$data['hasFulfillments'] as bool?);

  Input$FulfillmentFilterInput? get fulfillments =>
      (_$data['fulfillments'] as Input$FulfillmentFilterInput?);

  Input$LinesFilterInput? get lines =>
      (_$data['lines'] as Input$LinesFilterInput?);

  Input$IntFilterInput? get linesCount =>
      (_$data['linesCount'] as Input$IntFilterInput?);

  Input$PriceFilterInput? get totalGross =>
      (_$data['totalGross'] as Input$PriceFilterInput?);

  Input$PriceFilterInput? get totalNet =>
      (_$data['totalNet'] as Input$PriceFilterInput?);

  Input$GlobalIDFilterInput? get productTypeId =>
      (_$data['productTypeId'] as Input$GlobalIDFilterInput?);

  List<Input$OrderWhereInput>? get AND =>
      (_$data['AND'] as List<Input$OrderWhereInput>?);

  List<Input$OrderWhereInput>? get OR =>
      (_$data['OR'] as List<Input$OrderWhereInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.toJson();
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('number')) {
      final l$number = number;
      result$data['number'] = l$number?.toJson();
    }
    if (_$data.containsKey('channelId')) {
      final l$channelId = channelId;
      result$data['channelId'] = l$channelId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('userEmail')) {
      final l$userEmail = userEmail;
      result$data['userEmail'] = l$userEmail?.toJson();
    }
    if (_$data.containsKey('authorizeStatus')) {
      final l$authorizeStatus = authorizeStatus;
      result$data['authorizeStatus'] = l$authorizeStatus?.toJson();
    }
    if (_$data.containsKey('chargeStatus')) {
      final l$chargeStatus = chargeStatus;
      result$data['chargeStatus'] = l$chargeStatus?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('checkoutToken')) {
      final l$checkoutToken = checkoutToken;
      result$data['checkoutToken'] = l$checkoutToken?.toJson();
    }
    if (_$data.containsKey('checkoutId')) {
      final l$checkoutId = checkoutId;
      result$data['checkoutId'] = l$checkoutId?.toJson();
    }
    if (_$data.containsKey('isClickAndCollect')) {
      final l$isClickAndCollect = isClickAndCollect;
      result$data['isClickAndCollect'] = l$isClickAndCollect;
    }
    if (_$data.containsKey('isPreorder')) {
      final l$isPreorder = isPreorder;
      result$data['isPreorder'] = l$isPreorder;
    }
    if (_$data.containsKey('isGiftCardUsed')) {
      final l$isGiftCardUsed = isGiftCardUsed;
      result$data['isGiftCardUsed'] = l$isGiftCardUsed;
    }
    if (_$data.containsKey('isGiftCardBought')) {
      final l$isGiftCardBought = isGiftCardBought;
      result$data['isGiftCardBought'] = l$isGiftCardBought;
    }
    if (_$data.containsKey('voucherCode')) {
      final l$voucherCode = voucherCode;
      result$data['voucherCode'] = l$voucherCode?.toJson();
    }
    if (_$data.containsKey('hasInvoices')) {
      final l$hasInvoices = hasInvoices;
      result$data['hasInvoices'] = l$hasInvoices;
    }
    if (_$data.containsKey('invoices')) {
      final l$invoices = invoices;
      result$data['invoices'] = l$invoices?.toJson();
    }
    if (_$data.containsKey('hasFulfillments')) {
      final l$hasFulfillments = hasFulfillments;
      result$data['hasFulfillments'] = l$hasFulfillments;
    }
    if (_$data.containsKey('fulfillments')) {
      final l$fulfillments = fulfillments;
      result$data['fulfillments'] = l$fulfillments?.toJson();
    }
    if (_$data.containsKey('lines')) {
      final l$lines = lines;
      result$data['lines'] = l$lines?.toJson();
    }
    if (_$data.containsKey('linesCount')) {
      final l$linesCount = linesCount;
      result$data['linesCount'] = l$linesCount?.toJson();
    }
    if (_$data.containsKey('totalGross')) {
      final l$totalGross = totalGross;
      result$data['totalGross'] = l$totalGross?.toJson();
    }
    if (_$data.containsKey('totalNet')) {
      final l$totalNet = totalNet;
      result$data['totalNet'] = l$totalNet?.toJson();
    }
    if (_$data.containsKey('productTypeId')) {
      final l$productTypeId = productTypeId;
      result$data['productTypeId'] = l$productTypeId?.toJson();
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$OrderWhereInput<Input$OrderWhereInput> get copyWith =>
      CopyWith$Input$OrderWhereInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrderWhereInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$number = number;
    final lOther$number = other.number;
    if (_$data.containsKey('number') != other._$data.containsKey('number')) {
      return false;
    }
    if (l$number != lOther$number) {
      return false;
    }
    final l$channelId = channelId;
    final lOther$channelId = other.channelId;
    if (_$data.containsKey('channelId') !=
        other._$data.containsKey('channelId')) {
      return false;
    }
    if (l$channelId != lOther$channelId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$userEmail = userEmail;
    final lOther$userEmail = other.userEmail;
    if (_$data.containsKey('userEmail') !=
        other._$data.containsKey('userEmail')) {
      return false;
    }
    if (l$userEmail != lOther$userEmail) {
      return false;
    }
    final l$authorizeStatus = authorizeStatus;
    final lOther$authorizeStatus = other.authorizeStatus;
    if (_$data.containsKey('authorizeStatus') !=
        other._$data.containsKey('authorizeStatus')) {
      return false;
    }
    if (l$authorizeStatus != lOther$authorizeStatus) {
      return false;
    }
    final l$chargeStatus = chargeStatus;
    final lOther$chargeStatus = other.chargeStatus;
    if (_$data.containsKey('chargeStatus') !=
        other._$data.containsKey('chargeStatus')) {
      return false;
    }
    if (l$chargeStatus != lOther$chargeStatus) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$checkoutToken = checkoutToken;
    final lOther$checkoutToken = other.checkoutToken;
    if (_$data.containsKey('checkoutToken') !=
        other._$data.containsKey('checkoutToken')) {
      return false;
    }
    if (l$checkoutToken != lOther$checkoutToken) {
      return false;
    }
    final l$checkoutId = checkoutId;
    final lOther$checkoutId = other.checkoutId;
    if (_$data.containsKey('checkoutId') !=
        other._$data.containsKey('checkoutId')) {
      return false;
    }
    if (l$checkoutId != lOther$checkoutId) {
      return false;
    }
    final l$isClickAndCollect = isClickAndCollect;
    final lOther$isClickAndCollect = other.isClickAndCollect;
    if (_$data.containsKey('isClickAndCollect') !=
        other._$data.containsKey('isClickAndCollect')) {
      return false;
    }
    if (l$isClickAndCollect != lOther$isClickAndCollect) {
      return false;
    }
    final l$isPreorder = isPreorder;
    final lOther$isPreorder = other.isPreorder;
    if (_$data.containsKey('isPreorder') !=
        other._$data.containsKey('isPreorder')) {
      return false;
    }
    if (l$isPreorder != lOther$isPreorder) {
      return false;
    }
    final l$isGiftCardUsed = isGiftCardUsed;
    final lOther$isGiftCardUsed = other.isGiftCardUsed;
    if (_$data.containsKey('isGiftCardUsed') !=
        other._$data.containsKey('isGiftCardUsed')) {
      return false;
    }
    if (l$isGiftCardUsed != lOther$isGiftCardUsed) {
      return false;
    }
    final l$isGiftCardBought = isGiftCardBought;
    final lOther$isGiftCardBought = other.isGiftCardBought;
    if (_$data.containsKey('isGiftCardBought') !=
        other._$data.containsKey('isGiftCardBought')) {
      return false;
    }
    if (l$isGiftCardBought != lOther$isGiftCardBought) {
      return false;
    }
    final l$voucherCode = voucherCode;
    final lOther$voucherCode = other.voucherCode;
    if (_$data.containsKey('voucherCode') !=
        other._$data.containsKey('voucherCode')) {
      return false;
    }
    if (l$voucherCode != lOther$voucherCode) {
      return false;
    }
    final l$hasInvoices = hasInvoices;
    final lOther$hasInvoices = other.hasInvoices;
    if (_$data.containsKey('hasInvoices') !=
        other._$data.containsKey('hasInvoices')) {
      return false;
    }
    if (l$hasInvoices != lOther$hasInvoices) {
      return false;
    }
    final l$invoices = invoices;
    final lOther$invoices = other.invoices;
    if (_$data.containsKey('invoices') !=
        other._$data.containsKey('invoices')) {
      return false;
    }
    if (l$invoices != lOther$invoices) {
      return false;
    }
    final l$hasFulfillments = hasFulfillments;
    final lOther$hasFulfillments = other.hasFulfillments;
    if (_$data.containsKey('hasFulfillments') !=
        other._$data.containsKey('hasFulfillments')) {
      return false;
    }
    if (l$hasFulfillments != lOther$hasFulfillments) {
      return false;
    }
    final l$fulfillments = fulfillments;
    final lOther$fulfillments = other.fulfillments;
    if (_$data.containsKey('fulfillments') !=
        other._$data.containsKey('fulfillments')) {
      return false;
    }
    if (l$fulfillments != lOther$fulfillments) {
      return false;
    }
    final l$lines = lines;
    final lOther$lines = other.lines;
    if (_$data.containsKey('lines') != other._$data.containsKey('lines')) {
      return false;
    }
    if (l$lines != lOther$lines) {
      return false;
    }
    final l$linesCount = linesCount;
    final lOther$linesCount = other.linesCount;
    if (_$data.containsKey('linesCount') !=
        other._$data.containsKey('linesCount')) {
      return false;
    }
    if (l$linesCount != lOther$linesCount) {
      return false;
    }
    final l$totalGross = totalGross;
    final lOther$totalGross = other.totalGross;
    if (_$data.containsKey('totalGross') !=
        other._$data.containsKey('totalGross')) {
      return false;
    }
    if (l$totalGross != lOther$totalGross) {
      return false;
    }
    final l$totalNet = totalNet;
    final lOther$totalNet = other.totalNet;
    if (_$data.containsKey('totalNet') !=
        other._$data.containsKey('totalNet')) {
      return false;
    }
    if (l$totalNet != lOther$totalNet) {
      return false;
    }
    final l$productTypeId = productTypeId;
    final lOther$productTypeId = other.productTypeId;
    if (_$data.containsKey('productTypeId') !=
        other._$data.containsKey('productTypeId')) {
      return false;
    }
    if (l$productTypeId != lOther$productTypeId) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$metadata = metadata;
    final l$ids = ids;
    final l$number = number;
    final l$channelId = channelId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$user = user;
    final l$userEmail = userEmail;
    final l$authorizeStatus = authorizeStatus;
    final l$chargeStatus = chargeStatus;
    final l$status = status;
    final l$checkoutToken = checkoutToken;
    final l$checkoutId = checkoutId;
    final l$isClickAndCollect = isClickAndCollect;
    final l$isPreorder = isPreorder;
    final l$isGiftCardUsed = isGiftCardUsed;
    final l$isGiftCardBought = isGiftCardBought;
    final l$voucherCode = voucherCode;
    final l$hasInvoices = hasInvoices;
    final l$invoices = invoices;
    final l$hasFulfillments = hasFulfillments;
    final l$fulfillments = fulfillments;
    final l$lines = lines;
    final l$linesCount = linesCount;
    final l$totalGross = totalGross;
    final l$totalNet = totalNet;
    final l$productTypeId = productTypeId;
    final l$AND = AND;
    final l$OR = OR;
    return Object.hashAll([
      _$data.containsKey('metadata') ? l$metadata : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('number') ? l$number : const {},
      _$data.containsKey('channelId') ? l$channelId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('userEmail') ? l$userEmail : const {},
      _$data.containsKey('authorizeStatus') ? l$authorizeStatus : const {},
      _$data.containsKey('chargeStatus') ? l$chargeStatus : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('checkoutToken') ? l$checkoutToken : const {},
      _$data.containsKey('checkoutId') ? l$checkoutId : const {},
      _$data.containsKey('isClickAndCollect') ? l$isClickAndCollect : const {},
      _$data.containsKey('isPreorder') ? l$isPreorder : const {},
      _$data.containsKey('isGiftCardUsed') ? l$isGiftCardUsed : const {},
      _$data.containsKey('isGiftCardBought') ? l$isGiftCardBought : const {},
      _$data.containsKey('voucherCode') ? l$voucherCode : const {},
      _$data.containsKey('hasInvoices') ? l$hasInvoices : const {},
      _$data.containsKey('invoices') ? l$invoices : const {},
      _$data.containsKey('hasFulfillments') ? l$hasFulfillments : const {},
      _$data.containsKey('fulfillments') ? l$fulfillments : const {},
      _$data.containsKey('lines') ? l$lines : const {},
      _$data.containsKey('linesCount') ? l$linesCount : const {},
      _$data.containsKey('totalGross') ? l$totalGross : const {},
      _$data.containsKey('totalNet') ? l$totalNet : const {},
      _$data.containsKey('productTypeId') ? l$productTypeId : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OrderWhereInput<TRes> {
  factory CopyWith$Input$OrderWhereInput(
    Input$OrderWhereInput instance,
    TRes Function(Input$OrderWhereInput) then,
  ) = _CopyWithImpl$Input$OrderWhereInput;

  factory CopyWith$Input$OrderWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderWhereInput;

  TRes call({
    Input$MetadataFilterInput? metadata,
    List<String>? ids,
    Input$IntFilterInput? number,
    Input$GlobalIDFilterInput? channelId,
    Input$DateTimeRangeInput? createdAt,
    Input$DateTimeRangeInput? updatedAt,
    Input$GlobalIDFilterInput? user,
    Input$StringFilterInput? userEmail,
    Input$OrderAuthorizeStatusEnumFilterInput? authorizeStatus,
    Input$OrderChargeStatusEnumFilterInput? chargeStatus,
    Input$OrderStatusEnumFilterInput? status,
    Input$UUIDFilterInput? checkoutToken,
    Input$GlobalIDFilterInput? checkoutId,
    bool? isClickAndCollect,
    bool? isPreorder,
    bool? isGiftCardUsed,
    bool? isGiftCardBought,
    Input$StringFilterInput? voucherCode,
    bool? hasInvoices,
    Input$InvoiceFilterInput? invoices,
    bool? hasFulfillments,
    Input$FulfillmentFilterInput? fulfillments,
    Input$LinesFilterInput? lines,
    Input$IntFilterInput? linesCount,
    Input$PriceFilterInput? totalGross,
    Input$PriceFilterInput? totalNet,
    Input$GlobalIDFilterInput? productTypeId,
    List<Input$OrderWhereInput>? AND,
    List<Input$OrderWhereInput>? OR,
  });
  CopyWith$Input$MetadataFilterInput<TRes> get metadata;
  CopyWith$Input$IntFilterInput<TRes> get number;
  CopyWith$Input$GlobalIDFilterInput<TRes> get channelId;
  CopyWith$Input$DateTimeRangeInput<TRes> get createdAt;
  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt;
  CopyWith$Input$GlobalIDFilterInput<TRes> get user;
  CopyWith$Input$StringFilterInput<TRes> get userEmail;
  CopyWith$Input$OrderAuthorizeStatusEnumFilterInput<TRes> get authorizeStatus;
  CopyWith$Input$OrderChargeStatusEnumFilterInput<TRes> get chargeStatus;
  CopyWith$Input$OrderStatusEnumFilterInput<TRes> get status;
  CopyWith$Input$UUIDFilterInput<TRes> get checkoutToken;
  CopyWith$Input$GlobalIDFilterInput<TRes> get checkoutId;
  CopyWith$Input$StringFilterInput<TRes> get voucherCode;
  CopyWith$Input$InvoiceFilterInput<TRes> get invoices;
  CopyWith$Input$FulfillmentFilterInput<TRes> get fulfillments;
  CopyWith$Input$LinesFilterInput<TRes> get lines;
  CopyWith$Input$IntFilterInput<TRes> get linesCount;
  CopyWith$Input$PriceFilterInput<TRes> get totalGross;
  CopyWith$Input$PriceFilterInput<TRes> get totalNet;
  CopyWith$Input$GlobalIDFilterInput<TRes> get productTypeId;
  TRes AND(
      Iterable<Input$OrderWhereInput>? Function(
              Iterable<CopyWith$Input$OrderWhereInput<Input$OrderWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$OrderWhereInput>? Function(
              Iterable<CopyWith$Input$OrderWhereInput<Input$OrderWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$OrderWhereInput<TRes>
    implements CopyWith$Input$OrderWhereInput<TRes> {
  _CopyWithImpl$Input$OrderWhereInput(
    this._instance,
    this._then,
  );

  final Input$OrderWhereInput _instance;

  final TRes Function(Input$OrderWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? metadata = _undefined,
    Object? ids = _undefined,
    Object? number = _undefined,
    Object? channelId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? user = _undefined,
    Object? userEmail = _undefined,
    Object? authorizeStatus = _undefined,
    Object? chargeStatus = _undefined,
    Object? status = _undefined,
    Object? checkoutToken = _undefined,
    Object? checkoutId = _undefined,
    Object? isClickAndCollect = _undefined,
    Object? isPreorder = _undefined,
    Object? isGiftCardUsed = _undefined,
    Object? isGiftCardBought = _undefined,
    Object? voucherCode = _undefined,
    Object? hasInvoices = _undefined,
    Object? invoices = _undefined,
    Object? hasFulfillments = _undefined,
    Object? fulfillments = _undefined,
    Object? lines = _undefined,
    Object? linesCount = _undefined,
    Object? totalGross = _undefined,
    Object? totalNet = _undefined,
    Object? productTypeId = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
  }) =>
      _then(Input$OrderWhereInput._({
        ..._instance._$data,
        if (metadata != _undefined)
          'metadata': (metadata as Input$MetadataFilterInput?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (number != _undefined) 'number': (number as Input$IntFilterInput?),
        if (channelId != _undefined)
          'channelId': (channelId as Input$GlobalIDFilterInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeRangeInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeRangeInput?),
        if (user != _undefined) 'user': (user as Input$GlobalIDFilterInput?),
        if (userEmail != _undefined)
          'userEmail': (userEmail as Input$StringFilterInput?),
        if (authorizeStatus != _undefined)
          'authorizeStatus':
              (authorizeStatus as Input$OrderAuthorizeStatusEnumFilterInput?),
        if (chargeStatus != _undefined)
          'chargeStatus':
              (chargeStatus as Input$OrderChargeStatusEnumFilterInput?),
        if (status != _undefined)
          'status': (status as Input$OrderStatusEnumFilterInput?),
        if (checkoutToken != _undefined)
          'checkoutToken': (checkoutToken as Input$UUIDFilterInput?),
        if (checkoutId != _undefined)
          'checkoutId': (checkoutId as Input$GlobalIDFilterInput?),
        if (isClickAndCollect != _undefined)
          'isClickAndCollect': (isClickAndCollect as bool?),
        if (isPreorder != _undefined) 'isPreorder': (isPreorder as bool?),
        if (isGiftCardUsed != _undefined)
          'isGiftCardUsed': (isGiftCardUsed as bool?),
        if (isGiftCardBought != _undefined)
          'isGiftCardBought': (isGiftCardBought as bool?),
        if (voucherCode != _undefined)
          'voucherCode': (voucherCode as Input$StringFilterInput?),
        if (hasInvoices != _undefined) 'hasInvoices': (hasInvoices as bool?),
        if (invoices != _undefined)
          'invoices': (invoices as Input$InvoiceFilterInput?),
        if (hasFulfillments != _undefined)
          'hasFulfillments': (hasFulfillments as bool?),
        if (fulfillments != _undefined)
          'fulfillments': (fulfillments as Input$FulfillmentFilterInput?),
        if (lines != _undefined) 'lines': (lines as Input$LinesFilterInput?),
        if (linesCount != _undefined)
          'linesCount': (linesCount as Input$IntFilterInput?),
        if (totalGross != _undefined)
          'totalGross': (totalGross as Input$PriceFilterInput?),
        if (totalNet != _undefined)
          'totalNet': (totalNet as Input$PriceFilterInput?),
        if (productTypeId != _undefined)
          'productTypeId': (productTypeId as Input$GlobalIDFilterInput?),
        if (AND != _undefined) 'AND': (AND as List<Input$OrderWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$OrderWhereInput>?),
      }));

  CopyWith$Input$MetadataFilterInput<TRes> get metadata {
    final local$metadata = _instance.metadata;
    return local$metadata == null
        ? CopyWith$Input$MetadataFilterInput.stub(_then(_instance))
        : CopyWith$Input$MetadataFilterInput(
            local$metadata, (e) => call(metadata: e));
  }

  CopyWith$Input$IntFilterInput<TRes> get number {
    final local$number = _instance.number;
    return local$number == null
        ? CopyWith$Input$IntFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntFilterInput(local$number, (e) => call(number: e));
  }

  CopyWith$Input$GlobalIDFilterInput<TRes> get channelId {
    final local$channelId = _instance.channelId;
    return local$channelId == null
        ? CopyWith$Input$GlobalIDFilterInput.stub(_then(_instance))
        : CopyWith$Input$GlobalIDFilterInput(
            local$channelId, (e) => call(channelId: e));
  }

  CopyWith$Input$DateTimeRangeInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeRangeInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeRangeInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$GlobalIDFilterInput<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$Input$GlobalIDFilterInput.stub(_then(_instance))
        : CopyWith$Input$GlobalIDFilterInput(local$user, (e) => call(user: e));
  }

  CopyWith$Input$StringFilterInput<TRes> get userEmail {
    final local$userEmail = _instance.userEmail;
    return local$userEmail == null
        ? CopyWith$Input$StringFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringFilterInput(
            local$userEmail, (e) => call(userEmail: e));
  }

  CopyWith$Input$OrderAuthorizeStatusEnumFilterInput<TRes> get authorizeStatus {
    final local$authorizeStatus = _instance.authorizeStatus;
    return local$authorizeStatus == null
        ? CopyWith$Input$OrderAuthorizeStatusEnumFilterInput.stub(
            _then(_instance))
        : CopyWith$Input$OrderAuthorizeStatusEnumFilterInput(
            local$authorizeStatus, (e) => call(authorizeStatus: e));
  }

  CopyWith$Input$OrderChargeStatusEnumFilterInput<TRes> get chargeStatus {
    final local$chargeStatus = _instance.chargeStatus;
    return local$chargeStatus == null
        ? CopyWith$Input$OrderChargeStatusEnumFilterInput.stub(_then(_instance))
        : CopyWith$Input$OrderChargeStatusEnumFilterInput(
            local$chargeStatus, (e) => call(chargeStatus: e));
  }

  CopyWith$Input$OrderStatusEnumFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$OrderStatusEnumFilterInput.stub(_then(_instance))
        : CopyWith$Input$OrderStatusEnumFilterInput(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$UUIDFilterInput<TRes> get checkoutToken {
    final local$checkoutToken = _instance.checkoutToken;
    return local$checkoutToken == null
        ? CopyWith$Input$UUIDFilterInput.stub(_then(_instance))
        : CopyWith$Input$UUIDFilterInput(
            local$checkoutToken, (e) => call(checkoutToken: e));
  }

  CopyWith$Input$GlobalIDFilterInput<TRes> get checkoutId {
    final local$checkoutId = _instance.checkoutId;
    return local$checkoutId == null
        ? CopyWith$Input$GlobalIDFilterInput.stub(_then(_instance))
        : CopyWith$Input$GlobalIDFilterInput(
            local$checkoutId, (e) => call(checkoutId: e));
  }

  CopyWith$Input$StringFilterInput<TRes> get voucherCode {
    final local$voucherCode = _instance.voucherCode;
    return local$voucherCode == null
        ? CopyWith$Input$StringFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringFilterInput(
            local$voucherCode, (e) => call(voucherCode: e));
  }

  CopyWith$Input$InvoiceFilterInput<TRes> get invoices {
    final local$invoices = _instance.invoices;
    return local$invoices == null
        ? CopyWith$Input$InvoiceFilterInput.stub(_then(_instance))
        : CopyWith$Input$InvoiceFilterInput(
            local$invoices, (e) => call(invoices: e));
  }

  CopyWith$Input$FulfillmentFilterInput<TRes> get fulfillments {
    final local$fulfillments = _instance.fulfillments;
    return local$fulfillments == null
        ? CopyWith$Input$FulfillmentFilterInput.stub(_then(_instance))
        : CopyWith$Input$FulfillmentFilterInput(
            local$fulfillments, (e) => call(fulfillments: e));
  }

  CopyWith$Input$LinesFilterInput<TRes> get lines {
    final local$lines = _instance.lines;
    return local$lines == null
        ? CopyWith$Input$LinesFilterInput.stub(_then(_instance))
        : CopyWith$Input$LinesFilterInput(local$lines, (e) => call(lines: e));
  }

  CopyWith$Input$IntFilterInput<TRes> get linesCount {
    final local$linesCount = _instance.linesCount;
    return local$linesCount == null
        ? CopyWith$Input$IntFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntFilterInput(
            local$linesCount, (e) => call(linesCount: e));
  }

  CopyWith$Input$PriceFilterInput<TRes> get totalGross {
    final local$totalGross = _instance.totalGross;
    return local$totalGross == null
        ? CopyWith$Input$PriceFilterInput.stub(_then(_instance))
        : CopyWith$Input$PriceFilterInput(
            local$totalGross, (e) => call(totalGross: e));
  }

  CopyWith$Input$PriceFilterInput<TRes> get totalNet {
    final local$totalNet = _instance.totalNet;
    return local$totalNet == null
        ? CopyWith$Input$PriceFilterInput.stub(_then(_instance))
        : CopyWith$Input$PriceFilterInput(
            local$totalNet, (e) => call(totalNet: e));
  }

  CopyWith$Input$GlobalIDFilterInput<TRes> get productTypeId {
    final local$productTypeId = _instance.productTypeId;
    return local$productTypeId == null
        ? CopyWith$Input$GlobalIDFilterInput.stub(_then(_instance))
        : CopyWith$Input$GlobalIDFilterInput(
            local$productTypeId, (e) => call(productTypeId: e));
  }

  TRes AND(
          Iterable<Input$OrderWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$OrderWhereInput<Input$OrderWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$OrderWhereInput(
                e,
                (i) => i,
              )))?.toList());

  TRes OR(
          Iterable<Input$OrderWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$OrderWhereInput<Input$OrderWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$OrderWhereInput(
                e,
                (i) => i,
              )))?.toList());
}

class _CopyWithStubImpl$Input$OrderWhereInput<TRes>
    implements CopyWith$Input$OrderWhereInput<TRes> {
  _CopyWithStubImpl$Input$OrderWhereInput(this._res);

  TRes _res;

  call({
    Input$MetadataFilterInput? metadata,
    List<String>? ids,
    Input$IntFilterInput? number,
    Input$GlobalIDFilterInput? channelId,
    Input$DateTimeRangeInput? createdAt,
    Input$DateTimeRangeInput? updatedAt,
    Input$GlobalIDFilterInput? user,
    Input$StringFilterInput? userEmail,
    Input$OrderAuthorizeStatusEnumFilterInput? authorizeStatus,
    Input$OrderChargeStatusEnumFilterInput? chargeStatus,
    Input$OrderStatusEnumFilterInput? status,
    Input$UUIDFilterInput? checkoutToken,
    Input$GlobalIDFilterInput? checkoutId,
    bool? isClickAndCollect,
    bool? isPreorder,
    bool? isGiftCardUsed,
    bool? isGiftCardBought,
    Input$StringFilterInput? voucherCode,
    bool? hasInvoices,
    Input$InvoiceFilterInput? invoices,
    bool? hasFulfillments,
    Input$FulfillmentFilterInput? fulfillments,
    Input$LinesFilterInput? lines,
    Input$IntFilterInput? linesCount,
    Input$PriceFilterInput? totalGross,
    Input$PriceFilterInput? totalNet,
    Input$GlobalIDFilterInput? productTypeId,
    List<Input$OrderWhereInput>? AND,
    List<Input$OrderWhereInput>? OR,
  }) =>
      _res;

  CopyWith$Input$MetadataFilterInput<TRes> get metadata =>
      CopyWith$Input$MetadataFilterInput.stub(_res);

  CopyWith$Input$IntFilterInput<TRes> get number =>
      CopyWith$Input$IntFilterInput.stub(_res);

  CopyWith$Input$GlobalIDFilterInput<TRes> get channelId =>
      CopyWith$Input$GlobalIDFilterInput.stub(_res);

  CopyWith$Input$DateTimeRangeInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeRangeInput.stub(_res);

  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeRangeInput.stub(_res);

  CopyWith$Input$GlobalIDFilterInput<TRes> get user =>
      CopyWith$Input$GlobalIDFilterInput.stub(_res);

  CopyWith$Input$StringFilterInput<TRes> get userEmail =>
      CopyWith$Input$StringFilterInput.stub(_res);

  CopyWith$Input$OrderAuthorizeStatusEnumFilterInput<TRes>
      get authorizeStatus =>
          CopyWith$Input$OrderAuthorizeStatusEnumFilterInput.stub(_res);

  CopyWith$Input$OrderChargeStatusEnumFilterInput<TRes> get chargeStatus =>
      CopyWith$Input$OrderChargeStatusEnumFilterInput.stub(_res);

  CopyWith$Input$OrderStatusEnumFilterInput<TRes> get status =>
      CopyWith$Input$OrderStatusEnumFilterInput.stub(_res);

  CopyWith$Input$UUIDFilterInput<TRes> get checkoutToken =>
      CopyWith$Input$UUIDFilterInput.stub(_res);

  CopyWith$Input$GlobalIDFilterInput<TRes> get checkoutId =>
      CopyWith$Input$GlobalIDFilterInput.stub(_res);

  CopyWith$Input$StringFilterInput<TRes> get voucherCode =>
      CopyWith$Input$StringFilterInput.stub(_res);

  CopyWith$Input$InvoiceFilterInput<TRes> get invoices =>
      CopyWith$Input$InvoiceFilterInput.stub(_res);

  CopyWith$Input$FulfillmentFilterInput<TRes> get fulfillments =>
      CopyWith$Input$FulfillmentFilterInput.stub(_res);

  CopyWith$Input$LinesFilterInput<TRes> get lines =>
      CopyWith$Input$LinesFilterInput.stub(_res);

  CopyWith$Input$IntFilterInput<TRes> get linesCount =>
      CopyWith$Input$IntFilterInput.stub(_res);

  CopyWith$Input$PriceFilterInput<TRes> get totalGross =>
      CopyWith$Input$PriceFilterInput.stub(_res);

  CopyWith$Input$PriceFilterInput<TRes> get totalNet =>
      CopyWith$Input$PriceFilterInput.stub(_res);

  CopyWith$Input$GlobalIDFilterInput<TRes> get productTypeId =>
      CopyWith$Input$GlobalIDFilterInput.stub(_res);

  AND(_fn) => _res;

  OR(_fn) => _res;
}

class Input$PageCreateInput {
  factory Input$PageCreateInput({
    String? slug,
    String? title,
    String? content,
    List<Input$AttributeValueInput>? attributes,
    bool? isPublished,
    String? publicationDate,
    String? publishedAt,
    Input$SeoInput? seo,
    required String pageType,
  }) =>
      Input$PageCreateInput._({
        if (slug != null) r'slug': slug,
        if (title != null) r'title': title,
        if (content != null) r'content': content,
        if (attributes != null) r'attributes': attributes,
        if (isPublished != null) r'isPublished': isPublished,
        if (publicationDate != null) r'publicationDate': publicationDate,
        if (publishedAt != null) r'publishedAt': publishedAt,
        if (seo != null) r'seo': seo,
        r'pageType': pageType,
      });

  Input$PageCreateInput._(this._$data);

  factory Input$PageCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = (l$content as String?);
    }
    if (data.containsKey('attributes')) {
      final l$attributes = data['attributes'];
      result$data['attributes'] = (l$attributes as List<dynamic>?)
          ?.map((e) =>
              Input$AttributeValueInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('isPublished')) {
      final l$isPublished = data['isPublished'];
      result$data['isPublished'] = (l$isPublished as bool?);
    }
    if (data.containsKey('publicationDate')) {
      final l$publicationDate = data['publicationDate'];
      result$data['publicationDate'] = (l$publicationDate as String?);
    }
    if (data.containsKey('publishedAt')) {
      final l$publishedAt = data['publishedAt'];
      result$data['publishedAt'] = (l$publishedAt as String?);
    }
    if (data.containsKey('seo')) {
      final l$seo = data['seo'];
      result$data['seo'] = l$seo == null
          ? null
          : Input$SeoInput.fromJson((l$seo as Map<String, dynamic>));
    }
    final l$pageType = data['pageType'];
    result$data['pageType'] = (l$pageType as String);
    return Input$PageCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get slug => (_$data['slug'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get content => (_$data['content'] as String?);

  List<Input$AttributeValueInput>? get attributes =>
      (_$data['attributes'] as List<Input$AttributeValueInput>?);

  bool? get isPublished => (_$data['isPublished'] as bool?);

  String? get publicationDate => (_$data['publicationDate'] as String?);

  String? get publishedAt => (_$data['publishedAt'] as String?);

  Input$SeoInput? get seo => (_$data['seo'] as Input$SeoInput?);

  String get pageType => (_$data['pageType'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content;
    }
    if (_$data.containsKey('attributes')) {
      final l$attributes = attributes;
      result$data['attributes'] = l$attributes?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('isPublished')) {
      final l$isPublished = isPublished;
      result$data['isPublished'] = l$isPublished;
    }
    if (_$data.containsKey('publicationDate')) {
      final l$publicationDate = publicationDate;
      result$data['publicationDate'] = l$publicationDate;
    }
    if (_$data.containsKey('publishedAt')) {
      final l$publishedAt = publishedAt;
      result$data['publishedAt'] = l$publishedAt;
    }
    if (_$data.containsKey('seo')) {
      final l$seo = seo;
      result$data['seo'] = l$seo?.toJson();
    }
    final l$pageType = pageType;
    result$data['pageType'] = l$pageType;
    return result$data;
  }

  CopyWith$Input$PageCreateInput<Input$PageCreateInput> get copyWith =>
      CopyWith$Input$PageCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PageCreateInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$attributes = attributes;
    final lOther$attributes = other.attributes;
    if (_$data.containsKey('attributes') !=
        other._$data.containsKey('attributes')) {
      return false;
    }
    if (l$attributes != null && lOther$attributes != null) {
      if (l$attributes.length != lOther$attributes.length) {
        return false;
      }
      for (int i = 0; i < l$attributes.length; i++) {
        final l$attributes$entry = l$attributes[i];
        final lOther$attributes$entry = lOther$attributes[i];
        if (l$attributes$entry != lOther$attributes$entry) {
          return false;
        }
      }
    } else if (l$attributes != lOther$attributes) {
      return false;
    }
    final l$isPublished = isPublished;
    final lOther$isPublished = other.isPublished;
    if (_$data.containsKey('isPublished') !=
        other._$data.containsKey('isPublished')) {
      return false;
    }
    if (l$isPublished != lOther$isPublished) {
      return false;
    }
    final l$publicationDate = publicationDate;
    final lOther$publicationDate = other.publicationDate;
    if (_$data.containsKey('publicationDate') !=
        other._$data.containsKey('publicationDate')) {
      return false;
    }
    if (l$publicationDate != lOther$publicationDate) {
      return false;
    }
    final l$publishedAt = publishedAt;
    final lOther$publishedAt = other.publishedAt;
    if (_$data.containsKey('publishedAt') !=
        other._$data.containsKey('publishedAt')) {
      return false;
    }
    if (l$publishedAt != lOther$publishedAt) {
      return false;
    }
    final l$seo = seo;
    final lOther$seo = other.seo;
    if (_$data.containsKey('seo') != other._$data.containsKey('seo')) {
      return false;
    }
    if (l$seo != lOther$seo) {
      return false;
    }
    final l$pageType = pageType;
    final lOther$pageType = other.pageType;
    if (l$pageType != lOther$pageType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$slug = slug;
    final l$title = title;
    final l$content = content;
    final l$attributes = attributes;
    final l$isPublished = isPublished;
    final l$publicationDate = publicationDate;
    final l$publishedAt = publishedAt;
    final l$seo = seo;
    final l$pageType = pageType;
    return Object.hashAll([
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('attributes')
          ? l$attributes == null
              ? null
              : Object.hashAll(l$attributes.map((v) => v))
          : const {},
      _$data.containsKey('isPublished') ? l$isPublished : const {},
      _$data.containsKey('publicationDate') ? l$publicationDate : const {},
      _$data.containsKey('publishedAt') ? l$publishedAt : const {},
      _$data.containsKey('seo') ? l$seo : const {},
      l$pageType,
    ]);
  }
}

abstract class CopyWith$Input$PageCreateInput<TRes> {
  factory CopyWith$Input$PageCreateInput(
    Input$PageCreateInput instance,
    TRes Function(Input$PageCreateInput) then,
  ) = _CopyWithImpl$Input$PageCreateInput;

  factory CopyWith$Input$PageCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PageCreateInput;

  TRes call({
    String? slug,
    String? title,
    String? content,
    List<Input$AttributeValueInput>? attributes,
    bool? isPublished,
    String? publicationDate,
    String? publishedAt,
    Input$SeoInput? seo,
    String? pageType,
  });
  TRes attributes(
      Iterable<Input$AttributeValueInput>? Function(
              Iterable<
                  CopyWith$Input$AttributeValueInput<
                      Input$AttributeValueInput>>?)
          _fn);
  CopyWith$Input$SeoInput<TRes> get seo;
}

class _CopyWithImpl$Input$PageCreateInput<TRes>
    implements CopyWith$Input$PageCreateInput<TRes> {
  _CopyWithImpl$Input$PageCreateInput(
    this._instance,
    this._then,
  );

  final Input$PageCreateInput _instance;

  final TRes Function(Input$PageCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? slug = _undefined,
    Object? title = _undefined,
    Object? content = _undefined,
    Object? attributes = _undefined,
    Object? isPublished = _undefined,
    Object? publicationDate = _undefined,
    Object? publishedAt = _undefined,
    Object? seo = _undefined,
    Object? pageType = _undefined,
  }) =>
      _then(Input$PageCreateInput._({
        ..._instance._$data,
        if (slug != _undefined) 'slug': (slug as String?),
        if (title != _undefined) 'title': (title as String?),
        if (content != _undefined) 'content': (content as String?),
        if (attributes != _undefined)
          'attributes': (attributes as List<Input$AttributeValueInput>?),
        if (isPublished != _undefined) 'isPublished': (isPublished as bool?),
        if (publicationDate != _undefined)
          'publicationDate': (publicationDate as String?),
        if (publishedAt != _undefined) 'publishedAt': (publishedAt as String?),
        if (seo != _undefined) 'seo': (seo as Input$SeoInput?),
        if (pageType != _undefined && pageType != null)
          'pageType': (pageType as String),
      }));

  TRes attributes(
          Iterable<Input$AttributeValueInput>? Function(
                  Iterable<
                      CopyWith$Input$AttributeValueInput<
                          Input$AttributeValueInput>>?)
              _fn) =>
      call(
          attributes: _fn(_instance.attributes
              ?.map((e) => CopyWith$Input$AttributeValueInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$SeoInput<TRes> get seo {
    final local$seo = _instance.seo;
    return local$seo == null
        ? CopyWith$Input$SeoInput.stub(_then(_instance))
        : CopyWith$Input$SeoInput(local$seo, (e) => call(seo: e));
  }
}

class _CopyWithStubImpl$Input$PageCreateInput<TRes>
    implements CopyWith$Input$PageCreateInput<TRes> {
  _CopyWithStubImpl$Input$PageCreateInput(this._res);

  TRes _res;

  call({
    String? slug,
    String? title,
    String? content,
    List<Input$AttributeValueInput>? attributes,
    bool? isPublished,
    String? publicationDate,
    String? publishedAt,
    Input$SeoInput? seo,
    String? pageType,
  }) =>
      _res;

  attributes(_fn) => _res;

  CopyWith$Input$SeoInput<TRes> get seo => CopyWith$Input$SeoInput.stub(_res);
}

class Input$PageFilterInput {
  factory Input$PageFilterInput({
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? pageTypes,
    List<String>? ids,
    List<String>? slugs,
  }) =>
      Input$PageFilterInput._({
        if (search != null) r'search': search,
        if (metadata != null) r'metadata': metadata,
        if (pageTypes != null) r'pageTypes': pageTypes,
        if (ids != null) r'ids': ids,
        if (slugs != null) r'slugs': slugs,
      });

  Input$PageFilterInput._(this._$data);

  factory Input$PageFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('pageTypes')) {
      final l$pageTypes = data['pageTypes'];
      result$data['pageTypes'] =
          (l$pageTypes as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('slugs')) {
      final l$slugs = data['slugs'];
      result$data['slugs'] =
          (l$slugs as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$PageFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get search => (_$data['search'] as String?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get pageTypes => (_$data['pageTypes'] as List<String>?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  List<String>? get slugs => (_$data['slugs'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('pageTypes')) {
      final l$pageTypes = pageTypes;
      result$data['pageTypes'] = l$pageTypes?.map((e) => e).toList();
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('slugs')) {
      final l$slugs = slugs;
      result$data['slugs'] = l$slugs?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$PageFilterInput<Input$PageFilterInput> get copyWith =>
      CopyWith$Input$PageFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PageFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$pageTypes = pageTypes;
    final lOther$pageTypes = other.pageTypes;
    if (_$data.containsKey('pageTypes') !=
        other._$data.containsKey('pageTypes')) {
      return false;
    }
    if (l$pageTypes != null && lOther$pageTypes != null) {
      if (l$pageTypes.length != lOther$pageTypes.length) {
        return false;
      }
      for (int i = 0; i < l$pageTypes.length; i++) {
        final l$pageTypes$entry = l$pageTypes[i];
        final lOther$pageTypes$entry = lOther$pageTypes[i];
        if (l$pageTypes$entry != lOther$pageTypes$entry) {
          return false;
        }
      }
    } else if (l$pageTypes != lOther$pageTypes) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$slugs = slugs;
    final lOther$slugs = other.slugs;
    if (_$data.containsKey('slugs') != other._$data.containsKey('slugs')) {
      return false;
    }
    if (l$slugs != null && lOther$slugs != null) {
      if (l$slugs.length != lOther$slugs.length) {
        return false;
      }
      for (int i = 0; i < l$slugs.length; i++) {
        final l$slugs$entry = l$slugs[i];
        final lOther$slugs$entry = lOther$slugs[i];
        if (l$slugs$entry != lOther$slugs$entry) {
          return false;
        }
      }
    } else if (l$slugs != lOther$slugs) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$search = search;
    final l$metadata = metadata;
    final l$pageTypes = pageTypes;
    final l$ids = ids;
    final l$slugs = slugs;
    return Object.hashAll([
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('pageTypes')
          ? l$pageTypes == null
              ? null
              : Object.hashAll(l$pageTypes.map((v) => v))
          : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('slugs')
          ? l$slugs == null
              ? null
              : Object.hashAll(l$slugs.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PageFilterInput<TRes> {
  factory CopyWith$Input$PageFilterInput(
    Input$PageFilterInput instance,
    TRes Function(Input$PageFilterInput) then,
  ) = _CopyWithImpl$Input$PageFilterInput;

  factory CopyWith$Input$PageFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PageFilterInput;

  TRes call({
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? pageTypes,
    List<String>? ids,
    List<String>? slugs,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
}

class _CopyWithImpl$Input$PageFilterInput<TRes>
    implements CopyWith$Input$PageFilterInput<TRes> {
  _CopyWithImpl$Input$PageFilterInput(
    this._instance,
    this._then,
  );

  final Input$PageFilterInput _instance;

  final TRes Function(Input$PageFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? search = _undefined,
    Object? metadata = _undefined,
    Object? pageTypes = _undefined,
    Object? ids = _undefined,
    Object? slugs = _undefined,
  }) =>
      _then(Input$PageFilterInput._({
        ..._instance._$data,
        if (search != _undefined) 'search': (search as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (pageTypes != _undefined) 'pageTypes': (pageTypes as List<String>?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (slugs != _undefined) 'slugs': (slugs as List<String>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$PageFilterInput<TRes>
    implements CopyWith$Input$PageFilterInput<TRes> {
  _CopyWithStubImpl$Input$PageFilterInput(this._res);

  TRes _res;

  call({
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? pageTypes,
    List<String>? ids,
    List<String>? slugs,
  }) =>
      _res;

  metadata(_fn) => _res;
}

class Input$PageInput {
  factory Input$PageInput({
    String? slug,
    String? title,
    String? content,
    List<Input$AttributeValueInput>? attributes,
    bool? isPublished,
    String? publicationDate,
    String? publishedAt,
    Input$SeoInput? seo,
  }) =>
      Input$PageInput._({
        if (slug != null) r'slug': slug,
        if (title != null) r'title': title,
        if (content != null) r'content': content,
        if (attributes != null) r'attributes': attributes,
        if (isPublished != null) r'isPublished': isPublished,
        if (publicationDate != null) r'publicationDate': publicationDate,
        if (publishedAt != null) r'publishedAt': publishedAt,
        if (seo != null) r'seo': seo,
      });

  Input$PageInput._(this._$data);

  factory Input$PageInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = (l$content as String?);
    }
    if (data.containsKey('attributes')) {
      final l$attributes = data['attributes'];
      result$data['attributes'] = (l$attributes as List<dynamic>?)
          ?.map((e) =>
              Input$AttributeValueInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('isPublished')) {
      final l$isPublished = data['isPublished'];
      result$data['isPublished'] = (l$isPublished as bool?);
    }
    if (data.containsKey('publicationDate')) {
      final l$publicationDate = data['publicationDate'];
      result$data['publicationDate'] = (l$publicationDate as String?);
    }
    if (data.containsKey('publishedAt')) {
      final l$publishedAt = data['publishedAt'];
      result$data['publishedAt'] = (l$publishedAt as String?);
    }
    if (data.containsKey('seo')) {
      final l$seo = data['seo'];
      result$data['seo'] = l$seo == null
          ? null
          : Input$SeoInput.fromJson((l$seo as Map<String, dynamic>));
    }
    return Input$PageInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get slug => (_$data['slug'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get content => (_$data['content'] as String?);

  List<Input$AttributeValueInput>? get attributes =>
      (_$data['attributes'] as List<Input$AttributeValueInput>?);

  bool? get isPublished => (_$data['isPublished'] as bool?);

  String? get publicationDate => (_$data['publicationDate'] as String?);

  String? get publishedAt => (_$data['publishedAt'] as String?);

  Input$SeoInput? get seo => (_$data['seo'] as Input$SeoInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content;
    }
    if (_$data.containsKey('attributes')) {
      final l$attributes = attributes;
      result$data['attributes'] = l$attributes?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('isPublished')) {
      final l$isPublished = isPublished;
      result$data['isPublished'] = l$isPublished;
    }
    if (_$data.containsKey('publicationDate')) {
      final l$publicationDate = publicationDate;
      result$data['publicationDate'] = l$publicationDate;
    }
    if (_$data.containsKey('publishedAt')) {
      final l$publishedAt = publishedAt;
      result$data['publishedAt'] = l$publishedAt;
    }
    if (_$data.containsKey('seo')) {
      final l$seo = seo;
      result$data['seo'] = l$seo?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PageInput<Input$PageInput> get copyWith =>
      CopyWith$Input$PageInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PageInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$attributes = attributes;
    final lOther$attributes = other.attributes;
    if (_$data.containsKey('attributes') !=
        other._$data.containsKey('attributes')) {
      return false;
    }
    if (l$attributes != null && lOther$attributes != null) {
      if (l$attributes.length != lOther$attributes.length) {
        return false;
      }
      for (int i = 0; i < l$attributes.length; i++) {
        final l$attributes$entry = l$attributes[i];
        final lOther$attributes$entry = lOther$attributes[i];
        if (l$attributes$entry != lOther$attributes$entry) {
          return false;
        }
      }
    } else if (l$attributes != lOther$attributes) {
      return false;
    }
    final l$isPublished = isPublished;
    final lOther$isPublished = other.isPublished;
    if (_$data.containsKey('isPublished') !=
        other._$data.containsKey('isPublished')) {
      return false;
    }
    if (l$isPublished != lOther$isPublished) {
      return false;
    }
    final l$publicationDate = publicationDate;
    final lOther$publicationDate = other.publicationDate;
    if (_$data.containsKey('publicationDate') !=
        other._$data.containsKey('publicationDate')) {
      return false;
    }
    if (l$publicationDate != lOther$publicationDate) {
      return false;
    }
    final l$publishedAt = publishedAt;
    final lOther$publishedAt = other.publishedAt;
    if (_$data.containsKey('publishedAt') !=
        other._$data.containsKey('publishedAt')) {
      return false;
    }
    if (l$publishedAt != lOther$publishedAt) {
      return false;
    }
    final l$seo = seo;
    final lOther$seo = other.seo;
    if (_$data.containsKey('seo') != other._$data.containsKey('seo')) {
      return false;
    }
    if (l$seo != lOther$seo) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$slug = slug;
    final l$title = title;
    final l$content = content;
    final l$attributes = attributes;
    final l$isPublished = isPublished;
    final l$publicationDate = publicationDate;
    final l$publishedAt = publishedAt;
    final l$seo = seo;
    return Object.hashAll([
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('attributes')
          ? l$attributes == null
              ? null
              : Object.hashAll(l$attributes.map((v) => v))
          : const {},
      _$data.containsKey('isPublished') ? l$isPublished : const {},
      _$data.containsKey('publicationDate') ? l$publicationDate : const {},
      _$data.containsKey('publishedAt') ? l$publishedAt : const {},
      _$data.containsKey('seo') ? l$seo : const {},
    ]);
  }
}

abstract class CopyWith$Input$PageInput<TRes> {
  factory CopyWith$Input$PageInput(
    Input$PageInput instance,
    TRes Function(Input$PageInput) then,
  ) = _CopyWithImpl$Input$PageInput;

  factory CopyWith$Input$PageInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PageInput;

  TRes call({
    String? slug,
    String? title,
    String? content,
    List<Input$AttributeValueInput>? attributes,
    bool? isPublished,
    String? publicationDate,
    String? publishedAt,
    Input$SeoInput? seo,
  });
  TRes attributes(
      Iterable<Input$AttributeValueInput>? Function(
              Iterable<
                  CopyWith$Input$AttributeValueInput<
                      Input$AttributeValueInput>>?)
          _fn);
  CopyWith$Input$SeoInput<TRes> get seo;
}

class _CopyWithImpl$Input$PageInput<TRes>
    implements CopyWith$Input$PageInput<TRes> {
  _CopyWithImpl$Input$PageInput(
    this._instance,
    this._then,
  );

  final Input$PageInput _instance;

  final TRes Function(Input$PageInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? slug = _undefined,
    Object? title = _undefined,
    Object? content = _undefined,
    Object? attributes = _undefined,
    Object? isPublished = _undefined,
    Object? publicationDate = _undefined,
    Object? publishedAt = _undefined,
    Object? seo = _undefined,
  }) =>
      _then(Input$PageInput._({
        ..._instance._$data,
        if (slug != _undefined) 'slug': (slug as String?),
        if (title != _undefined) 'title': (title as String?),
        if (content != _undefined) 'content': (content as String?),
        if (attributes != _undefined)
          'attributes': (attributes as List<Input$AttributeValueInput>?),
        if (isPublished != _undefined) 'isPublished': (isPublished as bool?),
        if (publicationDate != _undefined)
          'publicationDate': (publicationDate as String?),
        if (publishedAt != _undefined) 'publishedAt': (publishedAt as String?),
        if (seo != _undefined) 'seo': (seo as Input$SeoInput?),
      }));

  TRes attributes(
          Iterable<Input$AttributeValueInput>? Function(
                  Iterable<
                      CopyWith$Input$AttributeValueInput<
                          Input$AttributeValueInput>>?)
              _fn) =>
      call(
          attributes: _fn(_instance.attributes
              ?.map((e) => CopyWith$Input$AttributeValueInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$SeoInput<TRes> get seo {
    final local$seo = _instance.seo;
    return local$seo == null
        ? CopyWith$Input$SeoInput.stub(_then(_instance))
        : CopyWith$Input$SeoInput(local$seo, (e) => call(seo: e));
  }
}

class _CopyWithStubImpl$Input$PageInput<TRes>
    implements CopyWith$Input$PageInput<TRes> {
  _CopyWithStubImpl$Input$PageInput(this._res);

  TRes _res;

  call({
    String? slug,
    String? title,
    String? content,
    List<Input$AttributeValueInput>? attributes,
    bool? isPublished,
    String? publicationDate,
    String? publishedAt,
    Input$SeoInput? seo,
  }) =>
      _res;

  attributes(_fn) => _res;

  CopyWith$Input$SeoInput<TRes> get seo => CopyWith$Input$SeoInput.stub(_res);
}

class Input$PageSortingInput {
  factory Input$PageSortingInput({
    required Enum$OrderDirection direction,
    required Enum$PageSortField field,
  }) =>
      Input$PageSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$PageSortingInput._(this._$data);

  factory Input$PageSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$PageSortField((l$field as String));
    return Input$PageSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$PageSortField get field => (_$data['field'] as Enum$PageSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$PageSortField(l$field);
    return result$data;
  }

  CopyWith$Input$PageSortingInput<Input$PageSortingInput> get copyWith =>
      CopyWith$Input$PageSortingInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PageSortingInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$PageSortingInput<TRes> {
  factory CopyWith$Input$PageSortingInput(
    Input$PageSortingInput instance,
    TRes Function(Input$PageSortingInput) then,
  ) = _CopyWithImpl$Input$PageSortingInput;

  factory CopyWith$Input$PageSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PageSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$PageSortField? field,
  });
}

class _CopyWithImpl$Input$PageSortingInput<TRes>
    implements CopyWith$Input$PageSortingInput<TRes> {
  _CopyWithImpl$Input$PageSortingInput(
    this._instance,
    this._then,
  );

  final Input$PageSortingInput _instance;

  final TRes Function(Input$PageSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$PageSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$PageSortField),
      }));
}

class _CopyWithStubImpl$Input$PageSortingInput<TRes>
    implements CopyWith$Input$PageSortingInput<TRes> {
  _CopyWithStubImpl$Input$PageSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$PageSortField? field,
  }) =>
      _res;
}

class Input$PageTranslationInput {
  factory Input$PageTranslationInput({
    String? slug,
    String? seoTitle,
    String? seoDescription,
    String? title,
    String? content,
  }) =>
      Input$PageTranslationInput._({
        if (slug != null) r'slug': slug,
        if (seoTitle != null) r'seoTitle': seoTitle,
        if (seoDescription != null) r'seoDescription': seoDescription,
        if (title != null) r'title': title,
        if (content != null) r'content': content,
      });

  Input$PageTranslationInput._(this._$data);

  factory Input$PageTranslationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('seoTitle')) {
      final l$seoTitle = data['seoTitle'];
      result$data['seoTitle'] = (l$seoTitle as String?);
    }
    if (data.containsKey('seoDescription')) {
      final l$seoDescription = data['seoDescription'];
      result$data['seoDescription'] = (l$seoDescription as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = (l$content as String?);
    }
    return Input$PageTranslationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get slug => (_$data['slug'] as String?);

  String? get seoTitle => (_$data['seoTitle'] as String?);

  String? get seoDescription => (_$data['seoDescription'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get content => (_$data['content'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('seoTitle')) {
      final l$seoTitle = seoTitle;
      result$data['seoTitle'] = l$seoTitle;
    }
    if (_$data.containsKey('seoDescription')) {
      final l$seoDescription = seoDescription;
      result$data['seoDescription'] = l$seoDescription;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content;
    }
    return result$data;
  }

  CopyWith$Input$PageTranslationInput<Input$PageTranslationInput>
      get copyWith => CopyWith$Input$PageTranslationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PageTranslationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$seoTitle = seoTitle;
    final lOther$seoTitle = other.seoTitle;
    if (_$data.containsKey('seoTitle') !=
        other._$data.containsKey('seoTitle')) {
      return false;
    }
    if (l$seoTitle != lOther$seoTitle) {
      return false;
    }
    final l$seoDescription = seoDescription;
    final lOther$seoDescription = other.seoDescription;
    if (_$data.containsKey('seoDescription') !=
        other._$data.containsKey('seoDescription')) {
      return false;
    }
    if (l$seoDescription != lOther$seoDescription) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$slug = slug;
    final l$seoTitle = seoTitle;
    final l$seoDescription = seoDescription;
    final l$title = title;
    final l$content = content;
    return Object.hashAll([
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('seoTitle') ? l$seoTitle : const {},
      _$data.containsKey('seoDescription') ? l$seoDescription : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('content') ? l$content : const {},
    ]);
  }
}

abstract class CopyWith$Input$PageTranslationInput<TRes> {
  factory CopyWith$Input$PageTranslationInput(
    Input$PageTranslationInput instance,
    TRes Function(Input$PageTranslationInput) then,
  ) = _CopyWithImpl$Input$PageTranslationInput;

  factory CopyWith$Input$PageTranslationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PageTranslationInput;

  TRes call({
    String? slug,
    String? seoTitle,
    String? seoDescription,
    String? title,
    String? content,
  });
}

class _CopyWithImpl$Input$PageTranslationInput<TRes>
    implements CopyWith$Input$PageTranslationInput<TRes> {
  _CopyWithImpl$Input$PageTranslationInput(
    this._instance,
    this._then,
  );

  final Input$PageTranslationInput _instance;

  final TRes Function(Input$PageTranslationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? slug = _undefined,
    Object? seoTitle = _undefined,
    Object? seoDescription = _undefined,
    Object? title = _undefined,
    Object? content = _undefined,
  }) =>
      _then(Input$PageTranslationInput._({
        ..._instance._$data,
        if (slug != _undefined) 'slug': (slug as String?),
        if (seoTitle != _undefined) 'seoTitle': (seoTitle as String?),
        if (seoDescription != _undefined)
          'seoDescription': (seoDescription as String?),
        if (title != _undefined) 'title': (title as String?),
        if (content != _undefined) 'content': (content as String?),
      }));
}

class _CopyWithStubImpl$Input$PageTranslationInput<TRes>
    implements CopyWith$Input$PageTranslationInput<TRes> {
  _CopyWithStubImpl$Input$PageTranslationInput(this._res);

  TRes _res;

  call({
    String? slug,
    String? seoTitle,
    String? seoDescription,
    String? title,
    String? content,
  }) =>
      _res;
}

class Input$PageTypeCreateInput {
  factory Input$PageTypeCreateInput({
    String? name,
    String? slug,
    List<String>? addAttributes,
  }) =>
      Input$PageTypeCreateInput._({
        if (name != null) r'name': name,
        if (slug != null) r'slug': slug,
        if (addAttributes != null) r'addAttributes': addAttributes,
      });

  Input$PageTypeCreateInput._(this._$data);

  factory Input$PageTypeCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('addAttributes')) {
      final l$addAttributes = data['addAttributes'];
      result$data['addAttributes'] = (l$addAttributes as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$PageTypeCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get slug => (_$data['slug'] as String?);

  List<String>? get addAttributes => (_$data['addAttributes'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('addAttributes')) {
      final l$addAttributes = addAttributes;
      result$data['addAttributes'] = l$addAttributes?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$PageTypeCreateInput<Input$PageTypeCreateInput> get copyWith =>
      CopyWith$Input$PageTypeCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PageTypeCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$addAttributes = addAttributes;
    final lOther$addAttributes = other.addAttributes;
    if (_$data.containsKey('addAttributes') !=
        other._$data.containsKey('addAttributes')) {
      return false;
    }
    if (l$addAttributes != null && lOther$addAttributes != null) {
      if (l$addAttributes.length != lOther$addAttributes.length) {
        return false;
      }
      for (int i = 0; i < l$addAttributes.length; i++) {
        final l$addAttributes$entry = l$addAttributes[i];
        final lOther$addAttributes$entry = lOther$addAttributes[i];
        if (l$addAttributes$entry != lOther$addAttributes$entry) {
          return false;
        }
      }
    } else if (l$addAttributes != lOther$addAttributes) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$addAttributes = addAttributes;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('addAttributes')
          ? l$addAttributes == null
              ? null
              : Object.hashAll(l$addAttributes.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PageTypeCreateInput<TRes> {
  factory CopyWith$Input$PageTypeCreateInput(
    Input$PageTypeCreateInput instance,
    TRes Function(Input$PageTypeCreateInput) then,
  ) = _CopyWithImpl$Input$PageTypeCreateInput;

  factory CopyWith$Input$PageTypeCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PageTypeCreateInput;

  TRes call({
    String? name,
    String? slug,
    List<String>? addAttributes,
  });
}

class _CopyWithImpl$Input$PageTypeCreateInput<TRes>
    implements CopyWith$Input$PageTypeCreateInput<TRes> {
  _CopyWithImpl$Input$PageTypeCreateInput(
    this._instance,
    this._then,
  );

  final Input$PageTypeCreateInput _instance;

  final TRes Function(Input$PageTypeCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? addAttributes = _undefined,
  }) =>
      _then(Input$PageTypeCreateInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (slug != _undefined) 'slug': (slug as String?),
        if (addAttributes != _undefined)
          'addAttributes': (addAttributes as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$PageTypeCreateInput<TRes>
    implements CopyWith$Input$PageTypeCreateInput<TRes> {
  _CopyWithStubImpl$Input$PageTypeCreateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? slug,
    List<String>? addAttributes,
  }) =>
      _res;
}

class Input$PageTypeFilterInput {
  factory Input$PageTypeFilterInput({
    String? search,
    List<String>? slugs,
  }) =>
      Input$PageTypeFilterInput._({
        if (search != null) r'search': search,
        if (slugs != null) r'slugs': slugs,
      });

  Input$PageTypeFilterInput._(this._$data);

  factory Input$PageTypeFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('slugs')) {
      final l$slugs = data['slugs'];
      result$data['slugs'] =
          (l$slugs as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$PageTypeFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get search => (_$data['search'] as String?);

  List<String>? get slugs => (_$data['slugs'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('slugs')) {
      final l$slugs = slugs;
      result$data['slugs'] = l$slugs?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$PageTypeFilterInput<Input$PageTypeFilterInput> get copyWith =>
      CopyWith$Input$PageTypeFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PageTypeFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$slugs = slugs;
    final lOther$slugs = other.slugs;
    if (_$data.containsKey('slugs') != other._$data.containsKey('slugs')) {
      return false;
    }
    if (l$slugs != null && lOther$slugs != null) {
      if (l$slugs.length != lOther$slugs.length) {
        return false;
      }
      for (int i = 0; i < l$slugs.length; i++) {
        final l$slugs$entry = l$slugs[i];
        final lOther$slugs$entry = lOther$slugs[i];
        if (l$slugs$entry != lOther$slugs$entry) {
          return false;
        }
      }
    } else if (l$slugs != lOther$slugs) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$search = search;
    final l$slugs = slugs;
    return Object.hashAll([
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('slugs')
          ? l$slugs == null
              ? null
              : Object.hashAll(l$slugs.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PageTypeFilterInput<TRes> {
  factory CopyWith$Input$PageTypeFilterInput(
    Input$PageTypeFilterInput instance,
    TRes Function(Input$PageTypeFilterInput) then,
  ) = _CopyWithImpl$Input$PageTypeFilterInput;

  factory CopyWith$Input$PageTypeFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PageTypeFilterInput;

  TRes call({
    String? search,
    List<String>? slugs,
  });
}

class _CopyWithImpl$Input$PageTypeFilterInput<TRes>
    implements CopyWith$Input$PageTypeFilterInput<TRes> {
  _CopyWithImpl$Input$PageTypeFilterInput(
    this._instance,
    this._then,
  );

  final Input$PageTypeFilterInput _instance;

  final TRes Function(Input$PageTypeFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? search = _undefined,
    Object? slugs = _undefined,
  }) =>
      _then(Input$PageTypeFilterInput._({
        ..._instance._$data,
        if (search != _undefined) 'search': (search as String?),
        if (slugs != _undefined) 'slugs': (slugs as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$PageTypeFilterInput<TRes>
    implements CopyWith$Input$PageTypeFilterInput<TRes> {
  _CopyWithStubImpl$Input$PageTypeFilterInput(this._res);

  TRes _res;

  call({
    String? search,
    List<String>? slugs,
  }) =>
      _res;
}

class Input$PageTypeSortingInput {
  factory Input$PageTypeSortingInput({
    required Enum$OrderDirection direction,
    required Enum$PageTypeSortField field,
  }) =>
      Input$PageTypeSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$PageTypeSortingInput._(this._$data);

  factory Input$PageTypeSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$PageTypeSortField((l$field as String));
    return Input$PageTypeSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$PageTypeSortField get field =>
      (_$data['field'] as Enum$PageTypeSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$PageTypeSortField(l$field);
    return result$data;
  }

  CopyWith$Input$PageTypeSortingInput<Input$PageTypeSortingInput>
      get copyWith => CopyWith$Input$PageTypeSortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PageTypeSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$PageTypeSortingInput<TRes> {
  factory CopyWith$Input$PageTypeSortingInput(
    Input$PageTypeSortingInput instance,
    TRes Function(Input$PageTypeSortingInput) then,
  ) = _CopyWithImpl$Input$PageTypeSortingInput;

  factory CopyWith$Input$PageTypeSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PageTypeSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$PageTypeSortField? field,
  });
}

class _CopyWithImpl$Input$PageTypeSortingInput<TRes>
    implements CopyWith$Input$PageTypeSortingInput<TRes> {
  _CopyWithImpl$Input$PageTypeSortingInput(
    this._instance,
    this._then,
  );

  final Input$PageTypeSortingInput _instance;

  final TRes Function(Input$PageTypeSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$PageTypeSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$PageTypeSortField),
      }));
}

class _CopyWithStubImpl$Input$PageTypeSortingInput<TRes>
    implements CopyWith$Input$PageTypeSortingInput<TRes> {
  _CopyWithStubImpl$Input$PageTypeSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$PageTypeSortField? field,
  }) =>
      _res;
}

class Input$PageTypeUpdateInput {
  factory Input$PageTypeUpdateInput({
    String? name,
    String? slug,
    List<String>? addAttributes,
    List<String>? removeAttributes,
  }) =>
      Input$PageTypeUpdateInput._({
        if (name != null) r'name': name,
        if (slug != null) r'slug': slug,
        if (addAttributes != null) r'addAttributes': addAttributes,
        if (removeAttributes != null) r'removeAttributes': removeAttributes,
      });

  Input$PageTypeUpdateInput._(this._$data);

  factory Input$PageTypeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('addAttributes')) {
      final l$addAttributes = data['addAttributes'];
      result$data['addAttributes'] = (l$addAttributes as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('removeAttributes')) {
      final l$removeAttributes = data['removeAttributes'];
      result$data['removeAttributes'] = (l$removeAttributes as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$PageTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get slug => (_$data['slug'] as String?);

  List<String>? get addAttributes => (_$data['addAttributes'] as List<String>?);

  List<String>? get removeAttributes =>
      (_$data['removeAttributes'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('addAttributes')) {
      final l$addAttributes = addAttributes;
      result$data['addAttributes'] = l$addAttributes?.map((e) => e).toList();
    }
    if (_$data.containsKey('removeAttributes')) {
      final l$removeAttributes = removeAttributes;
      result$data['removeAttributes'] =
          l$removeAttributes?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$PageTypeUpdateInput<Input$PageTypeUpdateInput> get copyWith =>
      CopyWith$Input$PageTypeUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PageTypeUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$addAttributes = addAttributes;
    final lOther$addAttributes = other.addAttributes;
    if (_$data.containsKey('addAttributes') !=
        other._$data.containsKey('addAttributes')) {
      return false;
    }
    if (l$addAttributes != null && lOther$addAttributes != null) {
      if (l$addAttributes.length != lOther$addAttributes.length) {
        return false;
      }
      for (int i = 0; i < l$addAttributes.length; i++) {
        final l$addAttributes$entry = l$addAttributes[i];
        final lOther$addAttributes$entry = lOther$addAttributes[i];
        if (l$addAttributes$entry != lOther$addAttributes$entry) {
          return false;
        }
      }
    } else if (l$addAttributes != lOther$addAttributes) {
      return false;
    }
    final l$removeAttributes = removeAttributes;
    final lOther$removeAttributes = other.removeAttributes;
    if (_$data.containsKey('removeAttributes') !=
        other._$data.containsKey('removeAttributes')) {
      return false;
    }
    if (l$removeAttributes != null && lOther$removeAttributes != null) {
      if (l$removeAttributes.length != lOther$removeAttributes.length) {
        return false;
      }
      for (int i = 0; i < l$removeAttributes.length; i++) {
        final l$removeAttributes$entry = l$removeAttributes[i];
        final lOther$removeAttributes$entry = lOther$removeAttributes[i];
        if (l$removeAttributes$entry != lOther$removeAttributes$entry) {
          return false;
        }
      }
    } else if (l$removeAttributes != lOther$removeAttributes) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$addAttributes = addAttributes;
    final l$removeAttributes = removeAttributes;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('addAttributes')
          ? l$addAttributes == null
              ? null
              : Object.hashAll(l$addAttributes.map((v) => v))
          : const {},
      _$data.containsKey('removeAttributes')
          ? l$removeAttributes == null
              ? null
              : Object.hashAll(l$removeAttributes.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PageTypeUpdateInput<TRes> {
  factory CopyWith$Input$PageTypeUpdateInput(
    Input$PageTypeUpdateInput instance,
    TRes Function(Input$PageTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$PageTypeUpdateInput;

  factory CopyWith$Input$PageTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PageTypeUpdateInput;

  TRes call({
    String? name,
    String? slug,
    List<String>? addAttributes,
    List<String>? removeAttributes,
  });
}

class _CopyWithImpl$Input$PageTypeUpdateInput<TRes>
    implements CopyWith$Input$PageTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$PageTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$PageTypeUpdateInput _instance;

  final TRes Function(Input$PageTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? addAttributes = _undefined,
    Object? removeAttributes = _undefined,
  }) =>
      _then(Input$PageTypeUpdateInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (slug != _undefined) 'slug': (slug as String?),
        if (addAttributes != _undefined)
          'addAttributes': (addAttributes as List<String>?),
        if (removeAttributes != _undefined)
          'removeAttributes': (removeAttributes as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$PageTypeUpdateInput<TRes>
    implements CopyWith$Input$PageTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$PageTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? slug,
    List<String>? addAttributes,
    List<String>? removeAttributes,
  }) =>
      _res;
}

class Input$PaymentCheckBalanceInput {
  factory Input$PaymentCheckBalanceInput({
    required String gatewayId,
    required String method,
    required String channel,
    required Input$CardInput card,
  }) =>
      Input$PaymentCheckBalanceInput._({
        r'gatewayId': gatewayId,
        r'method': method,
        r'channel': channel,
        r'card': card,
      });

  Input$PaymentCheckBalanceInput._(this._$data);

  factory Input$PaymentCheckBalanceInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$gatewayId = data['gatewayId'];
    result$data['gatewayId'] = (l$gatewayId as String);
    final l$method = data['method'];
    result$data['method'] = (l$method as String);
    final l$channel = data['channel'];
    result$data['channel'] = (l$channel as String);
    final l$card = data['card'];
    result$data['card'] =
        Input$CardInput.fromJson((l$card as Map<String, dynamic>));
    return Input$PaymentCheckBalanceInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get gatewayId => (_$data['gatewayId'] as String);

  String get method => (_$data['method'] as String);

  String get channel => (_$data['channel'] as String);

  Input$CardInput get card => (_$data['card'] as Input$CardInput);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$gatewayId = gatewayId;
    result$data['gatewayId'] = l$gatewayId;
    final l$method = method;
    result$data['method'] = l$method;
    final l$channel = channel;
    result$data['channel'] = l$channel;
    final l$card = card;
    result$data['card'] = l$card.toJson();
    return result$data;
  }

  CopyWith$Input$PaymentCheckBalanceInput<Input$PaymentCheckBalanceInput>
      get copyWith => CopyWith$Input$PaymentCheckBalanceInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PaymentCheckBalanceInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$gatewayId = gatewayId;
    final lOther$gatewayId = other.gatewayId;
    if (l$gatewayId != lOther$gatewayId) {
      return false;
    }
    final l$method = method;
    final lOther$method = other.method;
    if (l$method != lOther$method) {
      return false;
    }
    final l$channel = channel;
    final lOther$channel = other.channel;
    if (l$channel != lOther$channel) {
      return false;
    }
    final l$card = card;
    final lOther$card = other.card;
    if (l$card != lOther$card) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$gatewayId = gatewayId;
    final l$method = method;
    final l$channel = channel;
    final l$card = card;
    return Object.hashAll([
      l$gatewayId,
      l$method,
      l$channel,
      l$card,
    ]);
  }
}

abstract class CopyWith$Input$PaymentCheckBalanceInput<TRes> {
  factory CopyWith$Input$PaymentCheckBalanceInput(
    Input$PaymentCheckBalanceInput instance,
    TRes Function(Input$PaymentCheckBalanceInput) then,
  ) = _CopyWithImpl$Input$PaymentCheckBalanceInput;

  factory CopyWith$Input$PaymentCheckBalanceInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PaymentCheckBalanceInput;

  TRes call({
    String? gatewayId,
    String? method,
    String? channel,
    Input$CardInput? card,
  });
  CopyWith$Input$CardInput<TRes> get card;
}

class _CopyWithImpl$Input$PaymentCheckBalanceInput<TRes>
    implements CopyWith$Input$PaymentCheckBalanceInput<TRes> {
  _CopyWithImpl$Input$PaymentCheckBalanceInput(
    this._instance,
    this._then,
  );

  final Input$PaymentCheckBalanceInput _instance;

  final TRes Function(Input$PaymentCheckBalanceInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? gatewayId = _undefined,
    Object? method = _undefined,
    Object? channel = _undefined,
    Object? card = _undefined,
  }) =>
      _then(Input$PaymentCheckBalanceInput._({
        ..._instance._$data,
        if (gatewayId != _undefined && gatewayId != null)
          'gatewayId': (gatewayId as String),
        if (method != _undefined && method != null)
          'method': (method as String),
        if (channel != _undefined && channel != null)
          'channel': (channel as String),
        if (card != _undefined && card != null)
          'card': (card as Input$CardInput),
      }));

  CopyWith$Input$CardInput<TRes> get card {
    final local$card = _instance.card;
    return CopyWith$Input$CardInput(local$card, (e) => call(card: e));
  }
}

class _CopyWithStubImpl$Input$PaymentCheckBalanceInput<TRes>
    implements CopyWith$Input$PaymentCheckBalanceInput<TRes> {
  _CopyWithStubImpl$Input$PaymentCheckBalanceInput(this._res);

  TRes _res;

  call({
    String? gatewayId,
    String? method,
    String? channel,
    Input$CardInput? card,
  }) =>
      _res;

  CopyWith$Input$CardInput<TRes> get card =>
      CopyWith$Input$CardInput.stub(_res);
}

class Input$PaymentFilterInput {
  factory Input$PaymentFilterInput({
    List<String>? ids,
    List<String>? checkouts,
  }) =>
      Input$PaymentFilterInput._({
        if (ids != null) r'ids': ids,
        if (checkouts != null) r'checkouts': checkouts,
      });

  Input$PaymentFilterInput._(this._$data);

  factory Input$PaymentFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('checkouts')) {
      final l$checkouts = data['checkouts'];
      result$data['checkouts'] =
          (l$checkouts as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$PaymentFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get ids => (_$data['ids'] as List<String>?);

  List<String>? get checkouts => (_$data['checkouts'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('checkouts')) {
      final l$checkouts = checkouts;
      result$data['checkouts'] = l$checkouts?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$PaymentFilterInput<Input$PaymentFilterInput> get copyWith =>
      CopyWith$Input$PaymentFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PaymentFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$checkouts = checkouts;
    final lOther$checkouts = other.checkouts;
    if (_$data.containsKey('checkouts') !=
        other._$data.containsKey('checkouts')) {
      return false;
    }
    if (l$checkouts != null && lOther$checkouts != null) {
      if (l$checkouts.length != lOther$checkouts.length) {
        return false;
      }
      for (int i = 0; i < l$checkouts.length; i++) {
        final l$checkouts$entry = l$checkouts[i];
        final lOther$checkouts$entry = lOther$checkouts[i];
        if (l$checkouts$entry != lOther$checkouts$entry) {
          return false;
        }
      }
    } else if (l$checkouts != lOther$checkouts) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$ids = ids;
    final l$checkouts = checkouts;
    return Object.hashAll([
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('checkouts')
          ? l$checkouts == null
              ? null
              : Object.hashAll(l$checkouts.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PaymentFilterInput<TRes> {
  factory CopyWith$Input$PaymentFilterInput(
    Input$PaymentFilterInput instance,
    TRes Function(Input$PaymentFilterInput) then,
  ) = _CopyWithImpl$Input$PaymentFilterInput;

  factory CopyWith$Input$PaymentFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PaymentFilterInput;

  TRes call({
    List<String>? ids,
    List<String>? checkouts,
  });
}

class _CopyWithImpl$Input$PaymentFilterInput<TRes>
    implements CopyWith$Input$PaymentFilterInput<TRes> {
  _CopyWithImpl$Input$PaymentFilterInput(
    this._instance,
    this._then,
  );

  final Input$PaymentFilterInput _instance;

  final TRes Function(Input$PaymentFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? ids = _undefined,
    Object? checkouts = _undefined,
  }) =>
      _then(Input$PaymentFilterInput._({
        ..._instance._$data,
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (checkouts != _undefined) 'checkouts': (checkouts as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$PaymentFilterInput<TRes>
    implements CopyWith$Input$PaymentFilterInput<TRes> {
  _CopyWithStubImpl$Input$PaymentFilterInput(this._res);

  TRes _res;

  call({
    List<String>? ids,
    List<String>? checkouts,
  }) =>
      _res;
}

class Input$PaymentGatewayToInitialize {
  factory Input$PaymentGatewayToInitialize({
    required String id,
    String? data,
  }) =>
      Input$PaymentGatewayToInitialize._({
        r'id': id,
        if (data != null) r'data': data,
      });

  Input$PaymentGatewayToInitialize._(this._$data);

  factory Input$PaymentGatewayToInitialize.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('data')) {
      final l$data = data['data'];
      result$data['data'] = (l$data as String?);
    }
    return Input$PaymentGatewayToInitialize._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);

  String? get data => (_$data['data'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('data')) {
      final l$data = data;
      result$data['data'] = l$data;
    }
    return result$data;
  }

  CopyWith$Input$PaymentGatewayToInitialize<Input$PaymentGatewayToInitialize>
      get copyWith => CopyWith$Input$PaymentGatewayToInitialize(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PaymentGatewayToInitialize ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (_$data.containsKey('data') != other._$data.containsKey('data')) {
      return false;
    }
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$data = data;
    return Object.hashAll([
      l$id,
      _$data.containsKey('data') ? l$data : const {},
    ]);
  }
}

abstract class CopyWith$Input$PaymentGatewayToInitialize<TRes> {
  factory CopyWith$Input$PaymentGatewayToInitialize(
    Input$PaymentGatewayToInitialize instance,
    TRes Function(Input$PaymentGatewayToInitialize) then,
  ) = _CopyWithImpl$Input$PaymentGatewayToInitialize;

  factory CopyWith$Input$PaymentGatewayToInitialize.stub(TRes res) =
      _CopyWithStubImpl$Input$PaymentGatewayToInitialize;

  TRes call({
    String? id,
    String? data,
  });
}

class _CopyWithImpl$Input$PaymentGatewayToInitialize<TRes>
    implements CopyWith$Input$PaymentGatewayToInitialize<TRes> {
  _CopyWithImpl$Input$PaymentGatewayToInitialize(
    this._instance,
    this._then,
  );

  final Input$PaymentGatewayToInitialize _instance;

  final TRes Function(Input$PaymentGatewayToInitialize) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$PaymentGatewayToInitialize._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (data != _undefined) 'data': (data as String?),
      }));
}

class _CopyWithStubImpl$Input$PaymentGatewayToInitialize<TRes>
    implements CopyWith$Input$PaymentGatewayToInitialize<TRes> {
  _CopyWithStubImpl$Input$PaymentGatewayToInitialize(this._res);

  TRes _res;

  call({
    String? id,
    String? data,
  }) =>
      _res;
}

class Input$PaymentInput {
  factory Input$PaymentInput({
    required String gateway,
    String? token,
    String? amount,
    String? returnUrl,
    Enum$StorePaymentMethodEnum? storePaymentMethod,
    List<Input$MetadataInput>? metadata,
  }) =>
      Input$PaymentInput._({
        r'gateway': gateway,
        if (token != null) r'token': token,
        if (amount != null) r'amount': amount,
        if (returnUrl != null) r'returnUrl': returnUrl,
        if (storePaymentMethod != null)
          r'storePaymentMethod': storePaymentMethod,
        if (metadata != null) r'metadata': metadata,
      });

  Input$PaymentInput._(this._$data);

  factory Input$PaymentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$gateway = data['gateway'];
    result$data['gateway'] = (l$gateway as String);
    if (data.containsKey('token')) {
      final l$token = data['token'];
      result$data['token'] = (l$token as String?);
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = (l$amount as String?);
    }
    if (data.containsKey('returnUrl')) {
      final l$returnUrl = data['returnUrl'];
      result$data['returnUrl'] = (l$returnUrl as String?);
    }
    if (data.containsKey('storePaymentMethod')) {
      final l$storePaymentMethod = data['storePaymentMethod'];
      result$data['storePaymentMethod'] = l$storePaymentMethod == null
          ? null
          : fromJson$Enum$StorePaymentMethodEnum(
              (l$storePaymentMethod as String));
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$PaymentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get gateway => (_$data['gateway'] as String);

  String? get token => (_$data['token'] as String?);

  String? get amount => (_$data['amount'] as String?);

  String? get returnUrl => (_$data['returnUrl'] as String?);

  Enum$StorePaymentMethodEnum? get storePaymentMethod =>
      (_$data['storePaymentMethod'] as Enum$StorePaymentMethodEnum?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$gateway = gateway;
    result$data['gateway'] = l$gateway;
    if (_$data.containsKey('token')) {
      final l$token = token;
      result$data['token'] = l$token;
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount;
    }
    if (_$data.containsKey('returnUrl')) {
      final l$returnUrl = returnUrl;
      result$data['returnUrl'] = l$returnUrl;
    }
    if (_$data.containsKey('storePaymentMethod')) {
      final l$storePaymentMethod = storePaymentMethod;
      result$data['storePaymentMethod'] = l$storePaymentMethod == null
          ? null
          : toJson$Enum$StorePaymentMethodEnum(l$storePaymentMethod);
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$PaymentInput<Input$PaymentInput> get copyWith =>
      CopyWith$Input$PaymentInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PaymentInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$gateway = gateway;
    final lOther$gateway = other.gateway;
    if (l$gateway != lOther$gateway) {
      return false;
    }
    final l$token = token;
    final lOther$token = other.token;
    if (_$data.containsKey('token') != other._$data.containsKey('token')) {
      return false;
    }
    if (l$token != lOther$token) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$returnUrl = returnUrl;
    final lOther$returnUrl = other.returnUrl;
    if (_$data.containsKey('returnUrl') !=
        other._$data.containsKey('returnUrl')) {
      return false;
    }
    if (l$returnUrl != lOther$returnUrl) {
      return false;
    }
    final l$storePaymentMethod = storePaymentMethod;
    final lOther$storePaymentMethod = other.storePaymentMethod;
    if (_$data.containsKey('storePaymentMethod') !=
        other._$data.containsKey('storePaymentMethod')) {
      return false;
    }
    if (l$storePaymentMethod != lOther$storePaymentMethod) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$gateway = gateway;
    final l$token = token;
    final l$amount = amount;
    final l$returnUrl = returnUrl;
    final l$storePaymentMethod = storePaymentMethod;
    final l$metadata = metadata;
    return Object.hashAll([
      l$gateway,
      _$data.containsKey('token') ? l$token : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('returnUrl') ? l$returnUrl : const {},
      _$data.containsKey('storePaymentMethod')
          ? l$storePaymentMethod
          : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PaymentInput<TRes> {
  factory CopyWith$Input$PaymentInput(
    Input$PaymentInput instance,
    TRes Function(Input$PaymentInput) then,
  ) = _CopyWithImpl$Input$PaymentInput;

  factory CopyWith$Input$PaymentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PaymentInput;

  TRes call({
    String? gateway,
    String? token,
    String? amount,
    String? returnUrl,
    Enum$StorePaymentMethodEnum? storePaymentMethod,
    List<Input$MetadataInput>? metadata,
  });
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$PaymentInput<TRes>
    implements CopyWith$Input$PaymentInput<TRes> {
  _CopyWithImpl$Input$PaymentInput(
    this._instance,
    this._then,
  );

  final Input$PaymentInput _instance;

  final TRes Function(Input$PaymentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? gateway = _undefined,
    Object? token = _undefined,
    Object? amount = _undefined,
    Object? returnUrl = _undefined,
    Object? storePaymentMethod = _undefined,
    Object? metadata = _undefined,
  }) =>
      _then(Input$PaymentInput._({
        ..._instance._$data,
        if (gateway != _undefined && gateway != null)
          'gateway': (gateway as String),
        if (token != _undefined) 'token': (token as String?),
        if (amount != _undefined) 'amount': (amount as String?),
        if (returnUrl != _undefined) 'returnUrl': (returnUrl as String?),
        if (storePaymentMethod != _undefined)
          'storePaymentMethod':
              (storePaymentMethod as Enum$StorePaymentMethodEnum?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$PaymentInput<TRes>
    implements CopyWith$Input$PaymentInput<TRes> {
  _CopyWithStubImpl$Input$PaymentInput(this._res);

  TRes _res;

  call({
    String? gateway,
    String? token,
    String? amount,
    String? returnUrl,
    Enum$StorePaymentMethodEnum? storePaymentMethod,
    List<Input$MetadataInput>? metadata,
  }) =>
      _res;

  metadata(_fn) => _res;
}

class Input$PaymentSettingsInput {
  factory Input$PaymentSettingsInput(
          {Enum$TransactionFlowStrategyEnum? defaultTransactionFlowStrategy}) =>
      Input$PaymentSettingsInput._({
        if (defaultTransactionFlowStrategy != null)
          r'defaultTransactionFlowStrategy': defaultTransactionFlowStrategy,
      });

  Input$PaymentSettingsInput._(this._$data);

  factory Input$PaymentSettingsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('defaultTransactionFlowStrategy')) {
      final l$defaultTransactionFlowStrategy =
          data['defaultTransactionFlowStrategy'];
      result$data['defaultTransactionFlowStrategy'] =
          l$defaultTransactionFlowStrategy == null
              ? null
              : fromJson$Enum$TransactionFlowStrategyEnum(
                  (l$defaultTransactionFlowStrategy as String));
    }
    return Input$PaymentSettingsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$TransactionFlowStrategyEnum? get defaultTransactionFlowStrategy =>
      (_$data['defaultTransactionFlowStrategy']
          as Enum$TransactionFlowStrategyEnum?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('defaultTransactionFlowStrategy')) {
      final l$defaultTransactionFlowStrategy = defaultTransactionFlowStrategy;
      result$data['defaultTransactionFlowStrategy'] =
          l$defaultTransactionFlowStrategy == null
              ? null
              : toJson$Enum$TransactionFlowStrategyEnum(
                  l$defaultTransactionFlowStrategy);
    }
    return result$data;
  }

  CopyWith$Input$PaymentSettingsInput<Input$PaymentSettingsInput>
      get copyWith => CopyWith$Input$PaymentSettingsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PaymentSettingsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$defaultTransactionFlowStrategy = defaultTransactionFlowStrategy;
    final lOther$defaultTransactionFlowStrategy =
        other.defaultTransactionFlowStrategy;
    if (_$data.containsKey('defaultTransactionFlowStrategy') !=
        other._$data.containsKey('defaultTransactionFlowStrategy')) {
      return false;
    }
    if (l$defaultTransactionFlowStrategy !=
        lOther$defaultTransactionFlowStrategy) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$defaultTransactionFlowStrategy = defaultTransactionFlowStrategy;
    return Object.hashAll([
      _$data.containsKey('defaultTransactionFlowStrategy')
          ? l$defaultTransactionFlowStrategy
          : const {}
    ]);
  }
}

abstract class CopyWith$Input$PaymentSettingsInput<TRes> {
  factory CopyWith$Input$PaymentSettingsInput(
    Input$PaymentSettingsInput instance,
    TRes Function(Input$PaymentSettingsInput) then,
  ) = _CopyWithImpl$Input$PaymentSettingsInput;

  factory CopyWith$Input$PaymentSettingsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PaymentSettingsInput;

  TRes call({Enum$TransactionFlowStrategyEnum? defaultTransactionFlowStrategy});
}

class _CopyWithImpl$Input$PaymentSettingsInput<TRes>
    implements CopyWith$Input$PaymentSettingsInput<TRes> {
  _CopyWithImpl$Input$PaymentSettingsInput(
    this._instance,
    this._then,
  );

  final Input$PaymentSettingsInput _instance;

  final TRes Function(Input$PaymentSettingsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? defaultTransactionFlowStrategy = _undefined}) =>
      _then(Input$PaymentSettingsInput._({
        ..._instance._$data,
        if (defaultTransactionFlowStrategy != _undefined)
          'defaultTransactionFlowStrategy': (defaultTransactionFlowStrategy
              as Enum$TransactionFlowStrategyEnum?),
      }));
}

class _CopyWithStubImpl$Input$PaymentSettingsInput<TRes>
    implements CopyWith$Input$PaymentSettingsInput<TRes> {
  _CopyWithStubImpl$Input$PaymentSettingsInput(this._res);

  TRes _res;

  call({Enum$TransactionFlowStrategyEnum? defaultTransactionFlowStrategy}) =>
      _res;
}

class Input$PermissionGroupCreateInput {
  factory Input$PermissionGroupCreateInput({
    List<Enum$PermissionEnum>? addPermissions,
    List<String>? addUsers,
    List<String>? addChannels,
    required String name,
    bool? restrictedAccessToChannels,
  }) =>
      Input$PermissionGroupCreateInput._({
        if (addPermissions != null) r'addPermissions': addPermissions,
        if (addUsers != null) r'addUsers': addUsers,
        if (addChannels != null) r'addChannels': addChannels,
        r'name': name,
        if (restrictedAccessToChannels != null)
          r'restrictedAccessToChannels': restrictedAccessToChannels,
      });

  Input$PermissionGroupCreateInput._(this._$data);

  factory Input$PermissionGroupCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('addPermissions')) {
      final l$addPermissions = data['addPermissions'];
      result$data['addPermissions'] = (l$addPermissions as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PermissionEnum((e as String)))
          .toList();
    }
    if (data.containsKey('addUsers')) {
      final l$addUsers = data['addUsers'];
      result$data['addUsers'] =
          (l$addUsers as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('addChannels')) {
      final l$addChannels = data['addChannels'];
      result$data['addChannels'] =
          (l$addChannels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('restrictedAccessToChannels')) {
      final l$restrictedAccessToChannels = data['restrictedAccessToChannels'];
      result$data['restrictedAccessToChannels'] =
          (l$restrictedAccessToChannels as bool?);
    }
    return Input$PermissionGroupCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$PermissionEnum>? get addPermissions =>
      (_$data['addPermissions'] as List<Enum$PermissionEnum>?);

  List<String>? get addUsers => (_$data['addUsers'] as List<String>?);

  List<String>? get addChannels => (_$data['addChannels'] as List<String>?);

  String get name => (_$data['name'] as String);

  bool? get restrictedAccessToChannels =>
      (_$data['restrictedAccessToChannels'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('addPermissions')) {
      final l$addPermissions = addPermissions;
      result$data['addPermissions'] =
          l$addPermissions?.map((e) => toJson$Enum$PermissionEnum(e)).toList();
    }
    if (_$data.containsKey('addUsers')) {
      final l$addUsers = addUsers;
      result$data['addUsers'] = l$addUsers?.map((e) => e).toList();
    }
    if (_$data.containsKey('addChannels')) {
      final l$addChannels = addChannels;
      result$data['addChannels'] = l$addChannels?.map((e) => e).toList();
    }
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('restrictedAccessToChannels')) {
      final l$restrictedAccessToChannels = restrictedAccessToChannels;
      result$data['restrictedAccessToChannels'] = l$restrictedAccessToChannels;
    }
    return result$data;
  }

  CopyWith$Input$PermissionGroupCreateInput<Input$PermissionGroupCreateInput>
      get copyWith => CopyWith$Input$PermissionGroupCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PermissionGroupCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$addPermissions = addPermissions;
    final lOther$addPermissions = other.addPermissions;
    if (_$data.containsKey('addPermissions') !=
        other._$data.containsKey('addPermissions')) {
      return false;
    }
    if (l$addPermissions != null && lOther$addPermissions != null) {
      if (l$addPermissions.length != lOther$addPermissions.length) {
        return false;
      }
      for (int i = 0; i < l$addPermissions.length; i++) {
        final l$addPermissions$entry = l$addPermissions[i];
        final lOther$addPermissions$entry = lOther$addPermissions[i];
        if (l$addPermissions$entry != lOther$addPermissions$entry) {
          return false;
        }
      }
    } else if (l$addPermissions != lOther$addPermissions) {
      return false;
    }
    final l$addUsers = addUsers;
    final lOther$addUsers = other.addUsers;
    if (_$data.containsKey('addUsers') !=
        other._$data.containsKey('addUsers')) {
      return false;
    }
    if (l$addUsers != null && lOther$addUsers != null) {
      if (l$addUsers.length != lOther$addUsers.length) {
        return false;
      }
      for (int i = 0; i < l$addUsers.length; i++) {
        final l$addUsers$entry = l$addUsers[i];
        final lOther$addUsers$entry = lOther$addUsers[i];
        if (l$addUsers$entry != lOther$addUsers$entry) {
          return false;
        }
      }
    } else if (l$addUsers != lOther$addUsers) {
      return false;
    }
    final l$addChannels = addChannels;
    final lOther$addChannels = other.addChannels;
    if (_$data.containsKey('addChannels') !=
        other._$data.containsKey('addChannels')) {
      return false;
    }
    if (l$addChannels != null && lOther$addChannels != null) {
      if (l$addChannels.length != lOther$addChannels.length) {
        return false;
      }
      for (int i = 0; i < l$addChannels.length; i++) {
        final l$addChannels$entry = l$addChannels[i];
        final lOther$addChannels$entry = lOther$addChannels[i];
        if (l$addChannels$entry != lOther$addChannels$entry) {
          return false;
        }
      }
    } else if (l$addChannels != lOther$addChannels) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$restrictedAccessToChannels = restrictedAccessToChannels;
    final lOther$restrictedAccessToChannels = other.restrictedAccessToChannels;
    if (_$data.containsKey('restrictedAccessToChannels') !=
        other._$data.containsKey('restrictedAccessToChannels')) {
      return false;
    }
    if (l$restrictedAccessToChannels != lOther$restrictedAccessToChannels) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$addPermissions = addPermissions;
    final l$addUsers = addUsers;
    final l$addChannels = addChannels;
    final l$name = name;
    final l$restrictedAccessToChannels = restrictedAccessToChannels;
    return Object.hashAll([
      _$data.containsKey('addPermissions')
          ? l$addPermissions == null
              ? null
              : Object.hashAll(l$addPermissions.map((v) => v))
          : const {},
      _$data.containsKey('addUsers')
          ? l$addUsers == null
              ? null
              : Object.hashAll(l$addUsers.map((v) => v))
          : const {},
      _$data.containsKey('addChannels')
          ? l$addChannels == null
              ? null
              : Object.hashAll(l$addChannels.map((v) => v))
          : const {},
      l$name,
      _$data.containsKey('restrictedAccessToChannels')
          ? l$restrictedAccessToChannels
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PermissionGroupCreateInput<TRes> {
  factory CopyWith$Input$PermissionGroupCreateInput(
    Input$PermissionGroupCreateInput instance,
    TRes Function(Input$PermissionGroupCreateInput) then,
  ) = _CopyWithImpl$Input$PermissionGroupCreateInput;

  factory CopyWith$Input$PermissionGroupCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PermissionGroupCreateInput;

  TRes call({
    List<Enum$PermissionEnum>? addPermissions,
    List<String>? addUsers,
    List<String>? addChannels,
    String? name,
    bool? restrictedAccessToChannels,
  });
}

class _CopyWithImpl$Input$PermissionGroupCreateInput<TRes>
    implements CopyWith$Input$PermissionGroupCreateInput<TRes> {
  _CopyWithImpl$Input$PermissionGroupCreateInput(
    this._instance,
    this._then,
  );

  final Input$PermissionGroupCreateInput _instance;

  final TRes Function(Input$PermissionGroupCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? addPermissions = _undefined,
    Object? addUsers = _undefined,
    Object? addChannels = _undefined,
    Object? name = _undefined,
    Object? restrictedAccessToChannels = _undefined,
  }) =>
      _then(Input$PermissionGroupCreateInput._({
        ..._instance._$data,
        if (addPermissions != _undefined)
          'addPermissions': (addPermissions as List<Enum$PermissionEnum>?),
        if (addUsers != _undefined) 'addUsers': (addUsers as List<String>?),
        if (addChannels != _undefined)
          'addChannels': (addChannels as List<String>?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (restrictedAccessToChannels != _undefined)
          'restrictedAccessToChannels': (restrictedAccessToChannels as bool?),
      }));
}

class _CopyWithStubImpl$Input$PermissionGroupCreateInput<TRes>
    implements CopyWith$Input$PermissionGroupCreateInput<TRes> {
  _CopyWithStubImpl$Input$PermissionGroupCreateInput(this._res);

  TRes _res;

  call({
    List<Enum$PermissionEnum>? addPermissions,
    List<String>? addUsers,
    List<String>? addChannels,
    String? name,
    bool? restrictedAccessToChannels,
  }) =>
      _res;
}

class Input$PermissionGroupFilterInput {
  factory Input$PermissionGroupFilterInput({
    String? search,
    List<String>? ids,
  }) =>
      Input$PermissionGroupFilterInput._({
        if (search != null) r'search': search,
        if (ids != null) r'ids': ids,
      });

  Input$PermissionGroupFilterInput._(this._$data);

  factory Input$PermissionGroupFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$PermissionGroupFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get search => (_$data['search'] as String?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$PermissionGroupFilterInput<Input$PermissionGroupFilterInput>
      get copyWith => CopyWith$Input$PermissionGroupFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PermissionGroupFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$search = search;
    final l$ids = ids;
    return Object.hashAll([
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PermissionGroupFilterInput<TRes> {
  factory CopyWith$Input$PermissionGroupFilterInput(
    Input$PermissionGroupFilterInput instance,
    TRes Function(Input$PermissionGroupFilterInput) then,
  ) = _CopyWithImpl$Input$PermissionGroupFilterInput;

  factory CopyWith$Input$PermissionGroupFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PermissionGroupFilterInput;

  TRes call({
    String? search,
    List<String>? ids,
  });
}

class _CopyWithImpl$Input$PermissionGroupFilterInput<TRes>
    implements CopyWith$Input$PermissionGroupFilterInput<TRes> {
  _CopyWithImpl$Input$PermissionGroupFilterInput(
    this._instance,
    this._then,
  );

  final Input$PermissionGroupFilterInput _instance;

  final TRes Function(Input$PermissionGroupFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? search = _undefined,
    Object? ids = _undefined,
  }) =>
      _then(Input$PermissionGroupFilterInput._({
        ..._instance._$data,
        if (search != _undefined) 'search': (search as String?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$PermissionGroupFilterInput<TRes>
    implements CopyWith$Input$PermissionGroupFilterInput<TRes> {
  _CopyWithStubImpl$Input$PermissionGroupFilterInput(this._res);

  TRes _res;

  call({
    String? search,
    List<String>? ids,
  }) =>
      _res;
}

class Input$PermissionGroupSortingInput {
  factory Input$PermissionGroupSortingInput({
    required Enum$OrderDirection direction,
    required Enum$PermissionGroupSortField field,
  }) =>
      Input$PermissionGroupSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$PermissionGroupSortingInput._(this._$data);

  factory Input$PermissionGroupSortingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$PermissionGroupSortField((l$field as String));
    return Input$PermissionGroupSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$PermissionGroupSortField get field =>
      (_$data['field'] as Enum$PermissionGroupSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$PermissionGroupSortField(l$field);
    return result$data;
  }

  CopyWith$Input$PermissionGroupSortingInput<Input$PermissionGroupSortingInput>
      get copyWith => CopyWith$Input$PermissionGroupSortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PermissionGroupSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$PermissionGroupSortingInput<TRes> {
  factory CopyWith$Input$PermissionGroupSortingInput(
    Input$PermissionGroupSortingInput instance,
    TRes Function(Input$PermissionGroupSortingInput) then,
  ) = _CopyWithImpl$Input$PermissionGroupSortingInput;

  factory CopyWith$Input$PermissionGroupSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PermissionGroupSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$PermissionGroupSortField? field,
  });
}

class _CopyWithImpl$Input$PermissionGroupSortingInput<TRes>
    implements CopyWith$Input$PermissionGroupSortingInput<TRes> {
  _CopyWithImpl$Input$PermissionGroupSortingInput(
    this._instance,
    this._then,
  );

  final Input$PermissionGroupSortingInput _instance;

  final TRes Function(Input$PermissionGroupSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$PermissionGroupSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$PermissionGroupSortField),
      }));
}

class _CopyWithStubImpl$Input$PermissionGroupSortingInput<TRes>
    implements CopyWith$Input$PermissionGroupSortingInput<TRes> {
  _CopyWithStubImpl$Input$PermissionGroupSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$PermissionGroupSortField? field,
  }) =>
      _res;
}

class Input$PermissionGroupUpdateInput {
  factory Input$PermissionGroupUpdateInput({
    List<Enum$PermissionEnum>? addPermissions,
    List<String>? addUsers,
    List<String>? addChannels,
    String? name,
    List<Enum$PermissionEnum>? removePermissions,
    List<String>? removeUsers,
    List<String>? removeChannels,
    bool? restrictedAccessToChannels,
  }) =>
      Input$PermissionGroupUpdateInput._({
        if (addPermissions != null) r'addPermissions': addPermissions,
        if (addUsers != null) r'addUsers': addUsers,
        if (addChannels != null) r'addChannels': addChannels,
        if (name != null) r'name': name,
        if (removePermissions != null) r'removePermissions': removePermissions,
        if (removeUsers != null) r'removeUsers': removeUsers,
        if (removeChannels != null) r'removeChannels': removeChannels,
        if (restrictedAccessToChannels != null)
          r'restrictedAccessToChannels': restrictedAccessToChannels,
      });

  Input$PermissionGroupUpdateInput._(this._$data);

  factory Input$PermissionGroupUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('addPermissions')) {
      final l$addPermissions = data['addPermissions'];
      result$data['addPermissions'] = (l$addPermissions as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PermissionEnum((e as String)))
          .toList();
    }
    if (data.containsKey('addUsers')) {
      final l$addUsers = data['addUsers'];
      result$data['addUsers'] =
          (l$addUsers as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('addChannels')) {
      final l$addChannels = data['addChannels'];
      result$data['addChannels'] =
          (l$addChannels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('removePermissions')) {
      final l$removePermissions = data['removePermissions'];
      result$data['removePermissions'] = (l$removePermissions as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PermissionEnum((e as String)))
          .toList();
    }
    if (data.containsKey('removeUsers')) {
      final l$removeUsers = data['removeUsers'];
      result$data['removeUsers'] =
          (l$removeUsers as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('removeChannels')) {
      final l$removeChannels = data['removeChannels'];
      result$data['removeChannels'] = (l$removeChannels as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('restrictedAccessToChannels')) {
      final l$restrictedAccessToChannels = data['restrictedAccessToChannels'];
      result$data['restrictedAccessToChannels'] =
          (l$restrictedAccessToChannels as bool?);
    }
    return Input$PermissionGroupUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$PermissionEnum>? get addPermissions =>
      (_$data['addPermissions'] as List<Enum$PermissionEnum>?);

  List<String>? get addUsers => (_$data['addUsers'] as List<String>?);

  List<String>? get addChannels => (_$data['addChannels'] as List<String>?);

  String? get name => (_$data['name'] as String?);

  List<Enum$PermissionEnum>? get removePermissions =>
      (_$data['removePermissions'] as List<Enum$PermissionEnum>?);

  List<String>? get removeUsers => (_$data['removeUsers'] as List<String>?);

  List<String>? get removeChannels =>
      (_$data['removeChannels'] as List<String>?);

  bool? get restrictedAccessToChannels =>
      (_$data['restrictedAccessToChannels'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('addPermissions')) {
      final l$addPermissions = addPermissions;
      result$data['addPermissions'] =
          l$addPermissions?.map((e) => toJson$Enum$PermissionEnum(e)).toList();
    }
    if (_$data.containsKey('addUsers')) {
      final l$addUsers = addUsers;
      result$data['addUsers'] = l$addUsers?.map((e) => e).toList();
    }
    if (_$data.containsKey('addChannels')) {
      final l$addChannels = addChannels;
      result$data['addChannels'] = l$addChannels?.map((e) => e).toList();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('removePermissions')) {
      final l$removePermissions = removePermissions;
      result$data['removePermissions'] = l$removePermissions
          ?.map((e) => toJson$Enum$PermissionEnum(e))
          .toList();
    }
    if (_$data.containsKey('removeUsers')) {
      final l$removeUsers = removeUsers;
      result$data['removeUsers'] = l$removeUsers?.map((e) => e).toList();
    }
    if (_$data.containsKey('removeChannels')) {
      final l$removeChannels = removeChannels;
      result$data['removeChannels'] = l$removeChannels?.map((e) => e).toList();
    }
    if (_$data.containsKey('restrictedAccessToChannels')) {
      final l$restrictedAccessToChannels = restrictedAccessToChannels;
      result$data['restrictedAccessToChannels'] = l$restrictedAccessToChannels;
    }
    return result$data;
  }

  CopyWith$Input$PermissionGroupUpdateInput<Input$PermissionGroupUpdateInput>
      get copyWith => CopyWith$Input$PermissionGroupUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PermissionGroupUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$addPermissions = addPermissions;
    final lOther$addPermissions = other.addPermissions;
    if (_$data.containsKey('addPermissions') !=
        other._$data.containsKey('addPermissions')) {
      return false;
    }
    if (l$addPermissions != null && lOther$addPermissions != null) {
      if (l$addPermissions.length != lOther$addPermissions.length) {
        return false;
      }
      for (int i = 0; i < l$addPermissions.length; i++) {
        final l$addPermissions$entry = l$addPermissions[i];
        final lOther$addPermissions$entry = lOther$addPermissions[i];
        if (l$addPermissions$entry != lOther$addPermissions$entry) {
          return false;
        }
      }
    } else if (l$addPermissions != lOther$addPermissions) {
      return false;
    }
    final l$addUsers = addUsers;
    final lOther$addUsers = other.addUsers;
    if (_$data.containsKey('addUsers') !=
        other._$data.containsKey('addUsers')) {
      return false;
    }
    if (l$addUsers != null && lOther$addUsers != null) {
      if (l$addUsers.length != lOther$addUsers.length) {
        return false;
      }
      for (int i = 0; i < l$addUsers.length; i++) {
        final l$addUsers$entry = l$addUsers[i];
        final lOther$addUsers$entry = lOther$addUsers[i];
        if (l$addUsers$entry != lOther$addUsers$entry) {
          return false;
        }
      }
    } else if (l$addUsers != lOther$addUsers) {
      return false;
    }
    final l$addChannels = addChannels;
    final lOther$addChannels = other.addChannels;
    if (_$data.containsKey('addChannels') !=
        other._$data.containsKey('addChannels')) {
      return false;
    }
    if (l$addChannels != null && lOther$addChannels != null) {
      if (l$addChannels.length != lOther$addChannels.length) {
        return false;
      }
      for (int i = 0; i < l$addChannels.length; i++) {
        final l$addChannels$entry = l$addChannels[i];
        final lOther$addChannels$entry = lOther$addChannels[i];
        if (l$addChannels$entry != lOther$addChannels$entry) {
          return false;
        }
      }
    } else if (l$addChannels != lOther$addChannels) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$removePermissions = removePermissions;
    final lOther$removePermissions = other.removePermissions;
    if (_$data.containsKey('removePermissions') !=
        other._$data.containsKey('removePermissions')) {
      return false;
    }
    if (l$removePermissions != null && lOther$removePermissions != null) {
      if (l$removePermissions.length != lOther$removePermissions.length) {
        return false;
      }
      for (int i = 0; i < l$removePermissions.length; i++) {
        final l$removePermissions$entry = l$removePermissions[i];
        final lOther$removePermissions$entry = lOther$removePermissions[i];
        if (l$removePermissions$entry != lOther$removePermissions$entry) {
          return false;
        }
      }
    } else if (l$removePermissions != lOther$removePermissions) {
      return false;
    }
    final l$removeUsers = removeUsers;
    final lOther$removeUsers = other.removeUsers;
    if (_$data.containsKey('removeUsers') !=
        other._$data.containsKey('removeUsers')) {
      return false;
    }
    if (l$removeUsers != null && lOther$removeUsers != null) {
      if (l$removeUsers.length != lOther$removeUsers.length) {
        return false;
      }
      for (int i = 0; i < l$removeUsers.length; i++) {
        final l$removeUsers$entry = l$removeUsers[i];
        final lOther$removeUsers$entry = lOther$removeUsers[i];
        if (l$removeUsers$entry != lOther$removeUsers$entry) {
          return false;
        }
      }
    } else if (l$removeUsers != lOther$removeUsers) {
      return false;
    }
    final l$removeChannels = removeChannels;
    final lOther$removeChannels = other.removeChannels;
    if (_$data.containsKey('removeChannels') !=
        other._$data.containsKey('removeChannels')) {
      return false;
    }
    if (l$removeChannels != null && lOther$removeChannels != null) {
      if (l$removeChannels.length != lOther$removeChannels.length) {
        return false;
      }
      for (int i = 0; i < l$removeChannels.length; i++) {
        final l$removeChannels$entry = l$removeChannels[i];
        final lOther$removeChannels$entry = lOther$removeChannels[i];
        if (l$removeChannels$entry != lOther$removeChannels$entry) {
          return false;
        }
      }
    } else if (l$removeChannels != lOther$removeChannels) {
      return false;
    }
    final l$restrictedAccessToChannels = restrictedAccessToChannels;
    final lOther$restrictedAccessToChannels = other.restrictedAccessToChannels;
    if (_$data.containsKey('restrictedAccessToChannels') !=
        other._$data.containsKey('restrictedAccessToChannels')) {
      return false;
    }
    if (l$restrictedAccessToChannels != lOther$restrictedAccessToChannels) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$addPermissions = addPermissions;
    final l$addUsers = addUsers;
    final l$addChannels = addChannels;
    final l$name = name;
    final l$removePermissions = removePermissions;
    final l$removeUsers = removeUsers;
    final l$removeChannels = removeChannels;
    final l$restrictedAccessToChannels = restrictedAccessToChannels;
    return Object.hashAll([
      _$data.containsKey('addPermissions')
          ? l$addPermissions == null
              ? null
              : Object.hashAll(l$addPermissions.map((v) => v))
          : const {},
      _$data.containsKey('addUsers')
          ? l$addUsers == null
              ? null
              : Object.hashAll(l$addUsers.map((v) => v))
          : const {},
      _$data.containsKey('addChannels')
          ? l$addChannels == null
              ? null
              : Object.hashAll(l$addChannels.map((v) => v))
          : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('removePermissions')
          ? l$removePermissions == null
              ? null
              : Object.hashAll(l$removePermissions.map((v) => v))
          : const {},
      _$data.containsKey('removeUsers')
          ? l$removeUsers == null
              ? null
              : Object.hashAll(l$removeUsers.map((v) => v))
          : const {},
      _$data.containsKey('removeChannels')
          ? l$removeChannels == null
              ? null
              : Object.hashAll(l$removeChannels.map((v) => v))
          : const {},
      _$data.containsKey('restrictedAccessToChannels')
          ? l$restrictedAccessToChannels
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PermissionGroupUpdateInput<TRes> {
  factory CopyWith$Input$PermissionGroupUpdateInput(
    Input$PermissionGroupUpdateInput instance,
    TRes Function(Input$PermissionGroupUpdateInput) then,
  ) = _CopyWithImpl$Input$PermissionGroupUpdateInput;

  factory CopyWith$Input$PermissionGroupUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PermissionGroupUpdateInput;

  TRes call({
    List<Enum$PermissionEnum>? addPermissions,
    List<String>? addUsers,
    List<String>? addChannels,
    String? name,
    List<Enum$PermissionEnum>? removePermissions,
    List<String>? removeUsers,
    List<String>? removeChannels,
    bool? restrictedAccessToChannels,
  });
}

class _CopyWithImpl$Input$PermissionGroupUpdateInput<TRes>
    implements CopyWith$Input$PermissionGroupUpdateInput<TRes> {
  _CopyWithImpl$Input$PermissionGroupUpdateInput(
    this._instance,
    this._then,
  );

  final Input$PermissionGroupUpdateInput _instance;

  final TRes Function(Input$PermissionGroupUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? addPermissions = _undefined,
    Object? addUsers = _undefined,
    Object? addChannels = _undefined,
    Object? name = _undefined,
    Object? removePermissions = _undefined,
    Object? removeUsers = _undefined,
    Object? removeChannels = _undefined,
    Object? restrictedAccessToChannels = _undefined,
  }) =>
      _then(Input$PermissionGroupUpdateInput._({
        ..._instance._$data,
        if (addPermissions != _undefined)
          'addPermissions': (addPermissions as List<Enum$PermissionEnum>?),
        if (addUsers != _undefined) 'addUsers': (addUsers as List<String>?),
        if (addChannels != _undefined)
          'addChannels': (addChannels as List<String>?),
        if (name != _undefined) 'name': (name as String?),
        if (removePermissions != _undefined)
          'removePermissions':
              (removePermissions as List<Enum$PermissionEnum>?),
        if (removeUsers != _undefined)
          'removeUsers': (removeUsers as List<String>?),
        if (removeChannels != _undefined)
          'removeChannels': (removeChannels as List<String>?),
        if (restrictedAccessToChannels != _undefined)
          'restrictedAccessToChannels': (restrictedAccessToChannels as bool?),
      }));
}

class _CopyWithStubImpl$Input$PermissionGroupUpdateInput<TRes>
    implements CopyWith$Input$PermissionGroupUpdateInput<TRes> {
  _CopyWithStubImpl$Input$PermissionGroupUpdateInput(this._res);

  TRes _res;

  call({
    List<Enum$PermissionEnum>? addPermissions,
    List<String>? addUsers,
    List<String>? addChannels,
    String? name,
    List<Enum$PermissionEnum>? removePermissions,
    List<String>? removeUsers,
    List<String>? removeChannels,
    bool? restrictedAccessToChannels,
  }) =>
      _res;
}

class Input$PluginFilterInput {
  factory Input$PluginFilterInput({
    Input$PluginStatusInChannelsInput? statusInChannels,
    String? search,
    Enum$PluginConfigurationType? type,
  }) =>
      Input$PluginFilterInput._({
        if (statusInChannels != null) r'statusInChannels': statusInChannels,
        if (search != null) r'search': search,
        if (type != null) r'type': type,
      });

  Input$PluginFilterInput._(this._$data);

  factory Input$PluginFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('statusInChannels')) {
      final l$statusInChannels = data['statusInChannels'];
      result$data['statusInChannels'] = l$statusInChannels == null
          ? null
          : Input$PluginStatusInChannelsInput.fromJson(
              (l$statusInChannels as Map<String, dynamic>));
    }
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : fromJson$Enum$PluginConfigurationType((l$type as String));
    }
    return Input$PluginFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$PluginStatusInChannelsInput? get statusInChannels =>
      (_$data['statusInChannels'] as Input$PluginStatusInChannelsInput?);

  String? get search => (_$data['search'] as String?);

  Enum$PluginConfigurationType? get type =>
      (_$data['type'] as Enum$PluginConfigurationType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('statusInChannels')) {
      final l$statusInChannels = statusInChannels;
      result$data['statusInChannels'] = l$statusInChannels?.toJson();
    }
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] =
          l$type == null ? null : toJson$Enum$PluginConfigurationType(l$type);
    }
    return result$data;
  }

  CopyWith$Input$PluginFilterInput<Input$PluginFilterInput> get copyWith =>
      CopyWith$Input$PluginFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PluginFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$statusInChannels = statusInChannels;
    final lOther$statusInChannels = other.statusInChannels;
    if (_$data.containsKey('statusInChannels') !=
        other._$data.containsKey('statusInChannels')) {
      return false;
    }
    if (l$statusInChannels != lOther$statusInChannels) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$statusInChannels = statusInChannels;
    final l$search = search;
    final l$type = type;
    return Object.hashAll([
      _$data.containsKey('statusInChannels') ? l$statusInChannels : const {},
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('type') ? l$type : const {},
    ]);
  }
}

abstract class CopyWith$Input$PluginFilterInput<TRes> {
  factory CopyWith$Input$PluginFilterInput(
    Input$PluginFilterInput instance,
    TRes Function(Input$PluginFilterInput) then,
  ) = _CopyWithImpl$Input$PluginFilterInput;

  factory CopyWith$Input$PluginFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PluginFilterInput;

  TRes call({
    Input$PluginStatusInChannelsInput? statusInChannels,
    String? search,
    Enum$PluginConfigurationType? type,
  });
  CopyWith$Input$PluginStatusInChannelsInput<TRes> get statusInChannels;
}

class _CopyWithImpl$Input$PluginFilterInput<TRes>
    implements CopyWith$Input$PluginFilterInput<TRes> {
  _CopyWithImpl$Input$PluginFilterInput(
    this._instance,
    this._then,
  );

  final Input$PluginFilterInput _instance;

  final TRes Function(Input$PluginFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? statusInChannels = _undefined,
    Object? search = _undefined,
    Object? type = _undefined,
  }) =>
      _then(Input$PluginFilterInput._({
        ..._instance._$data,
        if (statusInChannels != _undefined)
          'statusInChannels':
              (statusInChannels as Input$PluginStatusInChannelsInput?),
        if (search != _undefined) 'search': (search as String?),
        if (type != _undefined) 'type': (type as Enum$PluginConfigurationType?),
      }));

  CopyWith$Input$PluginStatusInChannelsInput<TRes> get statusInChannels {
    final local$statusInChannels = _instance.statusInChannels;
    return local$statusInChannels == null
        ? CopyWith$Input$PluginStatusInChannelsInput.stub(_then(_instance))
        : CopyWith$Input$PluginStatusInChannelsInput(
            local$statusInChannels, (e) => call(statusInChannels: e));
  }
}

class _CopyWithStubImpl$Input$PluginFilterInput<TRes>
    implements CopyWith$Input$PluginFilterInput<TRes> {
  _CopyWithStubImpl$Input$PluginFilterInput(this._res);

  TRes _res;

  call({
    Input$PluginStatusInChannelsInput? statusInChannels,
    String? search,
    Enum$PluginConfigurationType? type,
  }) =>
      _res;

  CopyWith$Input$PluginStatusInChannelsInput<TRes> get statusInChannels =>
      CopyWith$Input$PluginStatusInChannelsInput.stub(_res);
}

class Input$PluginSortingInput {
  factory Input$PluginSortingInput({
    required Enum$OrderDirection direction,
    required Enum$PluginSortField field,
  }) =>
      Input$PluginSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$PluginSortingInput._(this._$data);

  factory Input$PluginSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$PluginSortField((l$field as String));
    return Input$PluginSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$PluginSortField get field => (_$data['field'] as Enum$PluginSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$PluginSortField(l$field);
    return result$data;
  }

  CopyWith$Input$PluginSortingInput<Input$PluginSortingInput> get copyWith =>
      CopyWith$Input$PluginSortingInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PluginSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$PluginSortingInput<TRes> {
  factory CopyWith$Input$PluginSortingInput(
    Input$PluginSortingInput instance,
    TRes Function(Input$PluginSortingInput) then,
  ) = _CopyWithImpl$Input$PluginSortingInput;

  factory CopyWith$Input$PluginSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PluginSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$PluginSortField? field,
  });
}

class _CopyWithImpl$Input$PluginSortingInput<TRes>
    implements CopyWith$Input$PluginSortingInput<TRes> {
  _CopyWithImpl$Input$PluginSortingInput(
    this._instance,
    this._then,
  );

  final Input$PluginSortingInput _instance;

  final TRes Function(Input$PluginSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$PluginSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$PluginSortField),
      }));
}

class _CopyWithStubImpl$Input$PluginSortingInput<TRes>
    implements CopyWith$Input$PluginSortingInput<TRes> {
  _CopyWithStubImpl$Input$PluginSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$PluginSortField? field,
  }) =>
      _res;
}

class Input$PluginStatusInChannelsInput {
  factory Input$PluginStatusInChannelsInput({
    required bool active,
    required List<String> channels,
  }) =>
      Input$PluginStatusInChannelsInput._({
        r'active': active,
        r'channels': channels,
      });

  Input$PluginStatusInChannelsInput._(this._$data);

  factory Input$PluginStatusInChannelsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$active = data['active'];
    result$data['active'] = (l$active as bool);
    final l$channels = data['channels'];
    result$data['channels'] =
        (l$channels as List<dynamic>).map((e) => (e as String)).toList();
    return Input$PluginStatusInChannelsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool get active => (_$data['active'] as bool);

  List<String> get channels => (_$data['channels'] as List<String>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$active = active;
    result$data['active'] = l$active;
    final l$channels = channels;
    result$data['channels'] = l$channels.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$PluginStatusInChannelsInput<Input$PluginStatusInChannelsInput>
      get copyWith => CopyWith$Input$PluginStatusInChannelsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PluginStatusInChannelsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (l$active != lOther$active) {
      return false;
    }
    final l$channels = channels;
    final lOther$channels = other.channels;
    if (l$channels.length != lOther$channels.length) {
      return false;
    }
    for (int i = 0; i < l$channels.length; i++) {
      final l$channels$entry = l$channels[i];
      final lOther$channels$entry = lOther$channels[i];
      if (l$channels$entry != lOther$channels$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$active = active;
    final l$channels = channels;
    return Object.hashAll([
      l$active,
      Object.hashAll(l$channels.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$PluginStatusInChannelsInput<TRes> {
  factory CopyWith$Input$PluginStatusInChannelsInput(
    Input$PluginStatusInChannelsInput instance,
    TRes Function(Input$PluginStatusInChannelsInput) then,
  ) = _CopyWithImpl$Input$PluginStatusInChannelsInput;

  factory CopyWith$Input$PluginStatusInChannelsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PluginStatusInChannelsInput;

  TRes call({
    bool? active,
    List<String>? channels,
  });
}

class _CopyWithImpl$Input$PluginStatusInChannelsInput<TRes>
    implements CopyWith$Input$PluginStatusInChannelsInput<TRes> {
  _CopyWithImpl$Input$PluginStatusInChannelsInput(
    this._instance,
    this._then,
  );

  final Input$PluginStatusInChannelsInput _instance;

  final TRes Function(Input$PluginStatusInChannelsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? active = _undefined,
    Object? channels = _undefined,
  }) =>
      _then(Input$PluginStatusInChannelsInput._({
        ..._instance._$data,
        if (active != _undefined && active != null) 'active': (active as bool),
        if (channels != _undefined && channels != null)
          'channels': (channels as List<String>),
      }));
}

class _CopyWithStubImpl$Input$PluginStatusInChannelsInput<TRes>
    implements CopyWith$Input$PluginStatusInChannelsInput<TRes> {
  _CopyWithStubImpl$Input$PluginStatusInChannelsInput(this._res);

  TRes _res;

  call({
    bool? active,
    List<String>? channels,
  }) =>
      _res;
}

class Input$PluginUpdateInput {
  factory Input$PluginUpdateInput({
    bool? active,
    List<Input$ConfigurationItemInput>? configuration,
  }) =>
      Input$PluginUpdateInput._({
        if (active != null) r'active': active,
        if (configuration != null) r'configuration': configuration,
      });

  Input$PluginUpdateInput._(this._$data);

  factory Input$PluginUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('active')) {
      final l$active = data['active'];
      result$data['active'] = (l$active as bool?);
    }
    if (data.containsKey('configuration')) {
      final l$configuration = data['configuration'];
      result$data['configuration'] = (l$configuration as List<dynamic>?)
          ?.map((e) => Input$ConfigurationItemInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$PluginUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get active => (_$data['active'] as bool?);

  List<Input$ConfigurationItemInput>? get configuration =>
      (_$data['configuration'] as List<Input$ConfigurationItemInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('active')) {
      final l$active = active;
      result$data['active'] = l$active;
    }
    if (_$data.containsKey('configuration')) {
      final l$configuration = configuration;
      result$data['configuration'] =
          l$configuration?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$PluginUpdateInput<Input$PluginUpdateInput> get copyWith =>
      CopyWith$Input$PluginUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PluginUpdateInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (_$data.containsKey('active') != other._$data.containsKey('active')) {
      return false;
    }
    if (l$active != lOther$active) {
      return false;
    }
    final l$configuration = configuration;
    final lOther$configuration = other.configuration;
    if (_$data.containsKey('configuration') !=
        other._$data.containsKey('configuration')) {
      return false;
    }
    if (l$configuration != null && lOther$configuration != null) {
      if (l$configuration.length != lOther$configuration.length) {
        return false;
      }
      for (int i = 0; i < l$configuration.length; i++) {
        final l$configuration$entry = l$configuration[i];
        final lOther$configuration$entry = lOther$configuration[i];
        if (l$configuration$entry != lOther$configuration$entry) {
          return false;
        }
      }
    } else if (l$configuration != lOther$configuration) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$active = active;
    final l$configuration = configuration;
    return Object.hashAll([
      _$data.containsKey('active') ? l$active : const {},
      _$data.containsKey('configuration')
          ? l$configuration == null
              ? null
              : Object.hashAll(l$configuration.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PluginUpdateInput<TRes> {
  factory CopyWith$Input$PluginUpdateInput(
    Input$PluginUpdateInput instance,
    TRes Function(Input$PluginUpdateInput) then,
  ) = _CopyWithImpl$Input$PluginUpdateInput;

  factory CopyWith$Input$PluginUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PluginUpdateInput;

  TRes call({
    bool? active,
    List<Input$ConfigurationItemInput>? configuration,
  });
  TRes configuration(
      Iterable<Input$ConfigurationItemInput>? Function(
              Iterable<
                  CopyWith$Input$ConfigurationItemInput<
                      Input$ConfigurationItemInput>>?)
          _fn);
}

class _CopyWithImpl$Input$PluginUpdateInput<TRes>
    implements CopyWith$Input$PluginUpdateInput<TRes> {
  _CopyWithImpl$Input$PluginUpdateInput(
    this._instance,
    this._then,
  );

  final Input$PluginUpdateInput _instance;

  final TRes Function(Input$PluginUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? active = _undefined,
    Object? configuration = _undefined,
  }) =>
      _then(Input$PluginUpdateInput._({
        ..._instance._$data,
        if (active != _undefined) 'active': (active as bool?),
        if (configuration != _undefined)
          'configuration':
              (configuration as List<Input$ConfigurationItemInput>?),
      }));

  TRes configuration(
          Iterable<Input$ConfigurationItemInput>? Function(
                  Iterable<
                      CopyWith$Input$ConfigurationItemInput<
                          Input$ConfigurationItemInput>>?)
              _fn) =>
      call(
          configuration: _fn(_instance.configuration
              ?.map((e) => CopyWith$Input$ConfigurationItemInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$PluginUpdateInput<TRes>
    implements CopyWith$Input$PluginUpdateInput<TRes> {
  _CopyWithStubImpl$Input$PluginUpdateInput(this._res);

  TRes _res;

  call({
    bool? active,
    List<Input$ConfigurationItemInput>? configuration,
  }) =>
      _res;

  configuration(_fn) => _res;
}

class Input$PreorderSettingsInput {
  factory Input$PreorderSettingsInput({
    int? globalThreshold,
    String? endDate,
  }) =>
      Input$PreorderSettingsInput._({
        if (globalThreshold != null) r'globalThreshold': globalThreshold,
        if (endDate != null) r'endDate': endDate,
      });

  Input$PreorderSettingsInput._(this._$data);

  factory Input$PreorderSettingsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('globalThreshold')) {
      final l$globalThreshold = data['globalThreshold'];
      result$data['globalThreshold'] = (l$globalThreshold as int?);
    }
    if (data.containsKey('endDate')) {
      final l$endDate = data['endDate'];
      result$data['endDate'] = (l$endDate as String?);
    }
    return Input$PreorderSettingsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get globalThreshold => (_$data['globalThreshold'] as int?);

  String? get endDate => (_$data['endDate'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('globalThreshold')) {
      final l$globalThreshold = globalThreshold;
      result$data['globalThreshold'] = l$globalThreshold;
    }
    if (_$data.containsKey('endDate')) {
      final l$endDate = endDate;
      result$data['endDate'] = l$endDate;
    }
    return result$data;
  }

  CopyWith$Input$PreorderSettingsInput<Input$PreorderSettingsInput>
      get copyWith => CopyWith$Input$PreorderSettingsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PreorderSettingsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$globalThreshold = globalThreshold;
    final lOther$globalThreshold = other.globalThreshold;
    if (_$data.containsKey('globalThreshold') !=
        other._$data.containsKey('globalThreshold')) {
      return false;
    }
    if (l$globalThreshold != lOther$globalThreshold) {
      return false;
    }
    final l$endDate = endDate;
    final lOther$endDate = other.endDate;
    if (_$data.containsKey('endDate') != other._$data.containsKey('endDate')) {
      return false;
    }
    if (l$endDate != lOther$endDate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$globalThreshold = globalThreshold;
    final l$endDate = endDate;
    return Object.hashAll([
      _$data.containsKey('globalThreshold') ? l$globalThreshold : const {},
      _$data.containsKey('endDate') ? l$endDate : const {},
    ]);
  }
}

abstract class CopyWith$Input$PreorderSettingsInput<TRes> {
  factory CopyWith$Input$PreorderSettingsInput(
    Input$PreorderSettingsInput instance,
    TRes Function(Input$PreorderSettingsInput) then,
  ) = _CopyWithImpl$Input$PreorderSettingsInput;

  factory CopyWith$Input$PreorderSettingsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PreorderSettingsInput;

  TRes call({
    int? globalThreshold,
    String? endDate,
  });
}

class _CopyWithImpl$Input$PreorderSettingsInput<TRes>
    implements CopyWith$Input$PreorderSettingsInput<TRes> {
  _CopyWithImpl$Input$PreorderSettingsInput(
    this._instance,
    this._then,
  );

  final Input$PreorderSettingsInput _instance;

  final TRes Function(Input$PreorderSettingsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? globalThreshold = _undefined,
    Object? endDate = _undefined,
  }) =>
      _then(Input$PreorderSettingsInput._({
        ..._instance._$data,
        if (globalThreshold != _undefined)
          'globalThreshold': (globalThreshold as int?),
        if (endDate != _undefined) 'endDate': (endDate as String?),
      }));
}

class _CopyWithStubImpl$Input$PreorderSettingsInput<TRes>
    implements CopyWith$Input$PreorderSettingsInput<TRes> {
  _CopyWithStubImpl$Input$PreorderSettingsInput(this._res);

  TRes _res;

  call({
    int? globalThreshold,
    String? endDate,
  }) =>
      _res;
}

class Input$PriceFilterInput {
  factory Input$PriceFilterInput({
    String? currency,
    required Input$DecimalFilterInput amount,
  }) =>
      Input$PriceFilterInput._({
        if (currency != null) r'currency': currency,
        r'amount': amount,
      });

  Input$PriceFilterInput._(this._$data);

  factory Input$PriceFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = (l$currency as String?);
    }
    final l$amount = data['amount'];
    result$data['amount'] =
        Input$DecimalFilterInput.fromJson((l$amount as Map<String, dynamic>));
    return Input$PriceFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get currency => (_$data['currency'] as String?);

  Input$DecimalFilterInput get amount =>
      (_$data['amount'] as Input$DecimalFilterInput);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency;
    }
    final l$amount = amount;
    result$data['amount'] = l$amount.toJson();
    return result$data;
  }

  CopyWith$Input$PriceFilterInput<Input$PriceFilterInput> get copyWith =>
      CopyWith$Input$PriceFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PriceFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (l$amount != lOther$amount) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$currency = currency;
    final l$amount = amount;
    return Object.hashAll([
      _$data.containsKey('currency') ? l$currency : const {},
      l$amount,
    ]);
  }
}

abstract class CopyWith$Input$PriceFilterInput<TRes> {
  factory CopyWith$Input$PriceFilterInput(
    Input$PriceFilterInput instance,
    TRes Function(Input$PriceFilterInput) then,
  ) = _CopyWithImpl$Input$PriceFilterInput;

  factory CopyWith$Input$PriceFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PriceFilterInput;

  TRes call({
    String? currency,
    Input$DecimalFilterInput? amount,
  });
  CopyWith$Input$DecimalFilterInput<TRes> get amount;
}

class _CopyWithImpl$Input$PriceFilterInput<TRes>
    implements CopyWith$Input$PriceFilterInput<TRes> {
  _CopyWithImpl$Input$PriceFilterInput(
    this._instance,
    this._then,
  );

  final Input$PriceFilterInput _instance;

  final TRes Function(Input$PriceFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? currency = _undefined,
    Object? amount = _undefined,
  }) =>
      _then(Input$PriceFilterInput._({
        ..._instance._$data,
        if (currency != _undefined) 'currency': (currency as String?),
        if (amount != _undefined && amount != null)
          'amount': (amount as Input$DecimalFilterInput),
      }));

  CopyWith$Input$DecimalFilterInput<TRes> get amount {
    final local$amount = _instance.amount;
    return CopyWith$Input$DecimalFilterInput(
        local$amount, (e) => call(amount: e));
  }
}

class _CopyWithStubImpl$Input$PriceFilterInput<TRes>
    implements CopyWith$Input$PriceFilterInput<TRes> {
  _CopyWithStubImpl$Input$PriceFilterInput(this._res);

  TRes _res;

  call({
    String? currency,
    Input$DecimalFilterInput? amount,
  }) =>
      _res;

  CopyWith$Input$DecimalFilterInput<TRes> get amount =>
      CopyWith$Input$DecimalFilterInput.stub(_res);
}

class Input$PriceInput {
  factory Input$PriceInput({
    required String currency,
    required String amount,
  }) =>
      Input$PriceInput._({
        r'currency': currency,
        r'amount': amount,
      });

  Input$PriceInput._(this._$data);

  factory Input$PriceInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$currency = data['currency'];
    result$data['currency'] = (l$currency as String);
    final l$amount = data['amount'];
    result$data['amount'] = (l$amount as String);
    return Input$PriceInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get currency => (_$data['currency'] as String);

  String get amount => (_$data['amount'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$currency = currency;
    result$data['currency'] = l$currency;
    final l$amount = amount;
    result$data['amount'] = l$amount;
    return result$data;
  }

  CopyWith$Input$PriceInput<Input$PriceInput> get copyWith =>
      CopyWith$Input$PriceInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PriceInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (l$amount != lOther$amount) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$currency = currency;
    final l$amount = amount;
    return Object.hashAll([
      l$currency,
      l$amount,
    ]);
  }
}

abstract class CopyWith$Input$PriceInput<TRes> {
  factory CopyWith$Input$PriceInput(
    Input$PriceInput instance,
    TRes Function(Input$PriceInput) then,
  ) = _CopyWithImpl$Input$PriceInput;

  factory CopyWith$Input$PriceInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PriceInput;

  TRes call({
    String? currency,
    String? amount,
  });
}

class _CopyWithImpl$Input$PriceInput<TRes>
    implements CopyWith$Input$PriceInput<TRes> {
  _CopyWithImpl$Input$PriceInput(
    this._instance,
    this._then,
  );

  final Input$PriceInput _instance;

  final TRes Function(Input$PriceInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? currency = _undefined,
    Object? amount = _undefined,
  }) =>
      _then(Input$PriceInput._({
        ..._instance._$data,
        if (currency != _undefined && currency != null)
          'currency': (currency as String),
        if (amount != _undefined && amount != null)
          'amount': (amount as String),
      }));
}

class _CopyWithStubImpl$Input$PriceInput<TRes>
    implements CopyWith$Input$PriceInput<TRes> {
  _CopyWithStubImpl$Input$PriceInput(this._res);

  TRes _res;

  call({
    String? currency,
    String? amount,
  }) =>
      _res;
}

class Input$PriceRangeInput {
  factory Input$PriceRangeInput({
    double? gte,
    double? lte,
  }) =>
      Input$PriceRangeInput._({
        if (gte != null) r'gte': gte,
        if (lte != null) r'lte': lte,
      });

  Input$PriceRangeInput._(this._$data);

  factory Input$PriceRangeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as num?)?.toDouble();
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as num?)?.toDouble();
    }
    return Input$PriceRangeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get gte => (_$data['gte'] as double?);

  double? get lte => (_$data['lte'] as double?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    return result$data;
  }

  CopyWith$Input$PriceRangeInput<Input$PriceRangeInput> get copyWith =>
      CopyWith$Input$PriceRangeInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PriceRangeInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$gte = gte;
    final l$lte = lte;
    return Object.hashAll([
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('lte') ? l$lte : const {},
    ]);
  }
}

abstract class CopyWith$Input$PriceRangeInput<TRes> {
  factory CopyWith$Input$PriceRangeInput(
    Input$PriceRangeInput instance,
    TRes Function(Input$PriceRangeInput) then,
  ) = _CopyWithImpl$Input$PriceRangeInput;

  factory CopyWith$Input$PriceRangeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PriceRangeInput;

  TRes call({
    double? gte,
    double? lte,
  });
}

class _CopyWithImpl$Input$PriceRangeInput<TRes>
    implements CopyWith$Input$PriceRangeInput<TRes> {
  _CopyWithImpl$Input$PriceRangeInput(
    this._instance,
    this._then,
  );

  final Input$PriceRangeInput _instance;

  final TRes Function(Input$PriceRangeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? gte = _undefined,
    Object? lte = _undefined,
  }) =>
      _then(Input$PriceRangeInput._({
        ..._instance._$data,
        if (gte != _undefined) 'gte': (gte as double?),
        if (lte != _undefined) 'lte': (lte as double?),
      }));
}

class _CopyWithStubImpl$Input$PriceRangeInput<TRes>
    implements CopyWith$Input$PriceRangeInput<TRes> {
  _CopyWithStubImpl$Input$PriceRangeInput(this._res);

  TRes _res;

  call({
    double? gte,
    double? lte,
  }) =>
      _res;
}

class Input$ProductAttributeAssignInput {
  factory Input$ProductAttributeAssignInput({
    required String id,
    required Enum$ProductAttributeType type,
    bool? variantSelection,
  }) =>
      Input$ProductAttributeAssignInput._({
        r'id': id,
        r'type': type,
        if (variantSelection != null) r'variantSelection': variantSelection,
      });

  Input$ProductAttributeAssignInput._(this._$data);

  factory Input$ProductAttributeAssignInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$type = data['type'];
    result$data['type'] =
        fromJson$Enum$ProductAttributeType((l$type as String));
    if (data.containsKey('variantSelection')) {
      final l$variantSelection = data['variantSelection'];
      result$data['variantSelection'] = (l$variantSelection as bool?);
    }
    return Input$ProductAttributeAssignInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);

  Enum$ProductAttributeType get type =>
      (_$data['type'] as Enum$ProductAttributeType);

  bool? get variantSelection => (_$data['variantSelection'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    final l$type = type;
    result$data['type'] = toJson$Enum$ProductAttributeType(l$type);
    if (_$data.containsKey('variantSelection')) {
      final l$variantSelection = variantSelection;
      result$data['variantSelection'] = l$variantSelection;
    }
    return result$data;
  }

  CopyWith$Input$ProductAttributeAssignInput<Input$ProductAttributeAssignInput>
      get copyWith => CopyWith$Input$ProductAttributeAssignInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductAttributeAssignInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) {
      return false;
    }
    final l$variantSelection = variantSelection;
    final lOther$variantSelection = other.variantSelection;
    if (_$data.containsKey('variantSelection') !=
        other._$data.containsKey('variantSelection')) {
      return false;
    }
    if (l$variantSelection != lOther$variantSelection) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$type = type;
    final l$variantSelection = variantSelection;
    return Object.hashAll([
      l$id,
      l$type,
      _$data.containsKey('variantSelection') ? l$variantSelection : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductAttributeAssignInput<TRes> {
  factory CopyWith$Input$ProductAttributeAssignInput(
    Input$ProductAttributeAssignInput instance,
    TRes Function(Input$ProductAttributeAssignInput) then,
  ) = _CopyWithImpl$Input$ProductAttributeAssignInput;

  factory CopyWith$Input$ProductAttributeAssignInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductAttributeAssignInput;

  TRes call({
    String? id,
    Enum$ProductAttributeType? type,
    bool? variantSelection,
  });
}

class _CopyWithImpl$Input$ProductAttributeAssignInput<TRes>
    implements CopyWith$Input$ProductAttributeAssignInput<TRes> {
  _CopyWithImpl$Input$ProductAttributeAssignInput(
    this._instance,
    this._then,
  );

  final Input$ProductAttributeAssignInput _instance;

  final TRes Function(Input$ProductAttributeAssignInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? type = _undefined,
    Object? variantSelection = _undefined,
  }) =>
      _then(Input$ProductAttributeAssignInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (type != _undefined && type != null)
          'type': (type as Enum$ProductAttributeType),
        if (variantSelection != _undefined)
          'variantSelection': (variantSelection as bool?),
      }));
}

class _CopyWithStubImpl$Input$ProductAttributeAssignInput<TRes>
    implements CopyWith$Input$ProductAttributeAssignInput<TRes> {
  _CopyWithStubImpl$Input$ProductAttributeAssignInput(this._res);

  TRes _res;

  call({
    String? id,
    Enum$ProductAttributeType? type,
    bool? variantSelection,
  }) =>
      _res;
}

class Input$ProductAttributeAssignmentUpdateInput {
  factory Input$ProductAttributeAssignmentUpdateInput({
    required String id,
    required bool variantSelection,
  }) =>
      Input$ProductAttributeAssignmentUpdateInput._({
        r'id': id,
        r'variantSelection': variantSelection,
      });

  Input$ProductAttributeAssignmentUpdateInput._(this._$data);

  factory Input$ProductAttributeAssignmentUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$variantSelection = data['variantSelection'];
    result$data['variantSelection'] = (l$variantSelection as bool);
    return Input$ProductAttributeAssignmentUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);

  bool get variantSelection => (_$data['variantSelection'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    final l$variantSelection = variantSelection;
    result$data['variantSelection'] = l$variantSelection;
    return result$data;
  }

  CopyWith$Input$ProductAttributeAssignmentUpdateInput<
          Input$ProductAttributeAssignmentUpdateInput>
      get copyWith => CopyWith$Input$ProductAttributeAssignmentUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductAttributeAssignmentUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$variantSelection = variantSelection;
    final lOther$variantSelection = other.variantSelection;
    if (l$variantSelection != lOther$variantSelection) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$variantSelection = variantSelection;
    return Object.hashAll([
      l$id,
      l$variantSelection,
    ]);
  }
}

abstract class CopyWith$Input$ProductAttributeAssignmentUpdateInput<TRes> {
  factory CopyWith$Input$ProductAttributeAssignmentUpdateInput(
    Input$ProductAttributeAssignmentUpdateInput instance,
    TRes Function(Input$ProductAttributeAssignmentUpdateInput) then,
  ) = _CopyWithImpl$Input$ProductAttributeAssignmentUpdateInput;

  factory CopyWith$Input$ProductAttributeAssignmentUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductAttributeAssignmentUpdateInput;

  TRes call({
    String? id,
    bool? variantSelection,
  });
}

class _CopyWithImpl$Input$ProductAttributeAssignmentUpdateInput<TRes>
    implements CopyWith$Input$ProductAttributeAssignmentUpdateInput<TRes> {
  _CopyWithImpl$Input$ProductAttributeAssignmentUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ProductAttributeAssignmentUpdateInput _instance;

  final TRes Function(Input$ProductAttributeAssignmentUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? variantSelection = _undefined,
  }) =>
      _then(Input$ProductAttributeAssignmentUpdateInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (variantSelection != _undefined && variantSelection != null)
          'variantSelection': (variantSelection as bool),
      }));
}

class _CopyWithStubImpl$Input$ProductAttributeAssignmentUpdateInput<TRes>
    implements CopyWith$Input$ProductAttributeAssignmentUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ProductAttributeAssignmentUpdateInput(this._res);

  TRes _res;

  call({
    String? id,
    bool? variantSelection,
  }) =>
      _res;
}

class Input$ProductBulkCreateInput {
  factory Input$ProductBulkCreateInput({
    List<Input$AttributeValueInput>? attributes,
    String? category,
    bool? chargeTaxes,
    List<String>? collections,
    String? description,
    String? name,
    String? slug,
    String? taxClass,
    String? taxCode,
    Input$SeoInput? seo,
    String? weight,
    double? rating,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
    required String productType,
    List<Input$MediaInput>? media,
    List<Input$ProductChannelListingCreateInput>? channelListings,
    List<Input$ProductVariantBulkCreateInput>? variants,
  }) =>
      Input$ProductBulkCreateInput._({
        if (attributes != null) r'attributes': attributes,
        if (category != null) r'category': category,
        if (chargeTaxes != null) r'chargeTaxes': chargeTaxes,
        if (collections != null) r'collections': collections,
        if (description != null) r'description': description,
        if (name != null) r'name': name,
        if (slug != null) r'slug': slug,
        if (taxClass != null) r'taxClass': taxClass,
        if (taxCode != null) r'taxCode': taxCode,
        if (seo != null) r'seo': seo,
        if (weight != null) r'weight': weight,
        if (rating != null) r'rating': rating,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (externalReference != null) r'externalReference': externalReference,
        r'productType': productType,
        if (media != null) r'media': media,
        if (channelListings != null) r'channelListings': channelListings,
        if (variants != null) r'variants': variants,
      });

  Input$ProductBulkCreateInput._(this._$data);

  factory Input$ProductBulkCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('attributes')) {
      final l$attributes = data['attributes'];
      result$data['attributes'] = (l$attributes as List<dynamic>?)
          ?.map((e) =>
              Input$AttributeValueInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as String?);
    }
    if (data.containsKey('chargeTaxes')) {
      final l$chargeTaxes = data['chargeTaxes'];
      result$data['chargeTaxes'] = (l$chargeTaxes as bool?);
    }
    if (data.containsKey('collections')) {
      final l$collections = data['collections'];
      result$data['collections'] =
          (l$collections as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('taxClass')) {
      final l$taxClass = data['taxClass'];
      result$data['taxClass'] = (l$taxClass as String?);
    }
    if (data.containsKey('taxCode')) {
      final l$taxCode = data['taxCode'];
      result$data['taxCode'] = (l$taxCode as String?);
    }
    if (data.containsKey('seo')) {
      final l$seo = data['seo'];
      result$data['seo'] = l$seo == null
          ? null
          : Input$SeoInput.fromJson((l$seo as Map<String, dynamic>));
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as num?)?.toDouble();
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    final l$productType = data['productType'];
    result$data['productType'] = (l$productType as String);
    if (data.containsKey('media')) {
      final l$media = data['media'];
      result$data['media'] = (l$media as List<dynamic>?)
          ?.map((e) => Input$MediaInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('channelListings')) {
      final l$channelListings = data['channelListings'];
      result$data['channelListings'] = (l$channelListings as List<dynamic>?)
          ?.map((e) => Input$ProductChannelListingCreateInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('variants')) {
      final l$variants = data['variants'];
      result$data['variants'] = (l$variants as List<dynamic>?)
          ?.map((e) => Input$ProductVariantBulkCreateInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$ProductBulkCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$AttributeValueInput>? get attributes =>
      (_$data['attributes'] as List<Input$AttributeValueInput>?);

  String? get category => (_$data['category'] as String?);

  bool? get chargeTaxes => (_$data['chargeTaxes'] as bool?);

  List<String>? get collections => (_$data['collections'] as List<String>?);

  String? get description => (_$data['description'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get slug => (_$data['slug'] as String?);

  String? get taxClass => (_$data['taxClass'] as String?);

  String? get taxCode => (_$data['taxCode'] as String?);

  Input$SeoInput? get seo => (_$data['seo'] as Input$SeoInput?);

  String? get weight => (_$data['weight'] as String?);

  double? get rating => (_$data['rating'] as double?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  String? get externalReference => (_$data['externalReference'] as String?);

  String get productType => (_$data['productType'] as String);

  List<Input$MediaInput>? get media =>
      (_$data['media'] as List<Input$MediaInput>?);

  List<Input$ProductChannelListingCreateInput>? get channelListings =>
      (_$data['channelListings']
          as List<Input$ProductChannelListingCreateInput>?);

  List<Input$ProductVariantBulkCreateInput>? get variants =>
      (_$data['variants'] as List<Input$ProductVariantBulkCreateInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('attributes')) {
      final l$attributes = attributes;
      result$data['attributes'] = l$attributes?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('chargeTaxes')) {
      final l$chargeTaxes = chargeTaxes;
      result$data['chargeTaxes'] = l$chargeTaxes;
    }
    if (_$data.containsKey('collections')) {
      final l$collections = collections;
      result$data['collections'] = l$collections?.map((e) => e).toList();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('taxClass')) {
      final l$taxClass = taxClass;
      result$data['taxClass'] = l$taxClass;
    }
    if (_$data.containsKey('taxCode')) {
      final l$taxCode = taxCode;
      result$data['taxCode'] = l$taxCode;
    }
    if (_$data.containsKey('seo')) {
      final l$seo = seo;
      result$data['seo'] = l$seo?.toJson();
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    final l$productType = productType;
    result$data['productType'] = l$productType;
    if (_$data.containsKey('media')) {
      final l$media = media;
      result$data['media'] = l$media?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('channelListings')) {
      final l$channelListings = channelListings;
      result$data['channelListings'] =
          l$channelListings?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('variants')) {
      final l$variants = variants;
      result$data['variants'] = l$variants?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductBulkCreateInput<Input$ProductBulkCreateInput>
      get copyWith => CopyWith$Input$ProductBulkCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductBulkCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$attributes = attributes;
    final lOther$attributes = other.attributes;
    if (_$data.containsKey('attributes') !=
        other._$data.containsKey('attributes')) {
      return false;
    }
    if (l$attributes != null && lOther$attributes != null) {
      if (l$attributes.length != lOther$attributes.length) {
        return false;
      }
      for (int i = 0; i < l$attributes.length; i++) {
        final l$attributes$entry = l$attributes[i];
        final lOther$attributes$entry = lOther$attributes[i];
        if (l$attributes$entry != lOther$attributes$entry) {
          return false;
        }
      }
    } else if (l$attributes != lOther$attributes) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$chargeTaxes = chargeTaxes;
    final lOther$chargeTaxes = other.chargeTaxes;
    if (_$data.containsKey('chargeTaxes') !=
        other._$data.containsKey('chargeTaxes')) {
      return false;
    }
    if (l$chargeTaxes != lOther$chargeTaxes) {
      return false;
    }
    final l$collections = collections;
    final lOther$collections = other.collections;
    if (_$data.containsKey('collections') !=
        other._$data.containsKey('collections')) {
      return false;
    }
    if (l$collections != null && lOther$collections != null) {
      if (l$collections.length != lOther$collections.length) {
        return false;
      }
      for (int i = 0; i < l$collections.length; i++) {
        final l$collections$entry = l$collections[i];
        final lOther$collections$entry = lOther$collections[i];
        if (l$collections$entry != lOther$collections$entry) {
          return false;
        }
      }
    } else if (l$collections != lOther$collections) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$taxClass = taxClass;
    final lOther$taxClass = other.taxClass;
    if (_$data.containsKey('taxClass') !=
        other._$data.containsKey('taxClass')) {
      return false;
    }
    if (l$taxClass != lOther$taxClass) {
      return false;
    }
    final l$taxCode = taxCode;
    final lOther$taxCode = other.taxCode;
    if (_$data.containsKey('taxCode') != other._$data.containsKey('taxCode')) {
      return false;
    }
    if (l$taxCode != lOther$taxCode) {
      return false;
    }
    final l$seo = seo;
    final lOther$seo = other.seo;
    if (_$data.containsKey('seo') != other._$data.containsKey('seo')) {
      return false;
    }
    if (l$seo != lOther$seo) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$productType = productType;
    final lOther$productType = other.productType;
    if (l$productType != lOther$productType) {
      return false;
    }
    final l$media = media;
    final lOther$media = other.media;
    if (_$data.containsKey('media') != other._$data.containsKey('media')) {
      return false;
    }
    if (l$media != null && lOther$media != null) {
      if (l$media.length != lOther$media.length) {
        return false;
      }
      for (int i = 0; i < l$media.length; i++) {
        final l$media$entry = l$media[i];
        final lOther$media$entry = lOther$media[i];
        if (l$media$entry != lOther$media$entry) {
          return false;
        }
      }
    } else if (l$media != lOther$media) {
      return false;
    }
    final l$channelListings = channelListings;
    final lOther$channelListings = other.channelListings;
    if (_$data.containsKey('channelListings') !=
        other._$data.containsKey('channelListings')) {
      return false;
    }
    if (l$channelListings != null && lOther$channelListings != null) {
      if (l$channelListings.length != lOther$channelListings.length) {
        return false;
      }
      for (int i = 0; i < l$channelListings.length; i++) {
        final l$channelListings$entry = l$channelListings[i];
        final lOther$channelListings$entry = lOther$channelListings[i];
        if (l$channelListings$entry != lOther$channelListings$entry) {
          return false;
        }
      }
    } else if (l$channelListings != lOther$channelListings) {
      return false;
    }
    final l$variants = variants;
    final lOther$variants = other.variants;
    if (_$data.containsKey('variants') !=
        other._$data.containsKey('variants')) {
      return false;
    }
    if (l$variants != null && lOther$variants != null) {
      if (l$variants.length != lOther$variants.length) {
        return false;
      }
      for (int i = 0; i < l$variants.length; i++) {
        final l$variants$entry = l$variants[i];
        final lOther$variants$entry = lOther$variants[i];
        if (l$variants$entry != lOther$variants$entry) {
          return false;
        }
      }
    } else if (l$variants != lOther$variants) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$attributes = attributes;
    final l$category = category;
    final l$chargeTaxes = chargeTaxes;
    final l$collections = collections;
    final l$description = description;
    final l$name = name;
    final l$slug = slug;
    final l$taxClass = taxClass;
    final l$taxCode = taxCode;
    final l$seo = seo;
    final l$weight = weight;
    final l$rating = rating;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$externalReference = externalReference;
    final l$productType = productType;
    final l$media = media;
    final l$channelListings = channelListings;
    final l$variants = variants;
    return Object.hashAll([
      _$data.containsKey('attributes')
          ? l$attributes == null
              ? null
              : Object.hashAll(l$attributes.map((v) => v))
          : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('chargeTaxes') ? l$chargeTaxes : const {},
      _$data.containsKey('collections')
          ? l$collections == null
              ? null
              : Object.hashAll(l$collections.map((v) => v))
          : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('taxClass') ? l$taxClass : const {},
      _$data.containsKey('taxCode') ? l$taxCode : const {},
      _$data.containsKey('seo') ? l$seo : const {},
      _$data.containsKey('weight') ? l$weight : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      l$productType,
      _$data.containsKey('media')
          ? l$media == null
              ? null
              : Object.hashAll(l$media.map((v) => v))
          : const {},
      _$data.containsKey('channelListings')
          ? l$channelListings == null
              ? null
              : Object.hashAll(l$channelListings.map((v) => v))
          : const {},
      _$data.containsKey('variants')
          ? l$variants == null
              ? null
              : Object.hashAll(l$variants.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductBulkCreateInput<TRes> {
  factory CopyWith$Input$ProductBulkCreateInput(
    Input$ProductBulkCreateInput instance,
    TRes Function(Input$ProductBulkCreateInput) then,
  ) = _CopyWithImpl$Input$ProductBulkCreateInput;

  factory CopyWith$Input$ProductBulkCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductBulkCreateInput;

  TRes call({
    List<Input$AttributeValueInput>? attributes,
    String? category,
    bool? chargeTaxes,
    List<String>? collections,
    String? description,
    String? name,
    String? slug,
    String? taxClass,
    String? taxCode,
    Input$SeoInput? seo,
    String? weight,
    double? rating,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
    String? productType,
    List<Input$MediaInput>? media,
    List<Input$ProductChannelListingCreateInput>? channelListings,
    List<Input$ProductVariantBulkCreateInput>? variants,
  });
  TRes attributes(
      Iterable<Input$AttributeValueInput>? Function(
              Iterable<
                  CopyWith$Input$AttributeValueInput<
                      Input$AttributeValueInput>>?)
          _fn);
  CopyWith$Input$SeoInput<TRes> get seo;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes media(
      Iterable<Input$MediaInput>? Function(
              Iterable<CopyWith$Input$MediaInput<Input$MediaInput>>?)
          _fn);
  TRes channelListings(
      Iterable<Input$ProductChannelListingCreateInput>? Function(
              Iterable<
                  CopyWith$Input$ProductChannelListingCreateInput<
                      Input$ProductChannelListingCreateInput>>?)
          _fn);
  TRes variants(
      Iterable<Input$ProductVariantBulkCreateInput>? Function(
              Iterable<
                  CopyWith$Input$ProductVariantBulkCreateInput<
                      Input$ProductVariantBulkCreateInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductBulkCreateInput<TRes>
    implements CopyWith$Input$ProductBulkCreateInput<TRes> {
  _CopyWithImpl$Input$ProductBulkCreateInput(
    this._instance,
    this._then,
  );

  final Input$ProductBulkCreateInput _instance;

  final TRes Function(Input$ProductBulkCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? attributes = _undefined,
    Object? category = _undefined,
    Object? chargeTaxes = _undefined,
    Object? collections = _undefined,
    Object? description = _undefined,
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? taxClass = _undefined,
    Object? taxCode = _undefined,
    Object? seo = _undefined,
    Object? weight = _undefined,
    Object? rating = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? externalReference = _undefined,
    Object? productType = _undefined,
    Object? media = _undefined,
    Object? channelListings = _undefined,
    Object? variants = _undefined,
  }) =>
      _then(Input$ProductBulkCreateInput._({
        ..._instance._$data,
        if (attributes != _undefined)
          'attributes': (attributes as List<Input$AttributeValueInput>?),
        if (category != _undefined) 'category': (category as String?),
        if (chargeTaxes != _undefined) 'chargeTaxes': (chargeTaxes as bool?),
        if (collections != _undefined)
          'collections': (collections as List<String>?),
        if (description != _undefined) 'description': (description as String?),
        if (name != _undefined) 'name': (name as String?),
        if (slug != _undefined) 'slug': (slug as String?),
        if (taxClass != _undefined) 'taxClass': (taxClass as String?),
        if (taxCode != _undefined) 'taxCode': (taxCode as String?),
        if (seo != _undefined) 'seo': (seo as Input$SeoInput?),
        if (weight != _undefined) 'weight': (weight as String?),
        if (rating != _undefined) 'rating': (rating as double?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (productType != _undefined && productType != null)
          'productType': (productType as String),
        if (media != _undefined) 'media': (media as List<Input$MediaInput>?),
        if (channelListings != _undefined)
          'channelListings': (channelListings
              as List<Input$ProductChannelListingCreateInput>?),
        if (variants != _undefined)
          'variants': (variants as List<Input$ProductVariantBulkCreateInput>?),
      }));

  TRes attributes(
          Iterable<Input$AttributeValueInput>? Function(
                  Iterable<
                      CopyWith$Input$AttributeValueInput<
                          Input$AttributeValueInput>>?)
              _fn) =>
      call(
          attributes: _fn(_instance.attributes
              ?.map((e) => CopyWith$Input$AttributeValueInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$SeoInput<TRes> get seo {
    final local$seo = _instance.seo;
    return local$seo == null
        ? CopyWith$Input$SeoInput.stub(_then(_instance))
        : CopyWith$Input$SeoInput(local$seo, (e) => call(seo: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes media(
          Iterable<Input$MediaInput>? Function(
                  Iterable<CopyWith$Input$MediaInput<Input$MediaInput>>?)
              _fn) =>
      call(
          media: _fn(_instance.media?.map((e) => CopyWith$Input$MediaInput(
                e,
                (i) => i,
              )))?.toList());

  TRes channelListings(
          Iterable<Input$ProductChannelListingCreateInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductChannelListingCreateInput<
                          Input$ProductChannelListingCreateInput>>?)
              _fn) =>
      call(
          channelListings: _fn(_instance.channelListings
              ?.map((e) => CopyWith$Input$ProductChannelListingCreateInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes variants(
          Iterable<Input$ProductVariantBulkCreateInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductVariantBulkCreateInput<
                          Input$ProductVariantBulkCreateInput>>?)
              _fn) =>
      call(
          variants: _fn(_instance.variants
              ?.map((e) => CopyWith$Input$ProductVariantBulkCreateInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductBulkCreateInput<TRes>
    implements CopyWith$Input$ProductBulkCreateInput<TRes> {
  _CopyWithStubImpl$Input$ProductBulkCreateInput(this._res);

  TRes _res;

  call({
    List<Input$AttributeValueInput>? attributes,
    String? category,
    bool? chargeTaxes,
    List<String>? collections,
    String? description,
    String? name,
    String? slug,
    String? taxClass,
    String? taxCode,
    Input$SeoInput? seo,
    String? weight,
    double? rating,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
    String? productType,
    List<Input$MediaInput>? media,
    List<Input$ProductChannelListingCreateInput>? channelListings,
    List<Input$ProductVariantBulkCreateInput>? variants,
  }) =>
      _res;

  attributes(_fn) => _res;

  CopyWith$Input$SeoInput<TRes> get seo => CopyWith$Input$SeoInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;

  media(_fn) => _res;

  channelListings(_fn) => _res;

  variants(_fn) => _res;
}

class Input$ProductBulkTranslateInput {
  factory Input$ProductBulkTranslateInput({
    String? id,
    String? externalReference,
    required Enum$LanguageCodeEnum languageCode,
    required Input$TranslationInput translationFields,
  }) =>
      Input$ProductBulkTranslateInput._({
        if (id != null) r'id': id,
        if (externalReference != null) r'externalReference': externalReference,
        r'languageCode': languageCode,
        r'translationFields': translationFields,
      });

  Input$ProductBulkTranslateInput._(this._$data);

  factory Input$ProductBulkTranslateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    final l$languageCode = data['languageCode'];
    result$data['languageCode'] =
        fromJson$Enum$LanguageCodeEnum((l$languageCode as String));
    final l$translationFields = data['translationFields'];
    result$data['translationFields'] = Input$TranslationInput.fromJson(
        (l$translationFields as Map<String, dynamic>));
    return Input$ProductBulkTranslateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get externalReference => (_$data['externalReference'] as String?);

  Enum$LanguageCodeEnum get languageCode =>
      (_$data['languageCode'] as Enum$LanguageCodeEnum);

  Input$TranslationInput get translationFields =>
      (_$data['translationFields'] as Input$TranslationInput);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    final l$languageCode = languageCode;
    result$data['languageCode'] = toJson$Enum$LanguageCodeEnum(l$languageCode);
    final l$translationFields = translationFields;
    result$data['translationFields'] = l$translationFields.toJson();
    return result$data;
  }

  CopyWith$Input$ProductBulkTranslateInput<Input$ProductBulkTranslateInput>
      get copyWith => CopyWith$Input$ProductBulkTranslateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductBulkTranslateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$languageCode = languageCode;
    final lOther$languageCode = other.languageCode;
    if (l$languageCode != lOther$languageCode) {
      return false;
    }
    final l$translationFields = translationFields;
    final lOther$translationFields = other.translationFields;
    if (l$translationFields != lOther$translationFields) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$externalReference = externalReference;
    final l$languageCode = languageCode;
    final l$translationFields = translationFields;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      l$languageCode,
      l$translationFields,
    ]);
  }
}

abstract class CopyWith$Input$ProductBulkTranslateInput<TRes> {
  factory CopyWith$Input$ProductBulkTranslateInput(
    Input$ProductBulkTranslateInput instance,
    TRes Function(Input$ProductBulkTranslateInput) then,
  ) = _CopyWithImpl$Input$ProductBulkTranslateInput;

  factory CopyWith$Input$ProductBulkTranslateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductBulkTranslateInput;

  TRes call({
    String? id,
    String? externalReference,
    Enum$LanguageCodeEnum? languageCode,
    Input$TranslationInput? translationFields,
  });
  CopyWith$Input$TranslationInput<TRes> get translationFields;
}

class _CopyWithImpl$Input$ProductBulkTranslateInput<TRes>
    implements CopyWith$Input$ProductBulkTranslateInput<TRes> {
  _CopyWithImpl$Input$ProductBulkTranslateInput(
    this._instance,
    this._then,
  );

  final Input$ProductBulkTranslateInput _instance;

  final TRes Function(Input$ProductBulkTranslateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? externalReference = _undefined,
    Object? languageCode = _undefined,
    Object? translationFields = _undefined,
  }) =>
      _then(Input$ProductBulkTranslateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (languageCode != _undefined && languageCode != null)
          'languageCode': (languageCode as Enum$LanguageCodeEnum),
        if (translationFields != _undefined && translationFields != null)
          'translationFields': (translationFields as Input$TranslationInput),
      }));

  CopyWith$Input$TranslationInput<TRes> get translationFields {
    final local$translationFields = _instance.translationFields;
    return CopyWith$Input$TranslationInput(
        local$translationFields, (e) => call(translationFields: e));
  }
}

class _CopyWithStubImpl$Input$ProductBulkTranslateInput<TRes>
    implements CopyWith$Input$ProductBulkTranslateInput<TRes> {
  _CopyWithStubImpl$Input$ProductBulkTranslateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? externalReference,
    Enum$LanguageCodeEnum? languageCode,
    Input$TranslationInput? translationFields,
  }) =>
      _res;

  CopyWith$Input$TranslationInput<TRes> get translationFields =>
      CopyWith$Input$TranslationInput.stub(_res);
}

class Input$ProductChannelListingAddInput {
  factory Input$ProductChannelListingAddInput({
    required String channelId,
    bool? isPublished,
    String? publicationDate,
    String? publishedAt,
    bool? visibleInListings,
    bool? isAvailableForPurchase,
    String? availableForPurchaseDate,
    String? availableForPurchaseAt,
    List<String>? addVariants,
    List<String>? removeVariants,
  }) =>
      Input$ProductChannelListingAddInput._({
        r'channelId': channelId,
        if (isPublished != null) r'isPublished': isPublished,
        if (publicationDate != null) r'publicationDate': publicationDate,
        if (publishedAt != null) r'publishedAt': publishedAt,
        if (visibleInListings != null) r'visibleInListings': visibleInListings,
        if (isAvailableForPurchase != null)
          r'isAvailableForPurchase': isAvailableForPurchase,
        if (availableForPurchaseDate != null)
          r'availableForPurchaseDate': availableForPurchaseDate,
        if (availableForPurchaseAt != null)
          r'availableForPurchaseAt': availableForPurchaseAt,
        if (addVariants != null) r'addVariants': addVariants,
        if (removeVariants != null) r'removeVariants': removeVariants,
      });

  Input$ProductChannelListingAddInput._(this._$data);

  factory Input$ProductChannelListingAddInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$channelId = data['channelId'];
    result$data['channelId'] = (l$channelId as String);
    if (data.containsKey('isPublished')) {
      final l$isPublished = data['isPublished'];
      result$data['isPublished'] = (l$isPublished as bool?);
    }
    if (data.containsKey('publicationDate')) {
      final l$publicationDate = data['publicationDate'];
      result$data['publicationDate'] = (l$publicationDate as String?);
    }
    if (data.containsKey('publishedAt')) {
      final l$publishedAt = data['publishedAt'];
      result$data['publishedAt'] = (l$publishedAt as String?);
    }
    if (data.containsKey('visibleInListings')) {
      final l$visibleInListings = data['visibleInListings'];
      result$data['visibleInListings'] = (l$visibleInListings as bool?);
    }
    if (data.containsKey('isAvailableForPurchase')) {
      final l$isAvailableForPurchase = data['isAvailableForPurchase'];
      result$data['isAvailableForPurchase'] =
          (l$isAvailableForPurchase as bool?);
    }
    if (data.containsKey('availableForPurchaseDate')) {
      final l$availableForPurchaseDate = data['availableForPurchaseDate'];
      result$data['availableForPurchaseDate'] =
          (l$availableForPurchaseDate as String?);
    }
    if (data.containsKey('availableForPurchaseAt')) {
      final l$availableForPurchaseAt = data['availableForPurchaseAt'];
      result$data['availableForPurchaseAt'] =
          (l$availableForPurchaseAt as String?);
    }
    if (data.containsKey('addVariants')) {
      final l$addVariants = data['addVariants'];
      result$data['addVariants'] =
          (l$addVariants as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('removeVariants')) {
      final l$removeVariants = data['removeVariants'];
      result$data['removeVariants'] = (l$removeVariants as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$ProductChannelListingAddInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get channelId => (_$data['channelId'] as String);

  bool? get isPublished => (_$data['isPublished'] as bool?);

  String? get publicationDate => (_$data['publicationDate'] as String?);

  String? get publishedAt => (_$data['publishedAt'] as String?);

  bool? get visibleInListings => (_$data['visibleInListings'] as bool?);

  bool? get isAvailableForPurchase =>
      (_$data['isAvailableForPurchase'] as bool?);

  String? get availableForPurchaseDate =>
      (_$data['availableForPurchaseDate'] as String?);

  String? get availableForPurchaseAt =>
      (_$data['availableForPurchaseAt'] as String?);

  List<String>? get addVariants => (_$data['addVariants'] as List<String>?);

  List<String>? get removeVariants =>
      (_$data['removeVariants'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$channelId = channelId;
    result$data['channelId'] = l$channelId;
    if (_$data.containsKey('isPublished')) {
      final l$isPublished = isPublished;
      result$data['isPublished'] = l$isPublished;
    }
    if (_$data.containsKey('publicationDate')) {
      final l$publicationDate = publicationDate;
      result$data['publicationDate'] = l$publicationDate;
    }
    if (_$data.containsKey('publishedAt')) {
      final l$publishedAt = publishedAt;
      result$data['publishedAt'] = l$publishedAt;
    }
    if (_$data.containsKey('visibleInListings')) {
      final l$visibleInListings = visibleInListings;
      result$data['visibleInListings'] = l$visibleInListings;
    }
    if (_$data.containsKey('isAvailableForPurchase')) {
      final l$isAvailableForPurchase = isAvailableForPurchase;
      result$data['isAvailableForPurchase'] = l$isAvailableForPurchase;
    }
    if (_$data.containsKey('availableForPurchaseDate')) {
      final l$availableForPurchaseDate = availableForPurchaseDate;
      result$data['availableForPurchaseDate'] = l$availableForPurchaseDate;
    }
    if (_$data.containsKey('availableForPurchaseAt')) {
      final l$availableForPurchaseAt = availableForPurchaseAt;
      result$data['availableForPurchaseAt'] = l$availableForPurchaseAt;
    }
    if (_$data.containsKey('addVariants')) {
      final l$addVariants = addVariants;
      result$data['addVariants'] = l$addVariants?.map((e) => e).toList();
    }
    if (_$data.containsKey('removeVariants')) {
      final l$removeVariants = removeVariants;
      result$data['removeVariants'] = l$removeVariants?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductChannelListingAddInput<
          Input$ProductChannelListingAddInput>
      get copyWith => CopyWith$Input$ProductChannelListingAddInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductChannelListingAddInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$channelId = channelId;
    final lOther$channelId = other.channelId;
    if (l$channelId != lOther$channelId) {
      return false;
    }
    final l$isPublished = isPublished;
    final lOther$isPublished = other.isPublished;
    if (_$data.containsKey('isPublished') !=
        other._$data.containsKey('isPublished')) {
      return false;
    }
    if (l$isPublished != lOther$isPublished) {
      return false;
    }
    final l$publicationDate = publicationDate;
    final lOther$publicationDate = other.publicationDate;
    if (_$data.containsKey('publicationDate') !=
        other._$data.containsKey('publicationDate')) {
      return false;
    }
    if (l$publicationDate != lOther$publicationDate) {
      return false;
    }
    final l$publishedAt = publishedAt;
    final lOther$publishedAt = other.publishedAt;
    if (_$data.containsKey('publishedAt') !=
        other._$data.containsKey('publishedAt')) {
      return false;
    }
    if (l$publishedAt != lOther$publishedAt) {
      return false;
    }
    final l$visibleInListings = visibleInListings;
    final lOther$visibleInListings = other.visibleInListings;
    if (_$data.containsKey('visibleInListings') !=
        other._$data.containsKey('visibleInListings')) {
      return false;
    }
    if (l$visibleInListings != lOther$visibleInListings) {
      return false;
    }
    final l$isAvailableForPurchase = isAvailableForPurchase;
    final lOther$isAvailableForPurchase = other.isAvailableForPurchase;
    if (_$data.containsKey('isAvailableForPurchase') !=
        other._$data.containsKey('isAvailableForPurchase')) {
      return false;
    }
    if (l$isAvailableForPurchase != lOther$isAvailableForPurchase) {
      return false;
    }
    final l$availableForPurchaseDate = availableForPurchaseDate;
    final lOther$availableForPurchaseDate = other.availableForPurchaseDate;
    if (_$data.containsKey('availableForPurchaseDate') !=
        other._$data.containsKey('availableForPurchaseDate')) {
      return false;
    }
    if (l$availableForPurchaseDate != lOther$availableForPurchaseDate) {
      return false;
    }
    final l$availableForPurchaseAt = availableForPurchaseAt;
    final lOther$availableForPurchaseAt = other.availableForPurchaseAt;
    if (_$data.containsKey('availableForPurchaseAt') !=
        other._$data.containsKey('availableForPurchaseAt')) {
      return false;
    }
    if (l$availableForPurchaseAt != lOther$availableForPurchaseAt) {
      return false;
    }
    final l$addVariants = addVariants;
    final lOther$addVariants = other.addVariants;
    if (_$data.containsKey('addVariants') !=
        other._$data.containsKey('addVariants')) {
      return false;
    }
    if (l$addVariants != null && lOther$addVariants != null) {
      if (l$addVariants.length != lOther$addVariants.length) {
        return false;
      }
      for (int i = 0; i < l$addVariants.length; i++) {
        final l$addVariants$entry = l$addVariants[i];
        final lOther$addVariants$entry = lOther$addVariants[i];
        if (l$addVariants$entry != lOther$addVariants$entry) {
          return false;
        }
      }
    } else if (l$addVariants != lOther$addVariants) {
      return false;
    }
    final l$removeVariants = removeVariants;
    final lOther$removeVariants = other.removeVariants;
    if (_$data.containsKey('removeVariants') !=
        other._$data.containsKey('removeVariants')) {
      return false;
    }
    if (l$removeVariants != null && lOther$removeVariants != null) {
      if (l$removeVariants.length != lOther$removeVariants.length) {
        return false;
      }
      for (int i = 0; i < l$removeVariants.length; i++) {
        final l$removeVariants$entry = l$removeVariants[i];
        final lOther$removeVariants$entry = lOther$removeVariants[i];
        if (l$removeVariants$entry != lOther$removeVariants$entry) {
          return false;
        }
      }
    } else if (l$removeVariants != lOther$removeVariants) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$channelId = channelId;
    final l$isPublished = isPublished;
    final l$publicationDate = publicationDate;
    final l$publishedAt = publishedAt;
    final l$visibleInListings = visibleInListings;
    final l$isAvailableForPurchase = isAvailableForPurchase;
    final l$availableForPurchaseDate = availableForPurchaseDate;
    final l$availableForPurchaseAt = availableForPurchaseAt;
    final l$addVariants = addVariants;
    final l$removeVariants = removeVariants;
    return Object.hashAll([
      l$channelId,
      _$data.containsKey('isPublished') ? l$isPublished : const {},
      _$data.containsKey('publicationDate') ? l$publicationDate : const {},
      _$data.containsKey('publishedAt') ? l$publishedAt : const {},
      _$data.containsKey('visibleInListings') ? l$visibleInListings : const {},
      _$data.containsKey('isAvailableForPurchase')
          ? l$isAvailableForPurchase
          : const {},
      _$data.containsKey('availableForPurchaseDate')
          ? l$availableForPurchaseDate
          : const {},
      _$data.containsKey('availableForPurchaseAt')
          ? l$availableForPurchaseAt
          : const {},
      _$data.containsKey('addVariants')
          ? l$addVariants == null
              ? null
              : Object.hashAll(l$addVariants.map((v) => v))
          : const {},
      _$data.containsKey('removeVariants')
          ? l$removeVariants == null
              ? null
              : Object.hashAll(l$removeVariants.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductChannelListingAddInput<TRes> {
  factory CopyWith$Input$ProductChannelListingAddInput(
    Input$ProductChannelListingAddInput instance,
    TRes Function(Input$ProductChannelListingAddInput) then,
  ) = _CopyWithImpl$Input$ProductChannelListingAddInput;

  factory CopyWith$Input$ProductChannelListingAddInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductChannelListingAddInput;

  TRes call({
    String? channelId,
    bool? isPublished,
    String? publicationDate,
    String? publishedAt,
    bool? visibleInListings,
    bool? isAvailableForPurchase,
    String? availableForPurchaseDate,
    String? availableForPurchaseAt,
    List<String>? addVariants,
    List<String>? removeVariants,
  });
}

class _CopyWithImpl$Input$ProductChannelListingAddInput<TRes>
    implements CopyWith$Input$ProductChannelListingAddInput<TRes> {
  _CopyWithImpl$Input$ProductChannelListingAddInput(
    this._instance,
    this._then,
  );

  final Input$ProductChannelListingAddInput _instance;

  final TRes Function(Input$ProductChannelListingAddInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? channelId = _undefined,
    Object? isPublished = _undefined,
    Object? publicationDate = _undefined,
    Object? publishedAt = _undefined,
    Object? visibleInListings = _undefined,
    Object? isAvailableForPurchase = _undefined,
    Object? availableForPurchaseDate = _undefined,
    Object? availableForPurchaseAt = _undefined,
    Object? addVariants = _undefined,
    Object? removeVariants = _undefined,
  }) =>
      _then(Input$ProductChannelListingAddInput._({
        ..._instance._$data,
        if (channelId != _undefined && channelId != null)
          'channelId': (channelId as String),
        if (isPublished != _undefined) 'isPublished': (isPublished as bool?),
        if (publicationDate != _undefined)
          'publicationDate': (publicationDate as String?),
        if (publishedAt != _undefined) 'publishedAt': (publishedAt as String?),
        if (visibleInListings != _undefined)
          'visibleInListings': (visibleInListings as bool?),
        if (isAvailableForPurchase != _undefined)
          'isAvailableForPurchase': (isAvailableForPurchase as bool?),
        if (availableForPurchaseDate != _undefined)
          'availableForPurchaseDate': (availableForPurchaseDate as String?),
        if (availableForPurchaseAt != _undefined)
          'availableForPurchaseAt': (availableForPurchaseAt as String?),
        if (addVariants != _undefined)
          'addVariants': (addVariants as List<String>?),
        if (removeVariants != _undefined)
          'removeVariants': (removeVariants as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$ProductChannelListingAddInput<TRes>
    implements CopyWith$Input$ProductChannelListingAddInput<TRes> {
  _CopyWithStubImpl$Input$ProductChannelListingAddInput(this._res);

  TRes _res;

  call({
    String? channelId,
    bool? isPublished,
    String? publicationDate,
    String? publishedAt,
    bool? visibleInListings,
    bool? isAvailableForPurchase,
    String? availableForPurchaseDate,
    String? availableForPurchaseAt,
    List<String>? addVariants,
    List<String>? removeVariants,
  }) =>
      _res;
}

class Input$ProductChannelListingCreateInput {
  factory Input$ProductChannelListingCreateInput({
    required String channelId,
    bool? isPublished,
    String? publishedAt,
    bool? visibleInListings,
    bool? isAvailableForPurchase,
    String? availableForPurchaseAt,
  }) =>
      Input$ProductChannelListingCreateInput._({
        r'channelId': channelId,
        if (isPublished != null) r'isPublished': isPublished,
        if (publishedAt != null) r'publishedAt': publishedAt,
        if (visibleInListings != null) r'visibleInListings': visibleInListings,
        if (isAvailableForPurchase != null)
          r'isAvailableForPurchase': isAvailableForPurchase,
        if (availableForPurchaseAt != null)
          r'availableForPurchaseAt': availableForPurchaseAt,
      });

  Input$ProductChannelListingCreateInput._(this._$data);

  factory Input$ProductChannelListingCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$channelId = data['channelId'];
    result$data['channelId'] = (l$channelId as String);
    if (data.containsKey('isPublished')) {
      final l$isPublished = data['isPublished'];
      result$data['isPublished'] = (l$isPublished as bool?);
    }
    if (data.containsKey('publishedAt')) {
      final l$publishedAt = data['publishedAt'];
      result$data['publishedAt'] = (l$publishedAt as String?);
    }
    if (data.containsKey('visibleInListings')) {
      final l$visibleInListings = data['visibleInListings'];
      result$data['visibleInListings'] = (l$visibleInListings as bool?);
    }
    if (data.containsKey('isAvailableForPurchase')) {
      final l$isAvailableForPurchase = data['isAvailableForPurchase'];
      result$data['isAvailableForPurchase'] =
          (l$isAvailableForPurchase as bool?);
    }
    if (data.containsKey('availableForPurchaseAt')) {
      final l$availableForPurchaseAt = data['availableForPurchaseAt'];
      result$data['availableForPurchaseAt'] =
          (l$availableForPurchaseAt as String?);
    }
    return Input$ProductChannelListingCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get channelId => (_$data['channelId'] as String);

  bool? get isPublished => (_$data['isPublished'] as bool?);

  String? get publishedAt => (_$data['publishedAt'] as String?);

  bool? get visibleInListings => (_$data['visibleInListings'] as bool?);

  bool? get isAvailableForPurchase =>
      (_$data['isAvailableForPurchase'] as bool?);

  String? get availableForPurchaseAt =>
      (_$data['availableForPurchaseAt'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$channelId = channelId;
    result$data['channelId'] = l$channelId;
    if (_$data.containsKey('isPublished')) {
      final l$isPublished = isPublished;
      result$data['isPublished'] = l$isPublished;
    }
    if (_$data.containsKey('publishedAt')) {
      final l$publishedAt = publishedAt;
      result$data['publishedAt'] = l$publishedAt;
    }
    if (_$data.containsKey('visibleInListings')) {
      final l$visibleInListings = visibleInListings;
      result$data['visibleInListings'] = l$visibleInListings;
    }
    if (_$data.containsKey('isAvailableForPurchase')) {
      final l$isAvailableForPurchase = isAvailableForPurchase;
      result$data['isAvailableForPurchase'] = l$isAvailableForPurchase;
    }
    if (_$data.containsKey('availableForPurchaseAt')) {
      final l$availableForPurchaseAt = availableForPurchaseAt;
      result$data['availableForPurchaseAt'] = l$availableForPurchaseAt;
    }
    return result$data;
  }

  CopyWith$Input$ProductChannelListingCreateInput<
          Input$ProductChannelListingCreateInput>
      get copyWith => CopyWith$Input$ProductChannelListingCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductChannelListingCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$channelId = channelId;
    final lOther$channelId = other.channelId;
    if (l$channelId != lOther$channelId) {
      return false;
    }
    final l$isPublished = isPublished;
    final lOther$isPublished = other.isPublished;
    if (_$data.containsKey('isPublished') !=
        other._$data.containsKey('isPublished')) {
      return false;
    }
    if (l$isPublished != lOther$isPublished) {
      return false;
    }
    final l$publishedAt = publishedAt;
    final lOther$publishedAt = other.publishedAt;
    if (_$data.containsKey('publishedAt') !=
        other._$data.containsKey('publishedAt')) {
      return false;
    }
    if (l$publishedAt != lOther$publishedAt) {
      return false;
    }
    final l$visibleInListings = visibleInListings;
    final lOther$visibleInListings = other.visibleInListings;
    if (_$data.containsKey('visibleInListings') !=
        other._$data.containsKey('visibleInListings')) {
      return false;
    }
    if (l$visibleInListings != lOther$visibleInListings) {
      return false;
    }
    final l$isAvailableForPurchase = isAvailableForPurchase;
    final lOther$isAvailableForPurchase = other.isAvailableForPurchase;
    if (_$data.containsKey('isAvailableForPurchase') !=
        other._$data.containsKey('isAvailableForPurchase')) {
      return false;
    }
    if (l$isAvailableForPurchase != lOther$isAvailableForPurchase) {
      return false;
    }
    final l$availableForPurchaseAt = availableForPurchaseAt;
    final lOther$availableForPurchaseAt = other.availableForPurchaseAt;
    if (_$data.containsKey('availableForPurchaseAt') !=
        other._$data.containsKey('availableForPurchaseAt')) {
      return false;
    }
    if (l$availableForPurchaseAt != lOther$availableForPurchaseAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$channelId = channelId;
    final l$isPublished = isPublished;
    final l$publishedAt = publishedAt;
    final l$visibleInListings = visibleInListings;
    final l$isAvailableForPurchase = isAvailableForPurchase;
    final l$availableForPurchaseAt = availableForPurchaseAt;
    return Object.hashAll([
      l$channelId,
      _$data.containsKey('isPublished') ? l$isPublished : const {},
      _$data.containsKey('publishedAt') ? l$publishedAt : const {},
      _$data.containsKey('visibleInListings') ? l$visibleInListings : const {},
      _$data.containsKey('isAvailableForPurchase')
          ? l$isAvailableForPurchase
          : const {},
      _$data.containsKey('availableForPurchaseAt')
          ? l$availableForPurchaseAt
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductChannelListingCreateInput<TRes> {
  factory CopyWith$Input$ProductChannelListingCreateInput(
    Input$ProductChannelListingCreateInput instance,
    TRes Function(Input$ProductChannelListingCreateInput) then,
  ) = _CopyWithImpl$Input$ProductChannelListingCreateInput;

  factory CopyWith$Input$ProductChannelListingCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductChannelListingCreateInput;

  TRes call({
    String? channelId,
    bool? isPublished,
    String? publishedAt,
    bool? visibleInListings,
    bool? isAvailableForPurchase,
    String? availableForPurchaseAt,
  });
}

class _CopyWithImpl$Input$ProductChannelListingCreateInput<TRes>
    implements CopyWith$Input$ProductChannelListingCreateInput<TRes> {
  _CopyWithImpl$Input$ProductChannelListingCreateInput(
    this._instance,
    this._then,
  );

  final Input$ProductChannelListingCreateInput _instance;

  final TRes Function(Input$ProductChannelListingCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? channelId = _undefined,
    Object? isPublished = _undefined,
    Object? publishedAt = _undefined,
    Object? visibleInListings = _undefined,
    Object? isAvailableForPurchase = _undefined,
    Object? availableForPurchaseAt = _undefined,
  }) =>
      _then(Input$ProductChannelListingCreateInput._({
        ..._instance._$data,
        if (channelId != _undefined && channelId != null)
          'channelId': (channelId as String),
        if (isPublished != _undefined) 'isPublished': (isPublished as bool?),
        if (publishedAt != _undefined) 'publishedAt': (publishedAt as String?),
        if (visibleInListings != _undefined)
          'visibleInListings': (visibleInListings as bool?),
        if (isAvailableForPurchase != _undefined)
          'isAvailableForPurchase': (isAvailableForPurchase as bool?),
        if (availableForPurchaseAt != _undefined)
          'availableForPurchaseAt': (availableForPurchaseAt as String?),
      }));
}

class _CopyWithStubImpl$Input$ProductChannelListingCreateInput<TRes>
    implements CopyWith$Input$ProductChannelListingCreateInput<TRes> {
  _CopyWithStubImpl$Input$ProductChannelListingCreateInput(this._res);

  TRes _res;

  call({
    String? channelId,
    bool? isPublished,
    String? publishedAt,
    bool? visibleInListings,
    bool? isAvailableForPurchase,
    String? availableForPurchaseAt,
  }) =>
      _res;
}

class Input$ProductChannelListingUpdateInput {
  factory Input$ProductChannelListingUpdateInput({
    List<Input$ProductChannelListingAddInput>? updateChannels,
    List<String>? removeChannels,
  }) =>
      Input$ProductChannelListingUpdateInput._({
        if (updateChannels != null) r'updateChannels': updateChannels,
        if (removeChannels != null) r'removeChannels': removeChannels,
      });

  Input$ProductChannelListingUpdateInput._(this._$data);

  factory Input$ProductChannelListingUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('updateChannels')) {
      final l$updateChannels = data['updateChannels'];
      result$data['updateChannels'] = (l$updateChannels as List<dynamic>?)
          ?.map((e) => Input$ProductChannelListingAddInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('removeChannels')) {
      final l$removeChannels = data['removeChannels'];
      result$data['removeChannels'] = (l$removeChannels as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$ProductChannelListingUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductChannelListingAddInput>? get updateChannels =>
      (_$data['updateChannels'] as List<Input$ProductChannelListingAddInput>?);

  List<String>? get removeChannels =>
      (_$data['removeChannels'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('updateChannels')) {
      final l$updateChannels = updateChannels;
      result$data['updateChannels'] =
          l$updateChannels?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('removeChannels')) {
      final l$removeChannels = removeChannels;
      result$data['removeChannels'] = l$removeChannels?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductChannelListingUpdateInput<
          Input$ProductChannelListingUpdateInput>
      get copyWith => CopyWith$Input$ProductChannelListingUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductChannelListingUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$updateChannels = updateChannels;
    final lOther$updateChannels = other.updateChannels;
    if (_$data.containsKey('updateChannels') !=
        other._$data.containsKey('updateChannels')) {
      return false;
    }
    if (l$updateChannels != null && lOther$updateChannels != null) {
      if (l$updateChannels.length != lOther$updateChannels.length) {
        return false;
      }
      for (int i = 0; i < l$updateChannels.length; i++) {
        final l$updateChannels$entry = l$updateChannels[i];
        final lOther$updateChannels$entry = lOther$updateChannels[i];
        if (l$updateChannels$entry != lOther$updateChannels$entry) {
          return false;
        }
      }
    } else if (l$updateChannels != lOther$updateChannels) {
      return false;
    }
    final l$removeChannels = removeChannels;
    final lOther$removeChannels = other.removeChannels;
    if (_$data.containsKey('removeChannels') !=
        other._$data.containsKey('removeChannels')) {
      return false;
    }
    if (l$removeChannels != null && lOther$removeChannels != null) {
      if (l$removeChannels.length != lOther$removeChannels.length) {
        return false;
      }
      for (int i = 0; i < l$removeChannels.length; i++) {
        final l$removeChannels$entry = l$removeChannels[i];
        final lOther$removeChannels$entry = lOther$removeChannels[i];
        if (l$removeChannels$entry != lOther$removeChannels$entry) {
          return false;
        }
      }
    } else if (l$removeChannels != lOther$removeChannels) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$updateChannels = updateChannels;
    final l$removeChannels = removeChannels;
    return Object.hashAll([
      _$data.containsKey('updateChannels')
          ? l$updateChannels == null
              ? null
              : Object.hashAll(l$updateChannels.map((v) => v))
          : const {},
      _$data.containsKey('removeChannels')
          ? l$removeChannels == null
              ? null
              : Object.hashAll(l$removeChannels.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductChannelListingUpdateInput<TRes> {
  factory CopyWith$Input$ProductChannelListingUpdateInput(
    Input$ProductChannelListingUpdateInput instance,
    TRes Function(Input$ProductChannelListingUpdateInput) then,
  ) = _CopyWithImpl$Input$ProductChannelListingUpdateInput;

  factory CopyWith$Input$ProductChannelListingUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductChannelListingUpdateInput;

  TRes call({
    List<Input$ProductChannelListingAddInput>? updateChannels,
    List<String>? removeChannels,
  });
  TRes updateChannels(
      Iterable<Input$ProductChannelListingAddInput>? Function(
              Iterable<
                  CopyWith$Input$ProductChannelListingAddInput<
                      Input$ProductChannelListingAddInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductChannelListingUpdateInput<TRes>
    implements CopyWith$Input$ProductChannelListingUpdateInput<TRes> {
  _CopyWithImpl$Input$ProductChannelListingUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ProductChannelListingUpdateInput _instance;

  final TRes Function(Input$ProductChannelListingUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? updateChannels = _undefined,
    Object? removeChannels = _undefined,
  }) =>
      _then(Input$ProductChannelListingUpdateInput._({
        ..._instance._$data,
        if (updateChannels != _undefined)
          'updateChannels':
              (updateChannels as List<Input$ProductChannelListingAddInput>?),
        if (removeChannels != _undefined)
          'removeChannels': (removeChannels as List<String>?),
      }));

  TRes updateChannels(
          Iterable<Input$ProductChannelListingAddInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductChannelListingAddInput<
                          Input$ProductChannelListingAddInput>>?)
              _fn) =>
      call(
          updateChannels: _fn(_instance.updateChannels
              ?.map((e) => CopyWith$Input$ProductChannelListingAddInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductChannelListingUpdateInput<TRes>
    implements CopyWith$Input$ProductChannelListingUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ProductChannelListingUpdateInput(this._res);

  TRes _res;

  call({
    List<Input$ProductChannelListingAddInput>? updateChannels,
    List<String>? removeChannels,
  }) =>
      _res;

  updateChannels(_fn) => _res;
}

class Input$ProductCreateInput {
  factory Input$ProductCreateInput({
    List<Input$AttributeValueInput>? attributes,
    String? category,
    bool? chargeTaxes,
    List<String>? collections,
    String? description,
    String? name,
    String? slug,
    String? taxClass,
    String? taxCode,
    Input$SeoInput? seo,
    String? weight,
    double? rating,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
    required String productType,
  }) =>
      Input$ProductCreateInput._({
        if (attributes != null) r'attributes': attributes,
        if (category != null) r'category': category,
        if (chargeTaxes != null) r'chargeTaxes': chargeTaxes,
        if (collections != null) r'collections': collections,
        if (description != null) r'description': description,
        if (name != null) r'name': name,
        if (slug != null) r'slug': slug,
        if (taxClass != null) r'taxClass': taxClass,
        if (taxCode != null) r'taxCode': taxCode,
        if (seo != null) r'seo': seo,
        if (weight != null) r'weight': weight,
        if (rating != null) r'rating': rating,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (externalReference != null) r'externalReference': externalReference,
        r'productType': productType,
      });

  Input$ProductCreateInput._(this._$data);

  factory Input$ProductCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('attributes')) {
      final l$attributes = data['attributes'];
      result$data['attributes'] = (l$attributes as List<dynamic>?)
          ?.map((e) =>
              Input$AttributeValueInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as String?);
    }
    if (data.containsKey('chargeTaxes')) {
      final l$chargeTaxes = data['chargeTaxes'];
      result$data['chargeTaxes'] = (l$chargeTaxes as bool?);
    }
    if (data.containsKey('collections')) {
      final l$collections = data['collections'];
      result$data['collections'] =
          (l$collections as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('taxClass')) {
      final l$taxClass = data['taxClass'];
      result$data['taxClass'] = (l$taxClass as String?);
    }
    if (data.containsKey('taxCode')) {
      final l$taxCode = data['taxCode'];
      result$data['taxCode'] = (l$taxCode as String?);
    }
    if (data.containsKey('seo')) {
      final l$seo = data['seo'];
      result$data['seo'] = l$seo == null
          ? null
          : Input$SeoInput.fromJson((l$seo as Map<String, dynamic>));
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as num?)?.toDouble();
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    final l$productType = data['productType'];
    result$data['productType'] = (l$productType as String);
    return Input$ProductCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$AttributeValueInput>? get attributes =>
      (_$data['attributes'] as List<Input$AttributeValueInput>?);

  String? get category => (_$data['category'] as String?);

  bool? get chargeTaxes => (_$data['chargeTaxes'] as bool?);

  List<String>? get collections => (_$data['collections'] as List<String>?);

  String? get description => (_$data['description'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get slug => (_$data['slug'] as String?);

  String? get taxClass => (_$data['taxClass'] as String?);

  String? get taxCode => (_$data['taxCode'] as String?);

  Input$SeoInput? get seo => (_$data['seo'] as Input$SeoInput?);

  String? get weight => (_$data['weight'] as String?);

  double? get rating => (_$data['rating'] as double?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  String? get externalReference => (_$data['externalReference'] as String?);

  String get productType => (_$data['productType'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('attributes')) {
      final l$attributes = attributes;
      result$data['attributes'] = l$attributes?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('chargeTaxes')) {
      final l$chargeTaxes = chargeTaxes;
      result$data['chargeTaxes'] = l$chargeTaxes;
    }
    if (_$data.containsKey('collections')) {
      final l$collections = collections;
      result$data['collections'] = l$collections?.map((e) => e).toList();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('taxClass')) {
      final l$taxClass = taxClass;
      result$data['taxClass'] = l$taxClass;
    }
    if (_$data.containsKey('taxCode')) {
      final l$taxCode = taxCode;
      result$data['taxCode'] = l$taxCode;
    }
    if (_$data.containsKey('seo')) {
      final l$seo = seo;
      result$data['seo'] = l$seo?.toJson();
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    final l$productType = productType;
    result$data['productType'] = l$productType;
    return result$data;
  }

  CopyWith$Input$ProductCreateInput<Input$ProductCreateInput> get copyWith =>
      CopyWith$Input$ProductCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$attributes = attributes;
    final lOther$attributes = other.attributes;
    if (_$data.containsKey('attributes') !=
        other._$data.containsKey('attributes')) {
      return false;
    }
    if (l$attributes != null && lOther$attributes != null) {
      if (l$attributes.length != lOther$attributes.length) {
        return false;
      }
      for (int i = 0; i < l$attributes.length; i++) {
        final l$attributes$entry = l$attributes[i];
        final lOther$attributes$entry = lOther$attributes[i];
        if (l$attributes$entry != lOther$attributes$entry) {
          return false;
        }
      }
    } else if (l$attributes != lOther$attributes) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$chargeTaxes = chargeTaxes;
    final lOther$chargeTaxes = other.chargeTaxes;
    if (_$data.containsKey('chargeTaxes') !=
        other._$data.containsKey('chargeTaxes')) {
      return false;
    }
    if (l$chargeTaxes != lOther$chargeTaxes) {
      return false;
    }
    final l$collections = collections;
    final lOther$collections = other.collections;
    if (_$data.containsKey('collections') !=
        other._$data.containsKey('collections')) {
      return false;
    }
    if (l$collections != null && lOther$collections != null) {
      if (l$collections.length != lOther$collections.length) {
        return false;
      }
      for (int i = 0; i < l$collections.length; i++) {
        final l$collections$entry = l$collections[i];
        final lOther$collections$entry = lOther$collections[i];
        if (l$collections$entry != lOther$collections$entry) {
          return false;
        }
      }
    } else if (l$collections != lOther$collections) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$taxClass = taxClass;
    final lOther$taxClass = other.taxClass;
    if (_$data.containsKey('taxClass') !=
        other._$data.containsKey('taxClass')) {
      return false;
    }
    if (l$taxClass != lOther$taxClass) {
      return false;
    }
    final l$taxCode = taxCode;
    final lOther$taxCode = other.taxCode;
    if (_$data.containsKey('taxCode') != other._$data.containsKey('taxCode')) {
      return false;
    }
    if (l$taxCode != lOther$taxCode) {
      return false;
    }
    final l$seo = seo;
    final lOther$seo = other.seo;
    if (_$data.containsKey('seo') != other._$data.containsKey('seo')) {
      return false;
    }
    if (l$seo != lOther$seo) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$productType = productType;
    final lOther$productType = other.productType;
    if (l$productType != lOther$productType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$attributes = attributes;
    final l$category = category;
    final l$chargeTaxes = chargeTaxes;
    final l$collections = collections;
    final l$description = description;
    final l$name = name;
    final l$slug = slug;
    final l$taxClass = taxClass;
    final l$taxCode = taxCode;
    final l$seo = seo;
    final l$weight = weight;
    final l$rating = rating;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$externalReference = externalReference;
    final l$productType = productType;
    return Object.hashAll([
      _$data.containsKey('attributes')
          ? l$attributes == null
              ? null
              : Object.hashAll(l$attributes.map((v) => v))
          : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('chargeTaxes') ? l$chargeTaxes : const {},
      _$data.containsKey('collections')
          ? l$collections == null
              ? null
              : Object.hashAll(l$collections.map((v) => v))
          : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('taxClass') ? l$taxClass : const {},
      _$data.containsKey('taxCode') ? l$taxCode : const {},
      _$data.containsKey('seo') ? l$seo : const {},
      _$data.containsKey('weight') ? l$weight : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      l$productType,
    ]);
  }
}

abstract class CopyWith$Input$ProductCreateInput<TRes> {
  factory CopyWith$Input$ProductCreateInput(
    Input$ProductCreateInput instance,
    TRes Function(Input$ProductCreateInput) then,
  ) = _CopyWithImpl$Input$ProductCreateInput;

  factory CopyWith$Input$ProductCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductCreateInput;

  TRes call({
    List<Input$AttributeValueInput>? attributes,
    String? category,
    bool? chargeTaxes,
    List<String>? collections,
    String? description,
    String? name,
    String? slug,
    String? taxClass,
    String? taxCode,
    Input$SeoInput? seo,
    String? weight,
    double? rating,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
    String? productType,
  });
  TRes attributes(
      Iterable<Input$AttributeValueInput>? Function(
              Iterable<
                  CopyWith$Input$AttributeValueInput<
                      Input$AttributeValueInput>>?)
          _fn);
  CopyWith$Input$SeoInput<TRes> get seo;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductCreateInput<TRes>
    implements CopyWith$Input$ProductCreateInput<TRes> {
  _CopyWithImpl$Input$ProductCreateInput(
    this._instance,
    this._then,
  );

  final Input$ProductCreateInput _instance;

  final TRes Function(Input$ProductCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? attributes = _undefined,
    Object? category = _undefined,
    Object? chargeTaxes = _undefined,
    Object? collections = _undefined,
    Object? description = _undefined,
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? taxClass = _undefined,
    Object? taxCode = _undefined,
    Object? seo = _undefined,
    Object? weight = _undefined,
    Object? rating = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? externalReference = _undefined,
    Object? productType = _undefined,
  }) =>
      _then(Input$ProductCreateInput._({
        ..._instance._$data,
        if (attributes != _undefined)
          'attributes': (attributes as List<Input$AttributeValueInput>?),
        if (category != _undefined) 'category': (category as String?),
        if (chargeTaxes != _undefined) 'chargeTaxes': (chargeTaxes as bool?),
        if (collections != _undefined)
          'collections': (collections as List<String>?),
        if (description != _undefined) 'description': (description as String?),
        if (name != _undefined) 'name': (name as String?),
        if (slug != _undefined) 'slug': (slug as String?),
        if (taxClass != _undefined) 'taxClass': (taxClass as String?),
        if (taxCode != _undefined) 'taxCode': (taxCode as String?),
        if (seo != _undefined) 'seo': (seo as Input$SeoInput?),
        if (weight != _undefined) 'weight': (weight as String?),
        if (rating != _undefined) 'rating': (rating as double?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (productType != _undefined && productType != null)
          'productType': (productType as String),
      }));

  TRes attributes(
          Iterable<Input$AttributeValueInput>? Function(
                  Iterable<
                      CopyWith$Input$AttributeValueInput<
                          Input$AttributeValueInput>>?)
              _fn) =>
      call(
          attributes: _fn(_instance.attributes
              ?.map((e) => CopyWith$Input$AttributeValueInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$SeoInput<TRes> get seo {
    final local$seo = _instance.seo;
    return local$seo == null
        ? CopyWith$Input$SeoInput.stub(_then(_instance))
        : CopyWith$Input$SeoInput(local$seo, (e) => call(seo: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductCreateInput<TRes>
    implements CopyWith$Input$ProductCreateInput<TRes> {
  _CopyWithStubImpl$Input$ProductCreateInput(this._res);

  TRes _res;

  call({
    List<Input$AttributeValueInput>? attributes,
    String? category,
    bool? chargeTaxes,
    List<String>? collections,
    String? description,
    String? name,
    String? slug,
    String? taxClass,
    String? taxCode,
    Input$SeoInput? seo,
    String? weight,
    double? rating,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
    String? productType,
  }) =>
      _res;

  attributes(_fn) => _res;

  CopyWith$Input$SeoInput<TRes> get seo => CopyWith$Input$SeoInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$ProductFilterInput {
  factory Input$ProductFilterInput({
    bool? isPublished,
    List<String>? collections,
    List<String>? categories,
    bool? hasCategory,
    List<Input$AttributeInput>? attributes,
    Enum$StockAvailability? stockAvailability,
    Input$ProductStockFilterInput? stocks,
    String? search,
    List<Input$MetadataFilter>? metadata,
    String? publishedFrom,
    bool? isAvailable,
    String? availableFrom,
    bool? isVisibleInListing,
    Input$PriceRangeInput? price,
    Input$PriceRangeInput? minimalPrice,
    Input$DateTimeRangeInput? updatedAt,
    List<String>? productTypes,
    bool? giftCard,
    List<String>? ids,
    bool? hasPreorderedVariants,
    List<String>? slugs,
    String? channel,
  }) =>
      Input$ProductFilterInput._({
        if (isPublished != null) r'isPublished': isPublished,
        if (collections != null) r'collections': collections,
        if (categories != null) r'categories': categories,
        if (hasCategory != null) r'hasCategory': hasCategory,
        if (attributes != null) r'attributes': attributes,
        if (stockAvailability != null) r'stockAvailability': stockAvailability,
        if (stocks != null) r'stocks': stocks,
        if (search != null) r'search': search,
        if (metadata != null) r'metadata': metadata,
        if (publishedFrom != null) r'publishedFrom': publishedFrom,
        if (isAvailable != null) r'isAvailable': isAvailable,
        if (availableFrom != null) r'availableFrom': availableFrom,
        if (isVisibleInListing != null)
          r'isVisibleInListing': isVisibleInListing,
        if (price != null) r'price': price,
        if (minimalPrice != null) r'minimalPrice': minimalPrice,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (productTypes != null) r'productTypes': productTypes,
        if (giftCard != null) r'giftCard': giftCard,
        if (ids != null) r'ids': ids,
        if (hasPreorderedVariants != null)
          r'hasPreorderedVariants': hasPreorderedVariants,
        if (slugs != null) r'slugs': slugs,
        if (channel != null) r'channel': channel,
      });

  Input$ProductFilterInput._(this._$data);

  factory Input$ProductFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('isPublished')) {
      final l$isPublished = data['isPublished'];
      result$data['isPublished'] = (l$isPublished as bool?);
    }
    if (data.containsKey('collections')) {
      final l$collections = data['collections'];
      result$data['collections'] =
          (l$collections as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('categories')) {
      final l$categories = data['categories'];
      result$data['categories'] =
          (l$categories as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('hasCategory')) {
      final l$hasCategory = data['hasCategory'];
      result$data['hasCategory'] = (l$hasCategory as bool?);
    }
    if (data.containsKey('attributes')) {
      final l$attributes = data['attributes'];
      result$data['attributes'] = (l$attributes as List<dynamic>?)
          ?.map(
              (e) => Input$AttributeInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('stockAvailability')) {
      final l$stockAvailability = data['stockAvailability'];
      result$data['stockAvailability'] = l$stockAvailability == null
          ? null
          : fromJson$Enum$StockAvailability((l$stockAvailability as String));
    }
    if (data.containsKey('stocks')) {
      final l$stocks = data['stocks'];
      result$data['stocks'] = l$stocks == null
          ? null
          : Input$ProductStockFilterInput.fromJson(
              (l$stocks as Map<String, dynamic>));
    }
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('publishedFrom')) {
      final l$publishedFrom = data['publishedFrom'];
      result$data['publishedFrom'] = (l$publishedFrom as String?);
    }
    if (data.containsKey('isAvailable')) {
      final l$isAvailable = data['isAvailable'];
      result$data['isAvailable'] = (l$isAvailable as bool?);
    }
    if (data.containsKey('availableFrom')) {
      final l$availableFrom = data['availableFrom'];
      result$data['availableFrom'] = (l$availableFrom as String?);
    }
    if (data.containsKey('isVisibleInListing')) {
      final l$isVisibleInListing = data['isVisibleInListing'];
      result$data['isVisibleInListing'] = (l$isVisibleInListing as bool?);
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] = l$price == null
          ? null
          : Input$PriceRangeInput.fromJson((l$price as Map<String, dynamic>));
    }
    if (data.containsKey('minimalPrice')) {
      final l$minimalPrice = data['minimalPrice'];
      result$data['minimalPrice'] = l$minimalPrice == null
          ? null
          : Input$PriceRangeInput.fromJson(
              (l$minimalPrice as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeRangeInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('productTypes')) {
      final l$productTypes = data['productTypes'];
      result$data['productTypes'] = (l$productTypes as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('giftCard')) {
      final l$giftCard = data['giftCard'];
      result$data['giftCard'] = (l$giftCard as bool?);
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('hasPreorderedVariants')) {
      final l$hasPreorderedVariants = data['hasPreorderedVariants'];
      result$data['hasPreorderedVariants'] = (l$hasPreorderedVariants as bool?);
    }
    if (data.containsKey('slugs')) {
      final l$slugs = data['slugs'];
      result$data['slugs'] =
          (l$slugs as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('channel')) {
      final l$channel = data['channel'];
      result$data['channel'] = (l$channel as String?);
    }
    return Input$ProductFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get isPublished => (_$data['isPublished'] as bool?);

  List<String>? get collections => (_$data['collections'] as List<String>?);

  List<String>? get categories => (_$data['categories'] as List<String>?);

  bool? get hasCategory => (_$data['hasCategory'] as bool?);

  List<Input$AttributeInput>? get attributes =>
      (_$data['attributes'] as List<Input$AttributeInput>?);

  Enum$StockAvailability? get stockAvailability =>
      (_$data['stockAvailability'] as Enum$StockAvailability?);

  Input$ProductStockFilterInput? get stocks =>
      (_$data['stocks'] as Input$ProductStockFilterInput?);

  String? get search => (_$data['search'] as String?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  String? get publishedFrom => (_$data['publishedFrom'] as String?);

  bool? get isAvailable => (_$data['isAvailable'] as bool?);

  String? get availableFrom => (_$data['availableFrom'] as String?);

  bool? get isVisibleInListing => (_$data['isVisibleInListing'] as bool?);

  Input$PriceRangeInput? get price =>
      (_$data['price'] as Input$PriceRangeInput?);

  Input$PriceRangeInput? get minimalPrice =>
      (_$data['minimalPrice'] as Input$PriceRangeInput?);

  Input$DateTimeRangeInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeRangeInput?);

  List<String>? get productTypes => (_$data['productTypes'] as List<String>?);

  bool? get giftCard => (_$data['giftCard'] as bool?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  bool? get hasPreorderedVariants => (_$data['hasPreorderedVariants'] as bool?);

  List<String>? get slugs => (_$data['slugs'] as List<String>?);

  String? get channel => (_$data['channel'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('isPublished')) {
      final l$isPublished = isPublished;
      result$data['isPublished'] = l$isPublished;
    }
    if (_$data.containsKey('collections')) {
      final l$collections = collections;
      result$data['collections'] = l$collections?.map((e) => e).toList();
    }
    if (_$data.containsKey('categories')) {
      final l$categories = categories;
      result$data['categories'] = l$categories?.map((e) => e).toList();
    }
    if (_$data.containsKey('hasCategory')) {
      final l$hasCategory = hasCategory;
      result$data['hasCategory'] = l$hasCategory;
    }
    if (_$data.containsKey('attributes')) {
      final l$attributes = attributes;
      result$data['attributes'] = l$attributes?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('stockAvailability')) {
      final l$stockAvailability = stockAvailability;
      result$data['stockAvailability'] = l$stockAvailability == null
          ? null
          : toJson$Enum$StockAvailability(l$stockAvailability);
    }
    if (_$data.containsKey('stocks')) {
      final l$stocks = stocks;
      result$data['stocks'] = l$stocks?.toJson();
    }
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('publishedFrom')) {
      final l$publishedFrom = publishedFrom;
      result$data['publishedFrom'] = l$publishedFrom;
    }
    if (_$data.containsKey('isAvailable')) {
      final l$isAvailable = isAvailable;
      result$data['isAvailable'] = l$isAvailable;
    }
    if (_$data.containsKey('availableFrom')) {
      final l$availableFrom = availableFrom;
      result$data['availableFrom'] = l$availableFrom;
    }
    if (_$data.containsKey('isVisibleInListing')) {
      final l$isVisibleInListing = isVisibleInListing;
      result$data['isVisibleInListing'] = l$isVisibleInListing;
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] = l$price?.toJson();
    }
    if (_$data.containsKey('minimalPrice')) {
      final l$minimalPrice = minimalPrice;
      result$data['minimalPrice'] = l$minimalPrice?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('productTypes')) {
      final l$productTypes = productTypes;
      result$data['productTypes'] = l$productTypes?.map((e) => e).toList();
    }
    if (_$data.containsKey('giftCard')) {
      final l$giftCard = giftCard;
      result$data['giftCard'] = l$giftCard;
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('hasPreorderedVariants')) {
      final l$hasPreorderedVariants = hasPreorderedVariants;
      result$data['hasPreorderedVariants'] = l$hasPreorderedVariants;
    }
    if (_$data.containsKey('slugs')) {
      final l$slugs = slugs;
      result$data['slugs'] = l$slugs?.map((e) => e).toList();
    }
    if (_$data.containsKey('channel')) {
      final l$channel = channel;
      result$data['channel'] = l$channel;
    }
    return result$data;
  }

  CopyWith$Input$ProductFilterInput<Input$ProductFilterInput> get copyWith =>
      CopyWith$Input$ProductFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$isPublished = isPublished;
    final lOther$isPublished = other.isPublished;
    if (_$data.containsKey('isPublished') !=
        other._$data.containsKey('isPublished')) {
      return false;
    }
    if (l$isPublished != lOther$isPublished) {
      return false;
    }
    final l$collections = collections;
    final lOther$collections = other.collections;
    if (_$data.containsKey('collections') !=
        other._$data.containsKey('collections')) {
      return false;
    }
    if (l$collections != null && lOther$collections != null) {
      if (l$collections.length != lOther$collections.length) {
        return false;
      }
      for (int i = 0; i < l$collections.length; i++) {
        final l$collections$entry = l$collections[i];
        final lOther$collections$entry = lOther$collections[i];
        if (l$collections$entry != lOther$collections$entry) {
          return false;
        }
      }
    } else if (l$collections != lOther$collections) {
      return false;
    }
    final l$categories = categories;
    final lOther$categories = other.categories;
    if (_$data.containsKey('categories') !=
        other._$data.containsKey('categories')) {
      return false;
    }
    if (l$categories != null && lOther$categories != null) {
      if (l$categories.length != lOther$categories.length) {
        return false;
      }
      for (int i = 0; i < l$categories.length; i++) {
        final l$categories$entry = l$categories[i];
        final lOther$categories$entry = lOther$categories[i];
        if (l$categories$entry != lOther$categories$entry) {
          return false;
        }
      }
    } else if (l$categories != lOther$categories) {
      return false;
    }
    final l$hasCategory = hasCategory;
    final lOther$hasCategory = other.hasCategory;
    if (_$data.containsKey('hasCategory') !=
        other._$data.containsKey('hasCategory')) {
      return false;
    }
    if (l$hasCategory != lOther$hasCategory) {
      return false;
    }
    final l$attributes = attributes;
    final lOther$attributes = other.attributes;
    if (_$data.containsKey('attributes') !=
        other._$data.containsKey('attributes')) {
      return false;
    }
    if (l$attributes != null && lOther$attributes != null) {
      if (l$attributes.length != lOther$attributes.length) {
        return false;
      }
      for (int i = 0; i < l$attributes.length; i++) {
        final l$attributes$entry = l$attributes[i];
        final lOther$attributes$entry = lOther$attributes[i];
        if (l$attributes$entry != lOther$attributes$entry) {
          return false;
        }
      }
    } else if (l$attributes != lOther$attributes) {
      return false;
    }
    final l$stockAvailability = stockAvailability;
    final lOther$stockAvailability = other.stockAvailability;
    if (_$data.containsKey('stockAvailability') !=
        other._$data.containsKey('stockAvailability')) {
      return false;
    }
    if (l$stockAvailability != lOther$stockAvailability) {
      return false;
    }
    final l$stocks = stocks;
    final lOther$stocks = other.stocks;
    if (_$data.containsKey('stocks') != other._$data.containsKey('stocks')) {
      return false;
    }
    if (l$stocks != lOther$stocks) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$publishedFrom = publishedFrom;
    final lOther$publishedFrom = other.publishedFrom;
    if (_$data.containsKey('publishedFrom') !=
        other._$data.containsKey('publishedFrom')) {
      return false;
    }
    if (l$publishedFrom != lOther$publishedFrom) {
      return false;
    }
    final l$isAvailable = isAvailable;
    final lOther$isAvailable = other.isAvailable;
    if (_$data.containsKey('isAvailable') !=
        other._$data.containsKey('isAvailable')) {
      return false;
    }
    if (l$isAvailable != lOther$isAvailable) {
      return false;
    }
    final l$availableFrom = availableFrom;
    final lOther$availableFrom = other.availableFrom;
    if (_$data.containsKey('availableFrom') !=
        other._$data.containsKey('availableFrom')) {
      return false;
    }
    if (l$availableFrom != lOther$availableFrom) {
      return false;
    }
    final l$isVisibleInListing = isVisibleInListing;
    final lOther$isVisibleInListing = other.isVisibleInListing;
    if (_$data.containsKey('isVisibleInListing') !=
        other._$data.containsKey('isVisibleInListing')) {
      return false;
    }
    if (l$isVisibleInListing != lOther$isVisibleInListing) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$minimalPrice = minimalPrice;
    final lOther$minimalPrice = other.minimalPrice;
    if (_$data.containsKey('minimalPrice') !=
        other._$data.containsKey('minimalPrice')) {
      return false;
    }
    if (l$minimalPrice != lOther$minimalPrice) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$productTypes = productTypes;
    final lOther$productTypes = other.productTypes;
    if (_$data.containsKey('productTypes') !=
        other._$data.containsKey('productTypes')) {
      return false;
    }
    if (l$productTypes != null && lOther$productTypes != null) {
      if (l$productTypes.length != lOther$productTypes.length) {
        return false;
      }
      for (int i = 0; i < l$productTypes.length; i++) {
        final l$productTypes$entry = l$productTypes[i];
        final lOther$productTypes$entry = lOther$productTypes[i];
        if (l$productTypes$entry != lOther$productTypes$entry) {
          return false;
        }
      }
    } else if (l$productTypes != lOther$productTypes) {
      return false;
    }
    final l$giftCard = giftCard;
    final lOther$giftCard = other.giftCard;
    if (_$data.containsKey('giftCard') !=
        other._$data.containsKey('giftCard')) {
      return false;
    }
    if (l$giftCard != lOther$giftCard) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$hasPreorderedVariants = hasPreorderedVariants;
    final lOther$hasPreorderedVariants = other.hasPreorderedVariants;
    if (_$data.containsKey('hasPreorderedVariants') !=
        other._$data.containsKey('hasPreorderedVariants')) {
      return false;
    }
    if (l$hasPreorderedVariants != lOther$hasPreorderedVariants) {
      return false;
    }
    final l$slugs = slugs;
    final lOther$slugs = other.slugs;
    if (_$data.containsKey('slugs') != other._$data.containsKey('slugs')) {
      return false;
    }
    if (l$slugs != null && lOther$slugs != null) {
      if (l$slugs.length != lOther$slugs.length) {
        return false;
      }
      for (int i = 0; i < l$slugs.length; i++) {
        final l$slugs$entry = l$slugs[i];
        final lOther$slugs$entry = lOther$slugs[i];
        if (l$slugs$entry != lOther$slugs$entry) {
          return false;
        }
      }
    } else if (l$slugs != lOther$slugs) {
      return false;
    }
    final l$channel = channel;
    final lOther$channel = other.channel;
    if (_$data.containsKey('channel') != other._$data.containsKey('channel')) {
      return false;
    }
    if (l$channel != lOther$channel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$isPublished = isPublished;
    final l$collections = collections;
    final l$categories = categories;
    final l$hasCategory = hasCategory;
    final l$attributes = attributes;
    final l$stockAvailability = stockAvailability;
    final l$stocks = stocks;
    final l$search = search;
    final l$metadata = metadata;
    final l$publishedFrom = publishedFrom;
    final l$isAvailable = isAvailable;
    final l$availableFrom = availableFrom;
    final l$isVisibleInListing = isVisibleInListing;
    final l$price = price;
    final l$minimalPrice = minimalPrice;
    final l$updatedAt = updatedAt;
    final l$productTypes = productTypes;
    final l$giftCard = giftCard;
    final l$ids = ids;
    final l$hasPreorderedVariants = hasPreorderedVariants;
    final l$slugs = slugs;
    final l$channel = channel;
    return Object.hashAll([
      _$data.containsKey('isPublished') ? l$isPublished : const {},
      _$data.containsKey('collections')
          ? l$collections == null
              ? null
              : Object.hashAll(l$collections.map((v) => v))
          : const {},
      _$data.containsKey('categories')
          ? l$categories == null
              ? null
              : Object.hashAll(l$categories.map((v) => v))
          : const {},
      _$data.containsKey('hasCategory') ? l$hasCategory : const {},
      _$data.containsKey('attributes')
          ? l$attributes == null
              ? null
              : Object.hashAll(l$attributes.map((v) => v))
          : const {},
      _$data.containsKey('stockAvailability') ? l$stockAvailability : const {},
      _$data.containsKey('stocks') ? l$stocks : const {},
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('publishedFrom') ? l$publishedFrom : const {},
      _$data.containsKey('isAvailable') ? l$isAvailable : const {},
      _$data.containsKey('availableFrom') ? l$availableFrom : const {},
      _$data.containsKey('isVisibleInListing')
          ? l$isVisibleInListing
          : const {},
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('minimalPrice') ? l$minimalPrice : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('productTypes')
          ? l$productTypes == null
              ? null
              : Object.hashAll(l$productTypes.map((v) => v))
          : const {},
      _$data.containsKey('giftCard') ? l$giftCard : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('hasPreorderedVariants')
          ? l$hasPreorderedVariants
          : const {},
      _$data.containsKey('slugs')
          ? l$slugs == null
              ? null
              : Object.hashAll(l$slugs.map((v) => v))
          : const {},
      _$data.containsKey('channel') ? l$channel : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductFilterInput<TRes> {
  factory CopyWith$Input$ProductFilterInput(
    Input$ProductFilterInput instance,
    TRes Function(Input$ProductFilterInput) then,
  ) = _CopyWithImpl$Input$ProductFilterInput;

  factory CopyWith$Input$ProductFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductFilterInput;

  TRes call({
    bool? isPublished,
    List<String>? collections,
    List<String>? categories,
    bool? hasCategory,
    List<Input$AttributeInput>? attributes,
    Enum$StockAvailability? stockAvailability,
    Input$ProductStockFilterInput? stocks,
    String? search,
    List<Input$MetadataFilter>? metadata,
    String? publishedFrom,
    bool? isAvailable,
    String? availableFrom,
    bool? isVisibleInListing,
    Input$PriceRangeInput? price,
    Input$PriceRangeInput? minimalPrice,
    Input$DateTimeRangeInput? updatedAt,
    List<String>? productTypes,
    bool? giftCard,
    List<String>? ids,
    bool? hasPreorderedVariants,
    List<String>? slugs,
    String? channel,
  });
  TRes attributes(
      Iterable<Input$AttributeInput>? Function(
              Iterable<CopyWith$Input$AttributeInput<Input$AttributeInput>>?)
          _fn);
  CopyWith$Input$ProductStockFilterInput<TRes> get stocks;
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
  CopyWith$Input$PriceRangeInput<TRes> get price;
  CopyWith$Input$PriceRangeInput<TRes> get minimalPrice;
  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$ProductFilterInput<TRes>
    implements CopyWith$Input$ProductFilterInput<TRes> {
  _CopyWithImpl$Input$ProductFilterInput(
    this._instance,
    this._then,
  );

  final Input$ProductFilterInput _instance;

  final TRes Function(Input$ProductFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? isPublished = _undefined,
    Object? collections = _undefined,
    Object? categories = _undefined,
    Object? hasCategory = _undefined,
    Object? attributes = _undefined,
    Object? stockAvailability = _undefined,
    Object? stocks = _undefined,
    Object? search = _undefined,
    Object? metadata = _undefined,
    Object? publishedFrom = _undefined,
    Object? isAvailable = _undefined,
    Object? availableFrom = _undefined,
    Object? isVisibleInListing = _undefined,
    Object? price = _undefined,
    Object? minimalPrice = _undefined,
    Object? updatedAt = _undefined,
    Object? productTypes = _undefined,
    Object? giftCard = _undefined,
    Object? ids = _undefined,
    Object? hasPreorderedVariants = _undefined,
    Object? slugs = _undefined,
    Object? channel = _undefined,
  }) =>
      _then(Input$ProductFilterInput._({
        ..._instance._$data,
        if (isPublished != _undefined) 'isPublished': (isPublished as bool?),
        if (collections != _undefined)
          'collections': (collections as List<String>?),
        if (categories != _undefined)
          'categories': (categories as List<String>?),
        if (hasCategory != _undefined) 'hasCategory': (hasCategory as bool?),
        if (attributes != _undefined)
          'attributes': (attributes as List<Input$AttributeInput>?),
        if (stockAvailability != _undefined)
          'stockAvailability': (stockAvailability as Enum$StockAvailability?),
        if (stocks != _undefined)
          'stocks': (stocks as Input$ProductStockFilterInput?),
        if (search != _undefined) 'search': (search as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (publishedFrom != _undefined)
          'publishedFrom': (publishedFrom as String?),
        if (isAvailable != _undefined) 'isAvailable': (isAvailable as bool?),
        if (availableFrom != _undefined)
          'availableFrom': (availableFrom as String?),
        if (isVisibleInListing != _undefined)
          'isVisibleInListing': (isVisibleInListing as bool?),
        if (price != _undefined) 'price': (price as Input$PriceRangeInput?),
        if (minimalPrice != _undefined)
          'minimalPrice': (minimalPrice as Input$PriceRangeInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeRangeInput?),
        if (productTypes != _undefined)
          'productTypes': (productTypes as List<String>?),
        if (giftCard != _undefined) 'giftCard': (giftCard as bool?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (hasPreorderedVariants != _undefined)
          'hasPreorderedVariants': (hasPreorderedVariants as bool?),
        if (slugs != _undefined) 'slugs': (slugs as List<String>?),
        if (channel != _undefined) 'channel': (channel as String?),
      }));

  TRes attributes(
          Iterable<Input$AttributeInput>? Function(
                  Iterable<
                      CopyWith$Input$AttributeInput<Input$AttributeInput>>?)
              _fn) =>
      call(
          attributes: _fn(
              _instance.attributes?.map((e) => CopyWith$Input$AttributeInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$ProductStockFilterInput<TRes> get stocks {
    final local$stocks = _instance.stocks;
    return local$stocks == null
        ? CopyWith$Input$ProductStockFilterInput.stub(_then(_instance))
        : CopyWith$Input$ProductStockFilterInput(
            local$stocks, (e) => call(stocks: e));
  }

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$PriceRangeInput<TRes> get price {
    final local$price = _instance.price;
    return local$price == null
        ? CopyWith$Input$PriceRangeInput.stub(_then(_instance))
        : CopyWith$Input$PriceRangeInput(local$price, (e) => call(price: e));
  }

  CopyWith$Input$PriceRangeInput<TRes> get minimalPrice {
    final local$minimalPrice = _instance.minimalPrice;
    return local$minimalPrice == null
        ? CopyWith$Input$PriceRangeInput.stub(_then(_instance))
        : CopyWith$Input$PriceRangeInput(
            local$minimalPrice, (e) => call(minimalPrice: e));
  }

  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeRangeInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }
}

class _CopyWithStubImpl$Input$ProductFilterInput<TRes>
    implements CopyWith$Input$ProductFilterInput<TRes> {
  _CopyWithStubImpl$Input$ProductFilterInput(this._res);

  TRes _res;

  call({
    bool? isPublished,
    List<String>? collections,
    List<String>? categories,
    bool? hasCategory,
    List<Input$AttributeInput>? attributes,
    Enum$StockAvailability? stockAvailability,
    Input$ProductStockFilterInput? stocks,
    String? search,
    List<Input$MetadataFilter>? metadata,
    String? publishedFrom,
    bool? isAvailable,
    String? availableFrom,
    bool? isVisibleInListing,
    Input$PriceRangeInput? price,
    Input$PriceRangeInput? minimalPrice,
    Input$DateTimeRangeInput? updatedAt,
    List<String>? productTypes,
    bool? giftCard,
    List<String>? ids,
    bool? hasPreorderedVariants,
    List<String>? slugs,
    String? channel,
  }) =>
      _res;

  attributes(_fn) => _res;

  CopyWith$Input$ProductStockFilterInput<TRes> get stocks =>
      CopyWith$Input$ProductStockFilterInput.stub(_res);

  metadata(_fn) => _res;

  CopyWith$Input$PriceRangeInput<TRes> get price =>
      CopyWith$Input$PriceRangeInput.stub(_res);

  CopyWith$Input$PriceRangeInput<TRes> get minimalPrice =>
      CopyWith$Input$PriceRangeInput.stub(_res);

  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeRangeInput.stub(_res);
}

class Input$ProductInput {
  factory Input$ProductInput({
    List<Input$AttributeValueInput>? attributes,
    String? category,
    bool? chargeTaxes,
    List<String>? collections,
    String? description,
    String? name,
    String? slug,
    String? taxClass,
    String? taxCode,
    Input$SeoInput? seo,
    String? weight,
    double? rating,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
  }) =>
      Input$ProductInput._({
        if (attributes != null) r'attributes': attributes,
        if (category != null) r'category': category,
        if (chargeTaxes != null) r'chargeTaxes': chargeTaxes,
        if (collections != null) r'collections': collections,
        if (description != null) r'description': description,
        if (name != null) r'name': name,
        if (slug != null) r'slug': slug,
        if (taxClass != null) r'taxClass': taxClass,
        if (taxCode != null) r'taxCode': taxCode,
        if (seo != null) r'seo': seo,
        if (weight != null) r'weight': weight,
        if (rating != null) r'rating': rating,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (externalReference != null) r'externalReference': externalReference,
      });

  Input$ProductInput._(this._$data);

  factory Input$ProductInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('attributes')) {
      final l$attributes = data['attributes'];
      result$data['attributes'] = (l$attributes as List<dynamic>?)
          ?.map((e) =>
              Input$AttributeValueInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as String?);
    }
    if (data.containsKey('chargeTaxes')) {
      final l$chargeTaxes = data['chargeTaxes'];
      result$data['chargeTaxes'] = (l$chargeTaxes as bool?);
    }
    if (data.containsKey('collections')) {
      final l$collections = data['collections'];
      result$data['collections'] =
          (l$collections as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('taxClass')) {
      final l$taxClass = data['taxClass'];
      result$data['taxClass'] = (l$taxClass as String?);
    }
    if (data.containsKey('taxCode')) {
      final l$taxCode = data['taxCode'];
      result$data['taxCode'] = (l$taxCode as String?);
    }
    if (data.containsKey('seo')) {
      final l$seo = data['seo'];
      result$data['seo'] = l$seo == null
          ? null
          : Input$SeoInput.fromJson((l$seo as Map<String, dynamic>));
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as num?)?.toDouble();
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    return Input$ProductInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$AttributeValueInput>? get attributes =>
      (_$data['attributes'] as List<Input$AttributeValueInput>?);

  String? get category => (_$data['category'] as String?);

  bool? get chargeTaxes => (_$data['chargeTaxes'] as bool?);

  List<String>? get collections => (_$data['collections'] as List<String>?);

  String? get description => (_$data['description'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get slug => (_$data['slug'] as String?);

  String? get taxClass => (_$data['taxClass'] as String?);

  String? get taxCode => (_$data['taxCode'] as String?);

  Input$SeoInput? get seo => (_$data['seo'] as Input$SeoInput?);

  String? get weight => (_$data['weight'] as String?);

  double? get rating => (_$data['rating'] as double?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  String? get externalReference => (_$data['externalReference'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('attributes')) {
      final l$attributes = attributes;
      result$data['attributes'] = l$attributes?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('chargeTaxes')) {
      final l$chargeTaxes = chargeTaxes;
      result$data['chargeTaxes'] = l$chargeTaxes;
    }
    if (_$data.containsKey('collections')) {
      final l$collections = collections;
      result$data['collections'] = l$collections?.map((e) => e).toList();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('taxClass')) {
      final l$taxClass = taxClass;
      result$data['taxClass'] = l$taxClass;
    }
    if (_$data.containsKey('taxCode')) {
      final l$taxCode = taxCode;
      result$data['taxCode'] = l$taxCode;
    }
    if (_$data.containsKey('seo')) {
      final l$seo = seo;
      result$data['seo'] = l$seo?.toJson();
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    return result$data;
  }

  CopyWith$Input$ProductInput<Input$ProductInput> get copyWith =>
      CopyWith$Input$ProductInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$attributes = attributes;
    final lOther$attributes = other.attributes;
    if (_$data.containsKey('attributes') !=
        other._$data.containsKey('attributes')) {
      return false;
    }
    if (l$attributes != null && lOther$attributes != null) {
      if (l$attributes.length != lOther$attributes.length) {
        return false;
      }
      for (int i = 0; i < l$attributes.length; i++) {
        final l$attributes$entry = l$attributes[i];
        final lOther$attributes$entry = lOther$attributes[i];
        if (l$attributes$entry != lOther$attributes$entry) {
          return false;
        }
      }
    } else if (l$attributes != lOther$attributes) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$chargeTaxes = chargeTaxes;
    final lOther$chargeTaxes = other.chargeTaxes;
    if (_$data.containsKey('chargeTaxes') !=
        other._$data.containsKey('chargeTaxes')) {
      return false;
    }
    if (l$chargeTaxes != lOther$chargeTaxes) {
      return false;
    }
    final l$collections = collections;
    final lOther$collections = other.collections;
    if (_$data.containsKey('collections') !=
        other._$data.containsKey('collections')) {
      return false;
    }
    if (l$collections != null && lOther$collections != null) {
      if (l$collections.length != lOther$collections.length) {
        return false;
      }
      for (int i = 0; i < l$collections.length; i++) {
        final l$collections$entry = l$collections[i];
        final lOther$collections$entry = lOther$collections[i];
        if (l$collections$entry != lOther$collections$entry) {
          return false;
        }
      }
    } else if (l$collections != lOther$collections) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$taxClass = taxClass;
    final lOther$taxClass = other.taxClass;
    if (_$data.containsKey('taxClass') !=
        other._$data.containsKey('taxClass')) {
      return false;
    }
    if (l$taxClass != lOther$taxClass) {
      return false;
    }
    final l$taxCode = taxCode;
    final lOther$taxCode = other.taxCode;
    if (_$data.containsKey('taxCode') != other._$data.containsKey('taxCode')) {
      return false;
    }
    if (l$taxCode != lOther$taxCode) {
      return false;
    }
    final l$seo = seo;
    final lOther$seo = other.seo;
    if (_$data.containsKey('seo') != other._$data.containsKey('seo')) {
      return false;
    }
    if (l$seo != lOther$seo) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$attributes = attributes;
    final l$category = category;
    final l$chargeTaxes = chargeTaxes;
    final l$collections = collections;
    final l$description = description;
    final l$name = name;
    final l$slug = slug;
    final l$taxClass = taxClass;
    final l$taxCode = taxCode;
    final l$seo = seo;
    final l$weight = weight;
    final l$rating = rating;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$externalReference = externalReference;
    return Object.hashAll([
      _$data.containsKey('attributes')
          ? l$attributes == null
              ? null
              : Object.hashAll(l$attributes.map((v) => v))
          : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('chargeTaxes') ? l$chargeTaxes : const {},
      _$data.containsKey('collections')
          ? l$collections == null
              ? null
              : Object.hashAll(l$collections.map((v) => v))
          : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('taxClass') ? l$taxClass : const {},
      _$data.containsKey('taxCode') ? l$taxCode : const {},
      _$data.containsKey('seo') ? l$seo : const {},
      _$data.containsKey('weight') ? l$weight : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductInput<TRes> {
  factory CopyWith$Input$ProductInput(
    Input$ProductInput instance,
    TRes Function(Input$ProductInput) then,
  ) = _CopyWithImpl$Input$ProductInput;

  factory CopyWith$Input$ProductInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductInput;

  TRes call({
    List<Input$AttributeValueInput>? attributes,
    String? category,
    bool? chargeTaxes,
    List<String>? collections,
    String? description,
    String? name,
    String? slug,
    String? taxClass,
    String? taxCode,
    Input$SeoInput? seo,
    String? weight,
    double? rating,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
  });
  TRes attributes(
      Iterable<Input$AttributeValueInput>? Function(
              Iterable<
                  CopyWith$Input$AttributeValueInput<
                      Input$AttributeValueInput>>?)
          _fn);
  CopyWith$Input$SeoInput<TRes> get seo;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductInput<TRes>
    implements CopyWith$Input$ProductInput<TRes> {
  _CopyWithImpl$Input$ProductInput(
    this._instance,
    this._then,
  );

  final Input$ProductInput _instance;

  final TRes Function(Input$ProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? attributes = _undefined,
    Object? category = _undefined,
    Object? chargeTaxes = _undefined,
    Object? collections = _undefined,
    Object? description = _undefined,
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? taxClass = _undefined,
    Object? taxCode = _undefined,
    Object? seo = _undefined,
    Object? weight = _undefined,
    Object? rating = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? externalReference = _undefined,
  }) =>
      _then(Input$ProductInput._({
        ..._instance._$data,
        if (attributes != _undefined)
          'attributes': (attributes as List<Input$AttributeValueInput>?),
        if (category != _undefined) 'category': (category as String?),
        if (chargeTaxes != _undefined) 'chargeTaxes': (chargeTaxes as bool?),
        if (collections != _undefined)
          'collections': (collections as List<String>?),
        if (description != _undefined) 'description': (description as String?),
        if (name != _undefined) 'name': (name as String?),
        if (slug != _undefined) 'slug': (slug as String?),
        if (taxClass != _undefined) 'taxClass': (taxClass as String?),
        if (taxCode != _undefined) 'taxCode': (taxCode as String?),
        if (seo != _undefined) 'seo': (seo as Input$SeoInput?),
        if (weight != _undefined) 'weight': (weight as String?),
        if (rating != _undefined) 'rating': (rating as double?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
      }));

  TRes attributes(
          Iterable<Input$AttributeValueInput>? Function(
                  Iterable<
                      CopyWith$Input$AttributeValueInput<
                          Input$AttributeValueInput>>?)
              _fn) =>
      call(
          attributes: _fn(_instance.attributes
              ?.map((e) => CopyWith$Input$AttributeValueInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$SeoInput<TRes> get seo {
    final local$seo = _instance.seo;
    return local$seo == null
        ? CopyWith$Input$SeoInput.stub(_then(_instance))
        : CopyWith$Input$SeoInput(local$seo, (e) => call(seo: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductInput<TRes>
    implements CopyWith$Input$ProductInput<TRes> {
  _CopyWithStubImpl$Input$ProductInput(this._res);

  TRes _res;

  call({
    List<Input$AttributeValueInput>? attributes,
    String? category,
    bool? chargeTaxes,
    List<String>? collections,
    String? description,
    String? name,
    String? slug,
    String? taxClass,
    String? taxCode,
    Input$SeoInput? seo,
    String? weight,
    double? rating,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
  }) =>
      _res;

  attributes(_fn) => _res;

  CopyWith$Input$SeoInput<TRes> get seo => CopyWith$Input$SeoInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$ProductMediaCreateInput {
  factory Input$ProductMediaCreateInput({
    String? alt,
    String? image,
    required String product,
    String? mediaUrl,
  }) =>
      Input$ProductMediaCreateInput._({
        if (alt != null) r'alt': alt,
        if (image != null) r'image': image,
        r'product': product,
        if (mediaUrl != null) r'mediaUrl': mediaUrl,
      });

  Input$ProductMediaCreateInput._(this._$data);

  factory Input$ProductMediaCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('alt')) {
      final l$alt = data['alt'];
      result$data['alt'] = (l$alt as String?);
    }
    if (data.containsKey('image')) {
      final l$image = data['image'];
      result$data['image'] = (l$image as String?);
    }
    final l$product = data['product'];
    result$data['product'] = (l$product as String);
    if (data.containsKey('mediaUrl')) {
      final l$mediaUrl = data['mediaUrl'];
      result$data['mediaUrl'] = (l$mediaUrl as String?);
    }
    return Input$ProductMediaCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get alt => (_$data['alt'] as String?);

  String? get image => (_$data['image'] as String?);

  String get product => (_$data['product'] as String);

  String? get mediaUrl => (_$data['mediaUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('alt')) {
      final l$alt = alt;
      result$data['alt'] = l$alt;
    }
    if (_$data.containsKey('image')) {
      final l$image = image;
      result$data['image'] = l$image;
    }
    final l$product = product;
    result$data['product'] = l$product;
    if (_$data.containsKey('mediaUrl')) {
      final l$mediaUrl = mediaUrl;
      result$data['mediaUrl'] = l$mediaUrl;
    }
    return result$data;
  }

  CopyWith$Input$ProductMediaCreateInput<Input$ProductMediaCreateInput>
      get copyWith => CopyWith$Input$ProductMediaCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductMediaCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$alt = alt;
    final lOther$alt = other.alt;
    if (_$data.containsKey('alt') != other._$data.containsKey('alt')) {
      return false;
    }
    if (l$alt != lOther$alt) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (_$data.containsKey('image') != other._$data.containsKey('image')) {
      return false;
    }
    if (l$image != lOther$image) {
      return false;
    }
    final l$product = product;
    final lOther$product = other.product;
    if (l$product != lOther$product) {
      return false;
    }
    final l$mediaUrl = mediaUrl;
    final lOther$mediaUrl = other.mediaUrl;
    if (_$data.containsKey('mediaUrl') !=
        other._$data.containsKey('mediaUrl')) {
      return false;
    }
    if (l$mediaUrl != lOther$mediaUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$alt = alt;
    final l$image = image;
    final l$product = product;
    final l$mediaUrl = mediaUrl;
    return Object.hashAll([
      _$data.containsKey('alt') ? l$alt : const {},
      _$data.containsKey('image') ? l$image : const {},
      l$product,
      _$data.containsKey('mediaUrl') ? l$mediaUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductMediaCreateInput<TRes> {
  factory CopyWith$Input$ProductMediaCreateInput(
    Input$ProductMediaCreateInput instance,
    TRes Function(Input$ProductMediaCreateInput) then,
  ) = _CopyWithImpl$Input$ProductMediaCreateInput;

  factory CopyWith$Input$ProductMediaCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductMediaCreateInput;

  TRes call({
    String? alt,
    String? image,
    String? product,
    String? mediaUrl,
  });
}

class _CopyWithImpl$Input$ProductMediaCreateInput<TRes>
    implements CopyWith$Input$ProductMediaCreateInput<TRes> {
  _CopyWithImpl$Input$ProductMediaCreateInput(
    this._instance,
    this._then,
  );

  final Input$ProductMediaCreateInput _instance;

  final TRes Function(Input$ProductMediaCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? alt = _undefined,
    Object? image = _undefined,
    Object? product = _undefined,
    Object? mediaUrl = _undefined,
  }) =>
      _then(Input$ProductMediaCreateInput._({
        ..._instance._$data,
        if (alt != _undefined) 'alt': (alt as String?),
        if (image != _undefined) 'image': (image as String?),
        if (product != _undefined && product != null)
          'product': (product as String),
        if (mediaUrl != _undefined) 'mediaUrl': (mediaUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$ProductMediaCreateInput<TRes>
    implements CopyWith$Input$ProductMediaCreateInput<TRes> {
  _CopyWithStubImpl$Input$ProductMediaCreateInput(this._res);

  TRes _res;

  call({
    String? alt,
    String? image,
    String? product,
    String? mediaUrl,
  }) =>
      _res;
}

class Input$ProductMediaUpdateInput {
  factory Input$ProductMediaUpdateInput({String? alt}) =>
      Input$ProductMediaUpdateInput._({
        if (alt != null) r'alt': alt,
      });

  Input$ProductMediaUpdateInput._(this._$data);

  factory Input$ProductMediaUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('alt')) {
      final l$alt = data['alt'];
      result$data['alt'] = (l$alt as String?);
    }
    return Input$ProductMediaUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get alt => (_$data['alt'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('alt')) {
      final l$alt = alt;
      result$data['alt'] = l$alt;
    }
    return result$data;
  }

  CopyWith$Input$ProductMediaUpdateInput<Input$ProductMediaUpdateInput>
      get copyWith => CopyWith$Input$ProductMediaUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductMediaUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$alt = alt;
    final lOther$alt = other.alt;
    if (_$data.containsKey('alt') != other._$data.containsKey('alt')) {
      return false;
    }
    if (l$alt != lOther$alt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$alt = alt;
    return Object.hashAll([_$data.containsKey('alt') ? l$alt : const {}]);
  }
}

abstract class CopyWith$Input$ProductMediaUpdateInput<TRes> {
  factory CopyWith$Input$ProductMediaUpdateInput(
    Input$ProductMediaUpdateInput instance,
    TRes Function(Input$ProductMediaUpdateInput) then,
  ) = _CopyWithImpl$Input$ProductMediaUpdateInput;

  factory CopyWith$Input$ProductMediaUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductMediaUpdateInput;

  TRes call({String? alt});
}

class _CopyWithImpl$Input$ProductMediaUpdateInput<TRes>
    implements CopyWith$Input$ProductMediaUpdateInput<TRes> {
  _CopyWithImpl$Input$ProductMediaUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ProductMediaUpdateInput _instance;

  final TRes Function(Input$ProductMediaUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? alt = _undefined}) =>
      _then(Input$ProductMediaUpdateInput._({
        ..._instance._$data,
        if (alt != _undefined) 'alt': (alt as String?),
      }));
}

class _CopyWithStubImpl$Input$ProductMediaUpdateInput<TRes>
    implements CopyWith$Input$ProductMediaUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ProductMediaUpdateInput(this._res);

  TRes _res;

  call({String? alt}) => _res;
}

class Input$ProductOrder {
  factory Input$ProductOrder({
    required Enum$OrderDirection direction,
    String? channel,
    String? attributeId,
    Enum$ProductOrderField? field,
  }) =>
      Input$ProductOrder._({
        r'direction': direction,
        if (channel != null) r'channel': channel,
        if (attributeId != null) r'attributeId': attributeId,
        if (field != null) r'field': field,
      });

  Input$ProductOrder._(this._$data);

  factory Input$ProductOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    if (data.containsKey('channel')) {
      final l$channel = data['channel'];
      result$data['channel'] = (l$channel as String?);
    }
    if (data.containsKey('attributeId')) {
      final l$attributeId = data['attributeId'];
      result$data['attributeId'] = (l$attributeId as String?);
    }
    if (data.containsKey('field')) {
      final l$field = data['field'];
      result$data['field'] = l$field == null
          ? null
          : fromJson$Enum$ProductOrderField((l$field as String));
    }
    return Input$ProductOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  String? get channel => (_$data['channel'] as String?);

  String? get attributeId => (_$data['attributeId'] as String?);

  Enum$ProductOrderField? get field =>
      (_$data['field'] as Enum$ProductOrderField?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    if (_$data.containsKey('channel')) {
      final l$channel = channel;
      result$data['channel'] = l$channel;
    }
    if (_$data.containsKey('attributeId')) {
      final l$attributeId = attributeId;
      result$data['attributeId'] = l$attributeId;
    }
    if (_$data.containsKey('field')) {
      final l$field = field;
      result$data['field'] =
          l$field == null ? null : toJson$Enum$ProductOrderField(l$field);
    }
    return result$data;
  }

  CopyWith$Input$ProductOrder<Input$ProductOrder> get copyWith =>
      CopyWith$Input$ProductOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$channel = channel;
    final lOther$channel = other.channel;
    if (_$data.containsKey('channel') != other._$data.containsKey('channel')) {
      return false;
    }
    if (l$channel != lOther$channel) {
      return false;
    }
    final l$attributeId = attributeId;
    final lOther$attributeId = other.attributeId;
    if (_$data.containsKey('attributeId') !=
        other._$data.containsKey('attributeId')) {
      return false;
    }
    if (l$attributeId != lOther$attributeId) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (_$data.containsKey('field') != other._$data.containsKey('field')) {
      return false;
    }
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$channel = channel;
    final l$attributeId = attributeId;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      _$data.containsKey('channel') ? l$channel : const {},
      _$data.containsKey('attributeId') ? l$attributeId : const {},
      _$data.containsKey('field') ? l$field : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductOrder<TRes> {
  factory CopyWith$Input$ProductOrder(
    Input$ProductOrder instance,
    TRes Function(Input$ProductOrder) then,
  ) = _CopyWithImpl$Input$ProductOrder;

  factory CopyWith$Input$ProductOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductOrder;

  TRes call({
    Enum$OrderDirection? direction,
    String? channel,
    String? attributeId,
    Enum$ProductOrderField? field,
  });
}

class _CopyWithImpl$Input$ProductOrder<TRes>
    implements CopyWith$Input$ProductOrder<TRes> {
  _CopyWithImpl$Input$ProductOrder(
    this._instance,
    this._then,
  );

  final Input$ProductOrder _instance;

  final TRes Function(Input$ProductOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? channel = _undefined,
    Object? attributeId = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$ProductOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (channel != _undefined) 'channel': (channel as String?),
        if (attributeId != _undefined) 'attributeId': (attributeId as String?),
        if (field != _undefined) 'field': (field as Enum$ProductOrderField?),
      }));
}

class _CopyWithStubImpl$Input$ProductOrder<TRes>
    implements CopyWith$Input$ProductOrder<TRes> {
  _CopyWithStubImpl$Input$ProductOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    String? channel,
    String? attributeId,
    Enum$ProductOrderField? field,
  }) =>
      _res;
}

class Input$ProductStockFilterInput {
  factory Input$ProductStockFilterInput({
    List<String>? warehouseIds,
    Input$IntRangeInput? quantity,
  }) =>
      Input$ProductStockFilterInput._({
        if (warehouseIds != null) r'warehouseIds': warehouseIds,
        if (quantity != null) r'quantity': quantity,
      });

  Input$ProductStockFilterInput._(this._$data);

  factory Input$ProductStockFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('warehouseIds')) {
      final l$warehouseIds = data['warehouseIds'];
      result$data['warehouseIds'] = (l$warehouseIds as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntRangeInput.fromJson((l$quantity as Map<String, dynamic>));
    }
    return Input$ProductStockFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get warehouseIds => (_$data['warehouseIds'] as List<String>?);

  Input$IntRangeInput? get quantity =>
      (_$data['quantity'] as Input$IntRangeInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('warehouseIds')) {
      final l$warehouseIds = warehouseIds;
      result$data['warehouseIds'] = l$warehouseIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductStockFilterInput<Input$ProductStockFilterInput>
      get copyWith => CopyWith$Input$ProductStockFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductStockFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$warehouseIds = warehouseIds;
    final lOther$warehouseIds = other.warehouseIds;
    if (_$data.containsKey('warehouseIds') !=
        other._$data.containsKey('warehouseIds')) {
      return false;
    }
    if (l$warehouseIds != null && lOther$warehouseIds != null) {
      if (l$warehouseIds.length != lOther$warehouseIds.length) {
        return false;
      }
      for (int i = 0; i < l$warehouseIds.length; i++) {
        final l$warehouseIds$entry = l$warehouseIds[i];
        final lOther$warehouseIds$entry = lOther$warehouseIds[i];
        if (l$warehouseIds$entry != lOther$warehouseIds$entry) {
          return false;
        }
      }
    } else if (l$warehouseIds != lOther$warehouseIds) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$warehouseIds = warehouseIds;
    final l$quantity = quantity;
    return Object.hashAll([
      _$data.containsKey('warehouseIds')
          ? l$warehouseIds == null
              ? null
              : Object.hashAll(l$warehouseIds.map((v) => v))
          : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductStockFilterInput<TRes> {
  factory CopyWith$Input$ProductStockFilterInput(
    Input$ProductStockFilterInput instance,
    TRes Function(Input$ProductStockFilterInput) then,
  ) = _CopyWithImpl$Input$ProductStockFilterInput;

  factory CopyWith$Input$ProductStockFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductStockFilterInput;

  TRes call({
    List<String>? warehouseIds,
    Input$IntRangeInput? quantity,
  });
  CopyWith$Input$IntRangeInput<TRes> get quantity;
}

class _CopyWithImpl$Input$ProductStockFilterInput<TRes>
    implements CopyWith$Input$ProductStockFilterInput<TRes> {
  _CopyWithImpl$Input$ProductStockFilterInput(
    this._instance,
    this._then,
  );

  final Input$ProductStockFilterInput _instance;

  final TRes Function(Input$ProductStockFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? warehouseIds = _undefined,
    Object? quantity = _undefined,
  }) =>
      _then(Input$ProductStockFilterInput._({
        ..._instance._$data,
        if (warehouseIds != _undefined)
          'warehouseIds': (warehouseIds as List<String>?),
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntRangeInput?),
      }));

  CopyWith$Input$IntRangeInput<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntRangeInput.stub(_then(_instance))
        : CopyWith$Input$IntRangeInput(
            local$quantity, (e) => call(quantity: e));
  }
}

class _CopyWithStubImpl$Input$ProductStockFilterInput<TRes>
    implements CopyWith$Input$ProductStockFilterInput<TRes> {
  _CopyWithStubImpl$Input$ProductStockFilterInput(this._res);

  TRes _res;

  call({
    List<String>? warehouseIds,
    Input$IntRangeInput? quantity,
  }) =>
      _res;

  CopyWith$Input$IntRangeInput<TRes> get quantity =>
      CopyWith$Input$IntRangeInput.stub(_res);
}

class Input$ProductTypeFilterInput {
  factory Input$ProductTypeFilterInput({
    String? search,
    Enum$ProductTypeConfigurable? configurable,
    Enum$ProductTypeEnum? productType,
    List<Input$MetadataFilter>? metadata,
    Enum$ProductTypeKindEnum? kind,
    List<String>? ids,
    List<String>? slugs,
  }) =>
      Input$ProductTypeFilterInput._({
        if (search != null) r'search': search,
        if (configurable != null) r'configurable': configurable,
        if (productType != null) r'productType': productType,
        if (metadata != null) r'metadata': metadata,
        if (kind != null) r'kind': kind,
        if (ids != null) r'ids': ids,
        if (slugs != null) r'slugs': slugs,
      });

  Input$ProductTypeFilterInput._(this._$data);

  factory Input$ProductTypeFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('configurable')) {
      final l$configurable = data['configurable'];
      result$data['configurable'] = l$configurable == null
          ? null
          : fromJson$Enum$ProductTypeConfigurable((l$configurable as String));
    }
    if (data.containsKey('productType')) {
      final l$productType = data['productType'];
      result$data['productType'] = l$productType == null
          ? null
          : fromJson$Enum$ProductTypeEnum((l$productType as String));
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('kind')) {
      final l$kind = data['kind'];
      result$data['kind'] = l$kind == null
          ? null
          : fromJson$Enum$ProductTypeKindEnum((l$kind as String));
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('slugs')) {
      final l$slugs = data['slugs'];
      result$data['slugs'] =
          (l$slugs as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$ProductTypeFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get search => (_$data['search'] as String?);

  Enum$ProductTypeConfigurable? get configurable =>
      (_$data['configurable'] as Enum$ProductTypeConfigurable?);

  Enum$ProductTypeEnum? get productType =>
      (_$data['productType'] as Enum$ProductTypeEnum?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  Enum$ProductTypeKindEnum? get kind =>
      (_$data['kind'] as Enum$ProductTypeKindEnum?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  List<String>? get slugs => (_$data['slugs'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('configurable')) {
      final l$configurable = configurable;
      result$data['configurable'] = l$configurable == null
          ? null
          : toJson$Enum$ProductTypeConfigurable(l$configurable);
    }
    if (_$data.containsKey('productType')) {
      final l$productType = productType;
      result$data['productType'] = l$productType == null
          ? null
          : toJson$Enum$ProductTypeEnum(l$productType);
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('kind')) {
      final l$kind = kind;
      result$data['kind'] =
          l$kind == null ? null : toJson$Enum$ProductTypeKindEnum(l$kind);
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('slugs')) {
      final l$slugs = slugs;
      result$data['slugs'] = l$slugs?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductTypeFilterInput<Input$ProductTypeFilterInput>
      get copyWith => CopyWith$Input$ProductTypeFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductTypeFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$configurable = configurable;
    final lOther$configurable = other.configurable;
    if (_$data.containsKey('configurable') !=
        other._$data.containsKey('configurable')) {
      return false;
    }
    if (l$configurable != lOther$configurable) {
      return false;
    }
    final l$productType = productType;
    final lOther$productType = other.productType;
    if (_$data.containsKey('productType') !=
        other._$data.containsKey('productType')) {
      return false;
    }
    if (l$productType != lOther$productType) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$kind = kind;
    final lOther$kind = other.kind;
    if (_$data.containsKey('kind') != other._$data.containsKey('kind')) {
      return false;
    }
    if (l$kind != lOther$kind) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$slugs = slugs;
    final lOther$slugs = other.slugs;
    if (_$data.containsKey('slugs') != other._$data.containsKey('slugs')) {
      return false;
    }
    if (l$slugs != null && lOther$slugs != null) {
      if (l$slugs.length != lOther$slugs.length) {
        return false;
      }
      for (int i = 0; i < l$slugs.length; i++) {
        final l$slugs$entry = l$slugs[i];
        final lOther$slugs$entry = lOther$slugs[i];
        if (l$slugs$entry != lOther$slugs$entry) {
          return false;
        }
      }
    } else if (l$slugs != lOther$slugs) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$search = search;
    final l$configurable = configurable;
    final l$productType = productType;
    final l$metadata = metadata;
    final l$kind = kind;
    final l$ids = ids;
    final l$slugs = slugs;
    return Object.hashAll([
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('configurable') ? l$configurable : const {},
      _$data.containsKey('productType') ? l$productType : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('kind') ? l$kind : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('slugs')
          ? l$slugs == null
              ? null
              : Object.hashAll(l$slugs.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductTypeFilterInput<TRes> {
  factory CopyWith$Input$ProductTypeFilterInput(
    Input$ProductTypeFilterInput instance,
    TRes Function(Input$ProductTypeFilterInput) then,
  ) = _CopyWithImpl$Input$ProductTypeFilterInput;

  factory CopyWith$Input$ProductTypeFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductTypeFilterInput;

  TRes call({
    String? search,
    Enum$ProductTypeConfigurable? configurable,
    Enum$ProductTypeEnum? productType,
    List<Input$MetadataFilter>? metadata,
    Enum$ProductTypeKindEnum? kind,
    List<String>? ids,
    List<String>? slugs,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductTypeFilterInput<TRes>
    implements CopyWith$Input$ProductTypeFilterInput<TRes> {
  _CopyWithImpl$Input$ProductTypeFilterInput(
    this._instance,
    this._then,
  );

  final Input$ProductTypeFilterInput _instance;

  final TRes Function(Input$ProductTypeFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? search = _undefined,
    Object? configurable = _undefined,
    Object? productType = _undefined,
    Object? metadata = _undefined,
    Object? kind = _undefined,
    Object? ids = _undefined,
    Object? slugs = _undefined,
  }) =>
      _then(Input$ProductTypeFilterInput._({
        ..._instance._$data,
        if (search != _undefined) 'search': (search as String?),
        if (configurable != _undefined)
          'configurable': (configurable as Enum$ProductTypeConfigurable?),
        if (productType != _undefined)
          'productType': (productType as Enum$ProductTypeEnum?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (kind != _undefined) 'kind': (kind as Enum$ProductTypeKindEnum?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (slugs != _undefined) 'slugs': (slugs as List<String>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductTypeFilterInput<TRes>
    implements CopyWith$Input$ProductTypeFilterInput<TRes> {
  _CopyWithStubImpl$Input$ProductTypeFilterInput(this._res);

  TRes _res;

  call({
    String? search,
    Enum$ProductTypeConfigurable? configurable,
    Enum$ProductTypeEnum? productType,
    List<Input$MetadataFilter>? metadata,
    Enum$ProductTypeKindEnum? kind,
    List<String>? ids,
    List<String>? slugs,
  }) =>
      _res;

  metadata(_fn) => _res;
}

class Input$ProductTypeInput {
  factory Input$ProductTypeInput({
    String? name,
    String? slug,
    Enum$ProductTypeKindEnum? kind,
    bool? hasVariants,
    List<String>? productAttributes,
    List<String>? variantAttributes,
    bool? isShippingRequired,
    bool? isDigital,
    String? weight,
    String? taxCode,
    String? taxClass,
  }) =>
      Input$ProductTypeInput._({
        if (name != null) r'name': name,
        if (slug != null) r'slug': slug,
        if (kind != null) r'kind': kind,
        if (hasVariants != null) r'hasVariants': hasVariants,
        if (productAttributes != null) r'productAttributes': productAttributes,
        if (variantAttributes != null) r'variantAttributes': variantAttributes,
        if (isShippingRequired != null)
          r'isShippingRequired': isShippingRequired,
        if (isDigital != null) r'isDigital': isDigital,
        if (weight != null) r'weight': weight,
        if (taxCode != null) r'taxCode': taxCode,
        if (taxClass != null) r'taxClass': taxClass,
      });

  Input$ProductTypeInput._(this._$data);

  factory Input$ProductTypeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('kind')) {
      final l$kind = data['kind'];
      result$data['kind'] = l$kind == null
          ? null
          : fromJson$Enum$ProductTypeKindEnum((l$kind as String));
    }
    if (data.containsKey('hasVariants')) {
      final l$hasVariants = data['hasVariants'];
      result$data['hasVariants'] = (l$hasVariants as bool?);
    }
    if (data.containsKey('productAttributes')) {
      final l$productAttributes = data['productAttributes'];
      result$data['productAttributes'] = (l$productAttributes as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('variantAttributes')) {
      final l$variantAttributes = data['variantAttributes'];
      result$data['variantAttributes'] = (l$variantAttributes as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('isShippingRequired')) {
      final l$isShippingRequired = data['isShippingRequired'];
      result$data['isShippingRequired'] = (l$isShippingRequired as bool?);
    }
    if (data.containsKey('isDigital')) {
      final l$isDigital = data['isDigital'];
      result$data['isDigital'] = (l$isDigital as bool?);
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as String?);
    }
    if (data.containsKey('taxCode')) {
      final l$taxCode = data['taxCode'];
      result$data['taxCode'] = (l$taxCode as String?);
    }
    if (data.containsKey('taxClass')) {
      final l$taxClass = data['taxClass'];
      result$data['taxClass'] = (l$taxClass as String?);
    }
    return Input$ProductTypeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get slug => (_$data['slug'] as String?);

  Enum$ProductTypeKindEnum? get kind =>
      (_$data['kind'] as Enum$ProductTypeKindEnum?);

  bool? get hasVariants => (_$data['hasVariants'] as bool?);

  List<String>? get productAttributes =>
      (_$data['productAttributes'] as List<String>?);

  List<String>? get variantAttributes =>
      (_$data['variantAttributes'] as List<String>?);

  bool? get isShippingRequired => (_$data['isShippingRequired'] as bool?);

  bool? get isDigital => (_$data['isDigital'] as bool?);

  String? get weight => (_$data['weight'] as String?);

  String? get taxCode => (_$data['taxCode'] as String?);

  String? get taxClass => (_$data['taxClass'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('kind')) {
      final l$kind = kind;
      result$data['kind'] =
          l$kind == null ? null : toJson$Enum$ProductTypeKindEnum(l$kind);
    }
    if (_$data.containsKey('hasVariants')) {
      final l$hasVariants = hasVariants;
      result$data['hasVariants'] = l$hasVariants;
    }
    if (_$data.containsKey('productAttributes')) {
      final l$productAttributes = productAttributes;
      result$data['productAttributes'] =
          l$productAttributes?.map((e) => e).toList();
    }
    if (_$data.containsKey('variantAttributes')) {
      final l$variantAttributes = variantAttributes;
      result$data['variantAttributes'] =
          l$variantAttributes?.map((e) => e).toList();
    }
    if (_$data.containsKey('isShippingRequired')) {
      final l$isShippingRequired = isShippingRequired;
      result$data['isShippingRequired'] = l$isShippingRequired;
    }
    if (_$data.containsKey('isDigital')) {
      final l$isDigital = isDigital;
      result$data['isDigital'] = l$isDigital;
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    if (_$data.containsKey('taxCode')) {
      final l$taxCode = taxCode;
      result$data['taxCode'] = l$taxCode;
    }
    if (_$data.containsKey('taxClass')) {
      final l$taxClass = taxClass;
      result$data['taxClass'] = l$taxClass;
    }
    return result$data;
  }

  CopyWith$Input$ProductTypeInput<Input$ProductTypeInput> get copyWith =>
      CopyWith$Input$ProductTypeInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductTypeInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$kind = kind;
    final lOther$kind = other.kind;
    if (_$data.containsKey('kind') != other._$data.containsKey('kind')) {
      return false;
    }
    if (l$kind != lOther$kind) {
      return false;
    }
    final l$hasVariants = hasVariants;
    final lOther$hasVariants = other.hasVariants;
    if (_$data.containsKey('hasVariants') !=
        other._$data.containsKey('hasVariants')) {
      return false;
    }
    if (l$hasVariants != lOther$hasVariants) {
      return false;
    }
    final l$productAttributes = productAttributes;
    final lOther$productAttributes = other.productAttributes;
    if (_$data.containsKey('productAttributes') !=
        other._$data.containsKey('productAttributes')) {
      return false;
    }
    if (l$productAttributes != null && lOther$productAttributes != null) {
      if (l$productAttributes.length != lOther$productAttributes.length) {
        return false;
      }
      for (int i = 0; i < l$productAttributes.length; i++) {
        final l$productAttributes$entry = l$productAttributes[i];
        final lOther$productAttributes$entry = lOther$productAttributes[i];
        if (l$productAttributes$entry != lOther$productAttributes$entry) {
          return false;
        }
      }
    } else if (l$productAttributes != lOther$productAttributes) {
      return false;
    }
    final l$variantAttributes = variantAttributes;
    final lOther$variantAttributes = other.variantAttributes;
    if (_$data.containsKey('variantAttributes') !=
        other._$data.containsKey('variantAttributes')) {
      return false;
    }
    if (l$variantAttributes != null && lOther$variantAttributes != null) {
      if (l$variantAttributes.length != lOther$variantAttributes.length) {
        return false;
      }
      for (int i = 0; i < l$variantAttributes.length; i++) {
        final l$variantAttributes$entry = l$variantAttributes[i];
        final lOther$variantAttributes$entry = lOther$variantAttributes[i];
        if (l$variantAttributes$entry != lOther$variantAttributes$entry) {
          return false;
        }
      }
    } else if (l$variantAttributes != lOther$variantAttributes) {
      return false;
    }
    final l$isShippingRequired = isShippingRequired;
    final lOther$isShippingRequired = other.isShippingRequired;
    if (_$data.containsKey('isShippingRequired') !=
        other._$data.containsKey('isShippingRequired')) {
      return false;
    }
    if (l$isShippingRequired != lOther$isShippingRequired) {
      return false;
    }
    final l$isDigital = isDigital;
    final lOther$isDigital = other.isDigital;
    if (_$data.containsKey('isDigital') !=
        other._$data.containsKey('isDigital')) {
      return false;
    }
    if (l$isDigital != lOther$isDigital) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    final l$taxCode = taxCode;
    final lOther$taxCode = other.taxCode;
    if (_$data.containsKey('taxCode') != other._$data.containsKey('taxCode')) {
      return false;
    }
    if (l$taxCode != lOther$taxCode) {
      return false;
    }
    final l$taxClass = taxClass;
    final lOther$taxClass = other.taxClass;
    if (_$data.containsKey('taxClass') !=
        other._$data.containsKey('taxClass')) {
      return false;
    }
    if (l$taxClass != lOther$taxClass) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$slug = slug;
    final l$kind = kind;
    final l$hasVariants = hasVariants;
    final l$productAttributes = productAttributes;
    final l$variantAttributes = variantAttributes;
    final l$isShippingRequired = isShippingRequired;
    final l$isDigital = isDigital;
    final l$weight = weight;
    final l$taxCode = taxCode;
    final l$taxClass = taxClass;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('kind') ? l$kind : const {},
      _$data.containsKey('hasVariants') ? l$hasVariants : const {},
      _$data.containsKey('productAttributes')
          ? l$productAttributes == null
              ? null
              : Object.hashAll(l$productAttributes.map((v) => v))
          : const {},
      _$data.containsKey('variantAttributes')
          ? l$variantAttributes == null
              ? null
              : Object.hashAll(l$variantAttributes.map((v) => v))
          : const {},
      _$data.containsKey('isShippingRequired')
          ? l$isShippingRequired
          : const {},
      _$data.containsKey('isDigital') ? l$isDigital : const {},
      _$data.containsKey('weight') ? l$weight : const {},
      _$data.containsKey('taxCode') ? l$taxCode : const {},
      _$data.containsKey('taxClass') ? l$taxClass : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductTypeInput<TRes> {
  factory CopyWith$Input$ProductTypeInput(
    Input$ProductTypeInput instance,
    TRes Function(Input$ProductTypeInput) then,
  ) = _CopyWithImpl$Input$ProductTypeInput;

  factory CopyWith$Input$ProductTypeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductTypeInput;

  TRes call({
    String? name,
    String? slug,
    Enum$ProductTypeKindEnum? kind,
    bool? hasVariants,
    List<String>? productAttributes,
    List<String>? variantAttributes,
    bool? isShippingRequired,
    bool? isDigital,
    String? weight,
    String? taxCode,
    String? taxClass,
  });
}

class _CopyWithImpl$Input$ProductTypeInput<TRes>
    implements CopyWith$Input$ProductTypeInput<TRes> {
  _CopyWithImpl$Input$ProductTypeInput(
    this._instance,
    this._then,
  );

  final Input$ProductTypeInput _instance;

  final TRes Function(Input$ProductTypeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? kind = _undefined,
    Object? hasVariants = _undefined,
    Object? productAttributes = _undefined,
    Object? variantAttributes = _undefined,
    Object? isShippingRequired = _undefined,
    Object? isDigital = _undefined,
    Object? weight = _undefined,
    Object? taxCode = _undefined,
    Object? taxClass = _undefined,
  }) =>
      _then(Input$ProductTypeInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (slug != _undefined) 'slug': (slug as String?),
        if (kind != _undefined) 'kind': (kind as Enum$ProductTypeKindEnum?),
        if (hasVariants != _undefined) 'hasVariants': (hasVariants as bool?),
        if (productAttributes != _undefined)
          'productAttributes': (productAttributes as List<String>?),
        if (variantAttributes != _undefined)
          'variantAttributes': (variantAttributes as List<String>?),
        if (isShippingRequired != _undefined)
          'isShippingRequired': (isShippingRequired as bool?),
        if (isDigital != _undefined) 'isDigital': (isDigital as bool?),
        if (weight != _undefined) 'weight': (weight as String?),
        if (taxCode != _undefined) 'taxCode': (taxCode as String?),
        if (taxClass != _undefined) 'taxClass': (taxClass as String?),
      }));
}

class _CopyWithStubImpl$Input$ProductTypeInput<TRes>
    implements CopyWith$Input$ProductTypeInput<TRes> {
  _CopyWithStubImpl$Input$ProductTypeInput(this._res);

  TRes _res;

  call({
    String? name,
    String? slug,
    Enum$ProductTypeKindEnum? kind,
    bool? hasVariants,
    List<String>? productAttributes,
    List<String>? variantAttributes,
    bool? isShippingRequired,
    bool? isDigital,
    String? weight,
    String? taxCode,
    String? taxClass,
  }) =>
      _res;
}

class Input$ProductTypeSortingInput {
  factory Input$ProductTypeSortingInput({
    required Enum$OrderDirection direction,
    required Enum$ProductTypeSortField field,
  }) =>
      Input$ProductTypeSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$ProductTypeSortingInput._(this._$data);

  factory Input$ProductTypeSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProductTypeSortField((l$field as String));
    return Input$ProductTypeSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$ProductTypeSortField get field =>
      (_$data['field'] as Enum$ProductTypeSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$ProductTypeSortField(l$field);
    return result$data;
  }

  CopyWith$Input$ProductTypeSortingInput<Input$ProductTypeSortingInput>
      get copyWith => CopyWith$Input$ProductTypeSortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductTypeSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$ProductTypeSortingInput<TRes> {
  factory CopyWith$Input$ProductTypeSortingInput(
    Input$ProductTypeSortingInput instance,
    TRes Function(Input$ProductTypeSortingInput) then,
  ) = _CopyWithImpl$Input$ProductTypeSortingInput;

  factory CopyWith$Input$ProductTypeSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductTypeSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$ProductTypeSortField? field,
  });
}

class _CopyWithImpl$Input$ProductTypeSortingInput<TRes>
    implements CopyWith$Input$ProductTypeSortingInput<TRes> {
  _CopyWithImpl$Input$ProductTypeSortingInput(
    this._instance,
    this._then,
  );

  final Input$ProductTypeSortingInput _instance;

  final TRes Function(Input$ProductTypeSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$ProductTypeSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$ProductTypeSortField),
      }));
}

class _CopyWithStubImpl$Input$ProductTypeSortingInput<TRes>
    implements CopyWith$Input$ProductTypeSortingInput<TRes> {
  _CopyWithStubImpl$Input$ProductTypeSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$ProductTypeSortField? field,
  }) =>
      _res;
}

class Input$ProductVariantBulkCreateInput {
  factory Input$ProductVariantBulkCreateInput({
    required List<Input$BulkAttributeValueInput> attributes,
    String? sku,
    String? name,
    bool? trackInventory,
    String? weight,
    Input$PreorderSettingsInput? preorder,
    int? quantityLimitPerCustomer,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
    List<Input$StockInput>? stocks,
    List<Input$ProductVariantChannelListingAddInput>? channelListings,
  }) =>
      Input$ProductVariantBulkCreateInput._({
        r'attributes': attributes,
        if (sku != null) r'sku': sku,
        if (name != null) r'name': name,
        if (trackInventory != null) r'trackInventory': trackInventory,
        if (weight != null) r'weight': weight,
        if (preorder != null) r'preorder': preorder,
        if (quantityLimitPerCustomer != null)
          r'quantityLimitPerCustomer': quantityLimitPerCustomer,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (externalReference != null) r'externalReference': externalReference,
        if (stocks != null) r'stocks': stocks,
        if (channelListings != null) r'channelListings': channelListings,
      });

  Input$ProductVariantBulkCreateInput._(this._$data);

  factory Input$ProductVariantBulkCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$attributes = data['attributes'];
    result$data['attributes'] = (l$attributes as List<dynamic>)
        .map((e) =>
            Input$BulkAttributeValueInput.fromJson((e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('sku')) {
      final l$sku = data['sku'];
      result$data['sku'] = (l$sku as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('trackInventory')) {
      final l$trackInventory = data['trackInventory'];
      result$data['trackInventory'] = (l$trackInventory as bool?);
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as String?);
    }
    if (data.containsKey('preorder')) {
      final l$preorder = data['preorder'];
      result$data['preorder'] = l$preorder == null
          ? null
          : Input$PreorderSettingsInput.fromJson(
              (l$preorder as Map<String, dynamic>));
    }
    if (data.containsKey('quantityLimitPerCustomer')) {
      final l$quantityLimitPerCustomer = data['quantityLimitPerCustomer'];
      result$data['quantityLimitPerCustomer'] =
          (l$quantityLimitPerCustomer as int?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    if (data.containsKey('stocks')) {
      final l$stocks = data['stocks'];
      result$data['stocks'] = (l$stocks as List<dynamic>?)
          ?.map((e) => Input$StockInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('channelListings')) {
      final l$channelListings = data['channelListings'];
      result$data['channelListings'] = (l$channelListings as List<dynamic>?)
          ?.map((e) => Input$ProductVariantChannelListingAddInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$ProductVariantBulkCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$BulkAttributeValueInput> get attributes =>
      (_$data['attributes'] as List<Input$BulkAttributeValueInput>);

  String? get sku => (_$data['sku'] as String?);

  String? get name => (_$data['name'] as String?);

  bool? get trackInventory => (_$data['trackInventory'] as bool?);

  String? get weight => (_$data['weight'] as String?);

  Input$PreorderSettingsInput? get preorder =>
      (_$data['preorder'] as Input$PreorderSettingsInput?);

  int? get quantityLimitPerCustomer =>
      (_$data['quantityLimitPerCustomer'] as int?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  String? get externalReference => (_$data['externalReference'] as String?);

  List<Input$StockInput>? get stocks =>
      (_$data['stocks'] as List<Input$StockInput>?);

  List<Input$ProductVariantChannelListingAddInput>? get channelListings =>
      (_$data['channelListings']
          as List<Input$ProductVariantChannelListingAddInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$attributes = attributes;
    result$data['attributes'] = l$attributes.map((e) => e.toJson()).toList();
    if (_$data.containsKey('sku')) {
      final l$sku = sku;
      result$data['sku'] = l$sku;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('trackInventory')) {
      final l$trackInventory = trackInventory;
      result$data['trackInventory'] = l$trackInventory;
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    if (_$data.containsKey('preorder')) {
      final l$preorder = preorder;
      result$data['preorder'] = l$preorder?.toJson();
    }
    if (_$data.containsKey('quantityLimitPerCustomer')) {
      final l$quantityLimitPerCustomer = quantityLimitPerCustomer;
      result$data['quantityLimitPerCustomer'] = l$quantityLimitPerCustomer;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    if (_$data.containsKey('stocks')) {
      final l$stocks = stocks;
      result$data['stocks'] = l$stocks?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('channelListings')) {
      final l$channelListings = channelListings;
      result$data['channelListings'] =
          l$channelListings?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductVariantBulkCreateInput<
          Input$ProductVariantBulkCreateInput>
      get copyWith => CopyWith$Input$ProductVariantBulkCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductVariantBulkCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$attributes = attributes;
    final lOther$attributes = other.attributes;
    if (l$attributes.length != lOther$attributes.length) {
      return false;
    }
    for (int i = 0; i < l$attributes.length; i++) {
      final l$attributes$entry = l$attributes[i];
      final lOther$attributes$entry = lOther$attributes[i];
      if (l$attributes$entry != lOther$attributes$entry) {
        return false;
      }
    }
    final l$sku = sku;
    final lOther$sku = other.sku;
    if (_$data.containsKey('sku') != other._$data.containsKey('sku')) {
      return false;
    }
    if (l$sku != lOther$sku) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$trackInventory = trackInventory;
    final lOther$trackInventory = other.trackInventory;
    if (_$data.containsKey('trackInventory') !=
        other._$data.containsKey('trackInventory')) {
      return false;
    }
    if (l$trackInventory != lOther$trackInventory) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    final l$preorder = preorder;
    final lOther$preorder = other.preorder;
    if (_$data.containsKey('preorder') !=
        other._$data.containsKey('preorder')) {
      return false;
    }
    if (l$preorder != lOther$preorder) {
      return false;
    }
    final l$quantityLimitPerCustomer = quantityLimitPerCustomer;
    final lOther$quantityLimitPerCustomer = other.quantityLimitPerCustomer;
    if (_$data.containsKey('quantityLimitPerCustomer') !=
        other._$data.containsKey('quantityLimitPerCustomer')) {
      return false;
    }
    if (l$quantityLimitPerCustomer != lOther$quantityLimitPerCustomer) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$stocks = stocks;
    final lOther$stocks = other.stocks;
    if (_$data.containsKey('stocks') != other._$data.containsKey('stocks')) {
      return false;
    }
    if (l$stocks != null && lOther$stocks != null) {
      if (l$stocks.length != lOther$stocks.length) {
        return false;
      }
      for (int i = 0; i < l$stocks.length; i++) {
        final l$stocks$entry = l$stocks[i];
        final lOther$stocks$entry = lOther$stocks[i];
        if (l$stocks$entry != lOther$stocks$entry) {
          return false;
        }
      }
    } else if (l$stocks != lOther$stocks) {
      return false;
    }
    final l$channelListings = channelListings;
    final lOther$channelListings = other.channelListings;
    if (_$data.containsKey('channelListings') !=
        other._$data.containsKey('channelListings')) {
      return false;
    }
    if (l$channelListings != null && lOther$channelListings != null) {
      if (l$channelListings.length != lOther$channelListings.length) {
        return false;
      }
      for (int i = 0; i < l$channelListings.length; i++) {
        final l$channelListings$entry = l$channelListings[i];
        final lOther$channelListings$entry = lOther$channelListings[i];
        if (l$channelListings$entry != lOther$channelListings$entry) {
          return false;
        }
      }
    } else if (l$channelListings != lOther$channelListings) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$attributes = attributes;
    final l$sku = sku;
    final l$name = name;
    final l$trackInventory = trackInventory;
    final l$weight = weight;
    final l$preorder = preorder;
    final l$quantityLimitPerCustomer = quantityLimitPerCustomer;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$externalReference = externalReference;
    final l$stocks = stocks;
    final l$channelListings = channelListings;
    return Object.hashAll([
      Object.hashAll(l$attributes.map((v) => v)),
      _$data.containsKey('sku') ? l$sku : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('trackInventory') ? l$trackInventory : const {},
      _$data.containsKey('weight') ? l$weight : const {},
      _$data.containsKey('preorder') ? l$preorder : const {},
      _$data.containsKey('quantityLimitPerCustomer')
          ? l$quantityLimitPerCustomer
          : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      _$data.containsKey('stocks')
          ? l$stocks == null
              ? null
              : Object.hashAll(l$stocks.map((v) => v))
          : const {},
      _$data.containsKey('channelListings')
          ? l$channelListings == null
              ? null
              : Object.hashAll(l$channelListings.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductVariantBulkCreateInput<TRes> {
  factory CopyWith$Input$ProductVariantBulkCreateInput(
    Input$ProductVariantBulkCreateInput instance,
    TRes Function(Input$ProductVariantBulkCreateInput) then,
  ) = _CopyWithImpl$Input$ProductVariantBulkCreateInput;

  factory CopyWith$Input$ProductVariantBulkCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductVariantBulkCreateInput;

  TRes call({
    List<Input$BulkAttributeValueInput>? attributes,
    String? sku,
    String? name,
    bool? trackInventory,
    String? weight,
    Input$PreorderSettingsInput? preorder,
    int? quantityLimitPerCustomer,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
    List<Input$StockInput>? stocks,
    List<Input$ProductVariantChannelListingAddInput>? channelListings,
  });
  TRes attributes(
      Iterable<Input$BulkAttributeValueInput> Function(
              Iterable<
                  CopyWith$Input$BulkAttributeValueInput<
                      Input$BulkAttributeValueInput>>)
          _fn);
  CopyWith$Input$PreorderSettingsInput<TRes> get preorder;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes stocks(
      Iterable<Input$StockInput>? Function(
              Iterable<CopyWith$Input$StockInput<Input$StockInput>>?)
          _fn);
  TRes channelListings(
      Iterable<Input$ProductVariantChannelListingAddInput>? Function(
              Iterable<
                  CopyWith$Input$ProductVariantChannelListingAddInput<
                      Input$ProductVariantChannelListingAddInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductVariantBulkCreateInput<TRes>
    implements CopyWith$Input$ProductVariantBulkCreateInput<TRes> {
  _CopyWithImpl$Input$ProductVariantBulkCreateInput(
    this._instance,
    this._then,
  );

  final Input$ProductVariantBulkCreateInput _instance;

  final TRes Function(Input$ProductVariantBulkCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? attributes = _undefined,
    Object? sku = _undefined,
    Object? name = _undefined,
    Object? trackInventory = _undefined,
    Object? weight = _undefined,
    Object? preorder = _undefined,
    Object? quantityLimitPerCustomer = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? externalReference = _undefined,
    Object? stocks = _undefined,
    Object? channelListings = _undefined,
  }) =>
      _then(Input$ProductVariantBulkCreateInput._({
        ..._instance._$data,
        if (attributes != _undefined && attributes != null)
          'attributes': (attributes as List<Input$BulkAttributeValueInput>),
        if (sku != _undefined) 'sku': (sku as String?),
        if (name != _undefined) 'name': (name as String?),
        if (trackInventory != _undefined)
          'trackInventory': (trackInventory as bool?),
        if (weight != _undefined) 'weight': (weight as String?),
        if (preorder != _undefined)
          'preorder': (preorder as Input$PreorderSettingsInput?),
        if (quantityLimitPerCustomer != _undefined)
          'quantityLimitPerCustomer': (quantityLimitPerCustomer as int?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (stocks != _undefined) 'stocks': (stocks as List<Input$StockInput>?),
        if (channelListings != _undefined)
          'channelListings': (channelListings
              as List<Input$ProductVariantChannelListingAddInput>?),
      }));

  TRes attributes(
          Iterable<Input$BulkAttributeValueInput> Function(
                  Iterable<
                      CopyWith$Input$BulkAttributeValueInput<
                          Input$BulkAttributeValueInput>>)
              _fn) =>
      call(
          attributes: _fn(_instance.attributes
              .map((e) => CopyWith$Input$BulkAttributeValueInput(
                    e,
                    (i) => i,
                  ))).toList());

  CopyWith$Input$PreorderSettingsInput<TRes> get preorder {
    final local$preorder = _instance.preorder;
    return local$preorder == null
        ? CopyWith$Input$PreorderSettingsInput.stub(_then(_instance))
        : CopyWith$Input$PreorderSettingsInput(
            local$preorder, (e) => call(preorder: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes stocks(
          Iterable<Input$StockInput>? Function(
                  Iterable<CopyWith$Input$StockInput<Input$StockInput>>?)
              _fn) =>
      call(
          stocks: _fn(_instance.stocks?.map((e) => CopyWith$Input$StockInput(
                e,
                (i) => i,
              )))?.toList());

  TRes channelListings(
          Iterable<Input$ProductVariantChannelListingAddInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductVariantChannelListingAddInput<
                          Input$ProductVariantChannelListingAddInput>>?)
              _fn) =>
      call(
          channelListings: _fn(_instance.channelListings
              ?.map((e) => CopyWith$Input$ProductVariantChannelListingAddInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductVariantBulkCreateInput<TRes>
    implements CopyWith$Input$ProductVariantBulkCreateInput<TRes> {
  _CopyWithStubImpl$Input$ProductVariantBulkCreateInput(this._res);

  TRes _res;

  call({
    List<Input$BulkAttributeValueInput>? attributes,
    String? sku,
    String? name,
    bool? trackInventory,
    String? weight,
    Input$PreorderSettingsInput? preorder,
    int? quantityLimitPerCustomer,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
    List<Input$StockInput>? stocks,
    List<Input$ProductVariantChannelListingAddInput>? channelListings,
  }) =>
      _res;

  attributes(_fn) => _res;

  CopyWith$Input$PreorderSettingsInput<TRes> get preorder =>
      CopyWith$Input$PreorderSettingsInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;

  stocks(_fn) => _res;

  channelListings(_fn) => _res;
}

class Input$ProductVariantBulkTranslateInput {
  factory Input$ProductVariantBulkTranslateInput({
    String? id,
    String? externalReference,
    required Enum$LanguageCodeEnum languageCode,
    required Input$NameTranslationInput translationFields,
  }) =>
      Input$ProductVariantBulkTranslateInput._({
        if (id != null) r'id': id,
        if (externalReference != null) r'externalReference': externalReference,
        r'languageCode': languageCode,
        r'translationFields': translationFields,
      });

  Input$ProductVariantBulkTranslateInput._(this._$data);

  factory Input$ProductVariantBulkTranslateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    final l$languageCode = data['languageCode'];
    result$data['languageCode'] =
        fromJson$Enum$LanguageCodeEnum((l$languageCode as String));
    final l$translationFields = data['translationFields'];
    result$data['translationFields'] = Input$NameTranslationInput.fromJson(
        (l$translationFields as Map<String, dynamic>));
    return Input$ProductVariantBulkTranslateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get externalReference => (_$data['externalReference'] as String?);

  Enum$LanguageCodeEnum get languageCode =>
      (_$data['languageCode'] as Enum$LanguageCodeEnum);

  Input$NameTranslationInput get translationFields =>
      (_$data['translationFields'] as Input$NameTranslationInput);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    final l$languageCode = languageCode;
    result$data['languageCode'] = toJson$Enum$LanguageCodeEnum(l$languageCode);
    final l$translationFields = translationFields;
    result$data['translationFields'] = l$translationFields.toJson();
    return result$data;
  }

  CopyWith$Input$ProductVariantBulkTranslateInput<
          Input$ProductVariantBulkTranslateInput>
      get copyWith => CopyWith$Input$ProductVariantBulkTranslateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductVariantBulkTranslateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$languageCode = languageCode;
    final lOther$languageCode = other.languageCode;
    if (l$languageCode != lOther$languageCode) {
      return false;
    }
    final l$translationFields = translationFields;
    final lOther$translationFields = other.translationFields;
    if (l$translationFields != lOther$translationFields) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$externalReference = externalReference;
    final l$languageCode = languageCode;
    final l$translationFields = translationFields;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      l$languageCode,
      l$translationFields,
    ]);
  }
}

abstract class CopyWith$Input$ProductVariantBulkTranslateInput<TRes> {
  factory CopyWith$Input$ProductVariantBulkTranslateInput(
    Input$ProductVariantBulkTranslateInput instance,
    TRes Function(Input$ProductVariantBulkTranslateInput) then,
  ) = _CopyWithImpl$Input$ProductVariantBulkTranslateInput;

  factory CopyWith$Input$ProductVariantBulkTranslateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductVariantBulkTranslateInput;

  TRes call({
    String? id,
    String? externalReference,
    Enum$LanguageCodeEnum? languageCode,
    Input$NameTranslationInput? translationFields,
  });
  CopyWith$Input$NameTranslationInput<TRes> get translationFields;
}

class _CopyWithImpl$Input$ProductVariantBulkTranslateInput<TRes>
    implements CopyWith$Input$ProductVariantBulkTranslateInput<TRes> {
  _CopyWithImpl$Input$ProductVariantBulkTranslateInput(
    this._instance,
    this._then,
  );

  final Input$ProductVariantBulkTranslateInput _instance;

  final TRes Function(Input$ProductVariantBulkTranslateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? externalReference = _undefined,
    Object? languageCode = _undefined,
    Object? translationFields = _undefined,
  }) =>
      _then(Input$ProductVariantBulkTranslateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (languageCode != _undefined && languageCode != null)
          'languageCode': (languageCode as Enum$LanguageCodeEnum),
        if (translationFields != _undefined && translationFields != null)
          'translationFields':
              (translationFields as Input$NameTranslationInput),
      }));

  CopyWith$Input$NameTranslationInput<TRes> get translationFields {
    final local$translationFields = _instance.translationFields;
    return CopyWith$Input$NameTranslationInput(
        local$translationFields, (e) => call(translationFields: e));
  }
}

class _CopyWithStubImpl$Input$ProductVariantBulkTranslateInput<TRes>
    implements CopyWith$Input$ProductVariantBulkTranslateInput<TRes> {
  _CopyWithStubImpl$Input$ProductVariantBulkTranslateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? externalReference,
    Enum$LanguageCodeEnum? languageCode,
    Input$NameTranslationInput? translationFields,
  }) =>
      _res;

  CopyWith$Input$NameTranslationInput<TRes> get translationFields =>
      CopyWith$Input$NameTranslationInput.stub(_res);
}

class Input$ProductVariantBulkUpdateInput {
  factory Input$ProductVariantBulkUpdateInput({
    List<Input$BulkAttributeValueInput>? attributes,
    String? sku,
    String? name,
    bool? trackInventory,
    String? weight,
    Input$PreorderSettingsInput? preorder,
    int? quantityLimitPerCustomer,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
    Input$ProductVariantStocksUpdateInput? stocks,
    Input$ProductVariantChannelListingUpdateInput? channelListings,
    required String id,
  }) =>
      Input$ProductVariantBulkUpdateInput._({
        if (attributes != null) r'attributes': attributes,
        if (sku != null) r'sku': sku,
        if (name != null) r'name': name,
        if (trackInventory != null) r'trackInventory': trackInventory,
        if (weight != null) r'weight': weight,
        if (preorder != null) r'preorder': preorder,
        if (quantityLimitPerCustomer != null)
          r'quantityLimitPerCustomer': quantityLimitPerCustomer,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (externalReference != null) r'externalReference': externalReference,
        if (stocks != null) r'stocks': stocks,
        if (channelListings != null) r'channelListings': channelListings,
        r'id': id,
      });

  Input$ProductVariantBulkUpdateInput._(this._$data);

  factory Input$ProductVariantBulkUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('attributes')) {
      final l$attributes = data['attributes'];
      result$data['attributes'] = (l$attributes as List<dynamic>?)
          ?.map((e) => Input$BulkAttributeValueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('sku')) {
      final l$sku = data['sku'];
      result$data['sku'] = (l$sku as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('trackInventory')) {
      final l$trackInventory = data['trackInventory'];
      result$data['trackInventory'] = (l$trackInventory as bool?);
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as String?);
    }
    if (data.containsKey('preorder')) {
      final l$preorder = data['preorder'];
      result$data['preorder'] = l$preorder == null
          ? null
          : Input$PreorderSettingsInput.fromJson(
              (l$preorder as Map<String, dynamic>));
    }
    if (data.containsKey('quantityLimitPerCustomer')) {
      final l$quantityLimitPerCustomer = data['quantityLimitPerCustomer'];
      result$data['quantityLimitPerCustomer'] =
          (l$quantityLimitPerCustomer as int?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    if (data.containsKey('stocks')) {
      final l$stocks = data['stocks'];
      result$data['stocks'] = l$stocks == null
          ? null
          : Input$ProductVariantStocksUpdateInput.fromJson(
              (l$stocks as Map<String, dynamic>));
    }
    if (data.containsKey('channelListings')) {
      final l$channelListings = data['channelListings'];
      result$data['channelListings'] = l$channelListings == null
          ? null
          : Input$ProductVariantChannelListingUpdateInput.fromJson(
              (l$channelListings as Map<String, dynamic>));
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$ProductVariantBulkUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$BulkAttributeValueInput>? get attributes =>
      (_$data['attributes'] as List<Input$BulkAttributeValueInput>?);

  String? get sku => (_$data['sku'] as String?);

  String? get name => (_$data['name'] as String?);

  bool? get trackInventory => (_$data['trackInventory'] as bool?);

  String? get weight => (_$data['weight'] as String?);

  Input$PreorderSettingsInput? get preorder =>
      (_$data['preorder'] as Input$PreorderSettingsInput?);

  int? get quantityLimitPerCustomer =>
      (_$data['quantityLimitPerCustomer'] as int?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  String? get externalReference => (_$data['externalReference'] as String?);

  Input$ProductVariantStocksUpdateInput? get stocks =>
      (_$data['stocks'] as Input$ProductVariantStocksUpdateInput?);

  Input$ProductVariantChannelListingUpdateInput? get channelListings =>
      (_$data['channelListings']
          as Input$ProductVariantChannelListingUpdateInput?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('attributes')) {
      final l$attributes = attributes;
      result$data['attributes'] = l$attributes?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('sku')) {
      final l$sku = sku;
      result$data['sku'] = l$sku;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('trackInventory')) {
      final l$trackInventory = trackInventory;
      result$data['trackInventory'] = l$trackInventory;
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    if (_$data.containsKey('preorder')) {
      final l$preorder = preorder;
      result$data['preorder'] = l$preorder?.toJson();
    }
    if (_$data.containsKey('quantityLimitPerCustomer')) {
      final l$quantityLimitPerCustomer = quantityLimitPerCustomer;
      result$data['quantityLimitPerCustomer'] = l$quantityLimitPerCustomer;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    if (_$data.containsKey('stocks')) {
      final l$stocks = stocks;
      result$data['stocks'] = l$stocks?.toJson();
    }
    if (_$data.containsKey('channelListings')) {
      final l$channelListings = channelListings;
      result$data['channelListings'] = l$channelListings?.toJson();
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$ProductVariantBulkUpdateInput<
          Input$ProductVariantBulkUpdateInput>
      get copyWith => CopyWith$Input$ProductVariantBulkUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductVariantBulkUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$attributes = attributes;
    final lOther$attributes = other.attributes;
    if (_$data.containsKey('attributes') !=
        other._$data.containsKey('attributes')) {
      return false;
    }
    if (l$attributes != null && lOther$attributes != null) {
      if (l$attributes.length != lOther$attributes.length) {
        return false;
      }
      for (int i = 0; i < l$attributes.length; i++) {
        final l$attributes$entry = l$attributes[i];
        final lOther$attributes$entry = lOther$attributes[i];
        if (l$attributes$entry != lOther$attributes$entry) {
          return false;
        }
      }
    } else if (l$attributes != lOther$attributes) {
      return false;
    }
    final l$sku = sku;
    final lOther$sku = other.sku;
    if (_$data.containsKey('sku') != other._$data.containsKey('sku')) {
      return false;
    }
    if (l$sku != lOther$sku) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$trackInventory = trackInventory;
    final lOther$trackInventory = other.trackInventory;
    if (_$data.containsKey('trackInventory') !=
        other._$data.containsKey('trackInventory')) {
      return false;
    }
    if (l$trackInventory != lOther$trackInventory) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    final l$preorder = preorder;
    final lOther$preorder = other.preorder;
    if (_$data.containsKey('preorder') !=
        other._$data.containsKey('preorder')) {
      return false;
    }
    if (l$preorder != lOther$preorder) {
      return false;
    }
    final l$quantityLimitPerCustomer = quantityLimitPerCustomer;
    final lOther$quantityLimitPerCustomer = other.quantityLimitPerCustomer;
    if (_$data.containsKey('quantityLimitPerCustomer') !=
        other._$data.containsKey('quantityLimitPerCustomer')) {
      return false;
    }
    if (l$quantityLimitPerCustomer != lOther$quantityLimitPerCustomer) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$stocks = stocks;
    final lOther$stocks = other.stocks;
    if (_$data.containsKey('stocks') != other._$data.containsKey('stocks')) {
      return false;
    }
    if (l$stocks != lOther$stocks) {
      return false;
    }
    final l$channelListings = channelListings;
    final lOther$channelListings = other.channelListings;
    if (_$data.containsKey('channelListings') !=
        other._$data.containsKey('channelListings')) {
      return false;
    }
    if (l$channelListings != lOther$channelListings) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$attributes = attributes;
    final l$sku = sku;
    final l$name = name;
    final l$trackInventory = trackInventory;
    final l$weight = weight;
    final l$preorder = preorder;
    final l$quantityLimitPerCustomer = quantityLimitPerCustomer;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$externalReference = externalReference;
    final l$stocks = stocks;
    final l$channelListings = channelListings;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('attributes')
          ? l$attributes == null
              ? null
              : Object.hashAll(l$attributes.map((v) => v))
          : const {},
      _$data.containsKey('sku') ? l$sku : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('trackInventory') ? l$trackInventory : const {},
      _$data.containsKey('weight') ? l$weight : const {},
      _$data.containsKey('preorder') ? l$preorder : const {},
      _$data.containsKey('quantityLimitPerCustomer')
          ? l$quantityLimitPerCustomer
          : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      _$data.containsKey('stocks') ? l$stocks : const {},
      _$data.containsKey('channelListings') ? l$channelListings : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$ProductVariantBulkUpdateInput<TRes> {
  factory CopyWith$Input$ProductVariantBulkUpdateInput(
    Input$ProductVariantBulkUpdateInput instance,
    TRes Function(Input$ProductVariantBulkUpdateInput) then,
  ) = _CopyWithImpl$Input$ProductVariantBulkUpdateInput;

  factory CopyWith$Input$ProductVariantBulkUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductVariantBulkUpdateInput;

  TRes call({
    List<Input$BulkAttributeValueInput>? attributes,
    String? sku,
    String? name,
    bool? trackInventory,
    String? weight,
    Input$PreorderSettingsInput? preorder,
    int? quantityLimitPerCustomer,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
    Input$ProductVariantStocksUpdateInput? stocks,
    Input$ProductVariantChannelListingUpdateInput? channelListings,
    String? id,
  });
  TRes attributes(
      Iterable<Input$BulkAttributeValueInput>? Function(
              Iterable<
                  CopyWith$Input$BulkAttributeValueInput<
                      Input$BulkAttributeValueInput>>?)
          _fn);
  CopyWith$Input$PreorderSettingsInput<TRes> get preorder;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  CopyWith$Input$ProductVariantStocksUpdateInput<TRes> get stocks;
  CopyWith$Input$ProductVariantChannelListingUpdateInput<TRes>
      get channelListings;
}

class _CopyWithImpl$Input$ProductVariantBulkUpdateInput<TRes>
    implements CopyWith$Input$ProductVariantBulkUpdateInput<TRes> {
  _CopyWithImpl$Input$ProductVariantBulkUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ProductVariantBulkUpdateInput _instance;

  final TRes Function(Input$ProductVariantBulkUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? attributes = _undefined,
    Object? sku = _undefined,
    Object? name = _undefined,
    Object? trackInventory = _undefined,
    Object? weight = _undefined,
    Object? preorder = _undefined,
    Object? quantityLimitPerCustomer = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? externalReference = _undefined,
    Object? stocks = _undefined,
    Object? channelListings = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$ProductVariantBulkUpdateInput._({
        ..._instance._$data,
        if (attributes != _undefined)
          'attributes': (attributes as List<Input$BulkAttributeValueInput>?),
        if (sku != _undefined) 'sku': (sku as String?),
        if (name != _undefined) 'name': (name as String?),
        if (trackInventory != _undefined)
          'trackInventory': (trackInventory as bool?),
        if (weight != _undefined) 'weight': (weight as String?),
        if (preorder != _undefined)
          'preorder': (preorder as Input$PreorderSettingsInput?),
        if (quantityLimitPerCustomer != _undefined)
          'quantityLimitPerCustomer': (quantityLimitPerCustomer as int?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (stocks != _undefined)
          'stocks': (stocks as Input$ProductVariantStocksUpdateInput?),
        if (channelListings != _undefined)
          'channelListings': (channelListings
              as Input$ProductVariantChannelListingUpdateInput?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));

  TRes attributes(
          Iterable<Input$BulkAttributeValueInput>? Function(
                  Iterable<
                      CopyWith$Input$BulkAttributeValueInput<
                          Input$BulkAttributeValueInput>>?)
              _fn) =>
      call(
          attributes: _fn(_instance.attributes
              ?.map((e) => CopyWith$Input$BulkAttributeValueInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$PreorderSettingsInput<TRes> get preorder {
    final local$preorder = _instance.preorder;
    return local$preorder == null
        ? CopyWith$Input$PreorderSettingsInput.stub(_then(_instance))
        : CopyWith$Input$PreorderSettingsInput(
            local$preorder, (e) => call(preorder: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$ProductVariantStocksUpdateInput<TRes> get stocks {
    final local$stocks = _instance.stocks;
    return local$stocks == null
        ? CopyWith$Input$ProductVariantStocksUpdateInput.stub(_then(_instance))
        : CopyWith$Input$ProductVariantStocksUpdateInput(
            local$stocks, (e) => call(stocks: e));
  }

  CopyWith$Input$ProductVariantChannelListingUpdateInput<TRes>
      get channelListings {
    final local$channelListings = _instance.channelListings;
    return local$channelListings == null
        ? CopyWith$Input$ProductVariantChannelListingUpdateInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductVariantChannelListingUpdateInput(
            local$channelListings, (e) => call(channelListings: e));
  }
}

class _CopyWithStubImpl$Input$ProductVariantBulkUpdateInput<TRes>
    implements CopyWith$Input$ProductVariantBulkUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ProductVariantBulkUpdateInput(this._res);

  TRes _res;

  call({
    List<Input$BulkAttributeValueInput>? attributes,
    String? sku,
    String? name,
    bool? trackInventory,
    String? weight,
    Input$PreorderSettingsInput? preorder,
    int? quantityLimitPerCustomer,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
    Input$ProductVariantStocksUpdateInput? stocks,
    Input$ProductVariantChannelListingUpdateInput? channelListings,
    String? id,
  }) =>
      _res;

  attributes(_fn) => _res;

  CopyWith$Input$PreorderSettingsInput<TRes> get preorder =>
      CopyWith$Input$PreorderSettingsInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;

  CopyWith$Input$ProductVariantStocksUpdateInput<TRes> get stocks =>
      CopyWith$Input$ProductVariantStocksUpdateInput.stub(_res);

  CopyWith$Input$ProductVariantChannelListingUpdateInput<TRes>
      get channelListings =>
          CopyWith$Input$ProductVariantChannelListingUpdateInput.stub(_res);
}

class Input$ProductVariantChannelListingAddInput {
  factory Input$ProductVariantChannelListingAddInput({
    required String channelId,
    required String price,
    String? costPrice,
    String? priorPrice,
    int? preorderThreshold,
  }) =>
      Input$ProductVariantChannelListingAddInput._({
        r'channelId': channelId,
        r'price': price,
        if (costPrice != null) r'costPrice': costPrice,
        if (priorPrice != null) r'priorPrice': priorPrice,
        if (preorderThreshold != null) r'preorderThreshold': preorderThreshold,
      });

  Input$ProductVariantChannelListingAddInput._(this._$data);

  factory Input$ProductVariantChannelListingAddInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$channelId = data['channelId'];
    result$data['channelId'] = (l$channelId as String);
    final l$price = data['price'];
    result$data['price'] = (l$price as String);
    if (data.containsKey('costPrice')) {
      final l$costPrice = data['costPrice'];
      result$data['costPrice'] = (l$costPrice as String?);
    }
    if (data.containsKey('priorPrice')) {
      final l$priorPrice = data['priorPrice'];
      result$data['priorPrice'] = (l$priorPrice as String?);
    }
    if (data.containsKey('preorderThreshold')) {
      final l$preorderThreshold = data['preorderThreshold'];
      result$data['preorderThreshold'] = (l$preorderThreshold as int?);
    }
    return Input$ProductVariantChannelListingAddInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get channelId => (_$data['channelId'] as String);

  String get price => (_$data['price'] as String);

  String? get costPrice => (_$data['costPrice'] as String?);

  String? get priorPrice => (_$data['priorPrice'] as String?);

  int? get preorderThreshold => (_$data['preorderThreshold'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$channelId = channelId;
    result$data['channelId'] = l$channelId;
    final l$price = price;
    result$data['price'] = l$price;
    if (_$data.containsKey('costPrice')) {
      final l$costPrice = costPrice;
      result$data['costPrice'] = l$costPrice;
    }
    if (_$data.containsKey('priorPrice')) {
      final l$priorPrice = priorPrice;
      result$data['priorPrice'] = l$priorPrice;
    }
    if (_$data.containsKey('preorderThreshold')) {
      final l$preorderThreshold = preorderThreshold;
      result$data['preorderThreshold'] = l$preorderThreshold;
    }
    return result$data;
  }

  CopyWith$Input$ProductVariantChannelListingAddInput<
          Input$ProductVariantChannelListingAddInput>
      get copyWith => CopyWith$Input$ProductVariantChannelListingAddInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductVariantChannelListingAddInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$channelId = channelId;
    final lOther$channelId = other.channelId;
    if (l$channelId != lOther$channelId) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (l$price != lOther$price) {
      return false;
    }
    final l$costPrice = costPrice;
    final lOther$costPrice = other.costPrice;
    if (_$data.containsKey('costPrice') !=
        other._$data.containsKey('costPrice')) {
      return false;
    }
    if (l$costPrice != lOther$costPrice) {
      return false;
    }
    final l$priorPrice = priorPrice;
    final lOther$priorPrice = other.priorPrice;
    if (_$data.containsKey('priorPrice') !=
        other._$data.containsKey('priorPrice')) {
      return false;
    }
    if (l$priorPrice != lOther$priorPrice) {
      return false;
    }
    final l$preorderThreshold = preorderThreshold;
    final lOther$preorderThreshold = other.preorderThreshold;
    if (_$data.containsKey('preorderThreshold') !=
        other._$data.containsKey('preorderThreshold')) {
      return false;
    }
    if (l$preorderThreshold != lOther$preorderThreshold) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$channelId = channelId;
    final l$price = price;
    final l$costPrice = costPrice;
    final l$priorPrice = priorPrice;
    final l$preorderThreshold = preorderThreshold;
    return Object.hashAll([
      l$channelId,
      l$price,
      _$data.containsKey('costPrice') ? l$costPrice : const {},
      _$data.containsKey('priorPrice') ? l$priorPrice : const {},
      _$data.containsKey('preorderThreshold') ? l$preorderThreshold : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductVariantChannelListingAddInput<TRes> {
  factory CopyWith$Input$ProductVariantChannelListingAddInput(
    Input$ProductVariantChannelListingAddInput instance,
    TRes Function(Input$ProductVariantChannelListingAddInput) then,
  ) = _CopyWithImpl$Input$ProductVariantChannelListingAddInput;

  factory CopyWith$Input$ProductVariantChannelListingAddInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductVariantChannelListingAddInput;

  TRes call({
    String? channelId,
    String? price,
    String? costPrice,
    String? priorPrice,
    int? preorderThreshold,
  });
}

class _CopyWithImpl$Input$ProductVariantChannelListingAddInput<TRes>
    implements CopyWith$Input$ProductVariantChannelListingAddInput<TRes> {
  _CopyWithImpl$Input$ProductVariantChannelListingAddInput(
    this._instance,
    this._then,
  );

  final Input$ProductVariantChannelListingAddInput _instance;

  final TRes Function(Input$ProductVariantChannelListingAddInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? channelId = _undefined,
    Object? price = _undefined,
    Object? costPrice = _undefined,
    Object? priorPrice = _undefined,
    Object? preorderThreshold = _undefined,
  }) =>
      _then(Input$ProductVariantChannelListingAddInput._({
        ..._instance._$data,
        if (channelId != _undefined && channelId != null)
          'channelId': (channelId as String),
        if (price != _undefined && price != null) 'price': (price as String),
        if (costPrice != _undefined) 'costPrice': (costPrice as String?),
        if (priorPrice != _undefined) 'priorPrice': (priorPrice as String?),
        if (preorderThreshold != _undefined)
          'preorderThreshold': (preorderThreshold as int?),
      }));
}

class _CopyWithStubImpl$Input$ProductVariantChannelListingAddInput<TRes>
    implements CopyWith$Input$ProductVariantChannelListingAddInput<TRes> {
  _CopyWithStubImpl$Input$ProductVariantChannelListingAddInput(this._res);

  TRes _res;

  call({
    String? channelId,
    String? price,
    String? costPrice,
    String? priorPrice,
    int? preorderThreshold,
  }) =>
      _res;
}

class Input$ProductVariantChannelListingUpdateInput {
  factory Input$ProductVariantChannelListingUpdateInput({
    List<Input$ProductVariantChannelListingAddInput>? create,
    List<Input$ChannelListingUpdateInput>? update,
    List<String>? remove,
  }) =>
      Input$ProductVariantChannelListingUpdateInput._({
        if (create != null) r'create': create,
        if (update != null) r'update': update,
        if (remove != null) r'remove': remove,
      });

  Input$ProductVariantChannelListingUpdateInput._(this._$data);

  factory Input$ProductVariantChannelListingUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$ProductVariantChannelListingAddInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) => Input$ChannelListingUpdateInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('remove')) {
      final l$remove = data['remove'];
      result$data['remove'] =
          (l$remove as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$ProductVariantChannelListingUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductVariantChannelListingAddInput>? get create =>
      (_$data['create'] as List<Input$ProductVariantChannelListingAddInput>?);

  List<Input$ChannelListingUpdateInput>? get update =>
      (_$data['update'] as List<Input$ChannelListingUpdateInput>?);

  List<String>? get remove => (_$data['remove'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('remove')) {
      final l$remove = remove;
      result$data['remove'] = l$remove?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductVariantChannelListingUpdateInput<
          Input$ProductVariantChannelListingUpdateInput>
      get copyWith => CopyWith$Input$ProductVariantChannelListingUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductVariantChannelListingUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$remove = remove;
    final lOther$remove = other.remove;
    if (_$data.containsKey('remove') != other._$data.containsKey('remove')) {
      return false;
    }
    if (l$remove != null && lOther$remove != null) {
      if (l$remove.length != lOther$remove.length) {
        return false;
      }
      for (int i = 0; i < l$remove.length; i++) {
        final l$remove$entry = l$remove[i];
        final lOther$remove$entry = lOther$remove[i];
        if (l$remove$entry != lOther$remove$entry) {
          return false;
        }
      }
    } else if (l$remove != lOther$remove) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$update = update;
    final l$remove = remove;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('remove')
          ? l$remove == null
              ? null
              : Object.hashAll(l$remove.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductVariantChannelListingUpdateInput<TRes> {
  factory CopyWith$Input$ProductVariantChannelListingUpdateInput(
    Input$ProductVariantChannelListingUpdateInput instance,
    TRes Function(Input$ProductVariantChannelListingUpdateInput) then,
  ) = _CopyWithImpl$Input$ProductVariantChannelListingUpdateInput;

  factory CopyWith$Input$ProductVariantChannelListingUpdateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductVariantChannelListingUpdateInput;

  TRes call({
    List<Input$ProductVariantChannelListingAddInput>? create,
    List<Input$ChannelListingUpdateInput>? update,
    List<String>? remove,
  });
  TRes create(
      Iterable<Input$ProductVariantChannelListingAddInput>? Function(
              Iterable<
                  CopyWith$Input$ProductVariantChannelListingAddInput<
                      Input$ProductVariantChannelListingAddInput>>?)
          _fn);
  TRes update(
      Iterable<Input$ChannelListingUpdateInput>? Function(
              Iterable<
                  CopyWith$Input$ChannelListingUpdateInput<
                      Input$ChannelListingUpdateInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductVariantChannelListingUpdateInput<TRes>
    implements CopyWith$Input$ProductVariantChannelListingUpdateInput<TRes> {
  _CopyWithImpl$Input$ProductVariantChannelListingUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ProductVariantChannelListingUpdateInput _instance;

  final TRes Function(Input$ProductVariantChannelListingUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? update = _undefined,
    Object? remove = _undefined,
  }) =>
      _then(Input$ProductVariantChannelListingUpdateInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$ProductVariantChannelListingAddInput>?),
        if (update != _undefined)
          'update': (update as List<Input$ChannelListingUpdateInput>?),
        if (remove != _undefined) 'remove': (remove as List<String>?),
      }));

  TRes create(
          Iterable<Input$ProductVariantChannelListingAddInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductVariantChannelListingAddInput<
                          Input$ProductVariantChannelListingAddInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$ProductVariantChannelListingAddInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes update(
          Iterable<Input$ChannelListingUpdateInput>? Function(
                  Iterable<
                      CopyWith$Input$ChannelListingUpdateInput<
                          Input$ChannelListingUpdateInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update
              ?.map((e) => CopyWith$Input$ChannelListingUpdateInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductVariantChannelListingUpdateInput<TRes>
    implements CopyWith$Input$ProductVariantChannelListingUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ProductVariantChannelListingUpdateInput(this._res);

  TRes _res;

  call({
    List<Input$ProductVariantChannelListingAddInput>? create,
    List<Input$ChannelListingUpdateInput>? update,
    List<String>? remove,
  }) =>
      _res;

  create(_fn) => _res;

  update(_fn) => _res;
}

class Input$ProductVariantCreateInput {
  factory Input$ProductVariantCreateInput({
    required List<Input$AttributeValueInput> attributes,
    String? sku,
    String? name,
    bool? trackInventory,
    String? weight,
    Input$PreorderSettingsInput? preorder,
    int? quantityLimitPerCustomer,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
    required String product,
    List<Input$StockInput>? stocks,
  }) =>
      Input$ProductVariantCreateInput._({
        r'attributes': attributes,
        if (sku != null) r'sku': sku,
        if (name != null) r'name': name,
        if (trackInventory != null) r'trackInventory': trackInventory,
        if (weight != null) r'weight': weight,
        if (preorder != null) r'preorder': preorder,
        if (quantityLimitPerCustomer != null)
          r'quantityLimitPerCustomer': quantityLimitPerCustomer,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (externalReference != null) r'externalReference': externalReference,
        r'product': product,
        if (stocks != null) r'stocks': stocks,
      });

  Input$ProductVariantCreateInput._(this._$data);

  factory Input$ProductVariantCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$attributes = data['attributes'];
    result$data['attributes'] = (l$attributes as List<dynamic>)
        .map((e) =>
            Input$AttributeValueInput.fromJson((e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('sku')) {
      final l$sku = data['sku'];
      result$data['sku'] = (l$sku as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('trackInventory')) {
      final l$trackInventory = data['trackInventory'];
      result$data['trackInventory'] = (l$trackInventory as bool?);
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as String?);
    }
    if (data.containsKey('preorder')) {
      final l$preorder = data['preorder'];
      result$data['preorder'] = l$preorder == null
          ? null
          : Input$PreorderSettingsInput.fromJson(
              (l$preorder as Map<String, dynamic>));
    }
    if (data.containsKey('quantityLimitPerCustomer')) {
      final l$quantityLimitPerCustomer = data['quantityLimitPerCustomer'];
      result$data['quantityLimitPerCustomer'] =
          (l$quantityLimitPerCustomer as int?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    final l$product = data['product'];
    result$data['product'] = (l$product as String);
    if (data.containsKey('stocks')) {
      final l$stocks = data['stocks'];
      result$data['stocks'] = (l$stocks as List<dynamic>?)
          ?.map((e) => Input$StockInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$ProductVariantCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$AttributeValueInput> get attributes =>
      (_$data['attributes'] as List<Input$AttributeValueInput>);

  String? get sku => (_$data['sku'] as String?);

  String? get name => (_$data['name'] as String?);

  bool? get trackInventory => (_$data['trackInventory'] as bool?);

  String? get weight => (_$data['weight'] as String?);

  Input$PreorderSettingsInput? get preorder =>
      (_$data['preorder'] as Input$PreorderSettingsInput?);

  int? get quantityLimitPerCustomer =>
      (_$data['quantityLimitPerCustomer'] as int?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  String? get externalReference => (_$data['externalReference'] as String?);

  String get product => (_$data['product'] as String);

  List<Input$StockInput>? get stocks =>
      (_$data['stocks'] as List<Input$StockInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$attributes = attributes;
    result$data['attributes'] = l$attributes.map((e) => e.toJson()).toList();
    if (_$data.containsKey('sku')) {
      final l$sku = sku;
      result$data['sku'] = l$sku;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('trackInventory')) {
      final l$trackInventory = trackInventory;
      result$data['trackInventory'] = l$trackInventory;
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    if (_$data.containsKey('preorder')) {
      final l$preorder = preorder;
      result$data['preorder'] = l$preorder?.toJson();
    }
    if (_$data.containsKey('quantityLimitPerCustomer')) {
      final l$quantityLimitPerCustomer = quantityLimitPerCustomer;
      result$data['quantityLimitPerCustomer'] = l$quantityLimitPerCustomer;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    final l$product = product;
    result$data['product'] = l$product;
    if (_$data.containsKey('stocks')) {
      final l$stocks = stocks;
      result$data['stocks'] = l$stocks?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductVariantCreateInput<Input$ProductVariantCreateInput>
      get copyWith => CopyWith$Input$ProductVariantCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductVariantCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$attributes = attributes;
    final lOther$attributes = other.attributes;
    if (l$attributes.length != lOther$attributes.length) {
      return false;
    }
    for (int i = 0; i < l$attributes.length; i++) {
      final l$attributes$entry = l$attributes[i];
      final lOther$attributes$entry = lOther$attributes[i];
      if (l$attributes$entry != lOther$attributes$entry) {
        return false;
      }
    }
    final l$sku = sku;
    final lOther$sku = other.sku;
    if (_$data.containsKey('sku') != other._$data.containsKey('sku')) {
      return false;
    }
    if (l$sku != lOther$sku) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$trackInventory = trackInventory;
    final lOther$trackInventory = other.trackInventory;
    if (_$data.containsKey('trackInventory') !=
        other._$data.containsKey('trackInventory')) {
      return false;
    }
    if (l$trackInventory != lOther$trackInventory) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    final l$preorder = preorder;
    final lOther$preorder = other.preorder;
    if (_$data.containsKey('preorder') !=
        other._$data.containsKey('preorder')) {
      return false;
    }
    if (l$preorder != lOther$preorder) {
      return false;
    }
    final l$quantityLimitPerCustomer = quantityLimitPerCustomer;
    final lOther$quantityLimitPerCustomer = other.quantityLimitPerCustomer;
    if (_$data.containsKey('quantityLimitPerCustomer') !=
        other._$data.containsKey('quantityLimitPerCustomer')) {
      return false;
    }
    if (l$quantityLimitPerCustomer != lOther$quantityLimitPerCustomer) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$product = product;
    final lOther$product = other.product;
    if (l$product != lOther$product) {
      return false;
    }
    final l$stocks = stocks;
    final lOther$stocks = other.stocks;
    if (_$data.containsKey('stocks') != other._$data.containsKey('stocks')) {
      return false;
    }
    if (l$stocks != null && lOther$stocks != null) {
      if (l$stocks.length != lOther$stocks.length) {
        return false;
      }
      for (int i = 0; i < l$stocks.length; i++) {
        final l$stocks$entry = l$stocks[i];
        final lOther$stocks$entry = lOther$stocks[i];
        if (l$stocks$entry != lOther$stocks$entry) {
          return false;
        }
      }
    } else if (l$stocks != lOther$stocks) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$attributes = attributes;
    final l$sku = sku;
    final l$name = name;
    final l$trackInventory = trackInventory;
    final l$weight = weight;
    final l$preorder = preorder;
    final l$quantityLimitPerCustomer = quantityLimitPerCustomer;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$externalReference = externalReference;
    final l$product = product;
    final l$stocks = stocks;
    return Object.hashAll([
      Object.hashAll(l$attributes.map((v) => v)),
      _$data.containsKey('sku') ? l$sku : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('trackInventory') ? l$trackInventory : const {},
      _$data.containsKey('weight') ? l$weight : const {},
      _$data.containsKey('preorder') ? l$preorder : const {},
      _$data.containsKey('quantityLimitPerCustomer')
          ? l$quantityLimitPerCustomer
          : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      l$product,
      _$data.containsKey('stocks')
          ? l$stocks == null
              ? null
              : Object.hashAll(l$stocks.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductVariantCreateInput<TRes> {
  factory CopyWith$Input$ProductVariantCreateInput(
    Input$ProductVariantCreateInput instance,
    TRes Function(Input$ProductVariantCreateInput) then,
  ) = _CopyWithImpl$Input$ProductVariantCreateInput;

  factory CopyWith$Input$ProductVariantCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductVariantCreateInput;

  TRes call({
    List<Input$AttributeValueInput>? attributes,
    String? sku,
    String? name,
    bool? trackInventory,
    String? weight,
    Input$PreorderSettingsInput? preorder,
    int? quantityLimitPerCustomer,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
    String? product,
    List<Input$StockInput>? stocks,
  });
  TRes attributes(
      Iterable<Input$AttributeValueInput> Function(
              Iterable<
                  CopyWith$Input$AttributeValueInput<
                      Input$AttributeValueInput>>)
          _fn);
  CopyWith$Input$PreorderSettingsInput<TRes> get preorder;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes stocks(
      Iterable<Input$StockInput>? Function(
              Iterable<CopyWith$Input$StockInput<Input$StockInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductVariantCreateInput<TRes>
    implements CopyWith$Input$ProductVariantCreateInput<TRes> {
  _CopyWithImpl$Input$ProductVariantCreateInput(
    this._instance,
    this._then,
  );

  final Input$ProductVariantCreateInput _instance;

  final TRes Function(Input$ProductVariantCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? attributes = _undefined,
    Object? sku = _undefined,
    Object? name = _undefined,
    Object? trackInventory = _undefined,
    Object? weight = _undefined,
    Object? preorder = _undefined,
    Object? quantityLimitPerCustomer = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? externalReference = _undefined,
    Object? product = _undefined,
    Object? stocks = _undefined,
  }) =>
      _then(Input$ProductVariantCreateInput._({
        ..._instance._$data,
        if (attributes != _undefined && attributes != null)
          'attributes': (attributes as List<Input$AttributeValueInput>),
        if (sku != _undefined) 'sku': (sku as String?),
        if (name != _undefined) 'name': (name as String?),
        if (trackInventory != _undefined)
          'trackInventory': (trackInventory as bool?),
        if (weight != _undefined) 'weight': (weight as String?),
        if (preorder != _undefined)
          'preorder': (preorder as Input$PreorderSettingsInput?),
        if (quantityLimitPerCustomer != _undefined)
          'quantityLimitPerCustomer': (quantityLimitPerCustomer as int?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (product != _undefined && product != null)
          'product': (product as String),
        if (stocks != _undefined) 'stocks': (stocks as List<Input$StockInput>?),
      }));

  TRes attributes(
          Iterable<Input$AttributeValueInput> Function(
                  Iterable<
                      CopyWith$Input$AttributeValueInput<
                          Input$AttributeValueInput>>)
              _fn) =>
      call(
          attributes: _fn(_instance.attributes
              .map((e) => CopyWith$Input$AttributeValueInput(
                    e,
                    (i) => i,
                  ))).toList());

  CopyWith$Input$PreorderSettingsInput<TRes> get preorder {
    final local$preorder = _instance.preorder;
    return local$preorder == null
        ? CopyWith$Input$PreorderSettingsInput.stub(_then(_instance))
        : CopyWith$Input$PreorderSettingsInput(
            local$preorder, (e) => call(preorder: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes stocks(
          Iterable<Input$StockInput>? Function(
                  Iterable<CopyWith$Input$StockInput<Input$StockInput>>?)
              _fn) =>
      call(
          stocks: _fn(_instance.stocks?.map((e) => CopyWith$Input$StockInput(
                e,
                (i) => i,
              )))?.toList());
}

class _CopyWithStubImpl$Input$ProductVariantCreateInput<TRes>
    implements CopyWith$Input$ProductVariantCreateInput<TRes> {
  _CopyWithStubImpl$Input$ProductVariantCreateInput(this._res);

  TRes _res;

  call({
    List<Input$AttributeValueInput>? attributes,
    String? sku,
    String? name,
    bool? trackInventory,
    String? weight,
    Input$PreorderSettingsInput? preorder,
    int? quantityLimitPerCustomer,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
    String? product,
    List<Input$StockInput>? stocks,
  }) =>
      _res;

  attributes(_fn) => _res;

  CopyWith$Input$PreorderSettingsInput<TRes> get preorder =>
      CopyWith$Input$PreorderSettingsInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;

  stocks(_fn) => _res;
}

class Input$ProductVariantFilterInput {
  factory Input$ProductVariantFilterInput({
    String? search,
    List<String>? sku,
    List<Input$MetadataFilter>? metadata,
    bool? isPreorder,
    Input$DateTimeRangeInput? updatedAt,
  }) =>
      Input$ProductVariantFilterInput._({
        if (search != null) r'search': search,
        if (sku != null) r'sku': sku,
        if (metadata != null) r'metadata': metadata,
        if (isPreorder != null) r'isPreorder': isPreorder,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$ProductVariantFilterInput._(this._$data);

  factory Input$ProductVariantFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('sku')) {
      final l$sku = data['sku'];
      result$data['sku'] =
          (l$sku as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('isPreorder')) {
      final l$isPreorder = data['isPreorder'];
      result$data['isPreorder'] = (l$isPreorder as bool?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeRangeInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    return Input$ProductVariantFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get search => (_$data['search'] as String?);

  List<String>? get sku => (_$data['sku'] as List<String>?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  bool? get isPreorder => (_$data['isPreorder'] as bool?);

  Input$DateTimeRangeInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeRangeInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('sku')) {
      final l$sku = sku;
      result$data['sku'] = l$sku?.map((e) => e).toList();
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('isPreorder')) {
      final l$isPreorder = isPreorder;
      result$data['isPreorder'] = l$isPreorder;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductVariantFilterInput<Input$ProductVariantFilterInput>
      get copyWith => CopyWith$Input$ProductVariantFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductVariantFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$sku = sku;
    final lOther$sku = other.sku;
    if (_$data.containsKey('sku') != other._$data.containsKey('sku')) {
      return false;
    }
    if (l$sku != null && lOther$sku != null) {
      if (l$sku.length != lOther$sku.length) {
        return false;
      }
      for (int i = 0; i < l$sku.length; i++) {
        final l$sku$entry = l$sku[i];
        final lOther$sku$entry = lOther$sku[i];
        if (l$sku$entry != lOther$sku$entry) {
          return false;
        }
      }
    } else if (l$sku != lOther$sku) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$isPreorder = isPreorder;
    final lOther$isPreorder = other.isPreorder;
    if (_$data.containsKey('isPreorder') !=
        other._$data.containsKey('isPreorder')) {
      return false;
    }
    if (l$isPreorder != lOther$isPreorder) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$search = search;
    final l$sku = sku;
    final l$metadata = metadata;
    final l$isPreorder = isPreorder;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('sku')
          ? l$sku == null
              ? null
              : Object.hashAll(l$sku.map((v) => v))
          : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('isPreorder') ? l$isPreorder : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductVariantFilterInput<TRes> {
  factory CopyWith$Input$ProductVariantFilterInput(
    Input$ProductVariantFilterInput instance,
    TRes Function(Input$ProductVariantFilterInput) then,
  ) = _CopyWithImpl$Input$ProductVariantFilterInput;

  factory CopyWith$Input$ProductVariantFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductVariantFilterInput;

  TRes call({
    String? search,
    List<String>? sku,
    List<Input$MetadataFilter>? metadata,
    bool? isPreorder,
    Input$DateTimeRangeInput? updatedAt,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$ProductVariantFilterInput<TRes>
    implements CopyWith$Input$ProductVariantFilterInput<TRes> {
  _CopyWithImpl$Input$ProductVariantFilterInput(
    this._instance,
    this._then,
  );

  final Input$ProductVariantFilterInput _instance;

  final TRes Function(Input$ProductVariantFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? search = _undefined,
    Object? sku = _undefined,
    Object? metadata = _undefined,
    Object? isPreorder = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$ProductVariantFilterInput._({
        ..._instance._$data,
        if (search != _undefined) 'search': (search as String?),
        if (sku != _undefined) 'sku': (sku as List<String>?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (isPreorder != _undefined) 'isPreorder': (isPreorder as bool?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeRangeInput?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeRangeInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }
}

class _CopyWithStubImpl$Input$ProductVariantFilterInput<TRes>
    implements CopyWith$Input$ProductVariantFilterInput<TRes> {
  _CopyWithStubImpl$Input$ProductVariantFilterInput(this._res);

  TRes _res;

  call({
    String? search,
    List<String>? sku,
    List<Input$MetadataFilter>? metadata,
    bool? isPreorder,
    Input$DateTimeRangeInput? updatedAt,
  }) =>
      _res;

  metadata(_fn) => _res;

  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeRangeInput.stub(_res);
}

class Input$ProductVariantInput {
  factory Input$ProductVariantInput({
    List<Input$AttributeValueInput>? attributes,
    String? sku,
    String? name,
    bool? trackInventory,
    String? weight,
    Input$PreorderSettingsInput? preorder,
    int? quantityLimitPerCustomer,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
  }) =>
      Input$ProductVariantInput._({
        if (attributes != null) r'attributes': attributes,
        if (sku != null) r'sku': sku,
        if (name != null) r'name': name,
        if (trackInventory != null) r'trackInventory': trackInventory,
        if (weight != null) r'weight': weight,
        if (preorder != null) r'preorder': preorder,
        if (quantityLimitPerCustomer != null)
          r'quantityLimitPerCustomer': quantityLimitPerCustomer,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (externalReference != null) r'externalReference': externalReference,
      });

  Input$ProductVariantInput._(this._$data);

  factory Input$ProductVariantInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('attributes')) {
      final l$attributes = data['attributes'];
      result$data['attributes'] = (l$attributes as List<dynamic>?)
          ?.map((e) =>
              Input$AttributeValueInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('sku')) {
      final l$sku = data['sku'];
      result$data['sku'] = (l$sku as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('trackInventory')) {
      final l$trackInventory = data['trackInventory'];
      result$data['trackInventory'] = (l$trackInventory as bool?);
    }
    if (data.containsKey('weight')) {
      final l$weight = data['weight'];
      result$data['weight'] = (l$weight as String?);
    }
    if (data.containsKey('preorder')) {
      final l$preorder = data['preorder'];
      result$data['preorder'] = l$preorder == null
          ? null
          : Input$PreorderSettingsInput.fromJson(
              (l$preorder as Map<String, dynamic>));
    }
    if (data.containsKey('quantityLimitPerCustomer')) {
      final l$quantityLimitPerCustomer = data['quantityLimitPerCustomer'];
      result$data['quantityLimitPerCustomer'] =
          (l$quantityLimitPerCustomer as int?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    return Input$ProductVariantInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$AttributeValueInput>? get attributes =>
      (_$data['attributes'] as List<Input$AttributeValueInput>?);

  String? get sku => (_$data['sku'] as String?);

  String? get name => (_$data['name'] as String?);

  bool? get trackInventory => (_$data['trackInventory'] as bool?);

  String? get weight => (_$data['weight'] as String?);

  Input$PreorderSettingsInput? get preorder =>
      (_$data['preorder'] as Input$PreorderSettingsInput?);

  int? get quantityLimitPerCustomer =>
      (_$data['quantityLimitPerCustomer'] as int?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  String? get externalReference => (_$data['externalReference'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('attributes')) {
      final l$attributes = attributes;
      result$data['attributes'] = l$attributes?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('sku')) {
      final l$sku = sku;
      result$data['sku'] = l$sku;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('trackInventory')) {
      final l$trackInventory = trackInventory;
      result$data['trackInventory'] = l$trackInventory;
    }
    if (_$data.containsKey('weight')) {
      final l$weight = weight;
      result$data['weight'] = l$weight;
    }
    if (_$data.containsKey('preorder')) {
      final l$preorder = preorder;
      result$data['preorder'] = l$preorder?.toJson();
    }
    if (_$data.containsKey('quantityLimitPerCustomer')) {
      final l$quantityLimitPerCustomer = quantityLimitPerCustomer;
      result$data['quantityLimitPerCustomer'] = l$quantityLimitPerCustomer;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    return result$data;
  }

  CopyWith$Input$ProductVariantInput<Input$ProductVariantInput> get copyWith =>
      CopyWith$Input$ProductVariantInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductVariantInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$attributes = attributes;
    final lOther$attributes = other.attributes;
    if (_$data.containsKey('attributes') !=
        other._$data.containsKey('attributes')) {
      return false;
    }
    if (l$attributes != null && lOther$attributes != null) {
      if (l$attributes.length != lOther$attributes.length) {
        return false;
      }
      for (int i = 0; i < l$attributes.length; i++) {
        final l$attributes$entry = l$attributes[i];
        final lOther$attributes$entry = lOther$attributes[i];
        if (l$attributes$entry != lOther$attributes$entry) {
          return false;
        }
      }
    } else if (l$attributes != lOther$attributes) {
      return false;
    }
    final l$sku = sku;
    final lOther$sku = other.sku;
    if (_$data.containsKey('sku') != other._$data.containsKey('sku')) {
      return false;
    }
    if (l$sku != lOther$sku) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$trackInventory = trackInventory;
    final lOther$trackInventory = other.trackInventory;
    if (_$data.containsKey('trackInventory') !=
        other._$data.containsKey('trackInventory')) {
      return false;
    }
    if (l$trackInventory != lOther$trackInventory) {
      return false;
    }
    final l$weight = weight;
    final lOther$weight = other.weight;
    if (_$data.containsKey('weight') != other._$data.containsKey('weight')) {
      return false;
    }
    if (l$weight != lOther$weight) {
      return false;
    }
    final l$preorder = preorder;
    final lOther$preorder = other.preorder;
    if (_$data.containsKey('preorder') !=
        other._$data.containsKey('preorder')) {
      return false;
    }
    if (l$preorder != lOther$preorder) {
      return false;
    }
    final l$quantityLimitPerCustomer = quantityLimitPerCustomer;
    final lOther$quantityLimitPerCustomer = other.quantityLimitPerCustomer;
    if (_$data.containsKey('quantityLimitPerCustomer') !=
        other._$data.containsKey('quantityLimitPerCustomer')) {
      return false;
    }
    if (l$quantityLimitPerCustomer != lOther$quantityLimitPerCustomer) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$attributes = attributes;
    final l$sku = sku;
    final l$name = name;
    final l$trackInventory = trackInventory;
    final l$weight = weight;
    final l$preorder = preorder;
    final l$quantityLimitPerCustomer = quantityLimitPerCustomer;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$externalReference = externalReference;
    return Object.hashAll([
      _$data.containsKey('attributes')
          ? l$attributes == null
              ? null
              : Object.hashAll(l$attributes.map((v) => v))
          : const {},
      _$data.containsKey('sku') ? l$sku : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('trackInventory') ? l$trackInventory : const {},
      _$data.containsKey('weight') ? l$weight : const {},
      _$data.containsKey('preorder') ? l$preorder : const {},
      _$data.containsKey('quantityLimitPerCustomer')
          ? l$quantityLimitPerCustomer
          : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductVariantInput<TRes> {
  factory CopyWith$Input$ProductVariantInput(
    Input$ProductVariantInput instance,
    TRes Function(Input$ProductVariantInput) then,
  ) = _CopyWithImpl$Input$ProductVariantInput;

  factory CopyWith$Input$ProductVariantInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductVariantInput;

  TRes call({
    List<Input$AttributeValueInput>? attributes,
    String? sku,
    String? name,
    bool? trackInventory,
    String? weight,
    Input$PreorderSettingsInput? preorder,
    int? quantityLimitPerCustomer,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
  });
  TRes attributes(
      Iterable<Input$AttributeValueInput>? Function(
              Iterable<
                  CopyWith$Input$AttributeValueInput<
                      Input$AttributeValueInput>>?)
          _fn);
  CopyWith$Input$PreorderSettingsInput<TRes> get preorder;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductVariantInput<TRes>
    implements CopyWith$Input$ProductVariantInput<TRes> {
  _CopyWithImpl$Input$ProductVariantInput(
    this._instance,
    this._then,
  );

  final Input$ProductVariantInput _instance;

  final TRes Function(Input$ProductVariantInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? attributes = _undefined,
    Object? sku = _undefined,
    Object? name = _undefined,
    Object? trackInventory = _undefined,
    Object? weight = _undefined,
    Object? preorder = _undefined,
    Object? quantityLimitPerCustomer = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? externalReference = _undefined,
  }) =>
      _then(Input$ProductVariantInput._({
        ..._instance._$data,
        if (attributes != _undefined)
          'attributes': (attributes as List<Input$AttributeValueInput>?),
        if (sku != _undefined) 'sku': (sku as String?),
        if (name != _undefined) 'name': (name as String?),
        if (trackInventory != _undefined)
          'trackInventory': (trackInventory as bool?),
        if (weight != _undefined) 'weight': (weight as String?),
        if (preorder != _undefined)
          'preorder': (preorder as Input$PreorderSettingsInput?),
        if (quantityLimitPerCustomer != _undefined)
          'quantityLimitPerCustomer': (quantityLimitPerCustomer as int?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
      }));

  TRes attributes(
          Iterable<Input$AttributeValueInput>? Function(
                  Iterable<
                      CopyWith$Input$AttributeValueInput<
                          Input$AttributeValueInput>>?)
              _fn) =>
      call(
          attributes: _fn(_instance.attributes
              ?.map((e) => CopyWith$Input$AttributeValueInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$PreorderSettingsInput<TRes> get preorder {
    final local$preorder = _instance.preorder;
    return local$preorder == null
        ? CopyWith$Input$PreorderSettingsInput.stub(_then(_instance))
        : CopyWith$Input$PreorderSettingsInput(
            local$preorder, (e) => call(preorder: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductVariantInput<TRes>
    implements CopyWith$Input$ProductVariantInput<TRes> {
  _CopyWithStubImpl$Input$ProductVariantInput(this._res);

  TRes _res;

  call({
    List<Input$AttributeValueInput>? attributes,
    String? sku,
    String? name,
    bool? trackInventory,
    String? weight,
    Input$PreorderSettingsInput? preorder,
    int? quantityLimitPerCustomer,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalReference,
  }) =>
      _res;

  attributes(_fn) => _res;

  CopyWith$Input$PreorderSettingsInput<TRes> get preorder =>
      CopyWith$Input$PreorderSettingsInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$ProductVariantSortingInput {
  factory Input$ProductVariantSortingInput({
    required Enum$OrderDirection direction,
    required Enum$ProductVariantSortField field,
  }) =>
      Input$ProductVariantSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$ProductVariantSortingInput._(this._$data);

  factory Input$ProductVariantSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProductVariantSortField((l$field as String));
    return Input$ProductVariantSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$ProductVariantSortField get field =>
      (_$data['field'] as Enum$ProductVariantSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$ProductVariantSortField(l$field);
    return result$data;
  }

  CopyWith$Input$ProductVariantSortingInput<Input$ProductVariantSortingInput>
      get copyWith => CopyWith$Input$ProductVariantSortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductVariantSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$ProductVariantSortingInput<TRes> {
  factory CopyWith$Input$ProductVariantSortingInput(
    Input$ProductVariantSortingInput instance,
    TRes Function(Input$ProductVariantSortingInput) then,
  ) = _CopyWithImpl$Input$ProductVariantSortingInput;

  factory CopyWith$Input$ProductVariantSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductVariantSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$ProductVariantSortField? field,
  });
}

class _CopyWithImpl$Input$ProductVariantSortingInput<TRes>
    implements CopyWith$Input$ProductVariantSortingInput<TRes> {
  _CopyWithImpl$Input$ProductVariantSortingInput(
    this._instance,
    this._then,
  );

  final Input$ProductVariantSortingInput _instance;

  final TRes Function(Input$ProductVariantSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$ProductVariantSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$ProductVariantSortField),
      }));
}

class _CopyWithStubImpl$Input$ProductVariantSortingInput<TRes>
    implements CopyWith$Input$ProductVariantSortingInput<TRes> {
  _CopyWithStubImpl$Input$ProductVariantSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$ProductVariantSortField? field,
  }) =>
      _res;
}

class Input$ProductVariantStocksUpdateInput {
  factory Input$ProductVariantStocksUpdateInput({
    List<Input$StockInput>? create,
    List<Input$StockUpdateInput>? update,
    List<String>? remove,
  }) =>
      Input$ProductVariantStocksUpdateInput._({
        if (create != null) r'create': create,
        if (update != null) r'update': update,
        if (remove != null) r'remove': remove,
      });

  Input$ProductVariantStocksUpdateInput._(this._$data);

  factory Input$ProductVariantStocksUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$StockInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) =>
              Input$StockUpdateInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('remove')) {
      final l$remove = data['remove'];
      result$data['remove'] =
          (l$remove as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$ProductVariantStocksUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$StockInput>? get create =>
      (_$data['create'] as List<Input$StockInput>?);

  List<Input$StockUpdateInput>? get update =>
      (_$data['update'] as List<Input$StockUpdateInput>?);

  List<String>? get remove => (_$data['remove'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('remove')) {
      final l$remove = remove;
      result$data['remove'] = l$remove?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductVariantStocksUpdateInput<
          Input$ProductVariantStocksUpdateInput>
      get copyWith => CopyWith$Input$ProductVariantStocksUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductVariantStocksUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$remove = remove;
    final lOther$remove = other.remove;
    if (_$data.containsKey('remove') != other._$data.containsKey('remove')) {
      return false;
    }
    if (l$remove != null && lOther$remove != null) {
      if (l$remove.length != lOther$remove.length) {
        return false;
      }
      for (int i = 0; i < l$remove.length; i++) {
        final l$remove$entry = l$remove[i];
        final lOther$remove$entry = lOther$remove[i];
        if (l$remove$entry != lOther$remove$entry) {
          return false;
        }
      }
    } else if (l$remove != lOther$remove) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$update = update;
    final l$remove = remove;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('remove')
          ? l$remove == null
              ? null
              : Object.hashAll(l$remove.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductVariantStocksUpdateInput<TRes> {
  factory CopyWith$Input$ProductVariantStocksUpdateInput(
    Input$ProductVariantStocksUpdateInput instance,
    TRes Function(Input$ProductVariantStocksUpdateInput) then,
  ) = _CopyWithImpl$Input$ProductVariantStocksUpdateInput;

  factory CopyWith$Input$ProductVariantStocksUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductVariantStocksUpdateInput;

  TRes call({
    List<Input$StockInput>? create,
    List<Input$StockUpdateInput>? update,
    List<String>? remove,
  });
  TRes create(
      Iterable<Input$StockInput>? Function(
              Iterable<CopyWith$Input$StockInput<Input$StockInput>>?)
          _fn);
  TRes update(
      Iterable<Input$StockUpdateInput>? Function(
              Iterable<
                  CopyWith$Input$StockUpdateInput<Input$StockUpdateInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductVariantStocksUpdateInput<TRes>
    implements CopyWith$Input$ProductVariantStocksUpdateInput<TRes> {
  _CopyWithImpl$Input$ProductVariantStocksUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ProductVariantStocksUpdateInput _instance;

  final TRes Function(Input$ProductVariantStocksUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? update = _undefined,
    Object? remove = _undefined,
  }) =>
      _then(Input$ProductVariantStocksUpdateInput._({
        ..._instance._$data,
        if (create != _undefined) 'create': (create as List<Input$StockInput>?),
        if (update != _undefined)
          'update': (update as List<Input$StockUpdateInput>?),
        if (remove != _undefined) 'remove': (remove as List<String>?),
      }));

  TRes create(
          Iterable<Input$StockInput>? Function(
                  Iterable<CopyWith$Input$StockInput<Input$StockInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create?.map((e) => CopyWith$Input$StockInput(
                e,
                (i) => i,
              )))?.toList());

  TRes update(
          Iterable<Input$StockUpdateInput>? Function(
                  Iterable<
                      CopyWith$Input$StockUpdateInput<Input$StockUpdateInput>>?)
              _fn) =>
      call(
          update:
              _fn(_instance.update?.map((e) => CopyWith$Input$StockUpdateInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductVariantStocksUpdateInput<TRes>
    implements CopyWith$Input$ProductVariantStocksUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ProductVariantStocksUpdateInput(this._res);

  TRes _res;

  call({
    List<Input$StockInput>? create,
    List<Input$StockUpdateInput>? update,
    List<String>? remove,
  }) =>
      _res;

  create(_fn) => _res;

  update(_fn) => _res;
}

class Input$ProductVariantWhereInput {
  factory Input$ProductVariantWhereInput({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<Input$ProductVariantWhereInput>? AND,
    List<Input$ProductVariantWhereInput>? OR,
  }) =>
      Input$ProductVariantWhereInput._({
        if (metadata != null) r'metadata': metadata,
        if (ids != null) r'ids': ids,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
      });

  Input$ProductVariantWhereInput._(this._$data);

  factory Input$ProductVariantWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$ProductVariantWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$ProductVariantWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$ProductVariantWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  List<Input$ProductVariantWhereInput>? get AND =>
      (_$data['AND'] as List<Input$ProductVariantWhereInput>?);

  List<Input$ProductVariantWhereInput>? get OR =>
      (_$data['OR'] as List<Input$ProductVariantWhereInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductVariantWhereInput<Input$ProductVariantWhereInput>
      get copyWith => CopyWith$Input$ProductVariantWhereInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductVariantWhereInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$metadata = metadata;
    final l$ids = ids;
    final l$AND = AND;
    final l$OR = OR;
    return Object.hashAll([
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductVariantWhereInput<TRes> {
  factory CopyWith$Input$ProductVariantWhereInput(
    Input$ProductVariantWhereInput instance,
    TRes Function(Input$ProductVariantWhereInput) then,
  ) = _CopyWithImpl$Input$ProductVariantWhereInput;

  factory CopyWith$Input$ProductVariantWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductVariantWhereInput;

  TRes call({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<Input$ProductVariantWhereInput>? AND,
    List<Input$ProductVariantWhereInput>? OR,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
  TRes AND(
      Iterable<Input$ProductVariantWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductVariantWhereInput<
                      Input$ProductVariantWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$ProductVariantWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductVariantWhereInput<
                      Input$ProductVariantWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductVariantWhereInput<TRes>
    implements CopyWith$Input$ProductVariantWhereInput<TRes> {
  _CopyWithImpl$Input$ProductVariantWhereInput(
    this._instance,
    this._then,
  );

  final Input$ProductVariantWhereInput _instance;

  final TRes Function(Input$ProductVariantWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? metadata = _undefined,
    Object? ids = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
  }) =>
      _then(Input$ProductVariantWhereInput._({
        ..._instance._$data,
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (AND != _undefined)
          'AND': (AND as List<Input$ProductVariantWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$ProductVariantWhereInput>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes AND(
          Iterable<Input$ProductVariantWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductVariantWhereInput<
                          Input$ProductVariantWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(
              _instance.AND?.map((e) => CopyWith$Input$ProductVariantWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes OR(
          Iterable<Input$ProductVariantWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductVariantWhereInput<
                          Input$ProductVariantWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$ProductVariantWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductVariantWhereInput<TRes>
    implements CopyWith$Input$ProductVariantWhereInput<TRes> {
  _CopyWithStubImpl$Input$ProductVariantWhereInput(this._res);

  TRes _res;

  call({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<Input$ProductVariantWhereInput>? AND,
    List<Input$ProductVariantWhereInput>? OR,
  }) =>
      _res;

  metadata(_fn) => _res;

  AND(_fn) => _res;

  OR(_fn) => _res;
}

class Input$ProductWhereInput {
  factory Input$ProductWhereInput({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    Input$StringFilterInput? name,
    Input$StringFilterInput? slug,
    Input$GlobalIDFilterInput? productType,
    Input$GlobalIDFilterInput? category,
    Input$GlobalIDFilterInput? collection,
    bool? isAvailable,
    bool? isPublished,
    bool? isVisibleInListing,
    String? publishedFrom,
    String? availableFrom,
    bool? hasCategory,
    Input$DecimalFilterInput? price,
    Input$DecimalFilterInput? minimalPrice,
    List<Input$AttributeInput>? attributes,
    Enum$StockAvailability? stockAvailability,
    Input$ProductStockFilterInput? stocks,
    bool? giftCard,
    bool? hasPreorderedVariants,
    Input$DateTimeFilterInput? updatedAt,
    List<Input$ProductWhereInput>? AND,
    List<Input$ProductWhereInput>? OR,
  }) =>
      Input$ProductWhereInput._({
        if (metadata != null) r'metadata': metadata,
        if (ids != null) r'ids': ids,
        if (name != null) r'name': name,
        if (slug != null) r'slug': slug,
        if (productType != null) r'productType': productType,
        if (category != null) r'category': category,
        if (collection != null) r'collection': collection,
        if (isAvailable != null) r'isAvailable': isAvailable,
        if (isPublished != null) r'isPublished': isPublished,
        if (isVisibleInListing != null)
          r'isVisibleInListing': isVisibleInListing,
        if (publishedFrom != null) r'publishedFrom': publishedFrom,
        if (availableFrom != null) r'availableFrom': availableFrom,
        if (hasCategory != null) r'hasCategory': hasCategory,
        if (price != null) r'price': price,
        if (minimalPrice != null) r'minimalPrice': minimalPrice,
        if (attributes != null) r'attributes': attributes,
        if (stockAvailability != null) r'stockAvailability': stockAvailability,
        if (stocks != null) r'stocks': stocks,
        if (giftCard != null) r'giftCard': giftCard,
        if (hasPreorderedVariants != null)
          r'hasPreorderedVariants': hasPreorderedVariants,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
      });

  Input$ProductWhereInput._(this._$data);

  factory Input$ProductWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilterInput.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = l$slug == null
          ? null
          : Input$StringFilterInput.fromJson((l$slug as Map<String, dynamic>));
    }
    if (data.containsKey('productType')) {
      final l$productType = data['productType'];
      result$data['productType'] = l$productType == null
          ? null
          : Input$GlobalIDFilterInput.fromJson(
              (l$productType as Map<String, dynamic>));
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = l$category == null
          ? null
          : Input$GlobalIDFilterInput.fromJson(
              (l$category as Map<String, dynamic>));
    }
    if (data.containsKey('collection')) {
      final l$collection = data['collection'];
      result$data['collection'] = l$collection == null
          ? null
          : Input$GlobalIDFilterInput.fromJson(
              (l$collection as Map<String, dynamic>));
    }
    if (data.containsKey('isAvailable')) {
      final l$isAvailable = data['isAvailable'];
      result$data['isAvailable'] = (l$isAvailable as bool?);
    }
    if (data.containsKey('isPublished')) {
      final l$isPublished = data['isPublished'];
      result$data['isPublished'] = (l$isPublished as bool?);
    }
    if (data.containsKey('isVisibleInListing')) {
      final l$isVisibleInListing = data['isVisibleInListing'];
      result$data['isVisibleInListing'] = (l$isVisibleInListing as bool?);
    }
    if (data.containsKey('publishedFrom')) {
      final l$publishedFrom = data['publishedFrom'];
      result$data['publishedFrom'] = (l$publishedFrom as String?);
    }
    if (data.containsKey('availableFrom')) {
      final l$availableFrom = data['availableFrom'];
      result$data['availableFrom'] = (l$availableFrom as String?);
    }
    if (data.containsKey('hasCategory')) {
      final l$hasCategory = data['hasCategory'];
      result$data['hasCategory'] = (l$hasCategory as bool?);
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] = l$price == null
          ? null
          : Input$DecimalFilterInput.fromJson(
              (l$price as Map<String, dynamic>));
    }
    if (data.containsKey('minimalPrice')) {
      final l$minimalPrice = data['minimalPrice'];
      result$data['minimalPrice'] = l$minimalPrice == null
          ? null
          : Input$DecimalFilterInput.fromJson(
              (l$minimalPrice as Map<String, dynamic>));
    }
    if (data.containsKey('attributes')) {
      final l$attributes = data['attributes'];
      result$data['attributes'] = (l$attributes as List<dynamic>?)
          ?.map(
              (e) => Input$AttributeInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('stockAvailability')) {
      final l$stockAvailability = data['stockAvailability'];
      result$data['stockAvailability'] = l$stockAvailability == null
          ? null
          : fromJson$Enum$StockAvailability((l$stockAvailability as String));
    }
    if (data.containsKey('stocks')) {
      final l$stocks = data['stocks'];
      result$data['stocks'] = l$stocks == null
          ? null
          : Input$ProductStockFilterInput.fromJson(
              (l$stocks as Map<String, dynamic>));
    }
    if (data.containsKey('giftCard')) {
      final l$giftCard = data['giftCard'];
      result$data['giftCard'] = (l$giftCard as bool?);
    }
    if (data.containsKey('hasPreorderedVariants')) {
      final l$hasPreorderedVariants = data['hasPreorderedVariants'];
      result$data['hasPreorderedVariants'] = (l$hasPreorderedVariants as bool?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$ProductWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$ProductWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$ProductWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  Input$StringFilterInput? get name =>
      (_$data['name'] as Input$StringFilterInput?);

  Input$StringFilterInput? get slug =>
      (_$data['slug'] as Input$StringFilterInput?);

  Input$GlobalIDFilterInput? get productType =>
      (_$data['productType'] as Input$GlobalIDFilterInput?);

  Input$GlobalIDFilterInput? get category =>
      (_$data['category'] as Input$GlobalIDFilterInput?);

  Input$GlobalIDFilterInput? get collection =>
      (_$data['collection'] as Input$GlobalIDFilterInput?);

  bool? get isAvailable => (_$data['isAvailable'] as bool?);

  bool? get isPublished => (_$data['isPublished'] as bool?);

  bool? get isVisibleInListing => (_$data['isVisibleInListing'] as bool?);

  String? get publishedFrom => (_$data['publishedFrom'] as String?);

  String? get availableFrom => (_$data['availableFrom'] as String?);

  bool? get hasCategory => (_$data['hasCategory'] as bool?);

  Input$DecimalFilterInput? get price =>
      (_$data['price'] as Input$DecimalFilterInput?);

  Input$DecimalFilterInput? get minimalPrice =>
      (_$data['minimalPrice'] as Input$DecimalFilterInput?);

  List<Input$AttributeInput>? get attributes =>
      (_$data['attributes'] as List<Input$AttributeInput>?);

  Enum$StockAvailability? get stockAvailability =>
      (_$data['stockAvailability'] as Enum$StockAvailability?);

  Input$ProductStockFilterInput? get stocks =>
      (_$data['stocks'] as Input$ProductStockFilterInput?);

  bool? get giftCard => (_$data['giftCard'] as bool?);

  bool? get hasPreorderedVariants => (_$data['hasPreorderedVariants'] as bool?);

  Input$DateTimeFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFilterInput?);

  List<Input$ProductWhereInput>? get AND =>
      (_$data['AND'] as List<Input$ProductWhereInput>?);

  List<Input$ProductWhereInput>? get OR =>
      (_$data['OR'] as List<Input$ProductWhereInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug?.toJson();
    }
    if (_$data.containsKey('productType')) {
      final l$productType = productType;
      result$data['productType'] = l$productType?.toJson();
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category?.toJson();
    }
    if (_$data.containsKey('collection')) {
      final l$collection = collection;
      result$data['collection'] = l$collection?.toJson();
    }
    if (_$data.containsKey('isAvailable')) {
      final l$isAvailable = isAvailable;
      result$data['isAvailable'] = l$isAvailable;
    }
    if (_$data.containsKey('isPublished')) {
      final l$isPublished = isPublished;
      result$data['isPublished'] = l$isPublished;
    }
    if (_$data.containsKey('isVisibleInListing')) {
      final l$isVisibleInListing = isVisibleInListing;
      result$data['isVisibleInListing'] = l$isVisibleInListing;
    }
    if (_$data.containsKey('publishedFrom')) {
      final l$publishedFrom = publishedFrom;
      result$data['publishedFrom'] = l$publishedFrom;
    }
    if (_$data.containsKey('availableFrom')) {
      final l$availableFrom = availableFrom;
      result$data['availableFrom'] = l$availableFrom;
    }
    if (_$data.containsKey('hasCategory')) {
      final l$hasCategory = hasCategory;
      result$data['hasCategory'] = l$hasCategory;
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] = l$price?.toJson();
    }
    if (_$data.containsKey('minimalPrice')) {
      final l$minimalPrice = minimalPrice;
      result$data['minimalPrice'] = l$minimalPrice?.toJson();
    }
    if (_$data.containsKey('attributes')) {
      final l$attributes = attributes;
      result$data['attributes'] = l$attributes?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('stockAvailability')) {
      final l$stockAvailability = stockAvailability;
      result$data['stockAvailability'] = l$stockAvailability == null
          ? null
          : toJson$Enum$StockAvailability(l$stockAvailability);
    }
    if (_$data.containsKey('stocks')) {
      final l$stocks = stocks;
      result$data['stocks'] = l$stocks?.toJson();
    }
    if (_$data.containsKey('giftCard')) {
      final l$giftCard = giftCard;
      result$data['giftCard'] = l$giftCard;
    }
    if (_$data.containsKey('hasPreorderedVariants')) {
      final l$hasPreorderedVariants = hasPreorderedVariants;
      result$data['hasPreorderedVariants'] = l$hasPreorderedVariants;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductWhereInput<Input$ProductWhereInput> get copyWith =>
      CopyWith$Input$ProductWhereInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProductWhereInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$productType = productType;
    final lOther$productType = other.productType;
    if (_$data.containsKey('productType') !=
        other._$data.containsKey('productType')) {
      return false;
    }
    if (l$productType != lOther$productType) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$collection = collection;
    final lOther$collection = other.collection;
    if (_$data.containsKey('collection') !=
        other._$data.containsKey('collection')) {
      return false;
    }
    if (l$collection != lOther$collection) {
      return false;
    }
    final l$isAvailable = isAvailable;
    final lOther$isAvailable = other.isAvailable;
    if (_$data.containsKey('isAvailable') !=
        other._$data.containsKey('isAvailable')) {
      return false;
    }
    if (l$isAvailable != lOther$isAvailable) {
      return false;
    }
    final l$isPublished = isPublished;
    final lOther$isPublished = other.isPublished;
    if (_$data.containsKey('isPublished') !=
        other._$data.containsKey('isPublished')) {
      return false;
    }
    if (l$isPublished != lOther$isPublished) {
      return false;
    }
    final l$isVisibleInListing = isVisibleInListing;
    final lOther$isVisibleInListing = other.isVisibleInListing;
    if (_$data.containsKey('isVisibleInListing') !=
        other._$data.containsKey('isVisibleInListing')) {
      return false;
    }
    if (l$isVisibleInListing != lOther$isVisibleInListing) {
      return false;
    }
    final l$publishedFrom = publishedFrom;
    final lOther$publishedFrom = other.publishedFrom;
    if (_$data.containsKey('publishedFrom') !=
        other._$data.containsKey('publishedFrom')) {
      return false;
    }
    if (l$publishedFrom != lOther$publishedFrom) {
      return false;
    }
    final l$availableFrom = availableFrom;
    final lOther$availableFrom = other.availableFrom;
    if (_$data.containsKey('availableFrom') !=
        other._$data.containsKey('availableFrom')) {
      return false;
    }
    if (l$availableFrom != lOther$availableFrom) {
      return false;
    }
    final l$hasCategory = hasCategory;
    final lOther$hasCategory = other.hasCategory;
    if (_$data.containsKey('hasCategory') !=
        other._$data.containsKey('hasCategory')) {
      return false;
    }
    if (l$hasCategory != lOther$hasCategory) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$minimalPrice = minimalPrice;
    final lOther$minimalPrice = other.minimalPrice;
    if (_$data.containsKey('minimalPrice') !=
        other._$data.containsKey('minimalPrice')) {
      return false;
    }
    if (l$minimalPrice != lOther$minimalPrice) {
      return false;
    }
    final l$attributes = attributes;
    final lOther$attributes = other.attributes;
    if (_$data.containsKey('attributes') !=
        other._$data.containsKey('attributes')) {
      return false;
    }
    if (l$attributes != null && lOther$attributes != null) {
      if (l$attributes.length != lOther$attributes.length) {
        return false;
      }
      for (int i = 0; i < l$attributes.length; i++) {
        final l$attributes$entry = l$attributes[i];
        final lOther$attributes$entry = lOther$attributes[i];
        if (l$attributes$entry != lOther$attributes$entry) {
          return false;
        }
      }
    } else if (l$attributes != lOther$attributes) {
      return false;
    }
    final l$stockAvailability = stockAvailability;
    final lOther$stockAvailability = other.stockAvailability;
    if (_$data.containsKey('stockAvailability') !=
        other._$data.containsKey('stockAvailability')) {
      return false;
    }
    if (l$stockAvailability != lOther$stockAvailability) {
      return false;
    }
    final l$stocks = stocks;
    final lOther$stocks = other.stocks;
    if (_$data.containsKey('stocks') != other._$data.containsKey('stocks')) {
      return false;
    }
    if (l$stocks != lOther$stocks) {
      return false;
    }
    final l$giftCard = giftCard;
    final lOther$giftCard = other.giftCard;
    if (_$data.containsKey('giftCard') !=
        other._$data.containsKey('giftCard')) {
      return false;
    }
    if (l$giftCard != lOther$giftCard) {
      return false;
    }
    final l$hasPreorderedVariants = hasPreorderedVariants;
    final lOther$hasPreorderedVariants = other.hasPreorderedVariants;
    if (_$data.containsKey('hasPreorderedVariants') !=
        other._$data.containsKey('hasPreorderedVariants')) {
      return false;
    }
    if (l$hasPreorderedVariants != lOther$hasPreorderedVariants) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$metadata = metadata;
    final l$ids = ids;
    final l$name = name;
    final l$slug = slug;
    final l$productType = productType;
    final l$category = category;
    final l$collection = collection;
    final l$isAvailable = isAvailable;
    final l$isPublished = isPublished;
    final l$isVisibleInListing = isVisibleInListing;
    final l$publishedFrom = publishedFrom;
    final l$availableFrom = availableFrom;
    final l$hasCategory = hasCategory;
    final l$price = price;
    final l$minimalPrice = minimalPrice;
    final l$attributes = attributes;
    final l$stockAvailability = stockAvailability;
    final l$stocks = stocks;
    final l$giftCard = giftCard;
    final l$hasPreorderedVariants = hasPreorderedVariants;
    final l$updatedAt = updatedAt;
    final l$AND = AND;
    final l$OR = OR;
    return Object.hashAll([
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('productType') ? l$productType : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('collection') ? l$collection : const {},
      _$data.containsKey('isAvailable') ? l$isAvailable : const {},
      _$data.containsKey('isPublished') ? l$isPublished : const {},
      _$data.containsKey('isVisibleInListing')
          ? l$isVisibleInListing
          : const {},
      _$data.containsKey('publishedFrom') ? l$publishedFrom : const {},
      _$data.containsKey('availableFrom') ? l$availableFrom : const {},
      _$data.containsKey('hasCategory') ? l$hasCategory : const {},
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('minimalPrice') ? l$minimalPrice : const {},
      _$data.containsKey('attributes')
          ? l$attributes == null
              ? null
              : Object.hashAll(l$attributes.map((v) => v))
          : const {},
      _$data.containsKey('stockAvailability') ? l$stockAvailability : const {},
      _$data.containsKey('stocks') ? l$stocks : const {},
      _$data.containsKey('giftCard') ? l$giftCard : const {},
      _$data.containsKey('hasPreorderedVariants')
          ? l$hasPreorderedVariants
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductWhereInput<TRes> {
  factory CopyWith$Input$ProductWhereInput(
    Input$ProductWhereInput instance,
    TRes Function(Input$ProductWhereInput) then,
  ) = _CopyWithImpl$Input$ProductWhereInput;

  factory CopyWith$Input$ProductWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductWhereInput;

  TRes call({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    Input$StringFilterInput? name,
    Input$StringFilterInput? slug,
    Input$GlobalIDFilterInput? productType,
    Input$GlobalIDFilterInput? category,
    Input$GlobalIDFilterInput? collection,
    bool? isAvailable,
    bool? isPublished,
    bool? isVisibleInListing,
    String? publishedFrom,
    String? availableFrom,
    bool? hasCategory,
    Input$DecimalFilterInput? price,
    Input$DecimalFilterInput? minimalPrice,
    List<Input$AttributeInput>? attributes,
    Enum$StockAvailability? stockAvailability,
    Input$ProductStockFilterInput? stocks,
    bool? giftCard,
    bool? hasPreorderedVariants,
    Input$DateTimeFilterInput? updatedAt,
    List<Input$ProductWhereInput>? AND,
    List<Input$ProductWhereInput>? OR,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
  CopyWith$Input$StringFilterInput<TRes> get name;
  CopyWith$Input$StringFilterInput<TRes> get slug;
  CopyWith$Input$GlobalIDFilterInput<TRes> get productType;
  CopyWith$Input$GlobalIDFilterInput<TRes> get category;
  CopyWith$Input$GlobalIDFilterInput<TRes> get collection;
  CopyWith$Input$DecimalFilterInput<TRes> get price;
  CopyWith$Input$DecimalFilterInput<TRes> get minimalPrice;
  TRes attributes(
      Iterable<Input$AttributeInput>? Function(
              Iterable<CopyWith$Input$AttributeInput<Input$AttributeInput>>?)
          _fn);
  CopyWith$Input$ProductStockFilterInput<TRes> get stocks;
  CopyWith$Input$DateTimeFilterInput<TRes> get updatedAt;
  TRes AND(
      Iterable<Input$ProductWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductWhereInput<Input$ProductWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$ProductWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductWhereInput<Input$ProductWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductWhereInput<TRes>
    implements CopyWith$Input$ProductWhereInput<TRes> {
  _CopyWithImpl$Input$ProductWhereInput(
    this._instance,
    this._then,
  );

  final Input$ProductWhereInput _instance;

  final TRes Function(Input$ProductWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? metadata = _undefined,
    Object? ids = _undefined,
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? productType = _undefined,
    Object? category = _undefined,
    Object? collection = _undefined,
    Object? isAvailable = _undefined,
    Object? isPublished = _undefined,
    Object? isVisibleInListing = _undefined,
    Object? publishedFrom = _undefined,
    Object? availableFrom = _undefined,
    Object? hasCategory = _undefined,
    Object? price = _undefined,
    Object? minimalPrice = _undefined,
    Object? attributes = _undefined,
    Object? stockAvailability = _undefined,
    Object? stocks = _undefined,
    Object? giftCard = _undefined,
    Object? hasPreorderedVariants = _undefined,
    Object? updatedAt = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
  }) =>
      _then(Input$ProductWhereInput._({
        ..._instance._$data,
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (name != _undefined) 'name': (name as Input$StringFilterInput?),
        if (slug != _undefined) 'slug': (slug as Input$StringFilterInput?),
        if (productType != _undefined)
          'productType': (productType as Input$GlobalIDFilterInput?),
        if (category != _undefined)
          'category': (category as Input$GlobalIDFilterInput?),
        if (collection != _undefined)
          'collection': (collection as Input$GlobalIDFilterInput?),
        if (isAvailable != _undefined) 'isAvailable': (isAvailable as bool?),
        if (isPublished != _undefined) 'isPublished': (isPublished as bool?),
        if (isVisibleInListing != _undefined)
          'isVisibleInListing': (isVisibleInListing as bool?),
        if (publishedFrom != _undefined)
          'publishedFrom': (publishedFrom as String?),
        if (availableFrom != _undefined)
          'availableFrom': (availableFrom as String?),
        if (hasCategory != _undefined) 'hasCategory': (hasCategory as bool?),
        if (price != _undefined) 'price': (price as Input$DecimalFilterInput?),
        if (minimalPrice != _undefined)
          'minimalPrice': (minimalPrice as Input$DecimalFilterInput?),
        if (attributes != _undefined)
          'attributes': (attributes as List<Input$AttributeInput>?),
        if (stockAvailability != _undefined)
          'stockAvailability': (stockAvailability as Enum$StockAvailability?),
        if (stocks != _undefined)
          'stocks': (stocks as Input$ProductStockFilterInput?),
        if (giftCard != _undefined) 'giftCard': (giftCard as bool?),
        if (hasPreorderedVariants != _undefined)
          'hasPreorderedVariants': (hasPreorderedVariants as bool?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFilterInput?),
        if (AND != _undefined) 'AND': (AND as List<Input$ProductWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$ProductWhereInput>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$StringFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringFilterInput(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilterInput<TRes> get slug {
    final local$slug = _instance.slug;
    return local$slug == null
        ? CopyWith$Input$StringFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringFilterInput(local$slug, (e) => call(slug: e));
  }

  CopyWith$Input$GlobalIDFilterInput<TRes> get productType {
    final local$productType = _instance.productType;
    return local$productType == null
        ? CopyWith$Input$GlobalIDFilterInput.stub(_then(_instance))
        : CopyWith$Input$GlobalIDFilterInput(
            local$productType, (e) => call(productType: e));
  }

  CopyWith$Input$GlobalIDFilterInput<TRes> get category {
    final local$category = _instance.category;
    return local$category == null
        ? CopyWith$Input$GlobalIDFilterInput.stub(_then(_instance))
        : CopyWith$Input$GlobalIDFilterInput(
            local$category, (e) => call(category: e));
  }

  CopyWith$Input$GlobalIDFilterInput<TRes> get collection {
    final local$collection = _instance.collection;
    return local$collection == null
        ? CopyWith$Input$GlobalIDFilterInput.stub(_then(_instance))
        : CopyWith$Input$GlobalIDFilterInput(
            local$collection, (e) => call(collection: e));
  }

  CopyWith$Input$DecimalFilterInput<TRes> get price {
    final local$price = _instance.price;
    return local$price == null
        ? CopyWith$Input$DecimalFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalFilterInput(local$price, (e) => call(price: e));
  }

  CopyWith$Input$DecimalFilterInput<TRes> get minimalPrice {
    final local$minimalPrice = _instance.minimalPrice;
    return local$minimalPrice == null
        ? CopyWith$Input$DecimalFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalFilterInput(
            local$minimalPrice, (e) => call(minimalPrice: e));
  }

  TRes attributes(
          Iterable<Input$AttributeInput>? Function(
                  Iterable<
                      CopyWith$Input$AttributeInput<Input$AttributeInput>>?)
              _fn) =>
      call(
          attributes: _fn(
              _instance.attributes?.map((e) => CopyWith$Input$AttributeInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$ProductStockFilterInput<TRes> get stocks {
    final local$stocks = _instance.stocks;
    return local$stocks == null
        ? CopyWith$Input$ProductStockFilterInput.stub(_then(_instance))
        : CopyWith$Input$ProductStockFilterInput(
            local$stocks, (e) => call(stocks: e));
  }

  CopyWith$Input$DateTimeFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilterInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  TRes AND(
          Iterable<Input$ProductWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductWhereInput<
                          Input$ProductWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$ProductWhereInput(
                e,
                (i) => i,
              )))?.toList());

  TRes OR(
          Iterable<Input$ProductWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductWhereInput<
                          Input$ProductWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$ProductWhereInput(
                e,
                (i) => i,
              )))?.toList());
}

class _CopyWithStubImpl$Input$ProductWhereInput<TRes>
    implements CopyWith$Input$ProductWhereInput<TRes> {
  _CopyWithStubImpl$Input$ProductWhereInput(this._res);

  TRes _res;

  call({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    Input$StringFilterInput? name,
    Input$StringFilterInput? slug,
    Input$GlobalIDFilterInput? productType,
    Input$GlobalIDFilterInput? category,
    Input$GlobalIDFilterInput? collection,
    bool? isAvailable,
    bool? isPublished,
    bool? isVisibleInListing,
    String? publishedFrom,
    String? availableFrom,
    bool? hasCategory,
    Input$DecimalFilterInput? price,
    Input$DecimalFilterInput? minimalPrice,
    List<Input$AttributeInput>? attributes,
    Enum$StockAvailability? stockAvailability,
    Input$ProductStockFilterInput? stocks,
    bool? giftCard,
    bool? hasPreorderedVariants,
    Input$DateTimeFilterInput? updatedAt,
    List<Input$ProductWhereInput>? AND,
    List<Input$ProductWhereInput>? OR,
  }) =>
      _res;

  metadata(_fn) => _res;

  CopyWith$Input$StringFilterInput<TRes> get name =>
      CopyWith$Input$StringFilterInput.stub(_res);

  CopyWith$Input$StringFilterInput<TRes> get slug =>
      CopyWith$Input$StringFilterInput.stub(_res);

  CopyWith$Input$GlobalIDFilterInput<TRes> get productType =>
      CopyWith$Input$GlobalIDFilterInput.stub(_res);

  CopyWith$Input$GlobalIDFilterInput<TRes> get category =>
      CopyWith$Input$GlobalIDFilterInput.stub(_res);

  CopyWith$Input$GlobalIDFilterInput<TRes> get collection =>
      CopyWith$Input$GlobalIDFilterInput.stub(_res);

  CopyWith$Input$DecimalFilterInput<TRes> get price =>
      CopyWith$Input$DecimalFilterInput.stub(_res);

  CopyWith$Input$DecimalFilterInput<TRes> get minimalPrice =>
      CopyWith$Input$DecimalFilterInput.stub(_res);

  attributes(_fn) => _res;

  CopyWith$Input$ProductStockFilterInput<TRes> get stocks =>
      CopyWith$Input$ProductStockFilterInput.stub(_res);

  CopyWith$Input$DateTimeFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFilterInput.stub(_res);

  AND(_fn) => _res;

  OR(_fn) => _res;
}

class Input$PromotionCreateInput {
  factory Input$PromotionCreateInput({
    String? description,
    String? startDate,
    String? endDate,
    required String name,
    required Enum$PromotionTypeEnum type,
    List<Input$PromotionRuleInput>? rules,
  }) =>
      Input$PromotionCreateInput._({
        if (description != null) r'description': description,
        if (startDate != null) r'startDate': startDate,
        if (endDate != null) r'endDate': endDate,
        r'name': name,
        r'type': type,
        if (rules != null) r'rules': rules,
      });

  Input$PromotionCreateInput._(this._$data);

  factory Input$PromotionCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('startDate')) {
      final l$startDate = data['startDate'];
      result$data['startDate'] = (l$startDate as String?);
    }
    if (data.containsKey('endDate')) {
      final l$endDate = data['endDate'];
      result$data['endDate'] = (l$endDate as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$type = data['type'];
    result$data['type'] = fromJson$Enum$PromotionTypeEnum((l$type as String));
    if (data.containsKey('rules')) {
      final l$rules = data['rules'];
      result$data['rules'] = (l$rules as List<dynamic>?)
          ?.map((e) =>
              Input$PromotionRuleInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$PromotionCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get description => (_$data['description'] as String?);

  String? get startDate => (_$data['startDate'] as String?);

  String? get endDate => (_$data['endDate'] as String?);

  String get name => (_$data['name'] as String);

  Enum$PromotionTypeEnum get type => (_$data['type'] as Enum$PromotionTypeEnum);

  List<Input$PromotionRuleInput>? get rules =>
      (_$data['rules'] as List<Input$PromotionRuleInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('startDate')) {
      final l$startDate = startDate;
      result$data['startDate'] = l$startDate;
    }
    if (_$data.containsKey('endDate')) {
      final l$endDate = endDate;
      result$data['endDate'] = l$endDate;
    }
    final l$name = name;
    result$data['name'] = l$name;
    final l$type = type;
    result$data['type'] = toJson$Enum$PromotionTypeEnum(l$type);
    if (_$data.containsKey('rules')) {
      final l$rules = rules;
      result$data['rules'] = l$rules?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$PromotionCreateInput<Input$PromotionCreateInput>
      get copyWith => CopyWith$Input$PromotionCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PromotionCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (_$data.containsKey('startDate') !=
        other._$data.containsKey('startDate')) {
      return false;
    }
    if (l$startDate != lOther$startDate) {
      return false;
    }
    final l$endDate = endDate;
    final lOther$endDate = other.endDate;
    if (_$data.containsKey('endDate') != other._$data.containsKey('endDate')) {
      return false;
    }
    if (l$endDate != lOther$endDate) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) {
      return false;
    }
    final l$rules = rules;
    final lOther$rules = other.rules;
    if (_$data.containsKey('rules') != other._$data.containsKey('rules')) {
      return false;
    }
    if (l$rules != null && lOther$rules != null) {
      if (l$rules.length != lOther$rules.length) {
        return false;
      }
      for (int i = 0; i < l$rules.length; i++) {
        final l$rules$entry = l$rules[i];
        final lOther$rules$entry = lOther$rules[i];
        if (l$rules$entry != lOther$rules$entry) {
          return false;
        }
      }
    } else if (l$rules != lOther$rules) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$description = description;
    final l$startDate = startDate;
    final l$endDate = endDate;
    final l$name = name;
    final l$type = type;
    final l$rules = rules;
    return Object.hashAll([
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('startDate') ? l$startDate : const {},
      _$data.containsKey('endDate') ? l$endDate : const {},
      l$name,
      l$type,
      _$data.containsKey('rules')
          ? l$rules == null
              ? null
              : Object.hashAll(l$rules.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromotionCreateInput<TRes> {
  factory CopyWith$Input$PromotionCreateInput(
    Input$PromotionCreateInput instance,
    TRes Function(Input$PromotionCreateInput) then,
  ) = _CopyWithImpl$Input$PromotionCreateInput;

  factory CopyWith$Input$PromotionCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromotionCreateInput;

  TRes call({
    String? description,
    String? startDate,
    String? endDate,
    String? name,
    Enum$PromotionTypeEnum? type,
    List<Input$PromotionRuleInput>? rules,
  });
  TRes rules(
      Iterable<Input$PromotionRuleInput>? Function(
              Iterable<
                  CopyWith$Input$PromotionRuleInput<Input$PromotionRuleInput>>?)
          _fn);
}

class _CopyWithImpl$Input$PromotionCreateInput<TRes>
    implements CopyWith$Input$PromotionCreateInput<TRes> {
  _CopyWithImpl$Input$PromotionCreateInput(
    this._instance,
    this._then,
  );

  final Input$PromotionCreateInput _instance;

  final TRes Function(Input$PromotionCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? description = _undefined,
    Object? startDate = _undefined,
    Object? endDate = _undefined,
    Object? name = _undefined,
    Object? type = _undefined,
    Object? rules = _undefined,
  }) =>
      _then(Input$PromotionCreateInput._({
        ..._instance._$data,
        if (description != _undefined) 'description': (description as String?),
        if (startDate != _undefined) 'startDate': (startDate as String?),
        if (endDate != _undefined) 'endDate': (endDate as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (type != _undefined && type != null)
          'type': (type as Enum$PromotionTypeEnum),
        if (rules != _undefined)
          'rules': (rules as List<Input$PromotionRuleInput>?),
      }));

  TRes rules(
          Iterable<Input$PromotionRuleInput>? Function(
                  Iterable<
                      CopyWith$Input$PromotionRuleInput<
                          Input$PromotionRuleInput>>?)
              _fn) =>
      call(
          rules:
              _fn(_instance.rules?.map((e) => CopyWith$Input$PromotionRuleInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$PromotionCreateInput<TRes>
    implements CopyWith$Input$PromotionCreateInput<TRes> {
  _CopyWithStubImpl$Input$PromotionCreateInput(this._res);

  TRes _res;

  call({
    String? description,
    String? startDate,
    String? endDate,
    String? name,
    Enum$PromotionTypeEnum? type,
    List<Input$PromotionRuleInput>? rules,
  }) =>
      _res;

  rules(_fn) => _res;
}

class Input$PromotionRuleCreateInput {
  factory Input$PromotionRuleCreateInput({
    String? name,
    String? description,
    Input$CataloguePredicateInput? cataloguePredicate,
    Input$OrderPredicateInput? orderPredicate,
    Enum$RewardValueTypeEnum? rewardValueType,
    String? rewardValue,
    Enum$RewardTypeEnum? rewardType,
    List<String>? channels,
    List<String>? gifts,
    required String promotion,
  }) =>
      Input$PromotionRuleCreateInput._({
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (cataloguePredicate != null)
          r'cataloguePredicate': cataloguePredicate,
        if (orderPredicate != null) r'orderPredicate': orderPredicate,
        if (rewardValueType != null) r'rewardValueType': rewardValueType,
        if (rewardValue != null) r'rewardValue': rewardValue,
        if (rewardType != null) r'rewardType': rewardType,
        if (channels != null) r'channels': channels,
        if (gifts != null) r'gifts': gifts,
        r'promotion': promotion,
      });

  Input$PromotionRuleCreateInput._(this._$data);

  factory Input$PromotionRuleCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('cataloguePredicate')) {
      final l$cataloguePredicate = data['cataloguePredicate'];
      result$data['cataloguePredicate'] = l$cataloguePredicate == null
          ? null
          : Input$CataloguePredicateInput.fromJson(
              (l$cataloguePredicate as Map<String, dynamic>));
    }
    if (data.containsKey('orderPredicate')) {
      final l$orderPredicate = data['orderPredicate'];
      result$data['orderPredicate'] = l$orderPredicate == null
          ? null
          : Input$OrderPredicateInput.fromJson(
              (l$orderPredicate as Map<String, dynamic>));
    }
    if (data.containsKey('rewardValueType')) {
      final l$rewardValueType = data['rewardValueType'];
      result$data['rewardValueType'] = l$rewardValueType == null
          ? null
          : fromJson$Enum$RewardValueTypeEnum((l$rewardValueType as String));
    }
    if (data.containsKey('rewardValue')) {
      final l$rewardValue = data['rewardValue'];
      result$data['rewardValue'] = (l$rewardValue as String?);
    }
    if (data.containsKey('rewardType')) {
      final l$rewardType = data['rewardType'];
      result$data['rewardType'] = l$rewardType == null
          ? null
          : fromJson$Enum$RewardTypeEnum((l$rewardType as String));
    }
    if (data.containsKey('channels')) {
      final l$channels = data['channels'];
      result$data['channels'] =
          (l$channels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('gifts')) {
      final l$gifts = data['gifts'];
      result$data['gifts'] =
          (l$gifts as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    final l$promotion = data['promotion'];
    result$data['promotion'] = (l$promotion as String);
    return Input$PromotionRuleCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  Input$CataloguePredicateInput? get cataloguePredicate =>
      (_$data['cataloguePredicate'] as Input$CataloguePredicateInput?);

  Input$OrderPredicateInput? get orderPredicate =>
      (_$data['orderPredicate'] as Input$OrderPredicateInput?);

  Enum$RewardValueTypeEnum? get rewardValueType =>
      (_$data['rewardValueType'] as Enum$RewardValueTypeEnum?);

  String? get rewardValue => (_$data['rewardValue'] as String?);

  Enum$RewardTypeEnum? get rewardType =>
      (_$data['rewardType'] as Enum$RewardTypeEnum?);

  List<String>? get channels => (_$data['channels'] as List<String>?);

  List<String>? get gifts => (_$data['gifts'] as List<String>?);

  String get promotion => (_$data['promotion'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('cataloguePredicate')) {
      final l$cataloguePredicate = cataloguePredicate;
      result$data['cataloguePredicate'] = l$cataloguePredicate?.toJson();
    }
    if (_$data.containsKey('orderPredicate')) {
      final l$orderPredicate = orderPredicate;
      result$data['orderPredicate'] = l$orderPredicate?.toJson();
    }
    if (_$data.containsKey('rewardValueType')) {
      final l$rewardValueType = rewardValueType;
      result$data['rewardValueType'] = l$rewardValueType == null
          ? null
          : toJson$Enum$RewardValueTypeEnum(l$rewardValueType);
    }
    if (_$data.containsKey('rewardValue')) {
      final l$rewardValue = rewardValue;
      result$data['rewardValue'] = l$rewardValue;
    }
    if (_$data.containsKey('rewardType')) {
      final l$rewardType = rewardType;
      result$data['rewardType'] = l$rewardType == null
          ? null
          : toJson$Enum$RewardTypeEnum(l$rewardType);
    }
    if (_$data.containsKey('channels')) {
      final l$channels = channels;
      result$data['channels'] = l$channels?.map((e) => e).toList();
    }
    if (_$data.containsKey('gifts')) {
      final l$gifts = gifts;
      result$data['gifts'] = l$gifts?.map((e) => e).toList();
    }
    final l$promotion = promotion;
    result$data['promotion'] = l$promotion;
    return result$data;
  }

  CopyWith$Input$PromotionRuleCreateInput<Input$PromotionRuleCreateInput>
      get copyWith => CopyWith$Input$PromotionRuleCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PromotionRuleCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$cataloguePredicate = cataloguePredicate;
    final lOther$cataloguePredicate = other.cataloguePredicate;
    if (_$data.containsKey('cataloguePredicate') !=
        other._$data.containsKey('cataloguePredicate')) {
      return false;
    }
    if (l$cataloguePredicate != lOther$cataloguePredicate) {
      return false;
    }
    final l$orderPredicate = orderPredicate;
    final lOther$orderPredicate = other.orderPredicate;
    if (_$data.containsKey('orderPredicate') !=
        other._$data.containsKey('orderPredicate')) {
      return false;
    }
    if (l$orderPredicate != lOther$orderPredicate) {
      return false;
    }
    final l$rewardValueType = rewardValueType;
    final lOther$rewardValueType = other.rewardValueType;
    if (_$data.containsKey('rewardValueType') !=
        other._$data.containsKey('rewardValueType')) {
      return false;
    }
    if (l$rewardValueType != lOther$rewardValueType) {
      return false;
    }
    final l$rewardValue = rewardValue;
    final lOther$rewardValue = other.rewardValue;
    if (_$data.containsKey('rewardValue') !=
        other._$data.containsKey('rewardValue')) {
      return false;
    }
    if (l$rewardValue != lOther$rewardValue) {
      return false;
    }
    final l$rewardType = rewardType;
    final lOther$rewardType = other.rewardType;
    if (_$data.containsKey('rewardType') !=
        other._$data.containsKey('rewardType')) {
      return false;
    }
    if (l$rewardType != lOther$rewardType) {
      return false;
    }
    final l$channels = channels;
    final lOther$channels = other.channels;
    if (_$data.containsKey('channels') !=
        other._$data.containsKey('channels')) {
      return false;
    }
    if (l$channels != null && lOther$channels != null) {
      if (l$channels.length != lOther$channels.length) {
        return false;
      }
      for (int i = 0; i < l$channels.length; i++) {
        final l$channels$entry = l$channels[i];
        final lOther$channels$entry = lOther$channels[i];
        if (l$channels$entry != lOther$channels$entry) {
          return false;
        }
      }
    } else if (l$channels != lOther$channels) {
      return false;
    }
    final l$gifts = gifts;
    final lOther$gifts = other.gifts;
    if (_$data.containsKey('gifts') != other._$data.containsKey('gifts')) {
      return false;
    }
    if (l$gifts != null && lOther$gifts != null) {
      if (l$gifts.length != lOther$gifts.length) {
        return false;
      }
      for (int i = 0; i < l$gifts.length; i++) {
        final l$gifts$entry = l$gifts[i];
        final lOther$gifts$entry = lOther$gifts[i];
        if (l$gifts$entry != lOther$gifts$entry) {
          return false;
        }
      }
    } else if (l$gifts != lOther$gifts) {
      return false;
    }
    final l$promotion = promotion;
    final lOther$promotion = other.promotion;
    if (l$promotion != lOther$promotion) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    final l$cataloguePredicate = cataloguePredicate;
    final l$orderPredicate = orderPredicate;
    final l$rewardValueType = rewardValueType;
    final l$rewardValue = rewardValue;
    final l$rewardType = rewardType;
    final l$channels = channels;
    final l$gifts = gifts;
    final l$promotion = promotion;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('cataloguePredicate')
          ? l$cataloguePredicate
          : const {},
      _$data.containsKey('orderPredicate') ? l$orderPredicate : const {},
      _$data.containsKey('rewardValueType') ? l$rewardValueType : const {},
      _$data.containsKey('rewardValue') ? l$rewardValue : const {},
      _$data.containsKey('rewardType') ? l$rewardType : const {},
      _$data.containsKey('channels')
          ? l$channels == null
              ? null
              : Object.hashAll(l$channels.map((v) => v))
          : const {},
      _$data.containsKey('gifts')
          ? l$gifts == null
              ? null
              : Object.hashAll(l$gifts.map((v) => v))
          : const {},
      l$promotion,
    ]);
  }
}

abstract class CopyWith$Input$PromotionRuleCreateInput<TRes> {
  factory CopyWith$Input$PromotionRuleCreateInput(
    Input$PromotionRuleCreateInput instance,
    TRes Function(Input$PromotionRuleCreateInput) then,
  ) = _CopyWithImpl$Input$PromotionRuleCreateInput;

  factory CopyWith$Input$PromotionRuleCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromotionRuleCreateInput;

  TRes call({
    String? name,
    String? description,
    Input$CataloguePredicateInput? cataloguePredicate,
    Input$OrderPredicateInput? orderPredicate,
    Enum$RewardValueTypeEnum? rewardValueType,
    String? rewardValue,
    Enum$RewardTypeEnum? rewardType,
    List<String>? channels,
    List<String>? gifts,
    String? promotion,
  });
  CopyWith$Input$CataloguePredicateInput<TRes> get cataloguePredicate;
  CopyWith$Input$OrderPredicateInput<TRes> get orderPredicate;
}

class _CopyWithImpl$Input$PromotionRuleCreateInput<TRes>
    implements CopyWith$Input$PromotionRuleCreateInput<TRes> {
  _CopyWithImpl$Input$PromotionRuleCreateInput(
    this._instance,
    this._then,
  );

  final Input$PromotionRuleCreateInput _instance;

  final TRes Function(Input$PromotionRuleCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
    Object? cataloguePredicate = _undefined,
    Object? orderPredicate = _undefined,
    Object? rewardValueType = _undefined,
    Object? rewardValue = _undefined,
    Object? rewardType = _undefined,
    Object? channels = _undefined,
    Object? gifts = _undefined,
    Object? promotion = _undefined,
  }) =>
      _then(Input$PromotionRuleCreateInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (cataloguePredicate != _undefined)
          'cataloguePredicate':
              (cataloguePredicate as Input$CataloguePredicateInput?),
        if (orderPredicate != _undefined)
          'orderPredicate': (orderPredicate as Input$OrderPredicateInput?),
        if (rewardValueType != _undefined)
          'rewardValueType': (rewardValueType as Enum$RewardValueTypeEnum?),
        if (rewardValue != _undefined) 'rewardValue': (rewardValue as String?),
        if (rewardType != _undefined)
          'rewardType': (rewardType as Enum$RewardTypeEnum?),
        if (channels != _undefined) 'channels': (channels as List<String>?),
        if (gifts != _undefined) 'gifts': (gifts as List<String>?),
        if (promotion != _undefined && promotion != null)
          'promotion': (promotion as String),
      }));

  CopyWith$Input$CataloguePredicateInput<TRes> get cataloguePredicate {
    final local$cataloguePredicate = _instance.cataloguePredicate;
    return local$cataloguePredicate == null
        ? CopyWith$Input$CataloguePredicateInput.stub(_then(_instance))
        : CopyWith$Input$CataloguePredicateInput(
            local$cataloguePredicate, (e) => call(cataloguePredicate: e));
  }

  CopyWith$Input$OrderPredicateInput<TRes> get orderPredicate {
    final local$orderPredicate = _instance.orderPredicate;
    return local$orderPredicate == null
        ? CopyWith$Input$OrderPredicateInput.stub(_then(_instance))
        : CopyWith$Input$OrderPredicateInput(
            local$orderPredicate, (e) => call(orderPredicate: e));
  }
}

class _CopyWithStubImpl$Input$PromotionRuleCreateInput<TRes>
    implements CopyWith$Input$PromotionRuleCreateInput<TRes> {
  _CopyWithStubImpl$Input$PromotionRuleCreateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? description,
    Input$CataloguePredicateInput? cataloguePredicate,
    Input$OrderPredicateInput? orderPredicate,
    Enum$RewardValueTypeEnum? rewardValueType,
    String? rewardValue,
    Enum$RewardTypeEnum? rewardType,
    List<String>? channels,
    List<String>? gifts,
    String? promotion,
  }) =>
      _res;

  CopyWith$Input$CataloguePredicateInput<TRes> get cataloguePredicate =>
      CopyWith$Input$CataloguePredicateInput.stub(_res);

  CopyWith$Input$OrderPredicateInput<TRes> get orderPredicate =>
      CopyWith$Input$OrderPredicateInput.stub(_res);
}

class Input$PromotionRuleInput {
  factory Input$PromotionRuleInput({
    String? name,
    String? description,
    Input$CataloguePredicateInput? cataloguePredicate,
    Input$OrderPredicateInput? orderPredicate,
    Enum$RewardValueTypeEnum? rewardValueType,
    String? rewardValue,
    Enum$RewardTypeEnum? rewardType,
    List<String>? channels,
    List<String>? gifts,
  }) =>
      Input$PromotionRuleInput._({
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (cataloguePredicate != null)
          r'cataloguePredicate': cataloguePredicate,
        if (orderPredicate != null) r'orderPredicate': orderPredicate,
        if (rewardValueType != null) r'rewardValueType': rewardValueType,
        if (rewardValue != null) r'rewardValue': rewardValue,
        if (rewardType != null) r'rewardType': rewardType,
        if (channels != null) r'channels': channels,
        if (gifts != null) r'gifts': gifts,
      });

  Input$PromotionRuleInput._(this._$data);

  factory Input$PromotionRuleInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('cataloguePredicate')) {
      final l$cataloguePredicate = data['cataloguePredicate'];
      result$data['cataloguePredicate'] = l$cataloguePredicate == null
          ? null
          : Input$CataloguePredicateInput.fromJson(
              (l$cataloguePredicate as Map<String, dynamic>));
    }
    if (data.containsKey('orderPredicate')) {
      final l$orderPredicate = data['orderPredicate'];
      result$data['orderPredicate'] = l$orderPredicate == null
          ? null
          : Input$OrderPredicateInput.fromJson(
              (l$orderPredicate as Map<String, dynamic>));
    }
    if (data.containsKey('rewardValueType')) {
      final l$rewardValueType = data['rewardValueType'];
      result$data['rewardValueType'] = l$rewardValueType == null
          ? null
          : fromJson$Enum$RewardValueTypeEnum((l$rewardValueType as String));
    }
    if (data.containsKey('rewardValue')) {
      final l$rewardValue = data['rewardValue'];
      result$data['rewardValue'] = (l$rewardValue as String?);
    }
    if (data.containsKey('rewardType')) {
      final l$rewardType = data['rewardType'];
      result$data['rewardType'] = l$rewardType == null
          ? null
          : fromJson$Enum$RewardTypeEnum((l$rewardType as String));
    }
    if (data.containsKey('channels')) {
      final l$channels = data['channels'];
      result$data['channels'] =
          (l$channels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('gifts')) {
      final l$gifts = data['gifts'];
      result$data['gifts'] =
          (l$gifts as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$PromotionRuleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  Input$CataloguePredicateInput? get cataloguePredicate =>
      (_$data['cataloguePredicate'] as Input$CataloguePredicateInput?);

  Input$OrderPredicateInput? get orderPredicate =>
      (_$data['orderPredicate'] as Input$OrderPredicateInput?);

  Enum$RewardValueTypeEnum? get rewardValueType =>
      (_$data['rewardValueType'] as Enum$RewardValueTypeEnum?);

  String? get rewardValue => (_$data['rewardValue'] as String?);

  Enum$RewardTypeEnum? get rewardType =>
      (_$data['rewardType'] as Enum$RewardTypeEnum?);

  List<String>? get channels => (_$data['channels'] as List<String>?);

  List<String>? get gifts => (_$data['gifts'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('cataloguePredicate')) {
      final l$cataloguePredicate = cataloguePredicate;
      result$data['cataloguePredicate'] = l$cataloguePredicate?.toJson();
    }
    if (_$data.containsKey('orderPredicate')) {
      final l$orderPredicate = orderPredicate;
      result$data['orderPredicate'] = l$orderPredicate?.toJson();
    }
    if (_$data.containsKey('rewardValueType')) {
      final l$rewardValueType = rewardValueType;
      result$data['rewardValueType'] = l$rewardValueType == null
          ? null
          : toJson$Enum$RewardValueTypeEnum(l$rewardValueType);
    }
    if (_$data.containsKey('rewardValue')) {
      final l$rewardValue = rewardValue;
      result$data['rewardValue'] = l$rewardValue;
    }
    if (_$data.containsKey('rewardType')) {
      final l$rewardType = rewardType;
      result$data['rewardType'] = l$rewardType == null
          ? null
          : toJson$Enum$RewardTypeEnum(l$rewardType);
    }
    if (_$data.containsKey('channels')) {
      final l$channels = channels;
      result$data['channels'] = l$channels?.map((e) => e).toList();
    }
    if (_$data.containsKey('gifts')) {
      final l$gifts = gifts;
      result$data['gifts'] = l$gifts?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$PromotionRuleInput<Input$PromotionRuleInput> get copyWith =>
      CopyWith$Input$PromotionRuleInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PromotionRuleInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$cataloguePredicate = cataloguePredicate;
    final lOther$cataloguePredicate = other.cataloguePredicate;
    if (_$data.containsKey('cataloguePredicate') !=
        other._$data.containsKey('cataloguePredicate')) {
      return false;
    }
    if (l$cataloguePredicate != lOther$cataloguePredicate) {
      return false;
    }
    final l$orderPredicate = orderPredicate;
    final lOther$orderPredicate = other.orderPredicate;
    if (_$data.containsKey('orderPredicate') !=
        other._$data.containsKey('orderPredicate')) {
      return false;
    }
    if (l$orderPredicate != lOther$orderPredicate) {
      return false;
    }
    final l$rewardValueType = rewardValueType;
    final lOther$rewardValueType = other.rewardValueType;
    if (_$data.containsKey('rewardValueType') !=
        other._$data.containsKey('rewardValueType')) {
      return false;
    }
    if (l$rewardValueType != lOther$rewardValueType) {
      return false;
    }
    final l$rewardValue = rewardValue;
    final lOther$rewardValue = other.rewardValue;
    if (_$data.containsKey('rewardValue') !=
        other._$data.containsKey('rewardValue')) {
      return false;
    }
    if (l$rewardValue != lOther$rewardValue) {
      return false;
    }
    final l$rewardType = rewardType;
    final lOther$rewardType = other.rewardType;
    if (_$data.containsKey('rewardType') !=
        other._$data.containsKey('rewardType')) {
      return false;
    }
    if (l$rewardType != lOther$rewardType) {
      return false;
    }
    final l$channels = channels;
    final lOther$channels = other.channels;
    if (_$data.containsKey('channels') !=
        other._$data.containsKey('channels')) {
      return false;
    }
    if (l$channels != null && lOther$channels != null) {
      if (l$channels.length != lOther$channels.length) {
        return false;
      }
      for (int i = 0; i < l$channels.length; i++) {
        final l$channels$entry = l$channels[i];
        final lOther$channels$entry = lOther$channels[i];
        if (l$channels$entry != lOther$channels$entry) {
          return false;
        }
      }
    } else if (l$channels != lOther$channels) {
      return false;
    }
    final l$gifts = gifts;
    final lOther$gifts = other.gifts;
    if (_$data.containsKey('gifts') != other._$data.containsKey('gifts')) {
      return false;
    }
    if (l$gifts != null && lOther$gifts != null) {
      if (l$gifts.length != lOther$gifts.length) {
        return false;
      }
      for (int i = 0; i < l$gifts.length; i++) {
        final l$gifts$entry = l$gifts[i];
        final lOther$gifts$entry = lOther$gifts[i];
        if (l$gifts$entry != lOther$gifts$entry) {
          return false;
        }
      }
    } else if (l$gifts != lOther$gifts) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    final l$cataloguePredicate = cataloguePredicate;
    final l$orderPredicate = orderPredicate;
    final l$rewardValueType = rewardValueType;
    final l$rewardValue = rewardValue;
    final l$rewardType = rewardType;
    final l$channels = channels;
    final l$gifts = gifts;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('cataloguePredicate')
          ? l$cataloguePredicate
          : const {},
      _$data.containsKey('orderPredicate') ? l$orderPredicate : const {},
      _$data.containsKey('rewardValueType') ? l$rewardValueType : const {},
      _$data.containsKey('rewardValue') ? l$rewardValue : const {},
      _$data.containsKey('rewardType') ? l$rewardType : const {},
      _$data.containsKey('channels')
          ? l$channels == null
              ? null
              : Object.hashAll(l$channels.map((v) => v))
          : const {},
      _$data.containsKey('gifts')
          ? l$gifts == null
              ? null
              : Object.hashAll(l$gifts.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromotionRuleInput<TRes> {
  factory CopyWith$Input$PromotionRuleInput(
    Input$PromotionRuleInput instance,
    TRes Function(Input$PromotionRuleInput) then,
  ) = _CopyWithImpl$Input$PromotionRuleInput;

  factory CopyWith$Input$PromotionRuleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromotionRuleInput;

  TRes call({
    String? name,
    String? description,
    Input$CataloguePredicateInput? cataloguePredicate,
    Input$OrderPredicateInput? orderPredicate,
    Enum$RewardValueTypeEnum? rewardValueType,
    String? rewardValue,
    Enum$RewardTypeEnum? rewardType,
    List<String>? channels,
    List<String>? gifts,
  });
  CopyWith$Input$CataloguePredicateInput<TRes> get cataloguePredicate;
  CopyWith$Input$OrderPredicateInput<TRes> get orderPredicate;
}

class _CopyWithImpl$Input$PromotionRuleInput<TRes>
    implements CopyWith$Input$PromotionRuleInput<TRes> {
  _CopyWithImpl$Input$PromotionRuleInput(
    this._instance,
    this._then,
  );

  final Input$PromotionRuleInput _instance;

  final TRes Function(Input$PromotionRuleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
    Object? cataloguePredicate = _undefined,
    Object? orderPredicate = _undefined,
    Object? rewardValueType = _undefined,
    Object? rewardValue = _undefined,
    Object? rewardType = _undefined,
    Object? channels = _undefined,
    Object? gifts = _undefined,
  }) =>
      _then(Input$PromotionRuleInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (cataloguePredicate != _undefined)
          'cataloguePredicate':
              (cataloguePredicate as Input$CataloguePredicateInput?),
        if (orderPredicate != _undefined)
          'orderPredicate': (orderPredicate as Input$OrderPredicateInput?),
        if (rewardValueType != _undefined)
          'rewardValueType': (rewardValueType as Enum$RewardValueTypeEnum?),
        if (rewardValue != _undefined) 'rewardValue': (rewardValue as String?),
        if (rewardType != _undefined)
          'rewardType': (rewardType as Enum$RewardTypeEnum?),
        if (channels != _undefined) 'channels': (channels as List<String>?),
        if (gifts != _undefined) 'gifts': (gifts as List<String>?),
      }));

  CopyWith$Input$CataloguePredicateInput<TRes> get cataloguePredicate {
    final local$cataloguePredicate = _instance.cataloguePredicate;
    return local$cataloguePredicate == null
        ? CopyWith$Input$CataloguePredicateInput.stub(_then(_instance))
        : CopyWith$Input$CataloguePredicateInput(
            local$cataloguePredicate, (e) => call(cataloguePredicate: e));
  }

  CopyWith$Input$OrderPredicateInput<TRes> get orderPredicate {
    final local$orderPredicate = _instance.orderPredicate;
    return local$orderPredicate == null
        ? CopyWith$Input$OrderPredicateInput.stub(_then(_instance))
        : CopyWith$Input$OrderPredicateInput(
            local$orderPredicate, (e) => call(orderPredicate: e));
  }
}

class _CopyWithStubImpl$Input$PromotionRuleInput<TRes>
    implements CopyWith$Input$PromotionRuleInput<TRes> {
  _CopyWithStubImpl$Input$PromotionRuleInput(this._res);

  TRes _res;

  call({
    String? name,
    String? description,
    Input$CataloguePredicateInput? cataloguePredicate,
    Input$OrderPredicateInput? orderPredicate,
    Enum$RewardValueTypeEnum? rewardValueType,
    String? rewardValue,
    Enum$RewardTypeEnum? rewardType,
    List<String>? channels,
    List<String>? gifts,
  }) =>
      _res;

  CopyWith$Input$CataloguePredicateInput<TRes> get cataloguePredicate =>
      CopyWith$Input$CataloguePredicateInput.stub(_res);

  CopyWith$Input$OrderPredicateInput<TRes> get orderPredicate =>
      CopyWith$Input$OrderPredicateInput.stub(_res);
}

class Input$PromotionRuleTranslationInput {
  factory Input$PromotionRuleTranslationInput({
    String? name,
    String? description,
  }) =>
      Input$PromotionRuleTranslationInput._({
        if (name != null) r'name': name,
        if (description != null) r'description': description,
      });

  Input$PromotionRuleTranslationInput._(this._$data);

  factory Input$PromotionRuleTranslationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    return Input$PromotionRuleTranslationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    return result$data;
  }

  CopyWith$Input$PromotionRuleTranslationInput<
          Input$PromotionRuleTranslationInput>
      get copyWith => CopyWith$Input$PromotionRuleTranslationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PromotionRuleTranslationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromotionRuleTranslationInput<TRes> {
  factory CopyWith$Input$PromotionRuleTranslationInput(
    Input$PromotionRuleTranslationInput instance,
    TRes Function(Input$PromotionRuleTranslationInput) then,
  ) = _CopyWithImpl$Input$PromotionRuleTranslationInput;

  factory CopyWith$Input$PromotionRuleTranslationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromotionRuleTranslationInput;

  TRes call({
    String? name,
    String? description,
  });
}

class _CopyWithImpl$Input$PromotionRuleTranslationInput<TRes>
    implements CopyWith$Input$PromotionRuleTranslationInput<TRes> {
  _CopyWithImpl$Input$PromotionRuleTranslationInput(
    this._instance,
    this._then,
  );

  final Input$PromotionRuleTranslationInput _instance;

  final TRes Function(Input$PromotionRuleTranslationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$PromotionRuleTranslationInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
      }));
}

class _CopyWithStubImpl$Input$PromotionRuleTranslationInput<TRes>
    implements CopyWith$Input$PromotionRuleTranslationInput<TRes> {
  _CopyWithStubImpl$Input$PromotionRuleTranslationInput(this._res);

  TRes _res;

  call({
    String? name,
    String? description,
  }) =>
      _res;
}

class Input$PromotionRuleUpdateInput {
  factory Input$PromotionRuleUpdateInput({
    String? name,
    String? description,
    Input$CataloguePredicateInput? cataloguePredicate,
    Input$OrderPredicateInput? orderPredicate,
    Enum$RewardValueTypeEnum? rewardValueType,
    String? rewardValue,
    Enum$RewardTypeEnum? rewardType,
    List<String>? addChannels,
    List<String>? removeChannels,
    List<String>? addGifts,
    List<String>? removeGifts,
  }) =>
      Input$PromotionRuleUpdateInput._({
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (cataloguePredicate != null)
          r'cataloguePredicate': cataloguePredicate,
        if (orderPredicate != null) r'orderPredicate': orderPredicate,
        if (rewardValueType != null) r'rewardValueType': rewardValueType,
        if (rewardValue != null) r'rewardValue': rewardValue,
        if (rewardType != null) r'rewardType': rewardType,
        if (addChannels != null) r'addChannels': addChannels,
        if (removeChannels != null) r'removeChannels': removeChannels,
        if (addGifts != null) r'addGifts': addGifts,
        if (removeGifts != null) r'removeGifts': removeGifts,
      });

  Input$PromotionRuleUpdateInput._(this._$data);

  factory Input$PromotionRuleUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('cataloguePredicate')) {
      final l$cataloguePredicate = data['cataloguePredicate'];
      result$data['cataloguePredicate'] = l$cataloguePredicate == null
          ? null
          : Input$CataloguePredicateInput.fromJson(
              (l$cataloguePredicate as Map<String, dynamic>));
    }
    if (data.containsKey('orderPredicate')) {
      final l$orderPredicate = data['orderPredicate'];
      result$data['orderPredicate'] = l$orderPredicate == null
          ? null
          : Input$OrderPredicateInput.fromJson(
              (l$orderPredicate as Map<String, dynamic>));
    }
    if (data.containsKey('rewardValueType')) {
      final l$rewardValueType = data['rewardValueType'];
      result$data['rewardValueType'] = l$rewardValueType == null
          ? null
          : fromJson$Enum$RewardValueTypeEnum((l$rewardValueType as String));
    }
    if (data.containsKey('rewardValue')) {
      final l$rewardValue = data['rewardValue'];
      result$data['rewardValue'] = (l$rewardValue as String?);
    }
    if (data.containsKey('rewardType')) {
      final l$rewardType = data['rewardType'];
      result$data['rewardType'] = l$rewardType == null
          ? null
          : fromJson$Enum$RewardTypeEnum((l$rewardType as String));
    }
    if (data.containsKey('addChannels')) {
      final l$addChannels = data['addChannels'];
      result$data['addChannels'] =
          (l$addChannels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('removeChannels')) {
      final l$removeChannels = data['removeChannels'];
      result$data['removeChannels'] = (l$removeChannels as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('addGifts')) {
      final l$addGifts = data['addGifts'];
      result$data['addGifts'] =
          (l$addGifts as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('removeGifts')) {
      final l$removeGifts = data['removeGifts'];
      result$data['removeGifts'] =
          (l$removeGifts as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$PromotionRuleUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  Input$CataloguePredicateInput? get cataloguePredicate =>
      (_$data['cataloguePredicate'] as Input$CataloguePredicateInput?);

  Input$OrderPredicateInput? get orderPredicate =>
      (_$data['orderPredicate'] as Input$OrderPredicateInput?);

  Enum$RewardValueTypeEnum? get rewardValueType =>
      (_$data['rewardValueType'] as Enum$RewardValueTypeEnum?);

  String? get rewardValue => (_$data['rewardValue'] as String?);

  Enum$RewardTypeEnum? get rewardType =>
      (_$data['rewardType'] as Enum$RewardTypeEnum?);

  List<String>? get addChannels => (_$data['addChannels'] as List<String>?);

  List<String>? get removeChannels =>
      (_$data['removeChannels'] as List<String>?);

  List<String>? get addGifts => (_$data['addGifts'] as List<String>?);

  List<String>? get removeGifts => (_$data['removeGifts'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('cataloguePredicate')) {
      final l$cataloguePredicate = cataloguePredicate;
      result$data['cataloguePredicate'] = l$cataloguePredicate?.toJson();
    }
    if (_$data.containsKey('orderPredicate')) {
      final l$orderPredicate = orderPredicate;
      result$data['orderPredicate'] = l$orderPredicate?.toJson();
    }
    if (_$data.containsKey('rewardValueType')) {
      final l$rewardValueType = rewardValueType;
      result$data['rewardValueType'] = l$rewardValueType == null
          ? null
          : toJson$Enum$RewardValueTypeEnum(l$rewardValueType);
    }
    if (_$data.containsKey('rewardValue')) {
      final l$rewardValue = rewardValue;
      result$data['rewardValue'] = l$rewardValue;
    }
    if (_$data.containsKey('rewardType')) {
      final l$rewardType = rewardType;
      result$data['rewardType'] = l$rewardType == null
          ? null
          : toJson$Enum$RewardTypeEnum(l$rewardType);
    }
    if (_$data.containsKey('addChannels')) {
      final l$addChannels = addChannels;
      result$data['addChannels'] = l$addChannels?.map((e) => e).toList();
    }
    if (_$data.containsKey('removeChannels')) {
      final l$removeChannels = removeChannels;
      result$data['removeChannels'] = l$removeChannels?.map((e) => e).toList();
    }
    if (_$data.containsKey('addGifts')) {
      final l$addGifts = addGifts;
      result$data['addGifts'] = l$addGifts?.map((e) => e).toList();
    }
    if (_$data.containsKey('removeGifts')) {
      final l$removeGifts = removeGifts;
      result$data['removeGifts'] = l$removeGifts?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$PromotionRuleUpdateInput<Input$PromotionRuleUpdateInput>
      get copyWith => CopyWith$Input$PromotionRuleUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PromotionRuleUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$cataloguePredicate = cataloguePredicate;
    final lOther$cataloguePredicate = other.cataloguePredicate;
    if (_$data.containsKey('cataloguePredicate') !=
        other._$data.containsKey('cataloguePredicate')) {
      return false;
    }
    if (l$cataloguePredicate != lOther$cataloguePredicate) {
      return false;
    }
    final l$orderPredicate = orderPredicate;
    final lOther$orderPredicate = other.orderPredicate;
    if (_$data.containsKey('orderPredicate') !=
        other._$data.containsKey('orderPredicate')) {
      return false;
    }
    if (l$orderPredicate != lOther$orderPredicate) {
      return false;
    }
    final l$rewardValueType = rewardValueType;
    final lOther$rewardValueType = other.rewardValueType;
    if (_$data.containsKey('rewardValueType') !=
        other._$data.containsKey('rewardValueType')) {
      return false;
    }
    if (l$rewardValueType != lOther$rewardValueType) {
      return false;
    }
    final l$rewardValue = rewardValue;
    final lOther$rewardValue = other.rewardValue;
    if (_$data.containsKey('rewardValue') !=
        other._$data.containsKey('rewardValue')) {
      return false;
    }
    if (l$rewardValue != lOther$rewardValue) {
      return false;
    }
    final l$rewardType = rewardType;
    final lOther$rewardType = other.rewardType;
    if (_$data.containsKey('rewardType') !=
        other._$data.containsKey('rewardType')) {
      return false;
    }
    if (l$rewardType != lOther$rewardType) {
      return false;
    }
    final l$addChannels = addChannels;
    final lOther$addChannels = other.addChannels;
    if (_$data.containsKey('addChannels') !=
        other._$data.containsKey('addChannels')) {
      return false;
    }
    if (l$addChannels != null && lOther$addChannels != null) {
      if (l$addChannels.length != lOther$addChannels.length) {
        return false;
      }
      for (int i = 0; i < l$addChannels.length; i++) {
        final l$addChannels$entry = l$addChannels[i];
        final lOther$addChannels$entry = lOther$addChannels[i];
        if (l$addChannels$entry != lOther$addChannels$entry) {
          return false;
        }
      }
    } else if (l$addChannels != lOther$addChannels) {
      return false;
    }
    final l$removeChannels = removeChannels;
    final lOther$removeChannels = other.removeChannels;
    if (_$data.containsKey('removeChannels') !=
        other._$data.containsKey('removeChannels')) {
      return false;
    }
    if (l$removeChannels != null && lOther$removeChannels != null) {
      if (l$removeChannels.length != lOther$removeChannels.length) {
        return false;
      }
      for (int i = 0; i < l$removeChannels.length; i++) {
        final l$removeChannels$entry = l$removeChannels[i];
        final lOther$removeChannels$entry = lOther$removeChannels[i];
        if (l$removeChannels$entry != lOther$removeChannels$entry) {
          return false;
        }
      }
    } else if (l$removeChannels != lOther$removeChannels) {
      return false;
    }
    final l$addGifts = addGifts;
    final lOther$addGifts = other.addGifts;
    if (_$data.containsKey('addGifts') !=
        other._$data.containsKey('addGifts')) {
      return false;
    }
    if (l$addGifts != null && lOther$addGifts != null) {
      if (l$addGifts.length != lOther$addGifts.length) {
        return false;
      }
      for (int i = 0; i < l$addGifts.length; i++) {
        final l$addGifts$entry = l$addGifts[i];
        final lOther$addGifts$entry = lOther$addGifts[i];
        if (l$addGifts$entry != lOther$addGifts$entry) {
          return false;
        }
      }
    } else if (l$addGifts != lOther$addGifts) {
      return false;
    }
    final l$removeGifts = removeGifts;
    final lOther$removeGifts = other.removeGifts;
    if (_$data.containsKey('removeGifts') !=
        other._$data.containsKey('removeGifts')) {
      return false;
    }
    if (l$removeGifts != null && lOther$removeGifts != null) {
      if (l$removeGifts.length != lOther$removeGifts.length) {
        return false;
      }
      for (int i = 0; i < l$removeGifts.length; i++) {
        final l$removeGifts$entry = l$removeGifts[i];
        final lOther$removeGifts$entry = lOther$removeGifts[i];
        if (l$removeGifts$entry != lOther$removeGifts$entry) {
          return false;
        }
      }
    } else if (l$removeGifts != lOther$removeGifts) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    final l$cataloguePredicate = cataloguePredicate;
    final l$orderPredicate = orderPredicate;
    final l$rewardValueType = rewardValueType;
    final l$rewardValue = rewardValue;
    final l$rewardType = rewardType;
    final l$addChannels = addChannels;
    final l$removeChannels = removeChannels;
    final l$addGifts = addGifts;
    final l$removeGifts = removeGifts;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('cataloguePredicate')
          ? l$cataloguePredicate
          : const {},
      _$data.containsKey('orderPredicate') ? l$orderPredicate : const {},
      _$data.containsKey('rewardValueType') ? l$rewardValueType : const {},
      _$data.containsKey('rewardValue') ? l$rewardValue : const {},
      _$data.containsKey('rewardType') ? l$rewardType : const {},
      _$data.containsKey('addChannels')
          ? l$addChannels == null
              ? null
              : Object.hashAll(l$addChannels.map((v) => v))
          : const {},
      _$data.containsKey('removeChannels')
          ? l$removeChannels == null
              ? null
              : Object.hashAll(l$removeChannels.map((v) => v))
          : const {},
      _$data.containsKey('addGifts')
          ? l$addGifts == null
              ? null
              : Object.hashAll(l$addGifts.map((v) => v))
          : const {},
      _$data.containsKey('removeGifts')
          ? l$removeGifts == null
              ? null
              : Object.hashAll(l$removeGifts.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromotionRuleUpdateInput<TRes> {
  factory CopyWith$Input$PromotionRuleUpdateInput(
    Input$PromotionRuleUpdateInput instance,
    TRes Function(Input$PromotionRuleUpdateInput) then,
  ) = _CopyWithImpl$Input$PromotionRuleUpdateInput;

  factory CopyWith$Input$PromotionRuleUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromotionRuleUpdateInput;

  TRes call({
    String? name,
    String? description,
    Input$CataloguePredicateInput? cataloguePredicate,
    Input$OrderPredicateInput? orderPredicate,
    Enum$RewardValueTypeEnum? rewardValueType,
    String? rewardValue,
    Enum$RewardTypeEnum? rewardType,
    List<String>? addChannels,
    List<String>? removeChannels,
    List<String>? addGifts,
    List<String>? removeGifts,
  });
  CopyWith$Input$CataloguePredicateInput<TRes> get cataloguePredicate;
  CopyWith$Input$OrderPredicateInput<TRes> get orderPredicate;
}

class _CopyWithImpl$Input$PromotionRuleUpdateInput<TRes>
    implements CopyWith$Input$PromotionRuleUpdateInput<TRes> {
  _CopyWithImpl$Input$PromotionRuleUpdateInput(
    this._instance,
    this._then,
  );

  final Input$PromotionRuleUpdateInput _instance;

  final TRes Function(Input$PromotionRuleUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
    Object? cataloguePredicate = _undefined,
    Object? orderPredicate = _undefined,
    Object? rewardValueType = _undefined,
    Object? rewardValue = _undefined,
    Object? rewardType = _undefined,
    Object? addChannels = _undefined,
    Object? removeChannels = _undefined,
    Object? addGifts = _undefined,
    Object? removeGifts = _undefined,
  }) =>
      _then(Input$PromotionRuleUpdateInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (cataloguePredicate != _undefined)
          'cataloguePredicate':
              (cataloguePredicate as Input$CataloguePredicateInput?),
        if (orderPredicate != _undefined)
          'orderPredicate': (orderPredicate as Input$OrderPredicateInput?),
        if (rewardValueType != _undefined)
          'rewardValueType': (rewardValueType as Enum$RewardValueTypeEnum?),
        if (rewardValue != _undefined) 'rewardValue': (rewardValue as String?),
        if (rewardType != _undefined)
          'rewardType': (rewardType as Enum$RewardTypeEnum?),
        if (addChannels != _undefined)
          'addChannels': (addChannels as List<String>?),
        if (removeChannels != _undefined)
          'removeChannels': (removeChannels as List<String>?),
        if (addGifts != _undefined) 'addGifts': (addGifts as List<String>?),
        if (removeGifts != _undefined)
          'removeGifts': (removeGifts as List<String>?),
      }));

  CopyWith$Input$CataloguePredicateInput<TRes> get cataloguePredicate {
    final local$cataloguePredicate = _instance.cataloguePredicate;
    return local$cataloguePredicate == null
        ? CopyWith$Input$CataloguePredicateInput.stub(_then(_instance))
        : CopyWith$Input$CataloguePredicateInput(
            local$cataloguePredicate, (e) => call(cataloguePredicate: e));
  }

  CopyWith$Input$OrderPredicateInput<TRes> get orderPredicate {
    final local$orderPredicate = _instance.orderPredicate;
    return local$orderPredicate == null
        ? CopyWith$Input$OrderPredicateInput.stub(_then(_instance))
        : CopyWith$Input$OrderPredicateInput(
            local$orderPredicate, (e) => call(orderPredicate: e));
  }
}

class _CopyWithStubImpl$Input$PromotionRuleUpdateInput<TRes>
    implements CopyWith$Input$PromotionRuleUpdateInput<TRes> {
  _CopyWithStubImpl$Input$PromotionRuleUpdateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? description,
    Input$CataloguePredicateInput? cataloguePredicate,
    Input$OrderPredicateInput? orderPredicate,
    Enum$RewardValueTypeEnum? rewardValueType,
    String? rewardValue,
    Enum$RewardTypeEnum? rewardType,
    List<String>? addChannels,
    List<String>? removeChannels,
    List<String>? addGifts,
    List<String>? removeGifts,
  }) =>
      _res;

  CopyWith$Input$CataloguePredicateInput<TRes> get cataloguePredicate =>
      CopyWith$Input$CataloguePredicateInput.stub(_res);

  CopyWith$Input$OrderPredicateInput<TRes> get orderPredicate =>
      CopyWith$Input$OrderPredicateInput.stub(_res);
}

class Input$PromotionSortingInput {
  factory Input$PromotionSortingInput({
    required Enum$OrderDirection direction,
    required Enum$PromotionSortField field,
  }) =>
      Input$PromotionSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$PromotionSortingInput._(this._$data);

  factory Input$PromotionSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$PromotionSortField((l$field as String));
    return Input$PromotionSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$PromotionSortField get field =>
      (_$data['field'] as Enum$PromotionSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$PromotionSortField(l$field);
    return result$data;
  }

  CopyWith$Input$PromotionSortingInput<Input$PromotionSortingInput>
      get copyWith => CopyWith$Input$PromotionSortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PromotionSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$PromotionSortingInput<TRes> {
  factory CopyWith$Input$PromotionSortingInput(
    Input$PromotionSortingInput instance,
    TRes Function(Input$PromotionSortingInput) then,
  ) = _CopyWithImpl$Input$PromotionSortingInput;

  factory CopyWith$Input$PromotionSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromotionSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$PromotionSortField? field,
  });
}

class _CopyWithImpl$Input$PromotionSortingInput<TRes>
    implements CopyWith$Input$PromotionSortingInput<TRes> {
  _CopyWithImpl$Input$PromotionSortingInput(
    this._instance,
    this._then,
  );

  final Input$PromotionSortingInput _instance;

  final TRes Function(Input$PromotionSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$PromotionSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$PromotionSortField),
      }));
}

class _CopyWithStubImpl$Input$PromotionSortingInput<TRes>
    implements CopyWith$Input$PromotionSortingInput<TRes> {
  _CopyWithStubImpl$Input$PromotionSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$PromotionSortField? field,
  }) =>
      _res;
}

class Input$PromotionTranslationInput {
  factory Input$PromotionTranslationInput({
    String? name,
    String? description,
  }) =>
      Input$PromotionTranslationInput._({
        if (name != null) r'name': name,
        if (description != null) r'description': description,
      });

  Input$PromotionTranslationInput._(this._$data);

  factory Input$PromotionTranslationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    return Input$PromotionTranslationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    return result$data;
  }

  CopyWith$Input$PromotionTranslationInput<Input$PromotionTranslationInput>
      get copyWith => CopyWith$Input$PromotionTranslationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PromotionTranslationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromotionTranslationInput<TRes> {
  factory CopyWith$Input$PromotionTranslationInput(
    Input$PromotionTranslationInput instance,
    TRes Function(Input$PromotionTranslationInput) then,
  ) = _CopyWithImpl$Input$PromotionTranslationInput;

  factory CopyWith$Input$PromotionTranslationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromotionTranslationInput;

  TRes call({
    String? name,
    String? description,
  });
}

class _CopyWithImpl$Input$PromotionTranslationInput<TRes>
    implements CopyWith$Input$PromotionTranslationInput<TRes> {
  _CopyWithImpl$Input$PromotionTranslationInput(
    this._instance,
    this._then,
  );

  final Input$PromotionTranslationInput _instance;

  final TRes Function(Input$PromotionTranslationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$PromotionTranslationInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
      }));
}

class _CopyWithStubImpl$Input$PromotionTranslationInput<TRes>
    implements CopyWith$Input$PromotionTranslationInput<TRes> {
  _CopyWithStubImpl$Input$PromotionTranslationInput(this._res);

  TRes _res;

  call({
    String? name,
    String? description,
  }) =>
      _res;
}

class Input$PromotionTypeEnumFilterInput {
  factory Input$PromotionTypeEnumFilterInput({
    Enum$PromotionTypeEnum? eq,
    List<Enum$PromotionTypeEnum>? oneOf,
  }) =>
      Input$PromotionTypeEnumFilterInput._({
        if (eq != null) r'eq': eq,
        if (oneOf != null) r'oneOf': oneOf,
      });

  Input$PromotionTypeEnumFilterInput._(this._$data);

  factory Input$PromotionTypeEnumFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$PromotionTypeEnum((l$eq as String));
    }
    if (data.containsKey('oneOf')) {
      final l$oneOf = data['oneOf'];
      result$data['oneOf'] = (l$oneOf as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PromotionTypeEnum((e as String)))
          .toList();
    }
    return Input$PromotionTypeEnumFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$PromotionTypeEnum? get eq => (_$data['eq'] as Enum$PromotionTypeEnum?);

  List<Enum$PromotionTypeEnum>? get oneOf =>
      (_$data['oneOf'] as List<Enum$PromotionTypeEnum>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] =
          l$eq == null ? null : toJson$Enum$PromotionTypeEnum(l$eq);
    }
    if (_$data.containsKey('oneOf')) {
      final l$oneOf = oneOf;
      result$data['oneOf'] =
          l$oneOf?.map((e) => toJson$Enum$PromotionTypeEnum(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$PromotionTypeEnumFilterInput<
          Input$PromotionTypeEnumFilterInput>
      get copyWith => CopyWith$Input$PromotionTypeEnumFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PromotionTypeEnumFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$oneOf = oneOf;
    final lOther$oneOf = other.oneOf;
    if (_$data.containsKey('oneOf') != other._$data.containsKey('oneOf')) {
      return false;
    }
    if (l$oneOf != null && lOther$oneOf != null) {
      if (l$oneOf.length != lOther$oneOf.length) {
        return false;
      }
      for (int i = 0; i < l$oneOf.length; i++) {
        final l$oneOf$entry = l$oneOf[i];
        final lOther$oneOf$entry = lOther$oneOf[i];
        if (l$oneOf$entry != lOther$oneOf$entry) {
          return false;
        }
      }
    } else if (l$oneOf != lOther$oneOf) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$oneOf = oneOf;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('oneOf')
          ? l$oneOf == null
              ? null
              : Object.hashAll(l$oneOf.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromotionTypeEnumFilterInput<TRes> {
  factory CopyWith$Input$PromotionTypeEnumFilterInput(
    Input$PromotionTypeEnumFilterInput instance,
    TRes Function(Input$PromotionTypeEnumFilterInput) then,
  ) = _CopyWithImpl$Input$PromotionTypeEnumFilterInput;

  factory CopyWith$Input$PromotionTypeEnumFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromotionTypeEnumFilterInput;

  TRes call({
    Enum$PromotionTypeEnum? eq,
    List<Enum$PromotionTypeEnum>? oneOf,
  });
}

class _CopyWithImpl$Input$PromotionTypeEnumFilterInput<TRes>
    implements CopyWith$Input$PromotionTypeEnumFilterInput<TRes> {
  _CopyWithImpl$Input$PromotionTypeEnumFilterInput(
    this._instance,
    this._then,
  );

  final Input$PromotionTypeEnumFilterInput _instance;

  final TRes Function(Input$PromotionTypeEnumFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? oneOf = _undefined,
  }) =>
      _then(Input$PromotionTypeEnumFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as Enum$PromotionTypeEnum?),
        if (oneOf != _undefined)
          'oneOf': (oneOf as List<Enum$PromotionTypeEnum>?),
      }));
}

class _CopyWithStubImpl$Input$PromotionTypeEnumFilterInput<TRes>
    implements CopyWith$Input$PromotionTypeEnumFilterInput<TRes> {
  _CopyWithStubImpl$Input$PromotionTypeEnumFilterInput(this._res);

  TRes _res;

  call({
    Enum$PromotionTypeEnum? eq,
    List<Enum$PromotionTypeEnum>? oneOf,
  }) =>
      _res;
}

class Input$PromotionUpdateInput {
  factory Input$PromotionUpdateInput({
    String? description,
    String? startDate,
    String? endDate,
    String? name,
  }) =>
      Input$PromotionUpdateInput._({
        if (description != null) r'description': description,
        if (startDate != null) r'startDate': startDate,
        if (endDate != null) r'endDate': endDate,
        if (name != null) r'name': name,
      });

  Input$PromotionUpdateInput._(this._$data);

  factory Input$PromotionUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('startDate')) {
      final l$startDate = data['startDate'];
      result$data['startDate'] = (l$startDate as String?);
    }
    if (data.containsKey('endDate')) {
      final l$endDate = data['endDate'];
      result$data['endDate'] = (l$endDate as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    return Input$PromotionUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get description => (_$data['description'] as String?);

  String? get startDate => (_$data['startDate'] as String?);

  String? get endDate => (_$data['endDate'] as String?);

  String? get name => (_$data['name'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('startDate')) {
      final l$startDate = startDate;
      result$data['startDate'] = l$startDate;
    }
    if (_$data.containsKey('endDate')) {
      final l$endDate = endDate;
      result$data['endDate'] = l$endDate;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    return result$data;
  }

  CopyWith$Input$PromotionUpdateInput<Input$PromotionUpdateInput>
      get copyWith => CopyWith$Input$PromotionUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PromotionUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (_$data.containsKey('startDate') !=
        other._$data.containsKey('startDate')) {
      return false;
    }
    if (l$startDate != lOther$startDate) {
      return false;
    }
    final l$endDate = endDate;
    final lOther$endDate = other.endDate;
    if (_$data.containsKey('endDate') != other._$data.containsKey('endDate')) {
      return false;
    }
    if (l$endDate != lOther$endDate) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$description = description;
    final l$startDate = startDate;
    final l$endDate = endDate;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('startDate') ? l$startDate : const {},
      _$data.containsKey('endDate') ? l$endDate : const {},
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromotionUpdateInput<TRes> {
  factory CopyWith$Input$PromotionUpdateInput(
    Input$PromotionUpdateInput instance,
    TRes Function(Input$PromotionUpdateInput) then,
  ) = _CopyWithImpl$Input$PromotionUpdateInput;

  factory CopyWith$Input$PromotionUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromotionUpdateInput;

  TRes call({
    String? description,
    String? startDate,
    String? endDate,
    String? name,
  });
}

class _CopyWithImpl$Input$PromotionUpdateInput<TRes>
    implements CopyWith$Input$PromotionUpdateInput<TRes> {
  _CopyWithImpl$Input$PromotionUpdateInput(
    this._instance,
    this._then,
  );

  final Input$PromotionUpdateInput _instance;

  final TRes Function(Input$PromotionUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? description = _undefined,
    Object? startDate = _undefined,
    Object? endDate = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$PromotionUpdateInput._({
        ..._instance._$data,
        if (description != _undefined) 'description': (description as String?),
        if (startDate != _undefined) 'startDate': (startDate as String?),
        if (endDate != _undefined) 'endDate': (endDate as String?),
        if (name != _undefined) 'name': (name as String?),
      }));
}

class _CopyWithStubImpl$Input$PromotionUpdateInput<TRes>
    implements CopyWith$Input$PromotionUpdateInput<TRes> {
  _CopyWithStubImpl$Input$PromotionUpdateInput(this._res);

  TRes _res;

  call({
    String? description,
    String? startDate,
    String? endDate,
    String? name,
  }) =>
      _res;
}

class Input$PromotionWhereInput {
  factory Input$PromotionWhereInput({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    Input$StringFilterInput? name,
    Input$DateTimeFilterInput? endDate,
    Input$DateTimeFilterInput? startDate,
    bool? isOldSale,
    Input$PromotionTypeEnumFilterInput? type,
    List<Input$PromotionWhereInput>? AND,
    List<Input$PromotionWhereInput>? OR,
  }) =>
      Input$PromotionWhereInput._({
        if (metadata != null) r'metadata': metadata,
        if (ids != null) r'ids': ids,
        if (name != null) r'name': name,
        if (endDate != null) r'endDate': endDate,
        if (startDate != null) r'startDate': startDate,
        if (isOldSale != null) r'isOldSale': isOldSale,
        if (type != null) r'type': type,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
      });

  Input$PromotionWhereInput._(this._$data);

  factory Input$PromotionWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilterInput.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('endDate')) {
      final l$endDate = data['endDate'];
      result$data['endDate'] = l$endDate == null
          ? null
          : Input$DateTimeFilterInput.fromJson(
              (l$endDate as Map<String, dynamic>));
    }
    if (data.containsKey('startDate')) {
      final l$startDate = data['startDate'];
      result$data['startDate'] = l$startDate == null
          ? null
          : Input$DateTimeFilterInput.fromJson(
              (l$startDate as Map<String, dynamic>));
    }
    if (data.containsKey('isOldSale')) {
      final l$isOldSale = data['isOldSale'];
      result$data['isOldSale'] = (l$isOldSale as bool?);
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : Input$PromotionTypeEnumFilterInput.fromJson(
              (l$type as Map<String, dynamic>));
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$PromotionWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$PromotionWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$PromotionWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  Input$StringFilterInput? get name =>
      (_$data['name'] as Input$StringFilterInput?);

  Input$DateTimeFilterInput? get endDate =>
      (_$data['endDate'] as Input$DateTimeFilterInput?);

  Input$DateTimeFilterInput? get startDate =>
      (_$data['startDate'] as Input$DateTimeFilterInput?);

  bool? get isOldSale => (_$data['isOldSale'] as bool?);

  Input$PromotionTypeEnumFilterInput? get type =>
      (_$data['type'] as Input$PromotionTypeEnumFilterInput?);

  List<Input$PromotionWhereInput>? get AND =>
      (_$data['AND'] as List<Input$PromotionWhereInput>?);

  List<Input$PromotionWhereInput>? get OR =>
      (_$data['OR'] as List<Input$PromotionWhereInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('endDate')) {
      final l$endDate = endDate;
      result$data['endDate'] = l$endDate?.toJson();
    }
    if (_$data.containsKey('startDate')) {
      final l$startDate = startDate;
      result$data['startDate'] = l$startDate?.toJson();
    }
    if (_$data.containsKey('isOldSale')) {
      final l$isOldSale = isOldSale;
      result$data['isOldSale'] = l$isOldSale;
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type?.toJson();
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$PromotionWhereInput<Input$PromotionWhereInput> get copyWith =>
      CopyWith$Input$PromotionWhereInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PromotionWhereInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$endDate = endDate;
    final lOther$endDate = other.endDate;
    if (_$data.containsKey('endDate') != other._$data.containsKey('endDate')) {
      return false;
    }
    if (l$endDate != lOther$endDate) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (_$data.containsKey('startDate') !=
        other._$data.containsKey('startDate')) {
      return false;
    }
    if (l$startDate != lOther$startDate) {
      return false;
    }
    final l$isOldSale = isOldSale;
    final lOther$isOldSale = other.isOldSale;
    if (_$data.containsKey('isOldSale') !=
        other._$data.containsKey('isOldSale')) {
      return false;
    }
    if (l$isOldSale != lOther$isOldSale) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$metadata = metadata;
    final l$ids = ids;
    final l$name = name;
    final l$endDate = endDate;
    final l$startDate = startDate;
    final l$isOldSale = isOldSale;
    final l$type = type;
    final l$AND = AND;
    final l$OR = OR;
    return Object.hashAll([
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('endDate') ? l$endDate : const {},
      _$data.containsKey('startDate') ? l$startDate : const {},
      _$data.containsKey('isOldSale') ? l$isOldSale : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PromotionWhereInput<TRes> {
  factory CopyWith$Input$PromotionWhereInput(
    Input$PromotionWhereInput instance,
    TRes Function(Input$PromotionWhereInput) then,
  ) = _CopyWithImpl$Input$PromotionWhereInput;

  factory CopyWith$Input$PromotionWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromotionWhereInput;

  TRes call({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    Input$StringFilterInput? name,
    Input$DateTimeFilterInput? endDate,
    Input$DateTimeFilterInput? startDate,
    bool? isOldSale,
    Input$PromotionTypeEnumFilterInput? type,
    List<Input$PromotionWhereInput>? AND,
    List<Input$PromotionWhereInput>? OR,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
  CopyWith$Input$StringFilterInput<TRes> get name;
  CopyWith$Input$DateTimeFilterInput<TRes> get endDate;
  CopyWith$Input$DateTimeFilterInput<TRes> get startDate;
  CopyWith$Input$PromotionTypeEnumFilterInput<TRes> get type;
  TRes AND(
      Iterable<Input$PromotionWhereInput>? Function(
              Iterable<
                  CopyWith$Input$PromotionWhereInput<
                      Input$PromotionWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$PromotionWhereInput>? Function(
              Iterable<
                  CopyWith$Input$PromotionWhereInput<
                      Input$PromotionWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$PromotionWhereInput<TRes>
    implements CopyWith$Input$PromotionWhereInput<TRes> {
  _CopyWithImpl$Input$PromotionWhereInput(
    this._instance,
    this._then,
  );

  final Input$PromotionWhereInput _instance;

  final TRes Function(Input$PromotionWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? metadata = _undefined,
    Object? ids = _undefined,
    Object? name = _undefined,
    Object? endDate = _undefined,
    Object? startDate = _undefined,
    Object? isOldSale = _undefined,
    Object? type = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
  }) =>
      _then(Input$PromotionWhereInput._({
        ..._instance._$data,
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (name != _undefined) 'name': (name as Input$StringFilterInput?),
        if (endDate != _undefined)
          'endDate': (endDate as Input$DateTimeFilterInput?),
        if (startDate != _undefined)
          'startDate': (startDate as Input$DateTimeFilterInput?),
        if (isOldSale != _undefined) 'isOldSale': (isOldSale as bool?),
        if (type != _undefined)
          'type': (type as Input$PromotionTypeEnumFilterInput?),
        if (AND != _undefined) 'AND': (AND as List<Input$PromotionWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$PromotionWhereInput>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$StringFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringFilterInput(local$name, (e) => call(name: e));
  }

  CopyWith$Input$DateTimeFilterInput<TRes> get endDate {
    final local$endDate = _instance.endDate;
    return local$endDate == null
        ? CopyWith$Input$DateTimeFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilterInput(
            local$endDate, (e) => call(endDate: e));
  }

  CopyWith$Input$DateTimeFilterInput<TRes> get startDate {
    final local$startDate = _instance.startDate;
    return local$startDate == null
        ? CopyWith$Input$DateTimeFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilterInput(
            local$startDate, (e) => call(startDate: e));
  }

  CopyWith$Input$PromotionTypeEnumFilterInput<TRes> get type {
    final local$type = _instance.type;
    return local$type == null
        ? CopyWith$Input$PromotionTypeEnumFilterInput.stub(_then(_instance))
        : CopyWith$Input$PromotionTypeEnumFilterInput(
            local$type, (e) => call(type: e));
  }

  TRes AND(
          Iterable<Input$PromotionWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$PromotionWhereInput<
                          Input$PromotionWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$PromotionWhereInput(
                e,
                (i) => i,
              )))?.toList());

  TRes OR(
          Iterable<Input$PromotionWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$PromotionWhereInput<
                          Input$PromotionWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$PromotionWhereInput(
                e,
                (i) => i,
              )))?.toList());
}

class _CopyWithStubImpl$Input$PromotionWhereInput<TRes>
    implements CopyWith$Input$PromotionWhereInput<TRes> {
  _CopyWithStubImpl$Input$PromotionWhereInput(this._res);

  TRes _res;

  call({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    Input$StringFilterInput? name,
    Input$DateTimeFilterInput? endDate,
    Input$DateTimeFilterInput? startDate,
    bool? isOldSale,
    Input$PromotionTypeEnumFilterInput? type,
    List<Input$PromotionWhereInput>? AND,
    List<Input$PromotionWhereInput>? OR,
  }) =>
      _res;

  metadata(_fn) => _res;

  CopyWith$Input$StringFilterInput<TRes> get name =>
      CopyWith$Input$StringFilterInput.stub(_res);

  CopyWith$Input$DateTimeFilterInput<TRes> get endDate =>
      CopyWith$Input$DateTimeFilterInput.stub(_res);

  CopyWith$Input$DateTimeFilterInput<TRes> get startDate =>
      CopyWith$Input$DateTimeFilterInput.stub(_res);

  CopyWith$Input$PromotionTypeEnumFilterInput<TRes> get type =>
      CopyWith$Input$PromotionTypeEnumFilterInput.stub(_res);

  AND(_fn) => _res;

  OR(_fn) => _res;
}

class Input$PublishableChannelListingInput {
  factory Input$PublishableChannelListingInput({
    required String channelId,
    bool? isPublished,
    String? publicationDate,
    String? publishedAt,
  }) =>
      Input$PublishableChannelListingInput._({
        r'channelId': channelId,
        if (isPublished != null) r'isPublished': isPublished,
        if (publicationDate != null) r'publicationDate': publicationDate,
        if (publishedAt != null) r'publishedAt': publishedAt,
      });

  Input$PublishableChannelListingInput._(this._$data);

  factory Input$PublishableChannelListingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$channelId = data['channelId'];
    result$data['channelId'] = (l$channelId as String);
    if (data.containsKey('isPublished')) {
      final l$isPublished = data['isPublished'];
      result$data['isPublished'] = (l$isPublished as bool?);
    }
    if (data.containsKey('publicationDate')) {
      final l$publicationDate = data['publicationDate'];
      result$data['publicationDate'] = (l$publicationDate as String?);
    }
    if (data.containsKey('publishedAt')) {
      final l$publishedAt = data['publishedAt'];
      result$data['publishedAt'] = (l$publishedAt as String?);
    }
    return Input$PublishableChannelListingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get channelId => (_$data['channelId'] as String);

  bool? get isPublished => (_$data['isPublished'] as bool?);

  String? get publicationDate => (_$data['publicationDate'] as String?);

  String? get publishedAt => (_$data['publishedAt'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$channelId = channelId;
    result$data['channelId'] = l$channelId;
    if (_$data.containsKey('isPublished')) {
      final l$isPublished = isPublished;
      result$data['isPublished'] = l$isPublished;
    }
    if (_$data.containsKey('publicationDate')) {
      final l$publicationDate = publicationDate;
      result$data['publicationDate'] = l$publicationDate;
    }
    if (_$data.containsKey('publishedAt')) {
      final l$publishedAt = publishedAt;
      result$data['publishedAt'] = l$publishedAt;
    }
    return result$data;
  }

  CopyWith$Input$PublishableChannelListingInput<
          Input$PublishableChannelListingInput>
      get copyWith => CopyWith$Input$PublishableChannelListingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PublishableChannelListingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$channelId = channelId;
    final lOther$channelId = other.channelId;
    if (l$channelId != lOther$channelId) {
      return false;
    }
    final l$isPublished = isPublished;
    final lOther$isPublished = other.isPublished;
    if (_$data.containsKey('isPublished') !=
        other._$data.containsKey('isPublished')) {
      return false;
    }
    if (l$isPublished != lOther$isPublished) {
      return false;
    }
    final l$publicationDate = publicationDate;
    final lOther$publicationDate = other.publicationDate;
    if (_$data.containsKey('publicationDate') !=
        other._$data.containsKey('publicationDate')) {
      return false;
    }
    if (l$publicationDate != lOther$publicationDate) {
      return false;
    }
    final l$publishedAt = publishedAt;
    final lOther$publishedAt = other.publishedAt;
    if (_$data.containsKey('publishedAt') !=
        other._$data.containsKey('publishedAt')) {
      return false;
    }
    if (l$publishedAt != lOther$publishedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$channelId = channelId;
    final l$isPublished = isPublished;
    final l$publicationDate = publicationDate;
    final l$publishedAt = publishedAt;
    return Object.hashAll([
      l$channelId,
      _$data.containsKey('isPublished') ? l$isPublished : const {},
      _$data.containsKey('publicationDate') ? l$publicationDate : const {},
      _$data.containsKey('publishedAt') ? l$publishedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PublishableChannelListingInput<TRes> {
  factory CopyWith$Input$PublishableChannelListingInput(
    Input$PublishableChannelListingInput instance,
    TRes Function(Input$PublishableChannelListingInput) then,
  ) = _CopyWithImpl$Input$PublishableChannelListingInput;

  factory CopyWith$Input$PublishableChannelListingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PublishableChannelListingInput;

  TRes call({
    String? channelId,
    bool? isPublished,
    String? publicationDate,
    String? publishedAt,
  });
}

class _CopyWithImpl$Input$PublishableChannelListingInput<TRes>
    implements CopyWith$Input$PublishableChannelListingInput<TRes> {
  _CopyWithImpl$Input$PublishableChannelListingInput(
    this._instance,
    this._then,
  );

  final Input$PublishableChannelListingInput _instance;

  final TRes Function(Input$PublishableChannelListingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? channelId = _undefined,
    Object? isPublished = _undefined,
    Object? publicationDate = _undefined,
    Object? publishedAt = _undefined,
  }) =>
      _then(Input$PublishableChannelListingInput._({
        ..._instance._$data,
        if (channelId != _undefined && channelId != null)
          'channelId': (channelId as String),
        if (isPublished != _undefined) 'isPublished': (isPublished as bool?),
        if (publicationDate != _undefined)
          'publicationDate': (publicationDate as String?),
        if (publishedAt != _undefined) 'publishedAt': (publishedAt as String?),
      }));
}

class _CopyWithStubImpl$Input$PublishableChannelListingInput<TRes>
    implements CopyWith$Input$PublishableChannelListingInput<TRes> {
  _CopyWithStubImpl$Input$PublishableChannelListingInput(this._res);

  TRes _res;

  call({
    String? channelId,
    bool? isPublished,
    String? publicationDate,
    String? publishedAt,
  }) =>
      _res;
}

class Input$ReorderInput {
  factory Input$ReorderInput({
    required String id,
    int? sortOrder,
  }) =>
      Input$ReorderInput._({
        r'id': id,
        if (sortOrder != null) r'sortOrder': sortOrder,
      });

  Input$ReorderInput._(this._$data);

  factory Input$ReorderInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('sortOrder')) {
      final l$sortOrder = data['sortOrder'];
      result$data['sortOrder'] = (l$sortOrder as int?);
    }
    return Input$ReorderInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);

  int? get sortOrder => (_$data['sortOrder'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('sortOrder')) {
      final l$sortOrder = sortOrder;
      result$data['sortOrder'] = l$sortOrder;
    }
    return result$data;
  }

  CopyWith$Input$ReorderInput<Input$ReorderInput> get copyWith =>
      CopyWith$Input$ReorderInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReorderInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$sortOrder = sortOrder;
    final lOther$sortOrder = other.sortOrder;
    if (_$data.containsKey('sortOrder') !=
        other._$data.containsKey('sortOrder')) {
      return false;
    }
    if (l$sortOrder != lOther$sortOrder) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$sortOrder = sortOrder;
    return Object.hashAll([
      l$id,
      _$data.containsKey('sortOrder') ? l$sortOrder : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReorderInput<TRes> {
  factory CopyWith$Input$ReorderInput(
    Input$ReorderInput instance,
    TRes Function(Input$ReorderInput) then,
  ) = _CopyWithImpl$Input$ReorderInput;

  factory CopyWith$Input$ReorderInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReorderInput;

  TRes call({
    String? id,
    int? sortOrder,
  });
}

class _CopyWithImpl$Input$ReorderInput<TRes>
    implements CopyWith$Input$ReorderInput<TRes> {
  _CopyWithImpl$Input$ReorderInput(
    this._instance,
    this._then,
  );

  final Input$ReorderInput _instance;

  final TRes Function(Input$ReorderInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? sortOrder = _undefined,
  }) =>
      _then(Input$ReorderInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (sortOrder != _undefined) 'sortOrder': (sortOrder as int?),
      }));
}

class _CopyWithStubImpl$Input$ReorderInput<TRes>
    implements CopyWith$Input$ReorderInput<TRes> {
  _CopyWithStubImpl$Input$ReorderInput(this._res);

  TRes _res;

  call({
    String? id,
    int? sortOrder,
  }) =>
      _res;
}

class Input$SaleChannelListingAddInput {
  factory Input$SaleChannelListingAddInput({
    required String channelId,
    required String discountValue,
  }) =>
      Input$SaleChannelListingAddInput._({
        r'channelId': channelId,
        r'discountValue': discountValue,
      });

  Input$SaleChannelListingAddInput._(this._$data);

  factory Input$SaleChannelListingAddInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$channelId = data['channelId'];
    result$data['channelId'] = (l$channelId as String);
    final l$discountValue = data['discountValue'];
    result$data['discountValue'] = (l$discountValue as String);
    return Input$SaleChannelListingAddInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get channelId => (_$data['channelId'] as String);

  String get discountValue => (_$data['discountValue'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$channelId = channelId;
    result$data['channelId'] = l$channelId;
    final l$discountValue = discountValue;
    result$data['discountValue'] = l$discountValue;
    return result$data;
  }

  CopyWith$Input$SaleChannelListingAddInput<Input$SaleChannelListingAddInput>
      get copyWith => CopyWith$Input$SaleChannelListingAddInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SaleChannelListingAddInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$channelId = channelId;
    final lOther$channelId = other.channelId;
    if (l$channelId != lOther$channelId) {
      return false;
    }
    final l$discountValue = discountValue;
    final lOther$discountValue = other.discountValue;
    if (l$discountValue != lOther$discountValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$channelId = channelId;
    final l$discountValue = discountValue;
    return Object.hashAll([
      l$channelId,
      l$discountValue,
    ]);
  }
}

abstract class CopyWith$Input$SaleChannelListingAddInput<TRes> {
  factory CopyWith$Input$SaleChannelListingAddInput(
    Input$SaleChannelListingAddInput instance,
    TRes Function(Input$SaleChannelListingAddInput) then,
  ) = _CopyWithImpl$Input$SaleChannelListingAddInput;

  factory CopyWith$Input$SaleChannelListingAddInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SaleChannelListingAddInput;

  TRes call({
    String? channelId,
    String? discountValue,
  });
}

class _CopyWithImpl$Input$SaleChannelListingAddInput<TRes>
    implements CopyWith$Input$SaleChannelListingAddInput<TRes> {
  _CopyWithImpl$Input$SaleChannelListingAddInput(
    this._instance,
    this._then,
  );

  final Input$SaleChannelListingAddInput _instance;

  final TRes Function(Input$SaleChannelListingAddInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? channelId = _undefined,
    Object? discountValue = _undefined,
  }) =>
      _then(Input$SaleChannelListingAddInput._({
        ..._instance._$data,
        if (channelId != _undefined && channelId != null)
          'channelId': (channelId as String),
        if (discountValue != _undefined && discountValue != null)
          'discountValue': (discountValue as String),
      }));
}

class _CopyWithStubImpl$Input$SaleChannelListingAddInput<TRes>
    implements CopyWith$Input$SaleChannelListingAddInput<TRes> {
  _CopyWithStubImpl$Input$SaleChannelListingAddInput(this._res);

  TRes _res;

  call({
    String? channelId,
    String? discountValue,
  }) =>
      _res;
}

class Input$SaleChannelListingInput {
  factory Input$SaleChannelListingInput({
    List<Input$SaleChannelListingAddInput>? addChannels,
    List<String>? removeChannels,
  }) =>
      Input$SaleChannelListingInput._({
        if (addChannels != null) r'addChannels': addChannels,
        if (removeChannels != null) r'removeChannels': removeChannels,
      });

  Input$SaleChannelListingInput._(this._$data);

  factory Input$SaleChannelListingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('addChannels')) {
      final l$addChannels = data['addChannels'];
      result$data['addChannels'] = (l$addChannels as List<dynamic>?)
          ?.map((e) => Input$SaleChannelListingAddInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('removeChannels')) {
      final l$removeChannels = data['removeChannels'];
      result$data['removeChannels'] = (l$removeChannels as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$SaleChannelListingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$SaleChannelListingAddInput>? get addChannels =>
      (_$data['addChannels'] as List<Input$SaleChannelListingAddInput>?);

  List<String>? get removeChannels =>
      (_$data['removeChannels'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('addChannels')) {
      final l$addChannels = addChannels;
      result$data['addChannels'] =
          l$addChannels?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('removeChannels')) {
      final l$removeChannels = removeChannels;
      result$data['removeChannels'] = l$removeChannels?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$SaleChannelListingInput<Input$SaleChannelListingInput>
      get copyWith => CopyWith$Input$SaleChannelListingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SaleChannelListingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$addChannels = addChannels;
    final lOther$addChannels = other.addChannels;
    if (_$data.containsKey('addChannels') !=
        other._$data.containsKey('addChannels')) {
      return false;
    }
    if (l$addChannels != null && lOther$addChannels != null) {
      if (l$addChannels.length != lOther$addChannels.length) {
        return false;
      }
      for (int i = 0; i < l$addChannels.length; i++) {
        final l$addChannels$entry = l$addChannels[i];
        final lOther$addChannels$entry = lOther$addChannels[i];
        if (l$addChannels$entry != lOther$addChannels$entry) {
          return false;
        }
      }
    } else if (l$addChannels != lOther$addChannels) {
      return false;
    }
    final l$removeChannels = removeChannels;
    final lOther$removeChannels = other.removeChannels;
    if (_$data.containsKey('removeChannels') !=
        other._$data.containsKey('removeChannels')) {
      return false;
    }
    if (l$removeChannels != null && lOther$removeChannels != null) {
      if (l$removeChannels.length != lOther$removeChannels.length) {
        return false;
      }
      for (int i = 0; i < l$removeChannels.length; i++) {
        final l$removeChannels$entry = l$removeChannels[i];
        final lOther$removeChannels$entry = lOther$removeChannels[i];
        if (l$removeChannels$entry != lOther$removeChannels$entry) {
          return false;
        }
      }
    } else if (l$removeChannels != lOther$removeChannels) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$addChannels = addChannels;
    final l$removeChannels = removeChannels;
    return Object.hashAll([
      _$data.containsKey('addChannels')
          ? l$addChannels == null
              ? null
              : Object.hashAll(l$addChannels.map((v) => v))
          : const {},
      _$data.containsKey('removeChannels')
          ? l$removeChannels == null
              ? null
              : Object.hashAll(l$removeChannels.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$SaleChannelListingInput<TRes> {
  factory CopyWith$Input$SaleChannelListingInput(
    Input$SaleChannelListingInput instance,
    TRes Function(Input$SaleChannelListingInput) then,
  ) = _CopyWithImpl$Input$SaleChannelListingInput;

  factory CopyWith$Input$SaleChannelListingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SaleChannelListingInput;

  TRes call({
    List<Input$SaleChannelListingAddInput>? addChannels,
    List<String>? removeChannels,
  });
  TRes addChannels(
      Iterable<Input$SaleChannelListingAddInput>? Function(
              Iterable<
                  CopyWith$Input$SaleChannelListingAddInput<
                      Input$SaleChannelListingAddInput>>?)
          _fn);
}

class _CopyWithImpl$Input$SaleChannelListingInput<TRes>
    implements CopyWith$Input$SaleChannelListingInput<TRes> {
  _CopyWithImpl$Input$SaleChannelListingInput(
    this._instance,
    this._then,
  );

  final Input$SaleChannelListingInput _instance;

  final TRes Function(Input$SaleChannelListingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? addChannels = _undefined,
    Object? removeChannels = _undefined,
  }) =>
      _then(Input$SaleChannelListingInput._({
        ..._instance._$data,
        if (addChannels != _undefined)
          'addChannels':
              (addChannels as List<Input$SaleChannelListingAddInput>?),
        if (removeChannels != _undefined)
          'removeChannels': (removeChannels as List<String>?),
      }));

  TRes addChannels(
          Iterable<Input$SaleChannelListingAddInput>? Function(
                  Iterable<
                      CopyWith$Input$SaleChannelListingAddInput<
                          Input$SaleChannelListingAddInput>>?)
              _fn) =>
      call(
          addChannels: _fn(_instance.addChannels
              ?.map((e) => CopyWith$Input$SaleChannelListingAddInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$SaleChannelListingInput<TRes>
    implements CopyWith$Input$SaleChannelListingInput<TRes> {
  _CopyWithStubImpl$Input$SaleChannelListingInput(this._res);

  TRes _res;

  call({
    List<Input$SaleChannelListingAddInput>? addChannels,
    List<String>? removeChannels,
  }) =>
      _res;

  addChannels(_fn) => _res;
}

class Input$SaleFilterInput {
  factory Input$SaleFilterInput({
    List<Enum$DiscountStatusEnum>? status,
    Enum$DiscountValueTypeEnum? saleType,
    Input$DateTimeRangeInput? started,
    String? search,
    List<Input$MetadataFilter>? metadata,
    Input$DateTimeRangeInput? updatedAt,
  }) =>
      Input$SaleFilterInput._({
        if (status != null) r'status': status,
        if (saleType != null) r'saleType': saleType,
        if (started != null) r'started': started,
        if (search != null) r'search': search,
        if (metadata != null) r'metadata': metadata,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Input$SaleFilterInput._(this._$data);

  factory Input$SaleFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as List<dynamic>?)
          ?.map((e) => fromJson$Enum$DiscountStatusEnum((e as String)))
          .toList();
    }
    if (data.containsKey('saleType')) {
      final l$saleType = data['saleType'];
      result$data['saleType'] = l$saleType == null
          ? null
          : fromJson$Enum$DiscountValueTypeEnum((l$saleType as String));
    }
    if (data.containsKey('started')) {
      final l$started = data['started'];
      result$data['started'] = l$started == null
          ? null
          : Input$DateTimeRangeInput.fromJson(
              (l$started as Map<String, dynamic>));
    }
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeRangeInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    return Input$SaleFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$DiscountStatusEnum>? get status =>
      (_$data['status'] as List<Enum$DiscountStatusEnum>?);

  Enum$DiscountValueTypeEnum? get saleType =>
      (_$data['saleType'] as Enum$DiscountValueTypeEnum?);

  Input$DateTimeRangeInput? get started =>
      (_$data['started'] as Input$DateTimeRangeInput?);

  String? get search => (_$data['search'] as String?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  Input$DateTimeRangeInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeRangeInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status?.map((e) => toJson$Enum$DiscountStatusEnum(e)).toList();
    }
    if (_$data.containsKey('saleType')) {
      final l$saleType = saleType;
      result$data['saleType'] = l$saleType == null
          ? null
          : toJson$Enum$DiscountValueTypeEnum(l$saleType);
    }
    if (_$data.containsKey('started')) {
      final l$started = started;
      result$data['started'] = l$started?.toJson();
    }
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SaleFilterInput<Input$SaleFilterInput> get copyWith =>
      CopyWith$Input$SaleFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SaleFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != null && lOther$status != null) {
      if (l$status.length != lOther$status.length) {
        return false;
      }
      for (int i = 0; i < l$status.length; i++) {
        final l$status$entry = l$status[i];
        final lOther$status$entry = lOther$status[i];
        if (l$status$entry != lOther$status$entry) {
          return false;
        }
      }
    } else if (l$status != lOther$status) {
      return false;
    }
    final l$saleType = saleType;
    final lOther$saleType = other.saleType;
    if (_$data.containsKey('saleType') !=
        other._$data.containsKey('saleType')) {
      return false;
    }
    if (l$saleType != lOther$saleType) {
      return false;
    }
    final l$started = started;
    final lOther$started = other.started;
    if (_$data.containsKey('started') != other._$data.containsKey('started')) {
      return false;
    }
    if (l$started != lOther$started) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$status = status;
    final l$saleType = saleType;
    final l$started = started;
    final l$search = search;
    final l$metadata = metadata;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('status')
          ? l$status == null
              ? null
              : Object.hashAll(l$status.map((v) => v))
          : const {},
      _$data.containsKey('saleType') ? l$saleType : const {},
      _$data.containsKey('started') ? l$started : const {},
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$SaleFilterInput<TRes> {
  factory CopyWith$Input$SaleFilterInput(
    Input$SaleFilterInput instance,
    TRes Function(Input$SaleFilterInput) then,
  ) = _CopyWithImpl$Input$SaleFilterInput;

  factory CopyWith$Input$SaleFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SaleFilterInput;

  TRes call({
    List<Enum$DiscountStatusEnum>? status,
    Enum$DiscountValueTypeEnum? saleType,
    Input$DateTimeRangeInput? started,
    String? search,
    List<Input$MetadataFilter>? metadata,
    Input$DateTimeRangeInput? updatedAt,
  });
  CopyWith$Input$DateTimeRangeInput<TRes> get started;
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$SaleFilterInput<TRes>
    implements CopyWith$Input$SaleFilterInput<TRes> {
  _CopyWithImpl$Input$SaleFilterInput(
    this._instance,
    this._then,
  );

  final Input$SaleFilterInput _instance;

  final TRes Function(Input$SaleFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? status = _undefined,
    Object? saleType = _undefined,
    Object? started = _undefined,
    Object? search = _undefined,
    Object? metadata = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Input$SaleFilterInput._({
        ..._instance._$data,
        if (status != _undefined)
          'status': (status as List<Enum$DiscountStatusEnum>?),
        if (saleType != _undefined)
          'saleType': (saleType as Enum$DiscountValueTypeEnum?),
        if (started != _undefined)
          'started': (started as Input$DateTimeRangeInput?),
        if (search != _undefined) 'search': (search as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeRangeInput?),
      }));

  CopyWith$Input$DateTimeRangeInput<TRes> get started {
    final local$started = _instance.started;
    return local$started == null
        ? CopyWith$Input$DateTimeRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeRangeInput(
            local$started, (e) => call(started: e));
  }

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeRangeInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }
}

class _CopyWithStubImpl$Input$SaleFilterInput<TRes>
    implements CopyWith$Input$SaleFilterInput<TRes> {
  _CopyWithStubImpl$Input$SaleFilterInput(this._res);

  TRes _res;

  call({
    List<Enum$DiscountStatusEnum>? status,
    Enum$DiscountValueTypeEnum? saleType,
    Input$DateTimeRangeInput? started,
    String? search,
    List<Input$MetadataFilter>? metadata,
    Input$DateTimeRangeInput? updatedAt,
  }) =>
      _res;

  CopyWith$Input$DateTimeRangeInput<TRes> get started =>
      CopyWith$Input$DateTimeRangeInput.stub(_res);

  metadata(_fn) => _res;

  CopyWith$Input$DateTimeRangeInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeRangeInput.stub(_res);
}

class Input$SaleInput {
  factory Input$SaleInput({
    String? name,
    Enum$DiscountValueTypeEnum? type,
    String? value,
    List<String>? products,
    List<String>? variants,
    List<String>? categories,
    List<String>? collections,
    String? startDate,
    String? endDate,
  }) =>
      Input$SaleInput._({
        if (name != null) r'name': name,
        if (type != null) r'type': type,
        if (value != null) r'value': value,
        if (products != null) r'products': products,
        if (variants != null) r'variants': variants,
        if (categories != null) r'categories': categories,
        if (collections != null) r'collections': collections,
        if (startDate != null) r'startDate': startDate,
        if (endDate != null) r'endDate': endDate,
      });

  Input$SaleInput._(this._$data);

  factory Input$SaleInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : fromJson$Enum$DiscountValueTypeEnum((l$type as String));
    }
    if (data.containsKey('value')) {
      final l$value = data['value'];
      result$data['value'] = (l$value as String?);
    }
    if (data.containsKey('products')) {
      final l$products = data['products'];
      result$data['products'] =
          (l$products as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('variants')) {
      final l$variants = data['variants'];
      result$data['variants'] =
          (l$variants as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('categories')) {
      final l$categories = data['categories'];
      result$data['categories'] =
          (l$categories as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('collections')) {
      final l$collections = data['collections'];
      result$data['collections'] =
          (l$collections as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('startDate')) {
      final l$startDate = data['startDate'];
      result$data['startDate'] = (l$startDate as String?);
    }
    if (data.containsKey('endDate')) {
      final l$endDate = data['endDate'];
      result$data['endDate'] = (l$endDate as String?);
    }
    return Input$SaleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  Enum$DiscountValueTypeEnum? get type =>
      (_$data['type'] as Enum$DiscountValueTypeEnum?);

  String? get value => (_$data['value'] as String?);

  List<String>? get products => (_$data['products'] as List<String>?);

  List<String>? get variants => (_$data['variants'] as List<String>?);

  List<String>? get categories => (_$data['categories'] as List<String>?);

  List<String>? get collections => (_$data['collections'] as List<String>?);

  String? get startDate => (_$data['startDate'] as String?);

  String? get endDate => (_$data['endDate'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] =
          l$type == null ? null : toJson$Enum$DiscountValueTypeEnum(l$type);
    }
    if (_$data.containsKey('value')) {
      final l$value = value;
      result$data['value'] = l$value;
    }
    if (_$data.containsKey('products')) {
      final l$products = products;
      result$data['products'] = l$products?.map((e) => e).toList();
    }
    if (_$data.containsKey('variants')) {
      final l$variants = variants;
      result$data['variants'] = l$variants?.map((e) => e).toList();
    }
    if (_$data.containsKey('categories')) {
      final l$categories = categories;
      result$data['categories'] = l$categories?.map((e) => e).toList();
    }
    if (_$data.containsKey('collections')) {
      final l$collections = collections;
      result$data['collections'] = l$collections?.map((e) => e).toList();
    }
    if (_$data.containsKey('startDate')) {
      final l$startDate = startDate;
      result$data['startDate'] = l$startDate;
    }
    if (_$data.containsKey('endDate')) {
      final l$endDate = endDate;
      result$data['endDate'] = l$endDate;
    }
    return result$data;
  }

  CopyWith$Input$SaleInput<Input$SaleInput> get copyWith =>
      CopyWith$Input$SaleInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SaleInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (_$data.containsKey('value') != other._$data.containsKey('value')) {
      return false;
    }
    if (l$value != lOther$value) {
      return false;
    }
    final l$products = products;
    final lOther$products = other.products;
    if (_$data.containsKey('products') !=
        other._$data.containsKey('products')) {
      return false;
    }
    if (l$products != null && lOther$products != null) {
      if (l$products.length != lOther$products.length) {
        return false;
      }
      for (int i = 0; i < l$products.length; i++) {
        final l$products$entry = l$products[i];
        final lOther$products$entry = lOther$products[i];
        if (l$products$entry != lOther$products$entry) {
          return false;
        }
      }
    } else if (l$products != lOther$products) {
      return false;
    }
    final l$variants = variants;
    final lOther$variants = other.variants;
    if (_$data.containsKey('variants') !=
        other._$data.containsKey('variants')) {
      return false;
    }
    if (l$variants != null && lOther$variants != null) {
      if (l$variants.length != lOther$variants.length) {
        return false;
      }
      for (int i = 0; i < l$variants.length; i++) {
        final l$variants$entry = l$variants[i];
        final lOther$variants$entry = lOther$variants[i];
        if (l$variants$entry != lOther$variants$entry) {
          return false;
        }
      }
    } else if (l$variants != lOther$variants) {
      return false;
    }
    final l$categories = categories;
    final lOther$categories = other.categories;
    if (_$data.containsKey('categories') !=
        other._$data.containsKey('categories')) {
      return false;
    }
    if (l$categories != null && lOther$categories != null) {
      if (l$categories.length != lOther$categories.length) {
        return false;
      }
      for (int i = 0; i < l$categories.length; i++) {
        final l$categories$entry = l$categories[i];
        final lOther$categories$entry = lOther$categories[i];
        if (l$categories$entry != lOther$categories$entry) {
          return false;
        }
      }
    } else if (l$categories != lOther$categories) {
      return false;
    }
    final l$collections = collections;
    final lOther$collections = other.collections;
    if (_$data.containsKey('collections') !=
        other._$data.containsKey('collections')) {
      return false;
    }
    if (l$collections != null && lOther$collections != null) {
      if (l$collections.length != lOther$collections.length) {
        return false;
      }
      for (int i = 0; i < l$collections.length; i++) {
        final l$collections$entry = l$collections[i];
        final lOther$collections$entry = lOther$collections[i];
        if (l$collections$entry != lOther$collections$entry) {
          return false;
        }
      }
    } else if (l$collections != lOther$collections) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (_$data.containsKey('startDate') !=
        other._$data.containsKey('startDate')) {
      return false;
    }
    if (l$startDate != lOther$startDate) {
      return false;
    }
    final l$endDate = endDate;
    final lOther$endDate = other.endDate;
    if (_$data.containsKey('endDate') != other._$data.containsKey('endDate')) {
      return false;
    }
    if (l$endDate != lOther$endDate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$type = type;
    final l$value = value;
    final l$products = products;
    final l$variants = variants;
    final l$categories = categories;
    final l$collections = collections;
    final l$startDate = startDate;
    final l$endDate = endDate;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('value') ? l$value : const {},
      _$data.containsKey('products')
          ? l$products == null
              ? null
              : Object.hashAll(l$products.map((v) => v))
          : const {},
      _$data.containsKey('variants')
          ? l$variants == null
              ? null
              : Object.hashAll(l$variants.map((v) => v))
          : const {},
      _$data.containsKey('categories')
          ? l$categories == null
              ? null
              : Object.hashAll(l$categories.map((v) => v))
          : const {},
      _$data.containsKey('collections')
          ? l$collections == null
              ? null
              : Object.hashAll(l$collections.map((v) => v))
          : const {},
      _$data.containsKey('startDate') ? l$startDate : const {},
      _$data.containsKey('endDate') ? l$endDate : const {},
    ]);
  }
}

abstract class CopyWith$Input$SaleInput<TRes> {
  factory CopyWith$Input$SaleInput(
    Input$SaleInput instance,
    TRes Function(Input$SaleInput) then,
  ) = _CopyWithImpl$Input$SaleInput;

  factory CopyWith$Input$SaleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SaleInput;

  TRes call({
    String? name,
    Enum$DiscountValueTypeEnum? type,
    String? value,
    List<String>? products,
    List<String>? variants,
    List<String>? categories,
    List<String>? collections,
    String? startDate,
    String? endDate,
  });
}

class _CopyWithImpl$Input$SaleInput<TRes>
    implements CopyWith$Input$SaleInput<TRes> {
  _CopyWithImpl$Input$SaleInput(
    this._instance,
    this._then,
  );

  final Input$SaleInput _instance;

  final TRes Function(Input$SaleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? type = _undefined,
    Object? value = _undefined,
    Object? products = _undefined,
    Object? variants = _undefined,
    Object? categories = _undefined,
    Object? collections = _undefined,
    Object? startDate = _undefined,
    Object? endDate = _undefined,
  }) =>
      _then(Input$SaleInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (type != _undefined) 'type': (type as Enum$DiscountValueTypeEnum?),
        if (value != _undefined) 'value': (value as String?),
        if (products != _undefined) 'products': (products as List<String>?),
        if (variants != _undefined) 'variants': (variants as List<String>?),
        if (categories != _undefined)
          'categories': (categories as List<String>?),
        if (collections != _undefined)
          'collections': (collections as List<String>?),
        if (startDate != _undefined) 'startDate': (startDate as String?),
        if (endDate != _undefined) 'endDate': (endDate as String?),
      }));
}

class _CopyWithStubImpl$Input$SaleInput<TRes>
    implements CopyWith$Input$SaleInput<TRes> {
  _CopyWithStubImpl$Input$SaleInput(this._res);

  TRes _res;

  call({
    String? name,
    Enum$DiscountValueTypeEnum? type,
    String? value,
    List<String>? products,
    List<String>? variants,
    List<String>? categories,
    List<String>? collections,
    String? startDate,
    String? endDate,
  }) =>
      _res;
}

class Input$SaleSortingInput {
  factory Input$SaleSortingInput({
    required Enum$OrderDirection direction,
    String? channel,
    required Enum$SaleSortField field,
  }) =>
      Input$SaleSortingInput._({
        r'direction': direction,
        if (channel != null) r'channel': channel,
        r'field': field,
      });

  Input$SaleSortingInput._(this._$data);

  factory Input$SaleSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    if (data.containsKey('channel')) {
      final l$channel = data['channel'];
      result$data['channel'] = (l$channel as String?);
    }
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$SaleSortField((l$field as String));
    return Input$SaleSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  String? get channel => (_$data['channel'] as String?);

  Enum$SaleSortField get field => (_$data['field'] as Enum$SaleSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    if (_$data.containsKey('channel')) {
      final l$channel = channel;
      result$data['channel'] = l$channel;
    }
    final l$field = field;
    result$data['field'] = toJson$Enum$SaleSortField(l$field);
    return result$data;
  }

  CopyWith$Input$SaleSortingInput<Input$SaleSortingInput> get copyWith =>
      CopyWith$Input$SaleSortingInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SaleSortingInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$channel = channel;
    final lOther$channel = other.channel;
    if (_$data.containsKey('channel') != other._$data.containsKey('channel')) {
      return false;
    }
    if (l$channel != lOther$channel) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$channel = channel;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      _$data.containsKey('channel') ? l$channel : const {},
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$SaleSortingInput<TRes> {
  factory CopyWith$Input$SaleSortingInput(
    Input$SaleSortingInput instance,
    TRes Function(Input$SaleSortingInput) then,
  ) = _CopyWithImpl$Input$SaleSortingInput;

  factory CopyWith$Input$SaleSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SaleSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    String? channel,
    Enum$SaleSortField? field,
  });
}

class _CopyWithImpl$Input$SaleSortingInput<TRes>
    implements CopyWith$Input$SaleSortingInput<TRes> {
  _CopyWithImpl$Input$SaleSortingInput(
    this._instance,
    this._then,
  );

  final Input$SaleSortingInput _instance;

  final TRes Function(Input$SaleSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? channel = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$SaleSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (channel != _undefined) 'channel': (channel as String?),
        if (field != _undefined && field != null)
          'field': (field as Enum$SaleSortField),
      }));
}

class _CopyWithStubImpl$Input$SaleSortingInput<TRes>
    implements CopyWith$Input$SaleSortingInput<TRes> {
  _CopyWithStubImpl$Input$SaleSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    String? channel,
    Enum$SaleSortField? field,
  }) =>
      _res;
}

class Input$SeoInput {
  factory Input$SeoInput({
    String? title,
    String? description,
  }) =>
      Input$SeoInput._({
        if (title != null) r'title': title,
        if (description != null) r'description': description,
      });

  Input$SeoInput._(this._$data);

  factory Input$SeoInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    return Input$SeoInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get title => (_$data['title'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    return result$data;
  }

  CopyWith$Input$SeoInput<Input$SeoInput> get copyWith =>
      CopyWith$Input$SeoInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SeoInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$title = title;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$SeoInput<TRes> {
  factory CopyWith$Input$SeoInput(
    Input$SeoInput instance,
    TRes Function(Input$SeoInput) then,
  ) = _CopyWithImpl$Input$SeoInput;

  factory CopyWith$Input$SeoInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SeoInput;

  TRes call({
    String? title,
    String? description,
  });
}

class _CopyWithImpl$Input$SeoInput<TRes>
    implements CopyWith$Input$SeoInput<TRes> {
  _CopyWithImpl$Input$SeoInput(
    this._instance,
    this._then,
  );

  final Input$SeoInput _instance;

  final TRes Function(Input$SeoInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? title = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$SeoInput._({
        ..._instance._$data,
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
      }));
}

class _CopyWithStubImpl$Input$SeoInput<TRes>
    implements CopyWith$Input$SeoInput<TRes> {
  _CopyWithStubImpl$Input$SeoInput(this._res);

  TRes _res;

  call({
    String? title,
    String? description,
  }) =>
      _res;
}

class Input$ShippingMethodChannelListingAddInput {
  factory Input$ShippingMethodChannelListingAddInput({
    required String channelId,
    String? price,
    String? minimumOrderPrice,
    String? maximumOrderPrice,
  }) =>
      Input$ShippingMethodChannelListingAddInput._({
        r'channelId': channelId,
        if (price != null) r'price': price,
        if (minimumOrderPrice != null) r'minimumOrderPrice': minimumOrderPrice,
        if (maximumOrderPrice != null) r'maximumOrderPrice': maximumOrderPrice,
      });

  Input$ShippingMethodChannelListingAddInput._(this._$data);

  factory Input$ShippingMethodChannelListingAddInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$channelId = data['channelId'];
    result$data['channelId'] = (l$channelId as String);
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] = (l$price as String?);
    }
    if (data.containsKey('minimumOrderPrice')) {
      final l$minimumOrderPrice = data['minimumOrderPrice'];
      result$data['minimumOrderPrice'] = (l$minimumOrderPrice as String?);
    }
    if (data.containsKey('maximumOrderPrice')) {
      final l$maximumOrderPrice = data['maximumOrderPrice'];
      result$data['maximumOrderPrice'] = (l$maximumOrderPrice as String?);
    }
    return Input$ShippingMethodChannelListingAddInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get channelId => (_$data['channelId'] as String);

  String? get price => (_$data['price'] as String?);

  String? get minimumOrderPrice => (_$data['minimumOrderPrice'] as String?);

  String? get maximumOrderPrice => (_$data['maximumOrderPrice'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$channelId = channelId;
    result$data['channelId'] = l$channelId;
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] = l$price;
    }
    if (_$data.containsKey('minimumOrderPrice')) {
      final l$minimumOrderPrice = minimumOrderPrice;
      result$data['minimumOrderPrice'] = l$minimumOrderPrice;
    }
    if (_$data.containsKey('maximumOrderPrice')) {
      final l$maximumOrderPrice = maximumOrderPrice;
      result$data['maximumOrderPrice'] = l$maximumOrderPrice;
    }
    return result$data;
  }

  CopyWith$Input$ShippingMethodChannelListingAddInput<
          Input$ShippingMethodChannelListingAddInput>
      get copyWith => CopyWith$Input$ShippingMethodChannelListingAddInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ShippingMethodChannelListingAddInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$channelId = channelId;
    final lOther$channelId = other.channelId;
    if (l$channelId != lOther$channelId) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$minimumOrderPrice = minimumOrderPrice;
    final lOther$minimumOrderPrice = other.minimumOrderPrice;
    if (_$data.containsKey('minimumOrderPrice') !=
        other._$data.containsKey('minimumOrderPrice')) {
      return false;
    }
    if (l$minimumOrderPrice != lOther$minimumOrderPrice) {
      return false;
    }
    final l$maximumOrderPrice = maximumOrderPrice;
    final lOther$maximumOrderPrice = other.maximumOrderPrice;
    if (_$data.containsKey('maximumOrderPrice') !=
        other._$data.containsKey('maximumOrderPrice')) {
      return false;
    }
    if (l$maximumOrderPrice != lOther$maximumOrderPrice) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$channelId = channelId;
    final l$price = price;
    final l$minimumOrderPrice = minimumOrderPrice;
    final l$maximumOrderPrice = maximumOrderPrice;
    return Object.hashAll([
      l$channelId,
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('minimumOrderPrice') ? l$minimumOrderPrice : const {},
      _$data.containsKey('maximumOrderPrice') ? l$maximumOrderPrice : const {},
    ]);
  }
}

abstract class CopyWith$Input$ShippingMethodChannelListingAddInput<TRes> {
  factory CopyWith$Input$ShippingMethodChannelListingAddInput(
    Input$ShippingMethodChannelListingAddInput instance,
    TRes Function(Input$ShippingMethodChannelListingAddInput) then,
  ) = _CopyWithImpl$Input$ShippingMethodChannelListingAddInput;

  factory CopyWith$Input$ShippingMethodChannelListingAddInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ShippingMethodChannelListingAddInput;

  TRes call({
    String? channelId,
    String? price,
    String? minimumOrderPrice,
    String? maximumOrderPrice,
  });
}

class _CopyWithImpl$Input$ShippingMethodChannelListingAddInput<TRes>
    implements CopyWith$Input$ShippingMethodChannelListingAddInput<TRes> {
  _CopyWithImpl$Input$ShippingMethodChannelListingAddInput(
    this._instance,
    this._then,
  );

  final Input$ShippingMethodChannelListingAddInput _instance;

  final TRes Function(Input$ShippingMethodChannelListingAddInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? channelId = _undefined,
    Object? price = _undefined,
    Object? minimumOrderPrice = _undefined,
    Object? maximumOrderPrice = _undefined,
  }) =>
      _then(Input$ShippingMethodChannelListingAddInput._({
        ..._instance._$data,
        if (channelId != _undefined && channelId != null)
          'channelId': (channelId as String),
        if (price != _undefined) 'price': (price as String?),
        if (minimumOrderPrice != _undefined)
          'minimumOrderPrice': (minimumOrderPrice as String?),
        if (maximumOrderPrice != _undefined)
          'maximumOrderPrice': (maximumOrderPrice as String?),
      }));
}

class _CopyWithStubImpl$Input$ShippingMethodChannelListingAddInput<TRes>
    implements CopyWith$Input$ShippingMethodChannelListingAddInput<TRes> {
  _CopyWithStubImpl$Input$ShippingMethodChannelListingAddInput(this._res);

  TRes _res;

  call({
    String? channelId,
    String? price,
    String? minimumOrderPrice,
    String? maximumOrderPrice,
  }) =>
      _res;
}

class Input$ShippingMethodChannelListingInput {
  factory Input$ShippingMethodChannelListingInput({
    List<Input$ShippingMethodChannelListingAddInput>? addChannels,
    List<String>? removeChannels,
  }) =>
      Input$ShippingMethodChannelListingInput._({
        if (addChannels != null) r'addChannels': addChannels,
        if (removeChannels != null) r'removeChannels': removeChannels,
      });

  Input$ShippingMethodChannelListingInput._(this._$data);

  factory Input$ShippingMethodChannelListingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('addChannels')) {
      final l$addChannels = data['addChannels'];
      result$data['addChannels'] = (l$addChannels as List<dynamic>?)
          ?.map((e) => Input$ShippingMethodChannelListingAddInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('removeChannels')) {
      final l$removeChannels = data['removeChannels'];
      result$data['removeChannels'] = (l$removeChannels as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$ShippingMethodChannelListingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ShippingMethodChannelListingAddInput>? get addChannels =>
      (_$data['addChannels']
          as List<Input$ShippingMethodChannelListingAddInput>?);

  List<String>? get removeChannels =>
      (_$data['removeChannels'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('addChannels')) {
      final l$addChannels = addChannels;
      result$data['addChannels'] =
          l$addChannels?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('removeChannels')) {
      final l$removeChannels = removeChannels;
      result$data['removeChannels'] = l$removeChannels?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$ShippingMethodChannelListingInput<
          Input$ShippingMethodChannelListingInput>
      get copyWith => CopyWith$Input$ShippingMethodChannelListingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ShippingMethodChannelListingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$addChannels = addChannels;
    final lOther$addChannels = other.addChannels;
    if (_$data.containsKey('addChannels') !=
        other._$data.containsKey('addChannels')) {
      return false;
    }
    if (l$addChannels != null && lOther$addChannels != null) {
      if (l$addChannels.length != lOther$addChannels.length) {
        return false;
      }
      for (int i = 0; i < l$addChannels.length; i++) {
        final l$addChannels$entry = l$addChannels[i];
        final lOther$addChannels$entry = lOther$addChannels[i];
        if (l$addChannels$entry != lOther$addChannels$entry) {
          return false;
        }
      }
    } else if (l$addChannels != lOther$addChannels) {
      return false;
    }
    final l$removeChannels = removeChannels;
    final lOther$removeChannels = other.removeChannels;
    if (_$data.containsKey('removeChannels') !=
        other._$data.containsKey('removeChannels')) {
      return false;
    }
    if (l$removeChannels != null && lOther$removeChannels != null) {
      if (l$removeChannels.length != lOther$removeChannels.length) {
        return false;
      }
      for (int i = 0; i < l$removeChannels.length; i++) {
        final l$removeChannels$entry = l$removeChannels[i];
        final lOther$removeChannels$entry = lOther$removeChannels[i];
        if (l$removeChannels$entry != lOther$removeChannels$entry) {
          return false;
        }
      }
    } else if (l$removeChannels != lOther$removeChannels) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$addChannels = addChannels;
    final l$removeChannels = removeChannels;
    return Object.hashAll([
      _$data.containsKey('addChannels')
          ? l$addChannels == null
              ? null
              : Object.hashAll(l$addChannels.map((v) => v))
          : const {},
      _$data.containsKey('removeChannels')
          ? l$removeChannels == null
              ? null
              : Object.hashAll(l$removeChannels.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ShippingMethodChannelListingInput<TRes> {
  factory CopyWith$Input$ShippingMethodChannelListingInput(
    Input$ShippingMethodChannelListingInput instance,
    TRes Function(Input$ShippingMethodChannelListingInput) then,
  ) = _CopyWithImpl$Input$ShippingMethodChannelListingInput;

  factory CopyWith$Input$ShippingMethodChannelListingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ShippingMethodChannelListingInput;

  TRes call({
    List<Input$ShippingMethodChannelListingAddInput>? addChannels,
    List<String>? removeChannels,
  });
  TRes addChannels(
      Iterable<Input$ShippingMethodChannelListingAddInput>? Function(
              Iterable<
                  CopyWith$Input$ShippingMethodChannelListingAddInput<
                      Input$ShippingMethodChannelListingAddInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ShippingMethodChannelListingInput<TRes>
    implements CopyWith$Input$ShippingMethodChannelListingInput<TRes> {
  _CopyWithImpl$Input$ShippingMethodChannelListingInput(
    this._instance,
    this._then,
  );

  final Input$ShippingMethodChannelListingInput _instance;

  final TRes Function(Input$ShippingMethodChannelListingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? addChannels = _undefined,
    Object? removeChannels = _undefined,
  }) =>
      _then(Input$ShippingMethodChannelListingInput._({
        ..._instance._$data,
        if (addChannels != _undefined)
          'addChannels': (addChannels
              as List<Input$ShippingMethodChannelListingAddInput>?),
        if (removeChannels != _undefined)
          'removeChannels': (removeChannels as List<String>?),
      }));

  TRes addChannels(
          Iterable<Input$ShippingMethodChannelListingAddInput>? Function(
                  Iterable<
                      CopyWith$Input$ShippingMethodChannelListingAddInput<
                          Input$ShippingMethodChannelListingAddInput>>?)
              _fn) =>
      call(
          addChannels: _fn(_instance.addChannels
              ?.map((e) => CopyWith$Input$ShippingMethodChannelListingAddInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ShippingMethodChannelListingInput<TRes>
    implements CopyWith$Input$ShippingMethodChannelListingInput<TRes> {
  _CopyWithStubImpl$Input$ShippingMethodChannelListingInput(this._res);

  TRes _res;

  call({
    List<Input$ShippingMethodChannelListingAddInput>? addChannels,
    List<String>? removeChannels,
  }) =>
      _res;

  addChannels(_fn) => _res;
}

class Input$ShippingPostalCodeRulesCreateInputRange {
  factory Input$ShippingPostalCodeRulesCreateInputRange({
    required String start,
    String? end,
  }) =>
      Input$ShippingPostalCodeRulesCreateInputRange._({
        r'start': start,
        if (end != null) r'end': end,
      });

  Input$ShippingPostalCodeRulesCreateInputRange._(this._$data);

  factory Input$ShippingPostalCodeRulesCreateInputRange.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$start = data['start'];
    result$data['start'] = (l$start as String);
    if (data.containsKey('end')) {
      final l$end = data['end'];
      result$data['end'] = (l$end as String?);
    }
    return Input$ShippingPostalCodeRulesCreateInputRange._(result$data);
  }

  Map<String, dynamic> _$data;

  String get start => (_$data['start'] as String);

  String? get end => (_$data['end'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$start = start;
    result$data['start'] = l$start;
    if (_$data.containsKey('end')) {
      final l$end = end;
      result$data['end'] = l$end;
    }
    return result$data;
  }

  CopyWith$Input$ShippingPostalCodeRulesCreateInputRange<
          Input$ShippingPostalCodeRulesCreateInputRange>
      get copyWith => CopyWith$Input$ShippingPostalCodeRulesCreateInputRange(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ShippingPostalCodeRulesCreateInputRange ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$start = start;
    final lOther$start = other.start;
    if (l$start != lOther$start) {
      return false;
    }
    final l$end = end;
    final lOther$end = other.end;
    if (_$data.containsKey('end') != other._$data.containsKey('end')) {
      return false;
    }
    if (l$end != lOther$end) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$start = start;
    final l$end = end;
    return Object.hashAll([
      l$start,
      _$data.containsKey('end') ? l$end : const {},
    ]);
  }
}

abstract class CopyWith$Input$ShippingPostalCodeRulesCreateInputRange<TRes> {
  factory CopyWith$Input$ShippingPostalCodeRulesCreateInputRange(
    Input$ShippingPostalCodeRulesCreateInputRange instance,
    TRes Function(Input$ShippingPostalCodeRulesCreateInputRange) then,
  ) = _CopyWithImpl$Input$ShippingPostalCodeRulesCreateInputRange;

  factory CopyWith$Input$ShippingPostalCodeRulesCreateInputRange.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ShippingPostalCodeRulesCreateInputRange;

  TRes call({
    String? start,
    String? end,
  });
}

class _CopyWithImpl$Input$ShippingPostalCodeRulesCreateInputRange<TRes>
    implements CopyWith$Input$ShippingPostalCodeRulesCreateInputRange<TRes> {
  _CopyWithImpl$Input$ShippingPostalCodeRulesCreateInputRange(
    this._instance,
    this._then,
  );

  final Input$ShippingPostalCodeRulesCreateInputRange _instance;

  final TRes Function(Input$ShippingPostalCodeRulesCreateInputRange) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? start = _undefined,
    Object? end = _undefined,
  }) =>
      _then(Input$ShippingPostalCodeRulesCreateInputRange._({
        ..._instance._$data,
        if (start != _undefined && start != null) 'start': (start as String),
        if (end != _undefined) 'end': (end as String?),
      }));
}

class _CopyWithStubImpl$Input$ShippingPostalCodeRulesCreateInputRange<TRes>
    implements CopyWith$Input$ShippingPostalCodeRulesCreateInputRange<TRes> {
  _CopyWithStubImpl$Input$ShippingPostalCodeRulesCreateInputRange(this._res);

  TRes _res;

  call({
    String? start,
    String? end,
  }) =>
      _res;
}

class Input$ShippingPriceExcludeProductsInput {
  factory Input$ShippingPriceExcludeProductsInput(
          {required List<String> products}) =>
      Input$ShippingPriceExcludeProductsInput._({
        r'products': products,
      });

  Input$ShippingPriceExcludeProductsInput._(this._$data);

  factory Input$ShippingPriceExcludeProductsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$products = data['products'];
    result$data['products'] =
        (l$products as List<dynamic>).map((e) => (e as String)).toList();
    return Input$ShippingPriceExcludeProductsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String> get products => (_$data['products'] as List<String>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$products = products;
    result$data['products'] = l$products.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$ShippingPriceExcludeProductsInput<
          Input$ShippingPriceExcludeProductsInput>
      get copyWith => CopyWith$Input$ShippingPriceExcludeProductsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ShippingPriceExcludeProductsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$products = products;
    final lOther$products = other.products;
    if (l$products.length != lOther$products.length) {
      return false;
    }
    for (int i = 0; i < l$products.length; i++) {
      final l$products$entry = l$products[i];
      final lOther$products$entry = lOther$products[i];
      if (l$products$entry != lOther$products$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$products = products;
    return Object.hashAll([Object.hashAll(l$products.map((v) => v))]);
  }
}

abstract class CopyWith$Input$ShippingPriceExcludeProductsInput<TRes> {
  factory CopyWith$Input$ShippingPriceExcludeProductsInput(
    Input$ShippingPriceExcludeProductsInput instance,
    TRes Function(Input$ShippingPriceExcludeProductsInput) then,
  ) = _CopyWithImpl$Input$ShippingPriceExcludeProductsInput;

  factory CopyWith$Input$ShippingPriceExcludeProductsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ShippingPriceExcludeProductsInput;

  TRes call({List<String>? products});
}

class _CopyWithImpl$Input$ShippingPriceExcludeProductsInput<TRes>
    implements CopyWith$Input$ShippingPriceExcludeProductsInput<TRes> {
  _CopyWithImpl$Input$ShippingPriceExcludeProductsInput(
    this._instance,
    this._then,
  );

  final Input$ShippingPriceExcludeProductsInput _instance;

  final TRes Function(Input$ShippingPriceExcludeProductsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? products = _undefined}) =>
      _then(Input$ShippingPriceExcludeProductsInput._({
        ..._instance._$data,
        if (products != _undefined && products != null)
          'products': (products as List<String>),
      }));
}

class _CopyWithStubImpl$Input$ShippingPriceExcludeProductsInput<TRes>
    implements CopyWith$Input$ShippingPriceExcludeProductsInput<TRes> {
  _CopyWithStubImpl$Input$ShippingPriceExcludeProductsInput(this._res);

  TRes _res;

  call({List<String>? products}) => _res;
}

class Input$ShippingPriceInput {
  factory Input$ShippingPriceInput({
    String? name,
    String? description,
    String? minimumOrderWeight,
    String? maximumOrderWeight,
    int? maximumDeliveryDays,
    int? minimumDeliveryDays,
    Enum$ShippingMethodTypeEnum? type,
    String? shippingZone,
    List<Input$ShippingPostalCodeRulesCreateInputRange>? addPostalCodeRules,
    List<String>? deletePostalCodeRules,
    Enum$PostalCodeRuleInclusionTypeEnum? inclusionType,
    String? taxClass,
  }) =>
      Input$ShippingPriceInput._({
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (minimumOrderWeight != null)
          r'minimumOrderWeight': minimumOrderWeight,
        if (maximumOrderWeight != null)
          r'maximumOrderWeight': maximumOrderWeight,
        if (maximumDeliveryDays != null)
          r'maximumDeliveryDays': maximumDeliveryDays,
        if (minimumDeliveryDays != null)
          r'minimumDeliveryDays': minimumDeliveryDays,
        if (type != null) r'type': type,
        if (shippingZone != null) r'shippingZone': shippingZone,
        if (addPostalCodeRules != null)
          r'addPostalCodeRules': addPostalCodeRules,
        if (deletePostalCodeRules != null)
          r'deletePostalCodeRules': deletePostalCodeRules,
        if (inclusionType != null) r'inclusionType': inclusionType,
        if (taxClass != null) r'taxClass': taxClass,
      });

  Input$ShippingPriceInput._(this._$data);

  factory Input$ShippingPriceInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('minimumOrderWeight')) {
      final l$minimumOrderWeight = data['minimumOrderWeight'];
      result$data['minimumOrderWeight'] = (l$minimumOrderWeight as String?);
    }
    if (data.containsKey('maximumOrderWeight')) {
      final l$maximumOrderWeight = data['maximumOrderWeight'];
      result$data['maximumOrderWeight'] = (l$maximumOrderWeight as String?);
    }
    if (data.containsKey('maximumDeliveryDays')) {
      final l$maximumDeliveryDays = data['maximumDeliveryDays'];
      result$data['maximumDeliveryDays'] = (l$maximumDeliveryDays as int?);
    }
    if (data.containsKey('minimumDeliveryDays')) {
      final l$minimumDeliveryDays = data['minimumDeliveryDays'];
      result$data['minimumDeliveryDays'] = (l$minimumDeliveryDays as int?);
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : fromJson$Enum$ShippingMethodTypeEnum((l$type as String));
    }
    if (data.containsKey('shippingZone')) {
      final l$shippingZone = data['shippingZone'];
      result$data['shippingZone'] = (l$shippingZone as String?);
    }
    if (data.containsKey('addPostalCodeRules')) {
      final l$addPostalCodeRules = data['addPostalCodeRules'];
      result$data['addPostalCodeRules'] = (l$addPostalCodeRules
              as List<dynamic>?)
          ?.map((e) => Input$ShippingPostalCodeRulesCreateInputRange.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deletePostalCodeRules')) {
      final l$deletePostalCodeRules = data['deletePostalCodeRules'];
      result$data['deletePostalCodeRules'] =
          (l$deletePostalCodeRules as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('inclusionType')) {
      final l$inclusionType = data['inclusionType'];
      result$data['inclusionType'] = l$inclusionType == null
          ? null
          : fromJson$Enum$PostalCodeRuleInclusionTypeEnum(
              (l$inclusionType as String));
    }
    if (data.containsKey('taxClass')) {
      final l$taxClass = data['taxClass'];
      result$data['taxClass'] = (l$taxClass as String?);
    }
    return Input$ShippingPriceInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get minimumOrderWeight => (_$data['minimumOrderWeight'] as String?);

  String? get maximumOrderWeight => (_$data['maximumOrderWeight'] as String?);

  int? get maximumDeliveryDays => (_$data['maximumDeliveryDays'] as int?);

  int? get minimumDeliveryDays => (_$data['minimumDeliveryDays'] as int?);

  Enum$ShippingMethodTypeEnum? get type =>
      (_$data['type'] as Enum$ShippingMethodTypeEnum?);

  String? get shippingZone => (_$data['shippingZone'] as String?);

  List<Input$ShippingPostalCodeRulesCreateInputRange>? get addPostalCodeRules =>
      (_$data['addPostalCodeRules']
          as List<Input$ShippingPostalCodeRulesCreateInputRange>?);

  List<String>? get deletePostalCodeRules =>
      (_$data['deletePostalCodeRules'] as List<String>?);

  Enum$PostalCodeRuleInclusionTypeEnum? get inclusionType =>
      (_$data['inclusionType'] as Enum$PostalCodeRuleInclusionTypeEnum?);

  String? get taxClass => (_$data['taxClass'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('minimumOrderWeight')) {
      final l$minimumOrderWeight = minimumOrderWeight;
      result$data['minimumOrderWeight'] = l$minimumOrderWeight;
    }
    if (_$data.containsKey('maximumOrderWeight')) {
      final l$maximumOrderWeight = maximumOrderWeight;
      result$data['maximumOrderWeight'] = l$maximumOrderWeight;
    }
    if (_$data.containsKey('maximumDeliveryDays')) {
      final l$maximumDeliveryDays = maximumDeliveryDays;
      result$data['maximumDeliveryDays'] = l$maximumDeliveryDays;
    }
    if (_$data.containsKey('minimumDeliveryDays')) {
      final l$minimumDeliveryDays = minimumDeliveryDays;
      result$data['minimumDeliveryDays'] = l$minimumDeliveryDays;
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] =
          l$type == null ? null : toJson$Enum$ShippingMethodTypeEnum(l$type);
    }
    if (_$data.containsKey('shippingZone')) {
      final l$shippingZone = shippingZone;
      result$data['shippingZone'] = l$shippingZone;
    }
    if (_$data.containsKey('addPostalCodeRules')) {
      final l$addPostalCodeRules = addPostalCodeRules;
      result$data['addPostalCodeRules'] =
          l$addPostalCodeRules?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deletePostalCodeRules')) {
      final l$deletePostalCodeRules = deletePostalCodeRules;
      result$data['deletePostalCodeRules'] =
          l$deletePostalCodeRules?.map((e) => e).toList();
    }
    if (_$data.containsKey('inclusionType')) {
      final l$inclusionType = inclusionType;
      result$data['inclusionType'] = l$inclusionType == null
          ? null
          : toJson$Enum$PostalCodeRuleInclusionTypeEnum(l$inclusionType);
    }
    if (_$data.containsKey('taxClass')) {
      final l$taxClass = taxClass;
      result$data['taxClass'] = l$taxClass;
    }
    return result$data;
  }

  CopyWith$Input$ShippingPriceInput<Input$ShippingPriceInput> get copyWith =>
      CopyWith$Input$ShippingPriceInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ShippingPriceInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$minimumOrderWeight = minimumOrderWeight;
    final lOther$minimumOrderWeight = other.minimumOrderWeight;
    if (_$data.containsKey('minimumOrderWeight') !=
        other._$data.containsKey('minimumOrderWeight')) {
      return false;
    }
    if (l$minimumOrderWeight != lOther$minimumOrderWeight) {
      return false;
    }
    final l$maximumOrderWeight = maximumOrderWeight;
    final lOther$maximumOrderWeight = other.maximumOrderWeight;
    if (_$data.containsKey('maximumOrderWeight') !=
        other._$data.containsKey('maximumOrderWeight')) {
      return false;
    }
    if (l$maximumOrderWeight != lOther$maximumOrderWeight) {
      return false;
    }
    final l$maximumDeliveryDays = maximumDeliveryDays;
    final lOther$maximumDeliveryDays = other.maximumDeliveryDays;
    if (_$data.containsKey('maximumDeliveryDays') !=
        other._$data.containsKey('maximumDeliveryDays')) {
      return false;
    }
    if (l$maximumDeliveryDays != lOther$maximumDeliveryDays) {
      return false;
    }
    final l$minimumDeliveryDays = minimumDeliveryDays;
    final lOther$minimumDeliveryDays = other.minimumDeliveryDays;
    if (_$data.containsKey('minimumDeliveryDays') !=
        other._$data.containsKey('minimumDeliveryDays')) {
      return false;
    }
    if (l$minimumDeliveryDays != lOther$minimumDeliveryDays) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$shippingZone = shippingZone;
    final lOther$shippingZone = other.shippingZone;
    if (_$data.containsKey('shippingZone') !=
        other._$data.containsKey('shippingZone')) {
      return false;
    }
    if (l$shippingZone != lOther$shippingZone) {
      return false;
    }
    final l$addPostalCodeRules = addPostalCodeRules;
    final lOther$addPostalCodeRules = other.addPostalCodeRules;
    if (_$data.containsKey('addPostalCodeRules') !=
        other._$data.containsKey('addPostalCodeRules')) {
      return false;
    }
    if (l$addPostalCodeRules != null && lOther$addPostalCodeRules != null) {
      if (l$addPostalCodeRules.length != lOther$addPostalCodeRules.length) {
        return false;
      }
      for (int i = 0; i < l$addPostalCodeRules.length; i++) {
        final l$addPostalCodeRules$entry = l$addPostalCodeRules[i];
        final lOther$addPostalCodeRules$entry = lOther$addPostalCodeRules[i];
        if (l$addPostalCodeRules$entry != lOther$addPostalCodeRules$entry) {
          return false;
        }
      }
    } else if (l$addPostalCodeRules != lOther$addPostalCodeRules) {
      return false;
    }
    final l$deletePostalCodeRules = deletePostalCodeRules;
    final lOther$deletePostalCodeRules = other.deletePostalCodeRules;
    if (_$data.containsKey('deletePostalCodeRules') !=
        other._$data.containsKey('deletePostalCodeRules')) {
      return false;
    }
    if (l$deletePostalCodeRules != null &&
        lOther$deletePostalCodeRules != null) {
      if (l$deletePostalCodeRules.length !=
          lOther$deletePostalCodeRules.length) {
        return false;
      }
      for (int i = 0; i < l$deletePostalCodeRules.length; i++) {
        final l$deletePostalCodeRules$entry = l$deletePostalCodeRules[i];
        final lOther$deletePostalCodeRules$entry =
            lOther$deletePostalCodeRules[i];
        if (l$deletePostalCodeRules$entry !=
            lOther$deletePostalCodeRules$entry) {
          return false;
        }
      }
    } else if (l$deletePostalCodeRules != lOther$deletePostalCodeRules) {
      return false;
    }
    final l$inclusionType = inclusionType;
    final lOther$inclusionType = other.inclusionType;
    if (_$data.containsKey('inclusionType') !=
        other._$data.containsKey('inclusionType')) {
      return false;
    }
    if (l$inclusionType != lOther$inclusionType) {
      return false;
    }
    final l$taxClass = taxClass;
    final lOther$taxClass = other.taxClass;
    if (_$data.containsKey('taxClass') !=
        other._$data.containsKey('taxClass')) {
      return false;
    }
    if (l$taxClass != lOther$taxClass) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    final l$minimumOrderWeight = minimumOrderWeight;
    final l$maximumOrderWeight = maximumOrderWeight;
    final l$maximumDeliveryDays = maximumDeliveryDays;
    final l$minimumDeliveryDays = minimumDeliveryDays;
    final l$type = type;
    final l$shippingZone = shippingZone;
    final l$addPostalCodeRules = addPostalCodeRules;
    final l$deletePostalCodeRules = deletePostalCodeRules;
    final l$inclusionType = inclusionType;
    final l$taxClass = taxClass;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('minimumOrderWeight')
          ? l$minimumOrderWeight
          : const {},
      _$data.containsKey('maximumOrderWeight')
          ? l$maximumOrderWeight
          : const {},
      _$data.containsKey('maximumDeliveryDays')
          ? l$maximumDeliveryDays
          : const {},
      _$data.containsKey('minimumDeliveryDays')
          ? l$minimumDeliveryDays
          : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('shippingZone') ? l$shippingZone : const {},
      _$data.containsKey('addPostalCodeRules')
          ? l$addPostalCodeRules == null
              ? null
              : Object.hashAll(l$addPostalCodeRules.map((v) => v))
          : const {},
      _$data.containsKey('deletePostalCodeRules')
          ? l$deletePostalCodeRules == null
              ? null
              : Object.hashAll(l$deletePostalCodeRules.map((v) => v))
          : const {},
      _$data.containsKey('inclusionType') ? l$inclusionType : const {},
      _$data.containsKey('taxClass') ? l$taxClass : const {},
    ]);
  }
}

abstract class CopyWith$Input$ShippingPriceInput<TRes> {
  factory CopyWith$Input$ShippingPriceInput(
    Input$ShippingPriceInput instance,
    TRes Function(Input$ShippingPriceInput) then,
  ) = _CopyWithImpl$Input$ShippingPriceInput;

  factory CopyWith$Input$ShippingPriceInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ShippingPriceInput;

  TRes call({
    String? name,
    String? description,
    String? minimumOrderWeight,
    String? maximumOrderWeight,
    int? maximumDeliveryDays,
    int? minimumDeliveryDays,
    Enum$ShippingMethodTypeEnum? type,
    String? shippingZone,
    List<Input$ShippingPostalCodeRulesCreateInputRange>? addPostalCodeRules,
    List<String>? deletePostalCodeRules,
    Enum$PostalCodeRuleInclusionTypeEnum? inclusionType,
    String? taxClass,
  });
  TRes addPostalCodeRules(
      Iterable<Input$ShippingPostalCodeRulesCreateInputRange>? Function(
              Iterable<
                  CopyWith$Input$ShippingPostalCodeRulesCreateInputRange<
                      Input$ShippingPostalCodeRulesCreateInputRange>>?)
          _fn);
}

class _CopyWithImpl$Input$ShippingPriceInput<TRes>
    implements CopyWith$Input$ShippingPriceInput<TRes> {
  _CopyWithImpl$Input$ShippingPriceInput(
    this._instance,
    this._then,
  );

  final Input$ShippingPriceInput _instance;

  final TRes Function(Input$ShippingPriceInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
    Object? minimumOrderWeight = _undefined,
    Object? maximumOrderWeight = _undefined,
    Object? maximumDeliveryDays = _undefined,
    Object? minimumDeliveryDays = _undefined,
    Object? type = _undefined,
    Object? shippingZone = _undefined,
    Object? addPostalCodeRules = _undefined,
    Object? deletePostalCodeRules = _undefined,
    Object? inclusionType = _undefined,
    Object? taxClass = _undefined,
  }) =>
      _then(Input$ShippingPriceInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (minimumOrderWeight != _undefined)
          'minimumOrderWeight': (minimumOrderWeight as String?),
        if (maximumOrderWeight != _undefined)
          'maximumOrderWeight': (maximumOrderWeight as String?),
        if (maximumDeliveryDays != _undefined)
          'maximumDeliveryDays': (maximumDeliveryDays as int?),
        if (minimumDeliveryDays != _undefined)
          'minimumDeliveryDays': (minimumDeliveryDays as int?),
        if (type != _undefined) 'type': (type as Enum$ShippingMethodTypeEnum?),
        if (shippingZone != _undefined)
          'shippingZone': (shippingZone as String?),
        if (addPostalCodeRules != _undefined)
          'addPostalCodeRules': (addPostalCodeRules
              as List<Input$ShippingPostalCodeRulesCreateInputRange>?),
        if (deletePostalCodeRules != _undefined)
          'deletePostalCodeRules': (deletePostalCodeRules as List<String>?),
        if (inclusionType != _undefined)
          'inclusionType':
              (inclusionType as Enum$PostalCodeRuleInclusionTypeEnum?),
        if (taxClass != _undefined) 'taxClass': (taxClass as String?),
      }));

  TRes addPostalCodeRules(
          Iterable<Input$ShippingPostalCodeRulesCreateInputRange>? Function(
                  Iterable<
                      CopyWith$Input$ShippingPostalCodeRulesCreateInputRange<
                          Input$ShippingPostalCodeRulesCreateInputRange>>?)
              _fn) =>
      call(
          addPostalCodeRules: _fn(_instance.addPostalCodeRules?.map(
              (e) => CopyWith$Input$ShippingPostalCodeRulesCreateInputRange(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ShippingPriceInput<TRes>
    implements CopyWith$Input$ShippingPriceInput<TRes> {
  _CopyWithStubImpl$Input$ShippingPriceInput(this._res);

  TRes _res;

  call({
    String? name,
    String? description,
    String? minimumOrderWeight,
    String? maximumOrderWeight,
    int? maximumDeliveryDays,
    int? minimumDeliveryDays,
    Enum$ShippingMethodTypeEnum? type,
    String? shippingZone,
    List<Input$ShippingPostalCodeRulesCreateInputRange>? addPostalCodeRules,
    List<String>? deletePostalCodeRules,
    Enum$PostalCodeRuleInclusionTypeEnum? inclusionType,
    String? taxClass,
  }) =>
      _res;

  addPostalCodeRules(_fn) => _res;
}

class Input$ShippingPriceTranslationInput {
  factory Input$ShippingPriceTranslationInput({
    String? name,
    String? description,
  }) =>
      Input$ShippingPriceTranslationInput._({
        if (name != null) r'name': name,
        if (description != null) r'description': description,
      });

  Input$ShippingPriceTranslationInput._(this._$data);

  factory Input$ShippingPriceTranslationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    return Input$ShippingPriceTranslationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    return result$data;
  }

  CopyWith$Input$ShippingPriceTranslationInput<
          Input$ShippingPriceTranslationInput>
      get copyWith => CopyWith$Input$ShippingPriceTranslationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ShippingPriceTranslationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$ShippingPriceTranslationInput<TRes> {
  factory CopyWith$Input$ShippingPriceTranslationInput(
    Input$ShippingPriceTranslationInput instance,
    TRes Function(Input$ShippingPriceTranslationInput) then,
  ) = _CopyWithImpl$Input$ShippingPriceTranslationInput;

  factory CopyWith$Input$ShippingPriceTranslationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ShippingPriceTranslationInput;

  TRes call({
    String? name,
    String? description,
  });
}

class _CopyWithImpl$Input$ShippingPriceTranslationInput<TRes>
    implements CopyWith$Input$ShippingPriceTranslationInput<TRes> {
  _CopyWithImpl$Input$ShippingPriceTranslationInput(
    this._instance,
    this._then,
  );

  final Input$ShippingPriceTranslationInput _instance;

  final TRes Function(Input$ShippingPriceTranslationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$ShippingPriceTranslationInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
      }));
}

class _CopyWithStubImpl$Input$ShippingPriceTranslationInput<TRes>
    implements CopyWith$Input$ShippingPriceTranslationInput<TRes> {
  _CopyWithStubImpl$Input$ShippingPriceTranslationInput(this._res);

  TRes _res;

  call({
    String? name,
    String? description,
  }) =>
      _res;
}

class Input$ShippingZoneCreateInput {
  factory Input$ShippingZoneCreateInput({
    String? name,
    String? description,
    List<String>? countries,
    bool? $default,
    List<String>? addWarehouses,
    List<String>? addChannels,
  }) =>
      Input$ShippingZoneCreateInput._({
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (countries != null) r'countries': countries,
        if ($default != null) r'default': $default,
        if (addWarehouses != null) r'addWarehouses': addWarehouses,
        if (addChannels != null) r'addChannels': addChannels,
      });

  Input$ShippingZoneCreateInput._(this._$data);

  factory Input$ShippingZoneCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('countries')) {
      final l$countries = data['countries'];
      result$data['countries'] =
          (l$countries as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('default')) {
      final l$$default = data['default'];
      result$data['default'] = (l$$default as bool?);
    }
    if (data.containsKey('addWarehouses')) {
      final l$addWarehouses = data['addWarehouses'];
      result$data['addWarehouses'] = (l$addWarehouses as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('addChannels')) {
      final l$addChannels = data['addChannels'];
      result$data['addChannels'] =
          (l$addChannels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$ShippingZoneCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  List<String>? get countries => (_$data['countries'] as List<String>?);

  bool? get $default => (_$data['default'] as bool?);

  List<String>? get addWarehouses => (_$data['addWarehouses'] as List<String>?);

  List<String>? get addChannels => (_$data['addChannels'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('countries')) {
      final l$countries = countries;
      result$data['countries'] = l$countries?.map((e) => e).toList();
    }
    if (_$data.containsKey('default')) {
      final l$$default = $default;
      result$data['default'] = l$$default;
    }
    if (_$data.containsKey('addWarehouses')) {
      final l$addWarehouses = addWarehouses;
      result$data['addWarehouses'] = l$addWarehouses?.map((e) => e).toList();
    }
    if (_$data.containsKey('addChannels')) {
      final l$addChannels = addChannels;
      result$data['addChannels'] = l$addChannels?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$ShippingZoneCreateInput<Input$ShippingZoneCreateInput>
      get copyWith => CopyWith$Input$ShippingZoneCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ShippingZoneCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$countries = countries;
    final lOther$countries = other.countries;
    if (_$data.containsKey('countries') !=
        other._$data.containsKey('countries')) {
      return false;
    }
    if (l$countries != null && lOther$countries != null) {
      if (l$countries.length != lOther$countries.length) {
        return false;
      }
      for (int i = 0; i < l$countries.length; i++) {
        final l$countries$entry = l$countries[i];
        final lOther$countries$entry = lOther$countries[i];
        if (l$countries$entry != lOther$countries$entry) {
          return false;
        }
      }
    } else if (l$countries != lOther$countries) {
      return false;
    }
    final l$$default = $default;
    final lOther$$default = other.$default;
    if (_$data.containsKey('default') != other._$data.containsKey('default')) {
      return false;
    }
    if (l$$default != lOther$$default) {
      return false;
    }
    final l$addWarehouses = addWarehouses;
    final lOther$addWarehouses = other.addWarehouses;
    if (_$data.containsKey('addWarehouses') !=
        other._$data.containsKey('addWarehouses')) {
      return false;
    }
    if (l$addWarehouses != null && lOther$addWarehouses != null) {
      if (l$addWarehouses.length != lOther$addWarehouses.length) {
        return false;
      }
      for (int i = 0; i < l$addWarehouses.length; i++) {
        final l$addWarehouses$entry = l$addWarehouses[i];
        final lOther$addWarehouses$entry = lOther$addWarehouses[i];
        if (l$addWarehouses$entry != lOther$addWarehouses$entry) {
          return false;
        }
      }
    } else if (l$addWarehouses != lOther$addWarehouses) {
      return false;
    }
    final l$addChannels = addChannels;
    final lOther$addChannels = other.addChannels;
    if (_$data.containsKey('addChannels') !=
        other._$data.containsKey('addChannels')) {
      return false;
    }
    if (l$addChannels != null && lOther$addChannels != null) {
      if (l$addChannels.length != lOther$addChannels.length) {
        return false;
      }
      for (int i = 0; i < l$addChannels.length; i++) {
        final l$addChannels$entry = l$addChannels[i];
        final lOther$addChannels$entry = lOther$addChannels[i];
        if (l$addChannels$entry != lOther$addChannels$entry) {
          return false;
        }
      }
    } else if (l$addChannels != lOther$addChannels) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    final l$countries = countries;
    final l$$default = $default;
    final l$addWarehouses = addWarehouses;
    final l$addChannels = addChannels;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('countries')
          ? l$countries == null
              ? null
              : Object.hashAll(l$countries.map((v) => v))
          : const {},
      _$data.containsKey('default') ? l$$default : const {},
      _$data.containsKey('addWarehouses')
          ? l$addWarehouses == null
              ? null
              : Object.hashAll(l$addWarehouses.map((v) => v))
          : const {},
      _$data.containsKey('addChannels')
          ? l$addChannels == null
              ? null
              : Object.hashAll(l$addChannels.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ShippingZoneCreateInput<TRes> {
  factory CopyWith$Input$ShippingZoneCreateInput(
    Input$ShippingZoneCreateInput instance,
    TRes Function(Input$ShippingZoneCreateInput) then,
  ) = _CopyWithImpl$Input$ShippingZoneCreateInput;

  factory CopyWith$Input$ShippingZoneCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ShippingZoneCreateInput;

  TRes call({
    String? name,
    String? description,
    List<String>? countries,
    bool? $default,
    List<String>? addWarehouses,
    List<String>? addChannels,
  });
}

class _CopyWithImpl$Input$ShippingZoneCreateInput<TRes>
    implements CopyWith$Input$ShippingZoneCreateInput<TRes> {
  _CopyWithImpl$Input$ShippingZoneCreateInput(
    this._instance,
    this._then,
  );

  final Input$ShippingZoneCreateInput _instance;

  final TRes Function(Input$ShippingZoneCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
    Object? countries = _undefined,
    Object? $default = _undefined,
    Object? addWarehouses = _undefined,
    Object? addChannels = _undefined,
  }) =>
      _then(Input$ShippingZoneCreateInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (countries != _undefined) 'countries': (countries as List<String>?),
        if ($default != _undefined) 'default': ($default as bool?),
        if (addWarehouses != _undefined)
          'addWarehouses': (addWarehouses as List<String>?),
        if (addChannels != _undefined)
          'addChannels': (addChannels as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$ShippingZoneCreateInput<TRes>
    implements CopyWith$Input$ShippingZoneCreateInput<TRes> {
  _CopyWithStubImpl$Input$ShippingZoneCreateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? description,
    List<String>? countries,
    bool? $default,
    List<String>? addWarehouses,
    List<String>? addChannels,
  }) =>
      _res;
}

class Input$ShippingZoneFilterInput {
  factory Input$ShippingZoneFilterInput({
    String? search,
    List<String>? channels,
  }) =>
      Input$ShippingZoneFilterInput._({
        if (search != null) r'search': search,
        if (channels != null) r'channels': channels,
      });

  Input$ShippingZoneFilterInput._(this._$data);

  factory Input$ShippingZoneFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('channels')) {
      final l$channels = data['channels'];
      result$data['channels'] =
          (l$channels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$ShippingZoneFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get search => (_$data['search'] as String?);

  List<String>? get channels => (_$data['channels'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('channels')) {
      final l$channels = channels;
      result$data['channels'] = l$channels?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$ShippingZoneFilterInput<Input$ShippingZoneFilterInput>
      get copyWith => CopyWith$Input$ShippingZoneFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ShippingZoneFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$channels = channels;
    final lOther$channels = other.channels;
    if (_$data.containsKey('channels') !=
        other._$data.containsKey('channels')) {
      return false;
    }
    if (l$channels != null && lOther$channels != null) {
      if (l$channels.length != lOther$channels.length) {
        return false;
      }
      for (int i = 0; i < l$channels.length; i++) {
        final l$channels$entry = l$channels[i];
        final lOther$channels$entry = lOther$channels[i];
        if (l$channels$entry != lOther$channels$entry) {
          return false;
        }
      }
    } else if (l$channels != lOther$channels) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$search = search;
    final l$channels = channels;
    return Object.hashAll([
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('channels')
          ? l$channels == null
              ? null
              : Object.hashAll(l$channels.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ShippingZoneFilterInput<TRes> {
  factory CopyWith$Input$ShippingZoneFilterInput(
    Input$ShippingZoneFilterInput instance,
    TRes Function(Input$ShippingZoneFilterInput) then,
  ) = _CopyWithImpl$Input$ShippingZoneFilterInput;

  factory CopyWith$Input$ShippingZoneFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ShippingZoneFilterInput;

  TRes call({
    String? search,
    List<String>? channels,
  });
}

class _CopyWithImpl$Input$ShippingZoneFilterInput<TRes>
    implements CopyWith$Input$ShippingZoneFilterInput<TRes> {
  _CopyWithImpl$Input$ShippingZoneFilterInput(
    this._instance,
    this._then,
  );

  final Input$ShippingZoneFilterInput _instance;

  final TRes Function(Input$ShippingZoneFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? search = _undefined,
    Object? channels = _undefined,
  }) =>
      _then(Input$ShippingZoneFilterInput._({
        ..._instance._$data,
        if (search != _undefined) 'search': (search as String?),
        if (channels != _undefined) 'channels': (channels as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$ShippingZoneFilterInput<TRes>
    implements CopyWith$Input$ShippingZoneFilterInput<TRes> {
  _CopyWithStubImpl$Input$ShippingZoneFilterInput(this._res);

  TRes _res;

  call({
    String? search,
    List<String>? channels,
  }) =>
      _res;
}

class Input$ShippingZoneUpdateInput {
  factory Input$ShippingZoneUpdateInput({
    String? name,
    String? description,
    List<String>? countries,
    bool? $default,
    List<String>? addWarehouses,
    List<String>? addChannels,
    List<String>? removeWarehouses,
    List<String>? removeChannels,
  }) =>
      Input$ShippingZoneUpdateInput._({
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (countries != null) r'countries': countries,
        if ($default != null) r'default': $default,
        if (addWarehouses != null) r'addWarehouses': addWarehouses,
        if (addChannels != null) r'addChannels': addChannels,
        if (removeWarehouses != null) r'removeWarehouses': removeWarehouses,
        if (removeChannels != null) r'removeChannels': removeChannels,
      });

  Input$ShippingZoneUpdateInput._(this._$data);

  factory Input$ShippingZoneUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('countries')) {
      final l$countries = data['countries'];
      result$data['countries'] =
          (l$countries as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('default')) {
      final l$$default = data['default'];
      result$data['default'] = (l$$default as bool?);
    }
    if (data.containsKey('addWarehouses')) {
      final l$addWarehouses = data['addWarehouses'];
      result$data['addWarehouses'] = (l$addWarehouses as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('addChannels')) {
      final l$addChannels = data['addChannels'];
      result$data['addChannels'] =
          (l$addChannels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('removeWarehouses')) {
      final l$removeWarehouses = data['removeWarehouses'];
      result$data['removeWarehouses'] = (l$removeWarehouses as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('removeChannels')) {
      final l$removeChannels = data['removeChannels'];
      result$data['removeChannels'] = (l$removeChannels as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$ShippingZoneUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  List<String>? get countries => (_$data['countries'] as List<String>?);

  bool? get $default => (_$data['default'] as bool?);

  List<String>? get addWarehouses => (_$data['addWarehouses'] as List<String>?);

  List<String>? get addChannels => (_$data['addChannels'] as List<String>?);

  List<String>? get removeWarehouses =>
      (_$data['removeWarehouses'] as List<String>?);

  List<String>? get removeChannels =>
      (_$data['removeChannels'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('countries')) {
      final l$countries = countries;
      result$data['countries'] = l$countries?.map((e) => e).toList();
    }
    if (_$data.containsKey('default')) {
      final l$$default = $default;
      result$data['default'] = l$$default;
    }
    if (_$data.containsKey('addWarehouses')) {
      final l$addWarehouses = addWarehouses;
      result$data['addWarehouses'] = l$addWarehouses?.map((e) => e).toList();
    }
    if (_$data.containsKey('addChannels')) {
      final l$addChannels = addChannels;
      result$data['addChannels'] = l$addChannels?.map((e) => e).toList();
    }
    if (_$data.containsKey('removeWarehouses')) {
      final l$removeWarehouses = removeWarehouses;
      result$data['removeWarehouses'] =
          l$removeWarehouses?.map((e) => e).toList();
    }
    if (_$data.containsKey('removeChannels')) {
      final l$removeChannels = removeChannels;
      result$data['removeChannels'] = l$removeChannels?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$ShippingZoneUpdateInput<Input$ShippingZoneUpdateInput>
      get copyWith => CopyWith$Input$ShippingZoneUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ShippingZoneUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$countries = countries;
    final lOther$countries = other.countries;
    if (_$data.containsKey('countries') !=
        other._$data.containsKey('countries')) {
      return false;
    }
    if (l$countries != null && lOther$countries != null) {
      if (l$countries.length != lOther$countries.length) {
        return false;
      }
      for (int i = 0; i < l$countries.length; i++) {
        final l$countries$entry = l$countries[i];
        final lOther$countries$entry = lOther$countries[i];
        if (l$countries$entry != lOther$countries$entry) {
          return false;
        }
      }
    } else if (l$countries != lOther$countries) {
      return false;
    }
    final l$$default = $default;
    final lOther$$default = other.$default;
    if (_$data.containsKey('default') != other._$data.containsKey('default')) {
      return false;
    }
    if (l$$default != lOther$$default) {
      return false;
    }
    final l$addWarehouses = addWarehouses;
    final lOther$addWarehouses = other.addWarehouses;
    if (_$data.containsKey('addWarehouses') !=
        other._$data.containsKey('addWarehouses')) {
      return false;
    }
    if (l$addWarehouses != null && lOther$addWarehouses != null) {
      if (l$addWarehouses.length != lOther$addWarehouses.length) {
        return false;
      }
      for (int i = 0; i < l$addWarehouses.length; i++) {
        final l$addWarehouses$entry = l$addWarehouses[i];
        final lOther$addWarehouses$entry = lOther$addWarehouses[i];
        if (l$addWarehouses$entry != lOther$addWarehouses$entry) {
          return false;
        }
      }
    } else if (l$addWarehouses != lOther$addWarehouses) {
      return false;
    }
    final l$addChannels = addChannels;
    final lOther$addChannels = other.addChannels;
    if (_$data.containsKey('addChannels') !=
        other._$data.containsKey('addChannels')) {
      return false;
    }
    if (l$addChannels != null && lOther$addChannels != null) {
      if (l$addChannels.length != lOther$addChannels.length) {
        return false;
      }
      for (int i = 0; i < l$addChannels.length; i++) {
        final l$addChannels$entry = l$addChannels[i];
        final lOther$addChannels$entry = lOther$addChannels[i];
        if (l$addChannels$entry != lOther$addChannels$entry) {
          return false;
        }
      }
    } else if (l$addChannels != lOther$addChannels) {
      return false;
    }
    final l$removeWarehouses = removeWarehouses;
    final lOther$removeWarehouses = other.removeWarehouses;
    if (_$data.containsKey('removeWarehouses') !=
        other._$data.containsKey('removeWarehouses')) {
      return false;
    }
    if (l$removeWarehouses != null && lOther$removeWarehouses != null) {
      if (l$removeWarehouses.length != lOther$removeWarehouses.length) {
        return false;
      }
      for (int i = 0; i < l$removeWarehouses.length; i++) {
        final l$removeWarehouses$entry = l$removeWarehouses[i];
        final lOther$removeWarehouses$entry = lOther$removeWarehouses[i];
        if (l$removeWarehouses$entry != lOther$removeWarehouses$entry) {
          return false;
        }
      }
    } else if (l$removeWarehouses != lOther$removeWarehouses) {
      return false;
    }
    final l$removeChannels = removeChannels;
    final lOther$removeChannels = other.removeChannels;
    if (_$data.containsKey('removeChannels') !=
        other._$data.containsKey('removeChannels')) {
      return false;
    }
    if (l$removeChannels != null && lOther$removeChannels != null) {
      if (l$removeChannels.length != lOther$removeChannels.length) {
        return false;
      }
      for (int i = 0; i < l$removeChannels.length; i++) {
        final l$removeChannels$entry = l$removeChannels[i];
        final lOther$removeChannels$entry = lOther$removeChannels[i];
        if (l$removeChannels$entry != lOther$removeChannels$entry) {
          return false;
        }
      }
    } else if (l$removeChannels != lOther$removeChannels) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    final l$countries = countries;
    final l$$default = $default;
    final l$addWarehouses = addWarehouses;
    final l$addChannels = addChannels;
    final l$removeWarehouses = removeWarehouses;
    final l$removeChannels = removeChannels;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('countries')
          ? l$countries == null
              ? null
              : Object.hashAll(l$countries.map((v) => v))
          : const {},
      _$data.containsKey('default') ? l$$default : const {},
      _$data.containsKey('addWarehouses')
          ? l$addWarehouses == null
              ? null
              : Object.hashAll(l$addWarehouses.map((v) => v))
          : const {},
      _$data.containsKey('addChannels')
          ? l$addChannels == null
              ? null
              : Object.hashAll(l$addChannels.map((v) => v))
          : const {},
      _$data.containsKey('removeWarehouses')
          ? l$removeWarehouses == null
              ? null
              : Object.hashAll(l$removeWarehouses.map((v) => v))
          : const {},
      _$data.containsKey('removeChannels')
          ? l$removeChannels == null
              ? null
              : Object.hashAll(l$removeChannels.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ShippingZoneUpdateInput<TRes> {
  factory CopyWith$Input$ShippingZoneUpdateInput(
    Input$ShippingZoneUpdateInput instance,
    TRes Function(Input$ShippingZoneUpdateInput) then,
  ) = _CopyWithImpl$Input$ShippingZoneUpdateInput;

  factory CopyWith$Input$ShippingZoneUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ShippingZoneUpdateInput;

  TRes call({
    String? name,
    String? description,
    List<String>? countries,
    bool? $default,
    List<String>? addWarehouses,
    List<String>? addChannels,
    List<String>? removeWarehouses,
    List<String>? removeChannels,
  });
}

class _CopyWithImpl$Input$ShippingZoneUpdateInput<TRes>
    implements CopyWith$Input$ShippingZoneUpdateInput<TRes> {
  _CopyWithImpl$Input$ShippingZoneUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ShippingZoneUpdateInput _instance;

  final TRes Function(Input$ShippingZoneUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
    Object? countries = _undefined,
    Object? $default = _undefined,
    Object? addWarehouses = _undefined,
    Object? addChannels = _undefined,
    Object? removeWarehouses = _undefined,
    Object? removeChannels = _undefined,
  }) =>
      _then(Input$ShippingZoneUpdateInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (countries != _undefined) 'countries': (countries as List<String>?),
        if ($default != _undefined) 'default': ($default as bool?),
        if (addWarehouses != _undefined)
          'addWarehouses': (addWarehouses as List<String>?),
        if (addChannels != _undefined)
          'addChannels': (addChannels as List<String>?),
        if (removeWarehouses != _undefined)
          'removeWarehouses': (removeWarehouses as List<String>?),
        if (removeChannels != _undefined)
          'removeChannels': (removeChannels as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$ShippingZoneUpdateInput<TRes>
    implements CopyWith$Input$ShippingZoneUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ShippingZoneUpdateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? description,
    List<String>? countries,
    bool? $default,
    List<String>? addWarehouses,
    List<String>? addChannels,
    List<String>? removeWarehouses,
    List<String>? removeChannels,
  }) =>
      _res;
}

class Input$ShopSettingsInput {
  factory Input$ShopSettingsInput({
    String? headerText,
    String? description,
    bool? trackInventoryByDefault,
    Enum$WeightUnitsEnum? defaultWeightUnit,
    bool? automaticFulfillmentDigitalProducts,
    bool? fulfillmentAutoApprove,
    bool? fulfillmentAllowUnpaid,
    int? defaultDigitalMaxDownloads,
    int? defaultDigitalUrlValidDays,
    String? defaultMailSenderName,
    String? defaultMailSenderAddress,
    String? customerSetPasswordUrl,
    int? reserveStockDurationAnonymousUser,
    int? reserveStockDurationAuthenticatedUser,
    int? limitQuantityPerCheckout,
    bool? enableAccountConfirmationByEmail,
    bool? allowLoginWithoutConfirmation,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    bool? includeTaxesInPrices,
    bool? displayGrossPrices,
    bool? chargeTaxesOnShipping,
  }) =>
      Input$ShopSettingsInput._({
        if (headerText != null) r'headerText': headerText,
        if (description != null) r'description': description,
        if (trackInventoryByDefault != null)
          r'trackInventoryByDefault': trackInventoryByDefault,
        if (defaultWeightUnit != null) r'defaultWeightUnit': defaultWeightUnit,
        if (automaticFulfillmentDigitalProducts != null)
          r'automaticFulfillmentDigitalProducts':
              automaticFulfillmentDigitalProducts,
        if (fulfillmentAutoApprove != null)
          r'fulfillmentAutoApprove': fulfillmentAutoApprove,
        if (fulfillmentAllowUnpaid != null)
          r'fulfillmentAllowUnpaid': fulfillmentAllowUnpaid,
        if (defaultDigitalMaxDownloads != null)
          r'defaultDigitalMaxDownloads': defaultDigitalMaxDownloads,
        if (defaultDigitalUrlValidDays != null)
          r'defaultDigitalUrlValidDays': defaultDigitalUrlValidDays,
        if (defaultMailSenderName != null)
          r'defaultMailSenderName': defaultMailSenderName,
        if (defaultMailSenderAddress != null)
          r'defaultMailSenderAddress': defaultMailSenderAddress,
        if (customerSetPasswordUrl != null)
          r'customerSetPasswordUrl': customerSetPasswordUrl,
        if (reserveStockDurationAnonymousUser != null)
          r'reserveStockDurationAnonymousUser':
              reserveStockDurationAnonymousUser,
        if (reserveStockDurationAuthenticatedUser != null)
          r'reserveStockDurationAuthenticatedUser':
              reserveStockDurationAuthenticatedUser,
        if (limitQuantityPerCheckout != null)
          r'limitQuantityPerCheckout': limitQuantityPerCheckout,
        if (enableAccountConfirmationByEmail != null)
          r'enableAccountConfirmationByEmail': enableAccountConfirmationByEmail,
        if (allowLoginWithoutConfirmation != null)
          r'allowLoginWithoutConfirmation': allowLoginWithoutConfirmation,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (includeTaxesInPrices != null)
          r'includeTaxesInPrices': includeTaxesInPrices,
        if (displayGrossPrices != null)
          r'displayGrossPrices': displayGrossPrices,
        if (chargeTaxesOnShipping != null)
          r'chargeTaxesOnShipping': chargeTaxesOnShipping,
      });

  Input$ShopSettingsInput._(this._$data);

  factory Input$ShopSettingsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('headerText')) {
      final l$headerText = data['headerText'];
      result$data['headerText'] = (l$headerText as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('trackInventoryByDefault')) {
      final l$trackInventoryByDefault = data['trackInventoryByDefault'];
      result$data['trackInventoryByDefault'] =
          (l$trackInventoryByDefault as bool?);
    }
    if (data.containsKey('defaultWeightUnit')) {
      final l$defaultWeightUnit = data['defaultWeightUnit'];
      result$data['defaultWeightUnit'] = l$defaultWeightUnit == null
          ? null
          : fromJson$Enum$WeightUnitsEnum((l$defaultWeightUnit as String));
    }
    if (data.containsKey('automaticFulfillmentDigitalProducts')) {
      final l$automaticFulfillmentDigitalProducts =
          data['automaticFulfillmentDigitalProducts'];
      result$data['automaticFulfillmentDigitalProducts'] =
          (l$automaticFulfillmentDigitalProducts as bool?);
    }
    if (data.containsKey('fulfillmentAutoApprove')) {
      final l$fulfillmentAutoApprove = data['fulfillmentAutoApprove'];
      result$data['fulfillmentAutoApprove'] =
          (l$fulfillmentAutoApprove as bool?);
    }
    if (data.containsKey('fulfillmentAllowUnpaid')) {
      final l$fulfillmentAllowUnpaid = data['fulfillmentAllowUnpaid'];
      result$data['fulfillmentAllowUnpaid'] =
          (l$fulfillmentAllowUnpaid as bool?);
    }
    if (data.containsKey('defaultDigitalMaxDownloads')) {
      final l$defaultDigitalMaxDownloads = data['defaultDigitalMaxDownloads'];
      result$data['defaultDigitalMaxDownloads'] =
          (l$defaultDigitalMaxDownloads as int?);
    }
    if (data.containsKey('defaultDigitalUrlValidDays')) {
      final l$defaultDigitalUrlValidDays = data['defaultDigitalUrlValidDays'];
      result$data['defaultDigitalUrlValidDays'] =
          (l$defaultDigitalUrlValidDays as int?);
    }
    if (data.containsKey('defaultMailSenderName')) {
      final l$defaultMailSenderName = data['defaultMailSenderName'];
      result$data['defaultMailSenderName'] =
          (l$defaultMailSenderName as String?);
    }
    if (data.containsKey('defaultMailSenderAddress')) {
      final l$defaultMailSenderAddress = data['defaultMailSenderAddress'];
      result$data['defaultMailSenderAddress'] =
          (l$defaultMailSenderAddress as String?);
    }
    if (data.containsKey('customerSetPasswordUrl')) {
      final l$customerSetPasswordUrl = data['customerSetPasswordUrl'];
      result$data['customerSetPasswordUrl'] =
          (l$customerSetPasswordUrl as String?);
    }
    if (data.containsKey('reserveStockDurationAnonymousUser')) {
      final l$reserveStockDurationAnonymousUser =
          data['reserveStockDurationAnonymousUser'];
      result$data['reserveStockDurationAnonymousUser'] =
          (l$reserveStockDurationAnonymousUser as int?);
    }
    if (data.containsKey('reserveStockDurationAuthenticatedUser')) {
      final l$reserveStockDurationAuthenticatedUser =
          data['reserveStockDurationAuthenticatedUser'];
      result$data['reserveStockDurationAuthenticatedUser'] =
          (l$reserveStockDurationAuthenticatedUser as int?);
    }
    if (data.containsKey('limitQuantityPerCheckout')) {
      final l$limitQuantityPerCheckout = data['limitQuantityPerCheckout'];
      result$data['limitQuantityPerCheckout'] =
          (l$limitQuantityPerCheckout as int?);
    }
    if (data.containsKey('enableAccountConfirmationByEmail')) {
      final l$enableAccountConfirmationByEmail =
          data['enableAccountConfirmationByEmail'];
      result$data['enableAccountConfirmationByEmail'] =
          (l$enableAccountConfirmationByEmail as bool?);
    }
    if (data.containsKey('allowLoginWithoutConfirmation')) {
      final l$allowLoginWithoutConfirmation =
          data['allowLoginWithoutConfirmation'];
      result$data['allowLoginWithoutConfirmation'] =
          (l$allowLoginWithoutConfirmation as bool?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('includeTaxesInPrices')) {
      final l$includeTaxesInPrices = data['includeTaxesInPrices'];
      result$data['includeTaxesInPrices'] = (l$includeTaxesInPrices as bool?);
    }
    if (data.containsKey('displayGrossPrices')) {
      final l$displayGrossPrices = data['displayGrossPrices'];
      result$data['displayGrossPrices'] = (l$displayGrossPrices as bool?);
    }
    if (data.containsKey('chargeTaxesOnShipping')) {
      final l$chargeTaxesOnShipping = data['chargeTaxesOnShipping'];
      result$data['chargeTaxesOnShipping'] = (l$chargeTaxesOnShipping as bool?);
    }
    return Input$ShopSettingsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get headerText => (_$data['headerText'] as String?);

  String? get description => (_$data['description'] as String?);

  bool? get trackInventoryByDefault =>
      (_$data['trackInventoryByDefault'] as bool?);

  Enum$WeightUnitsEnum? get defaultWeightUnit =>
      (_$data['defaultWeightUnit'] as Enum$WeightUnitsEnum?);

  bool? get automaticFulfillmentDigitalProducts =>
      (_$data['automaticFulfillmentDigitalProducts'] as bool?);

  bool? get fulfillmentAutoApprove =>
      (_$data['fulfillmentAutoApprove'] as bool?);

  bool? get fulfillmentAllowUnpaid =>
      (_$data['fulfillmentAllowUnpaid'] as bool?);

  int? get defaultDigitalMaxDownloads =>
      (_$data['defaultDigitalMaxDownloads'] as int?);

  int? get defaultDigitalUrlValidDays =>
      (_$data['defaultDigitalUrlValidDays'] as int?);

  String? get defaultMailSenderName =>
      (_$data['defaultMailSenderName'] as String?);

  String? get defaultMailSenderAddress =>
      (_$data['defaultMailSenderAddress'] as String?);

  String? get customerSetPasswordUrl =>
      (_$data['customerSetPasswordUrl'] as String?);

  int? get reserveStockDurationAnonymousUser =>
      (_$data['reserveStockDurationAnonymousUser'] as int?);

  int? get reserveStockDurationAuthenticatedUser =>
      (_$data['reserveStockDurationAuthenticatedUser'] as int?);

  int? get limitQuantityPerCheckout =>
      (_$data['limitQuantityPerCheckout'] as int?);

  bool? get enableAccountConfirmationByEmail =>
      (_$data['enableAccountConfirmationByEmail'] as bool?);

  bool? get allowLoginWithoutConfirmation =>
      (_$data['allowLoginWithoutConfirmation'] as bool?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  bool? get includeTaxesInPrices => (_$data['includeTaxesInPrices'] as bool?);

  bool? get displayGrossPrices => (_$data['displayGrossPrices'] as bool?);

  bool? get chargeTaxesOnShipping => (_$data['chargeTaxesOnShipping'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('headerText')) {
      final l$headerText = headerText;
      result$data['headerText'] = l$headerText;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('trackInventoryByDefault')) {
      final l$trackInventoryByDefault = trackInventoryByDefault;
      result$data['trackInventoryByDefault'] = l$trackInventoryByDefault;
    }
    if (_$data.containsKey('defaultWeightUnit')) {
      final l$defaultWeightUnit = defaultWeightUnit;
      result$data['defaultWeightUnit'] = l$defaultWeightUnit == null
          ? null
          : toJson$Enum$WeightUnitsEnum(l$defaultWeightUnit);
    }
    if (_$data.containsKey('automaticFulfillmentDigitalProducts')) {
      final l$automaticFulfillmentDigitalProducts =
          automaticFulfillmentDigitalProducts;
      result$data['automaticFulfillmentDigitalProducts'] =
          l$automaticFulfillmentDigitalProducts;
    }
    if (_$data.containsKey('fulfillmentAutoApprove')) {
      final l$fulfillmentAutoApprove = fulfillmentAutoApprove;
      result$data['fulfillmentAutoApprove'] = l$fulfillmentAutoApprove;
    }
    if (_$data.containsKey('fulfillmentAllowUnpaid')) {
      final l$fulfillmentAllowUnpaid = fulfillmentAllowUnpaid;
      result$data['fulfillmentAllowUnpaid'] = l$fulfillmentAllowUnpaid;
    }
    if (_$data.containsKey('defaultDigitalMaxDownloads')) {
      final l$defaultDigitalMaxDownloads = defaultDigitalMaxDownloads;
      result$data['defaultDigitalMaxDownloads'] = l$defaultDigitalMaxDownloads;
    }
    if (_$data.containsKey('defaultDigitalUrlValidDays')) {
      final l$defaultDigitalUrlValidDays = defaultDigitalUrlValidDays;
      result$data['defaultDigitalUrlValidDays'] = l$defaultDigitalUrlValidDays;
    }
    if (_$data.containsKey('defaultMailSenderName')) {
      final l$defaultMailSenderName = defaultMailSenderName;
      result$data['defaultMailSenderName'] = l$defaultMailSenderName;
    }
    if (_$data.containsKey('defaultMailSenderAddress')) {
      final l$defaultMailSenderAddress = defaultMailSenderAddress;
      result$data['defaultMailSenderAddress'] = l$defaultMailSenderAddress;
    }
    if (_$data.containsKey('customerSetPasswordUrl')) {
      final l$customerSetPasswordUrl = customerSetPasswordUrl;
      result$data['customerSetPasswordUrl'] = l$customerSetPasswordUrl;
    }
    if (_$data.containsKey('reserveStockDurationAnonymousUser')) {
      final l$reserveStockDurationAnonymousUser =
          reserveStockDurationAnonymousUser;
      result$data['reserveStockDurationAnonymousUser'] =
          l$reserveStockDurationAnonymousUser;
    }
    if (_$data.containsKey('reserveStockDurationAuthenticatedUser')) {
      final l$reserveStockDurationAuthenticatedUser =
          reserveStockDurationAuthenticatedUser;
      result$data['reserveStockDurationAuthenticatedUser'] =
          l$reserveStockDurationAuthenticatedUser;
    }
    if (_$data.containsKey('limitQuantityPerCheckout')) {
      final l$limitQuantityPerCheckout = limitQuantityPerCheckout;
      result$data['limitQuantityPerCheckout'] = l$limitQuantityPerCheckout;
    }
    if (_$data.containsKey('enableAccountConfirmationByEmail')) {
      final l$enableAccountConfirmationByEmail =
          enableAccountConfirmationByEmail;
      result$data['enableAccountConfirmationByEmail'] =
          l$enableAccountConfirmationByEmail;
    }
    if (_$data.containsKey('allowLoginWithoutConfirmation')) {
      final l$allowLoginWithoutConfirmation = allowLoginWithoutConfirmation;
      result$data['allowLoginWithoutConfirmation'] =
          l$allowLoginWithoutConfirmation;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('includeTaxesInPrices')) {
      final l$includeTaxesInPrices = includeTaxesInPrices;
      result$data['includeTaxesInPrices'] = l$includeTaxesInPrices;
    }
    if (_$data.containsKey('displayGrossPrices')) {
      final l$displayGrossPrices = displayGrossPrices;
      result$data['displayGrossPrices'] = l$displayGrossPrices;
    }
    if (_$data.containsKey('chargeTaxesOnShipping')) {
      final l$chargeTaxesOnShipping = chargeTaxesOnShipping;
      result$data['chargeTaxesOnShipping'] = l$chargeTaxesOnShipping;
    }
    return result$data;
  }

  CopyWith$Input$ShopSettingsInput<Input$ShopSettingsInput> get copyWith =>
      CopyWith$Input$ShopSettingsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ShopSettingsInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$headerText = headerText;
    final lOther$headerText = other.headerText;
    if (_$data.containsKey('headerText') !=
        other._$data.containsKey('headerText')) {
      return false;
    }
    if (l$headerText != lOther$headerText) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$trackInventoryByDefault = trackInventoryByDefault;
    final lOther$trackInventoryByDefault = other.trackInventoryByDefault;
    if (_$data.containsKey('trackInventoryByDefault') !=
        other._$data.containsKey('trackInventoryByDefault')) {
      return false;
    }
    if (l$trackInventoryByDefault != lOther$trackInventoryByDefault) {
      return false;
    }
    final l$defaultWeightUnit = defaultWeightUnit;
    final lOther$defaultWeightUnit = other.defaultWeightUnit;
    if (_$data.containsKey('defaultWeightUnit') !=
        other._$data.containsKey('defaultWeightUnit')) {
      return false;
    }
    if (l$defaultWeightUnit != lOther$defaultWeightUnit) {
      return false;
    }
    final l$automaticFulfillmentDigitalProducts =
        automaticFulfillmentDigitalProducts;
    final lOther$automaticFulfillmentDigitalProducts =
        other.automaticFulfillmentDigitalProducts;
    if (_$data.containsKey('automaticFulfillmentDigitalProducts') !=
        other._$data.containsKey('automaticFulfillmentDigitalProducts')) {
      return false;
    }
    if (l$automaticFulfillmentDigitalProducts !=
        lOther$automaticFulfillmentDigitalProducts) {
      return false;
    }
    final l$fulfillmentAutoApprove = fulfillmentAutoApprove;
    final lOther$fulfillmentAutoApprove = other.fulfillmentAutoApprove;
    if (_$data.containsKey('fulfillmentAutoApprove') !=
        other._$data.containsKey('fulfillmentAutoApprove')) {
      return false;
    }
    if (l$fulfillmentAutoApprove != lOther$fulfillmentAutoApprove) {
      return false;
    }
    final l$fulfillmentAllowUnpaid = fulfillmentAllowUnpaid;
    final lOther$fulfillmentAllowUnpaid = other.fulfillmentAllowUnpaid;
    if (_$data.containsKey('fulfillmentAllowUnpaid') !=
        other._$data.containsKey('fulfillmentAllowUnpaid')) {
      return false;
    }
    if (l$fulfillmentAllowUnpaid != lOther$fulfillmentAllowUnpaid) {
      return false;
    }
    final l$defaultDigitalMaxDownloads = defaultDigitalMaxDownloads;
    final lOther$defaultDigitalMaxDownloads = other.defaultDigitalMaxDownloads;
    if (_$data.containsKey('defaultDigitalMaxDownloads') !=
        other._$data.containsKey('defaultDigitalMaxDownloads')) {
      return false;
    }
    if (l$defaultDigitalMaxDownloads != lOther$defaultDigitalMaxDownloads) {
      return false;
    }
    final l$defaultDigitalUrlValidDays = defaultDigitalUrlValidDays;
    final lOther$defaultDigitalUrlValidDays = other.defaultDigitalUrlValidDays;
    if (_$data.containsKey('defaultDigitalUrlValidDays') !=
        other._$data.containsKey('defaultDigitalUrlValidDays')) {
      return false;
    }
    if (l$defaultDigitalUrlValidDays != lOther$defaultDigitalUrlValidDays) {
      return false;
    }
    final l$defaultMailSenderName = defaultMailSenderName;
    final lOther$defaultMailSenderName = other.defaultMailSenderName;
    if (_$data.containsKey('defaultMailSenderName') !=
        other._$data.containsKey('defaultMailSenderName')) {
      return false;
    }
    if (l$defaultMailSenderName != lOther$defaultMailSenderName) {
      return false;
    }
    final l$defaultMailSenderAddress = defaultMailSenderAddress;
    final lOther$defaultMailSenderAddress = other.defaultMailSenderAddress;
    if (_$data.containsKey('defaultMailSenderAddress') !=
        other._$data.containsKey('defaultMailSenderAddress')) {
      return false;
    }
    if (l$defaultMailSenderAddress != lOther$defaultMailSenderAddress) {
      return false;
    }
    final l$customerSetPasswordUrl = customerSetPasswordUrl;
    final lOther$customerSetPasswordUrl = other.customerSetPasswordUrl;
    if (_$data.containsKey('customerSetPasswordUrl') !=
        other._$data.containsKey('customerSetPasswordUrl')) {
      return false;
    }
    if (l$customerSetPasswordUrl != lOther$customerSetPasswordUrl) {
      return false;
    }
    final l$reserveStockDurationAnonymousUser =
        reserveStockDurationAnonymousUser;
    final lOther$reserveStockDurationAnonymousUser =
        other.reserveStockDurationAnonymousUser;
    if (_$data.containsKey('reserveStockDurationAnonymousUser') !=
        other._$data.containsKey('reserveStockDurationAnonymousUser')) {
      return false;
    }
    if (l$reserveStockDurationAnonymousUser !=
        lOther$reserveStockDurationAnonymousUser) {
      return false;
    }
    final l$reserveStockDurationAuthenticatedUser =
        reserveStockDurationAuthenticatedUser;
    final lOther$reserveStockDurationAuthenticatedUser =
        other.reserveStockDurationAuthenticatedUser;
    if (_$data.containsKey('reserveStockDurationAuthenticatedUser') !=
        other._$data.containsKey('reserveStockDurationAuthenticatedUser')) {
      return false;
    }
    if (l$reserveStockDurationAuthenticatedUser !=
        lOther$reserveStockDurationAuthenticatedUser) {
      return false;
    }
    final l$limitQuantityPerCheckout = limitQuantityPerCheckout;
    final lOther$limitQuantityPerCheckout = other.limitQuantityPerCheckout;
    if (_$data.containsKey('limitQuantityPerCheckout') !=
        other._$data.containsKey('limitQuantityPerCheckout')) {
      return false;
    }
    if (l$limitQuantityPerCheckout != lOther$limitQuantityPerCheckout) {
      return false;
    }
    final l$enableAccountConfirmationByEmail = enableAccountConfirmationByEmail;
    final lOther$enableAccountConfirmationByEmail =
        other.enableAccountConfirmationByEmail;
    if (_$data.containsKey('enableAccountConfirmationByEmail') !=
        other._$data.containsKey('enableAccountConfirmationByEmail')) {
      return false;
    }
    if (l$enableAccountConfirmationByEmail !=
        lOther$enableAccountConfirmationByEmail) {
      return false;
    }
    final l$allowLoginWithoutConfirmation = allowLoginWithoutConfirmation;
    final lOther$allowLoginWithoutConfirmation =
        other.allowLoginWithoutConfirmation;
    if (_$data.containsKey('allowLoginWithoutConfirmation') !=
        other._$data.containsKey('allowLoginWithoutConfirmation')) {
      return false;
    }
    if (l$allowLoginWithoutConfirmation !=
        lOther$allowLoginWithoutConfirmation) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$includeTaxesInPrices = includeTaxesInPrices;
    final lOther$includeTaxesInPrices = other.includeTaxesInPrices;
    if (_$data.containsKey('includeTaxesInPrices') !=
        other._$data.containsKey('includeTaxesInPrices')) {
      return false;
    }
    if (l$includeTaxesInPrices != lOther$includeTaxesInPrices) {
      return false;
    }
    final l$displayGrossPrices = displayGrossPrices;
    final lOther$displayGrossPrices = other.displayGrossPrices;
    if (_$data.containsKey('displayGrossPrices') !=
        other._$data.containsKey('displayGrossPrices')) {
      return false;
    }
    if (l$displayGrossPrices != lOther$displayGrossPrices) {
      return false;
    }
    final l$chargeTaxesOnShipping = chargeTaxesOnShipping;
    final lOther$chargeTaxesOnShipping = other.chargeTaxesOnShipping;
    if (_$data.containsKey('chargeTaxesOnShipping') !=
        other._$data.containsKey('chargeTaxesOnShipping')) {
      return false;
    }
    if (l$chargeTaxesOnShipping != lOther$chargeTaxesOnShipping) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$headerText = headerText;
    final l$description = description;
    final l$trackInventoryByDefault = trackInventoryByDefault;
    final l$defaultWeightUnit = defaultWeightUnit;
    final l$automaticFulfillmentDigitalProducts =
        automaticFulfillmentDigitalProducts;
    final l$fulfillmentAutoApprove = fulfillmentAutoApprove;
    final l$fulfillmentAllowUnpaid = fulfillmentAllowUnpaid;
    final l$defaultDigitalMaxDownloads = defaultDigitalMaxDownloads;
    final l$defaultDigitalUrlValidDays = defaultDigitalUrlValidDays;
    final l$defaultMailSenderName = defaultMailSenderName;
    final l$defaultMailSenderAddress = defaultMailSenderAddress;
    final l$customerSetPasswordUrl = customerSetPasswordUrl;
    final l$reserveStockDurationAnonymousUser =
        reserveStockDurationAnonymousUser;
    final l$reserveStockDurationAuthenticatedUser =
        reserveStockDurationAuthenticatedUser;
    final l$limitQuantityPerCheckout = limitQuantityPerCheckout;
    final l$enableAccountConfirmationByEmail = enableAccountConfirmationByEmail;
    final l$allowLoginWithoutConfirmation = allowLoginWithoutConfirmation;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$includeTaxesInPrices = includeTaxesInPrices;
    final l$displayGrossPrices = displayGrossPrices;
    final l$chargeTaxesOnShipping = chargeTaxesOnShipping;
    return Object.hashAll([
      _$data.containsKey('headerText') ? l$headerText : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('trackInventoryByDefault')
          ? l$trackInventoryByDefault
          : const {},
      _$data.containsKey('defaultWeightUnit') ? l$defaultWeightUnit : const {},
      _$data.containsKey('automaticFulfillmentDigitalProducts')
          ? l$automaticFulfillmentDigitalProducts
          : const {},
      _$data.containsKey('fulfillmentAutoApprove')
          ? l$fulfillmentAutoApprove
          : const {},
      _$data.containsKey('fulfillmentAllowUnpaid')
          ? l$fulfillmentAllowUnpaid
          : const {},
      _$data.containsKey('defaultDigitalMaxDownloads')
          ? l$defaultDigitalMaxDownloads
          : const {},
      _$data.containsKey('defaultDigitalUrlValidDays')
          ? l$defaultDigitalUrlValidDays
          : const {},
      _$data.containsKey('defaultMailSenderName')
          ? l$defaultMailSenderName
          : const {},
      _$data.containsKey('defaultMailSenderAddress')
          ? l$defaultMailSenderAddress
          : const {},
      _$data.containsKey('customerSetPasswordUrl')
          ? l$customerSetPasswordUrl
          : const {},
      _$data.containsKey('reserveStockDurationAnonymousUser')
          ? l$reserveStockDurationAnonymousUser
          : const {},
      _$data.containsKey('reserveStockDurationAuthenticatedUser')
          ? l$reserveStockDurationAuthenticatedUser
          : const {},
      _$data.containsKey('limitQuantityPerCheckout')
          ? l$limitQuantityPerCheckout
          : const {},
      _$data.containsKey('enableAccountConfirmationByEmail')
          ? l$enableAccountConfirmationByEmail
          : const {},
      _$data.containsKey('allowLoginWithoutConfirmation')
          ? l$allowLoginWithoutConfirmation
          : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('includeTaxesInPrices')
          ? l$includeTaxesInPrices
          : const {},
      _$data.containsKey('displayGrossPrices')
          ? l$displayGrossPrices
          : const {},
      _$data.containsKey('chargeTaxesOnShipping')
          ? l$chargeTaxesOnShipping
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ShopSettingsInput<TRes> {
  factory CopyWith$Input$ShopSettingsInput(
    Input$ShopSettingsInput instance,
    TRes Function(Input$ShopSettingsInput) then,
  ) = _CopyWithImpl$Input$ShopSettingsInput;

  factory CopyWith$Input$ShopSettingsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ShopSettingsInput;

  TRes call({
    String? headerText,
    String? description,
    bool? trackInventoryByDefault,
    Enum$WeightUnitsEnum? defaultWeightUnit,
    bool? automaticFulfillmentDigitalProducts,
    bool? fulfillmentAutoApprove,
    bool? fulfillmentAllowUnpaid,
    int? defaultDigitalMaxDownloads,
    int? defaultDigitalUrlValidDays,
    String? defaultMailSenderName,
    String? defaultMailSenderAddress,
    String? customerSetPasswordUrl,
    int? reserveStockDurationAnonymousUser,
    int? reserveStockDurationAuthenticatedUser,
    int? limitQuantityPerCheckout,
    bool? enableAccountConfirmationByEmail,
    bool? allowLoginWithoutConfirmation,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    bool? includeTaxesInPrices,
    bool? displayGrossPrices,
    bool? chargeTaxesOnShipping,
  });
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ShopSettingsInput<TRes>
    implements CopyWith$Input$ShopSettingsInput<TRes> {
  _CopyWithImpl$Input$ShopSettingsInput(
    this._instance,
    this._then,
  );

  final Input$ShopSettingsInput _instance;

  final TRes Function(Input$ShopSettingsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? headerText = _undefined,
    Object? description = _undefined,
    Object? trackInventoryByDefault = _undefined,
    Object? defaultWeightUnit = _undefined,
    Object? automaticFulfillmentDigitalProducts = _undefined,
    Object? fulfillmentAutoApprove = _undefined,
    Object? fulfillmentAllowUnpaid = _undefined,
    Object? defaultDigitalMaxDownloads = _undefined,
    Object? defaultDigitalUrlValidDays = _undefined,
    Object? defaultMailSenderName = _undefined,
    Object? defaultMailSenderAddress = _undefined,
    Object? customerSetPasswordUrl = _undefined,
    Object? reserveStockDurationAnonymousUser = _undefined,
    Object? reserveStockDurationAuthenticatedUser = _undefined,
    Object? limitQuantityPerCheckout = _undefined,
    Object? enableAccountConfirmationByEmail = _undefined,
    Object? allowLoginWithoutConfirmation = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? includeTaxesInPrices = _undefined,
    Object? displayGrossPrices = _undefined,
    Object? chargeTaxesOnShipping = _undefined,
  }) =>
      _then(Input$ShopSettingsInput._({
        ..._instance._$data,
        if (headerText != _undefined) 'headerText': (headerText as String?),
        if (description != _undefined) 'description': (description as String?),
        if (trackInventoryByDefault != _undefined)
          'trackInventoryByDefault': (trackInventoryByDefault as bool?),
        if (defaultWeightUnit != _undefined)
          'defaultWeightUnit': (defaultWeightUnit as Enum$WeightUnitsEnum?),
        if (automaticFulfillmentDigitalProducts != _undefined)
          'automaticFulfillmentDigitalProducts':
              (automaticFulfillmentDigitalProducts as bool?),
        if (fulfillmentAutoApprove != _undefined)
          'fulfillmentAutoApprove': (fulfillmentAutoApprove as bool?),
        if (fulfillmentAllowUnpaid != _undefined)
          'fulfillmentAllowUnpaid': (fulfillmentAllowUnpaid as bool?),
        if (defaultDigitalMaxDownloads != _undefined)
          'defaultDigitalMaxDownloads': (defaultDigitalMaxDownloads as int?),
        if (defaultDigitalUrlValidDays != _undefined)
          'defaultDigitalUrlValidDays': (defaultDigitalUrlValidDays as int?),
        if (defaultMailSenderName != _undefined)
          'defaultMailSenderName': (defaultMailSenderName as String?),
        if (defaultMailSenderAddress != _undefined)
          'defaultMailSenderAddress': (defaultMailSenderAddress as String?),
        if (customerSetPasswordUrl != _undefined)
          'customerSetPasswordUrl': (customerSetPasswordUrl as String?),
        if (reserveStockDurationAnonymousUser != _undefined)
          'reserveStockDurationAnonymousUser':
              (reserveStockDurationAnonymousUser as int?),
        if (reserveStockDurationAuthenticatedUser != _undefined)
          'reserveStockDurationAuthenticatedUser':
              (reserveStockDurationAuthenticatedUser as int?),
        if (limitQuantityPerCheckout != _undefined)
          'limitQuantityPerCheckout': (limitQuantityPerCheckout as int?),
        if (enableAccountConfirmationByEmail != _undefined)
          'enableAccountConfirmationByEmail':
              (enableAccountConfirmationByEmail as bool?),
        if (allowLoginWithoutConfirmation != _undefined)
          'allowLoginWithoutConfirmation':
              (allowLoginWithoutConfirmation as bool?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (includeTaxesInPrices != _undefined)
          'includeTaxesInPrices': (includeTaxesInPrices as bool?),
        if (displayGrossPrices != _undefined)
          'displayGrossPrices': (displayGrossPrices as bool?),
        if (chargeTaxesOnShipping != _undefined)
          'chargeTaxesOnShipping': (chargeTaxesOnShipping as bool?),
      }));

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ShopSettingsInput<TRes>
    implements CopyWith$Input$ShopSettingsInput<TRes> {
  _CopyWithStubImpl$Input$ShopSettingsInput(this._res);

  TRes _res;

  call({
    String? headerText,
    String? description,
    bool? trackInventoryByDefault,
    Enum$WeightUnitsEnum? defaultWeightUnit,
    bool? automaticFulfillmentDigitalProducts,
    bool? fulfillmentAutoApprove,
    bool? fulfillmentAllowUnpaid,
    int? defaultDigitalMaxDownloads,
    int? defaultDigitalUrlValidDays,
    String? defaultMailSenderName,
    String? defaultMailSenderAddress,
    String? customerSetPasswordUrl,
    int? reserveStockDurationAnonymousUser,
    int? reserveStockDurationAuthenticatedUser,
    int? limitQuantityPerCheckout,
    bool? enableAccountConfirmationByEmail,
    bool? allowLoginWithoutConfirmation,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    bool? includeTaxesInPrices,
    bool? displayGrossPrices,
    bool? chargeTaxesOnShipping,
  }) =>
      _res;

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$ShopSettingsTranslationInput {
  factory Input$ShopSettingsTranslationInput({
    String? headerText,
    String? description,
  }) =>
      Input$ShopSettingsTranslationInput._({
        if (headerText != null) r'headerText': headerText,
        if (description != null) r'description': description,
      });

  Input$ShopSettingsTranslationInput._(this._$data);

  factory Input$ShopSettingsTranslationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('headerText')) {
      final l$headerText = data['headerText'];
      result$data['headerText'] = (l$headerText as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    return Input$ShopSettingsTranslationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get headerText => (_$data['headerText'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('headerText')) {
      final l$headerText = headerText;
      result$data['headerText'] = l$headerText;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    return result$data;
  }

  CopyWith$Input$ShopSettingsTranslationInput<
          Input$ShopSettingsTranslationInput>
      get copyWith => CopyWith$Input$ShopSettingsTranslationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ShopSettingsTranslationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$headerText = headerText;
    final lOther$headerText = other.headerText;
    if (_$data.containsKey('headerText') !=
        other._$data.containsKey('headerText')) {
      return false;
    }
    if (l$headerText != lOther$headerText) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$headerText = headerText;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('headerText') ? l$headerText : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$ShopSettingsTranslationInput<TRes> {
  factory CopyWith$Input$ShopSettingsTranslationInput(
    Input$ShopSettingsTranslationInput instance,
    TRes Function(Input$ShopSettingsTranslationInput) then,
  ) = _CopyWithImpl$Input$ShopSettingsTranslationInput;

  factory CopyWith$Input$ShopSettingsTranslationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ShopSettingsTranslationInput;

  TRes call({
    String? headerText,
    String? description,
  });
}

class _CopyWithImpl$Input$ShopSettingsTranslationInput<TRes>
    implements CopyWith$Input$ShopSettingsTranslationInput<TRes> {
  _CopyWithImpl$Input$ShopSettingsTranslationInput(
    this._instance,
    this._then,
  );

  final Input$ShopSettingsTranslationInput _instance;

  final TRes Function(Input$ShopSettingsTranslationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? headerText = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$ShopSettingsTranslationInput._({
        ..._instance._$data,
        if (headerText != _undefined) 'headerText': (headerText as String?),
        if (description != _undefined) 'description': (description as String?),
      }));
}

class _CopyWithStubImpl$Input$ShopSettingsTranslationInput<TRes>
    implements CopyWith$Input$ShopSettingsTranslationInput<TRes> {
  _CopyWithStubImpl$Input$ShopSettingsTranslationInput(this._res);

  TRes _res;

  call({
    String? headerText,
    String? description,
  }) =>
      _res;
}

class Input$SiteDomainInput {
  factory Input$SiteDomainInput({
    String? domain,
    String? name,
  }) =>
      Input$SiteDomainInput._({
        if (domain != null) r'domain': domain,
        if (name != null) r'name': name,
      });

  Input$SiteDomainInput._(this._$data);

  factory Input$SiteDomainInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('domain')) {
      final l$domain = data['domain'];
      result$data['domain'] = (l$domain as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    return Input$SiteDomainInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get domain => (_$data['domain'] as String?);

  String? get name => (_$data['name'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('domain')) {
      final l$domain = domain;
      result$data['domain'] = l$domain;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    return result$data;
  }

  CopyWith$Input$SiteDomainInput<Input$SiteDomainInput> get copyWith =>
      CopyWith$Input$SiteDomainInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SiteDomainInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$domain = domain;
    final lOther$domain = other.domain;
    if (_$data.containsKey('domain') != other._$data.containsKey('domain')) {
      return false;
    }
    if (l$domain != lOther$domain) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$domain = domain;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('domain') ? l$domain : const {},
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$SiteDomainInput<TRes> {
  factory CopyWith$Input$SiteDomainInput(
    Input$SiteDomainInput instance,
    TRes Function(Input$SiteDomainInput) then,
  ) = _CopyWithImpl$Input$SiteDomainInput;

  factory CopyWith$Input$SiteDomainInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SiteDomainInput;

  TRes call({
    String? domain,
    String? name,
  });
}

class _CopyWithImpl$Input$SiteDomainInput<TRes>
    implements CopyWith$Input$SiteDomainInput<TRes> {
  _CopyWithImpl$Input$SiteDomainInput(
    this._instance,
    this._then,
  );

  final Input$SiteDomainInput _instance;

  final TRes Function(Input$SiteDomainInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? domain = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$SiteDomainInput._({
        ..._instance._$data,
        if (domain != _undefined) 'domain': (domain as String?),
        if (name != _undefined) 'name': (name as String?),
      }));
}

class _CopyWithStubImpl$Input$SiteDomainInput<TRes>
    implements CopyWith$Input$SiteDomainInput<TRes> {
  _CopyWithStubImpl$Input$SiteDomainInput(this._res);

  TRes _res;

  call({
    String? domain,
    String? name,
  }) =>
      _res;
}

class Input$StaffCreateInput {
  factory Input$StaffCreateInput({
    String? firstName,
    String? lastName,
    String? email,
    bool? isActive,
    String? note,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    List<String>? addGroups,
    String? redirectUrl,
  }) =>
      Input$StaffCreateInput._({
        if (firstName != null) r'firstName': firstName,
        if (lastName != null) r'lastName': lastName,
        if (email != null) r'email': email,
        if (isActive != null) r'isActive': isActive,
        if (note != null) r'note': note,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (addGroups != null) r'addGroups': addGroups,
        if (redirectUrl != null) r'redirectUrl': redirectUrl,
      });

  Input$StaffCreateInput._(this._$data);

  factory Input$StaffCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('firstName')) {
      final l$firstName = data['firstName'];
      result$data['firstName'] = (l$firstName as String?);
    }
    if (data.containsKey('lastName')) {
      final l$lastName = data['lastName'];
      result$data['lastName'] = (l$lastName as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = (l$isActive as bool?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('addGroups')) {
      final l$addGroups = data['addGroups'];
      result$data['addGroups'] =
          (l$addGroups as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('redirectUrl')) {
      final l$redirectUrl = data['redirectUrl'];
      result$data['redirectUrl'] = (l$redirectUrl as String?);
    }
    return Input$StaffCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get firstName => (_$data['firstName'] as String?);

  String? get lastName => (_$data['lastName'] as String?);

  String? get email => (_$data['email'] as String?);

  bool? get isActive => (_$data['isActive'] as bool?);

  String? get note => (_$data['note'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  List<String>? get addGroups => (_$data['addGroups'] as List<String>?);

  String? get redirectUrl => (_$data['redirectUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('firstName')) {
      final l$firstName = firstName;
      result$data['firstName'] = l$firstName;
    }
    if (_$data.containsKey('lastName')) {
      final l$lastName = lastName;
      result$data['lastName'] = l$lastName;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('addGroups')) {
      final l$addGroups = addGroups;
      result$data['addGroups'] = l$addGroups?.map((e) => e).toList();
    }
    if (_$data.containsKey('redirectUrl')) {
      final l$redirectUrl = redirectUrl;
      result$data['redirectUrl'] = l$redirectUrl;
    }
    return result$data;
  }

  CopyWith$Input$StaffCreateInput<Input$StaffCreateInput> get copyWith =>
      CopyWith$Input$StaffCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$StaffCreateInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$firstName = firstName;
    final lOther$firstName = other.firstName;
    if (_$data.containsKey('firstName') !=
        other._$data.containsKey('firstName')) {
      return false;
    }
    if (l$firstName != lOther$firstName) {
      return false;
    }
    final l$lastName = lastName;
    final lOther$lastName = other.lastName;
    if (_$data.containsKey('lastName') !=
        other._$data.containsKey('lastName')) {
      return false;
    }
    if (l$lastName != lOther$lastName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$addGroups = addGroups;
    final lOther$addGroups = other.addGroups;
    if (_$data.containsKey('addGroups') !=
        other._$data.containsKey('addGroups')) {
      return false;
    }
    if (l$addGroups != null && lOther$addGroups != null) {
      if (l$addGroups.length != lOther$addGroups.length) {
        return false;
      }
      for (int i = 0; i < l$addGroups.length; i++) {
        final l$addGroups$entry = l$addGroups[i];
        final lOther$addGroups$entry = lOther$addGroups[i];
        if (l$addGroups$entry != lOther$addGroups$entry) {
          return false;
        }
      }
    } else if (l$addGroups != lOther$addGroups) {
      return false;
    }
    final l$redirectUrl = redirectUrl;
    final lOther$redirectUrl = other.redirectUrl;
    if (_$data.containsKey('redirectUrl') !=
        other._$data.containsKey('redirectUrl')) {
      return false;
    }
    if (l$redirectUrl != lOther$redirectUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$firstName = firstName;
    final l$lastName = lastName;
    final l$email = email;
    final l$isActive = isActive;
    final l$note = note;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$addGroups = addGroups;
    final l$redirectUrl = redirectUrl;
    return Object.hashAll([
      _$data.containsKey('firstName') ? l$firstName : const {},
      _$data.containsKey('lastName') ? l$lastName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('note') ? l$note : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('addGroups')
          ? l$addGroups == null
              ? null
              : Object.hashAll(l$addGroups.map((v) => v))
          : const {},
      _$data.containsKey('redirectUrl') ? l$redirectUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$StaffCreateInput<TRes> {
  factory CopyWith$Input$StaffCreateInput(
    Input$StaffCreateInput instance,
    TRes Function(Input$StaffCreateInput) then,
  ) = _CopyWithImpl$Input$StaffCreateInput;

  factory CopyWith$Input$StaffCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StaffCreateInput;

  TRes call({
    String? firstName,
    String? lastName,
    String? email,
    bool? isActive,
    String? note,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    List<String>? addGroups,
    String? redirectUrl,
  });
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$StaffCreateInput<TRes>
    implements CopyWith$Input$StaffCreateInput<TRes> {
  _CopyWithImpl$Input$StaffCreateInput(
    this._instance,
    this._then,
  );

  final Input$StaffCreateInput _instance;

  final TRes Function(Input$StaffCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? firstName = _undefined,
    Object? lastName = _undefined,
    Object? email = _undefined,
    Object? isActive = _undefined,
    Object? note = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? addGroups = _undefined,
    Object? redirectUrl = _undefined,
  }) =>
      _then(Input$StaffCreateInput._({
        ..._instance._$data,
        if (firstName != _undefined) 'firstName': (firstName as String?),
        if (lastName != _undefined) 'lastName': (lastName as String?),
        if (email != _undefined) 'email': (email as String?),
        if (isActive != _undefined) 'isActive': (isActive as bool?),
        if (note != _undefined) 'note': (note as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (addGroups != _undefined) 'addGroups': (addGroups as List<String>?),
        if (redirectUrl != _undefined) 'redirectUrl': (redirectUrl as String?),
      }));

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$StaffCreateInput<TRes>
    implements CopyWith$Input$StaffCreateInput<TRes> {
  _CopyWithStubImpl$Input$StaffCreateInput(this._res);

  TRes _res;

  call({
    String? firstName,
    String? lastName,
    String? email,
    bool? isActive,
    String? note,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    List<String>? addGroups,
    String? redirectUrl,
  }) =>
      _res;

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$StaffNotificationRecipientInput {
  factory Input$StaffNotificationRecipientInput({
    String? user,
    String? email,
    bool? active,
  }) =>
      Input$StaffNotificationRecipientInput._({
        if (user != null) r'user': user,
        if (email != null) r'email': email,
        if (active != null) r'active': active,
      });

  Input$StaffNotificationRecipientInput._(this._$data);

  factory Input$StaffNotificationRecipientInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = (l$user as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('active')) {
      final l$active = data['active'];
      result$data['active'] = (l$active as bool?);
    }
    return Input$StaffNotificationRecipientInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get user => (_$data['user'] as String?);

  String? get email => (_$data['email'] as String?);

  bool? get active => (_$data['active'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('active')) {
      final l$active = active;
      result$data['active'] = l$active;
    }
    return result$data;
  }

  CopyWith$Input$StaffNotificationRecipientInput<
          Input$StaffNotificationRecipientInput>
      get copyWith => CopyWith$Input$StaffNotificationRecipientInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$StaffNotificationRecipientInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (_$data.containsKey('active') != other._$data.containsKey('active')) {
      return false;
    }
    if (l$active != lOther$active) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$user = user;
    final l$email = email;
    final l$active = active;
    return Object.hashAll([
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('active') ? l$active : const {},
    ]);
  }
}

abstract class CopyWith$Input$StaffNotificationRecipientInput<TRes> {
  factory CopyWith$Input$StaffNotificationRecipientInput(
    Input$StaffNotificationRecipientInput instance,
    TRes Function(Input$StaffNotificationRecipientInput) then,
  ) = _CopyWithImpl$Input$StaffNotificationRecipientInput;

  factory CopyWith$Input$StaffNotificationRecipientInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StaffNotificationRecipientInput;

  TRes call({
    String? user,
    String? email,
    bool? active,
  });
}

class _CopyWithImpl$Input$StaffNotificationRecipientInput<TRes>
    implements CopyWith$Input$StaffNotificationRecipientInput<TRes> {
  _CopyWithImpl$Input$StaffNotificationRecipientInput(
    this._instance,
    this._then,
  );

  final Input$StaffNotificationRecipientInput _instance;

  final TRes Function(Input$StaffNotificationRecipientInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? user = _undefined,
    Object? email = _undefined,
    Object? active = _undefined,
  }) =>
      _then(Input$StaffNotificationRecipientInput._({
        ..._instance._$data,
        if (user != _undefined) 'user': (user as String?),
        if (email != _undefined) 'email': (email as String?),
        if (active != _undefined) 'active': (active as bool?),
      }));
}

class _CopyWithStubImpl$Input$StaffNotificationRecipientInput<TRes>
    implements CopyWith$Input$StaffNotificationRecipientInput<TRes> {
  _CopyWithStubImpl$Input$StaffNotificationRecipientInput(this._res);

  TRes _res;

  call({
    String? user,
    String? email,
    bool? active,
  }) =>
      _res;
}

class Input$StaffUpdateInput {
  factory Input$StaffUpdateInput({
    String? firstName,
    String? lastName,
    String? email,
    bool? isActive,
    String? note,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    List<String>? addGroups,
    List<String>? removeGroups,
  }) =>
      Input$StaffUpdateInput._({
        if (firstName != null) r'firstName': firstName,
        if (lastName != null) r'lastName': lastName,
        if (email != null) r'email': email,
        if (isActive != null) r'isActive': isActive,
        if (note != null) r'note': note,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (addGroups != null) r'addGroups': addGroups,
        if (removeGroups != null) r'removeGroups': removeGroups,
      });

  Input$StaffUpdateInput._(this._$data);

  factory Input$StaffUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('firstName')) {
      final l$firstName = data['firstName'];
      result$data['firstName'] = (l$firstName as String?);
    }
    if (data.containsKey('lastName')) {
      final l$lastName = data['lastName'];
      result$data['lastName'] = (l$lastName as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = (l$isActive as bool?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('addGroups')) {
      final l$addGroups = data['addGroups'];
      result$data['addGroups'] =
          (l$addGroups as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('removeGroups')) {
      final l$removeGroups = data['removeGroups'];
      result$data['removeGroups'] = (l$removeGroups as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$StaffUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get firstName => (_$data['firstName'] as String?);

  String? get lastName => (_$data['lastName'] as String?);

  String? get email => (_$data['email'] as String?);

  bool? get isActive => (_$data['isActive'] as bool?);

  String? get note => (_$data['note'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  List<String>? get addGroups => (_$data['addGroups'] as List<String>?);

  List<String>? get removeGroups => (_$data['removeGroups'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('firstName')) {
      final l$firstName = firstName;
      result$data['firstName'] = l$firstName;
    }
    if (_$data.containsKey('lastName')) {
      final l$lastName = lastName;
      result$data['lastName'] = l$lastName;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('addGroups')) {
      final l$addGroups = addGroups;
      result$data['addGroups'] = l$addGroups?.map((e) => e).toList();
    }
    if (_$data.containsKey('removeGroups')) {
      final l$removeGroups = removeGroups;
      result$data['removeGroups'] = l$removeGroups?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$StaffUpdateInput<Input$StaffUpdateInput> get copyWith =>
      CopyWith$Input$StaffUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$StaffUpdateInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$firstName = firstName;
    final lOther$firstName = other.firstName;
    if (_$data.containsKey('firstName') !=
        other._$data.containsKey('firstName')) {
      return false;
    }
    if (l$firstName != lOther$firstName) {
      return false;
    }
    final l$lastName = lastName;
    final lOther$lastName = other.lastName;
    if (_$data.containsKey('lastName') !=
        other._$data.containsKey('lastName')) {
      return false;
    }
    if (l$lastName != lOther$lastName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$addGroups = addGroups;
    final lOther$addGroups = other.addGroups;
    if (_$data.containsKey('addGroups') !=
        other._$data.containsKey('addGroups')) {
      return false;
    }
    if (l$addGroups != null && lOther$addGroups != null) {
      if (l$addGroups.length != lOther$addGroups.length) {
        return false;
      }
      for (int i = 0; i < l$addGroups.length; i++) {
        final l$addGroups$entry = l$addGroups[i];
        final lOther$addGroups$entry = lOther$addGroups[i];
        if (l$addGroups$entry != lOther$addGroups$entry) {
          return false;
        }
      }
    } else if (l$addGroups != lOther$addGroups) {
      return false;
    }
    final l$removeGroups = removeGroups;
    final lOther$removeGroups = other.removeGroups;
    if (_$data.containsKey('removeGroups') !=
        other._$data.containsKey('removeGroups')) {
      return false;
    }
    if (l$removeGroups != null && lOther$removeGroups != null) {
      if (l$removeGroups.length != lOther$removeGroups.length) {
        return false;
      }
      for (int i = 0; i < l$removeGroups.length; i++) {
        final l$removeGroups$entry = l$removeGroups[i];
        final lOther$removeGroups$entry = lOther$removeGroups[i];
        if (l$removeGroups$entry != lOther$removeGroups$entry) {
          return false;
        }
      }
    } else if (l$removeGroups != lOther$removeGroups) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$firstName = firstName;
    final l$lastName = lastName;
    final l$email = email;
    final l$isActive = isActive;
    final l$note = note;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$addGroups = addGroups;
    final l$removeGroups = removeGroups;
    return Object.hashAll([
      _$data.containsKey('firstName') ? l$firstName : const {},
      _$data.containsKey('lastName') ? l$lastName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('note') ? l$note : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('addGroups')
          ? l$addGroups == null
              ? null
              : Object.hashAll(l$addGroups.map((v) => v))
          : const {},
      _$data.containsKey('removeGroups')
          ? l$removeGroups == null
              ? null
              : Object.hashAll(l$removeGroups.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$StaffUpdateInput<TRes> {
  factory CopyWith$Input$StaffUpdateInput(
    Input$StaffUpdateInput instance,
    TRes Function(Input$StaffUpdateInput) then,
  ) = _CopyWithImpl$Input$StaffUpdateInput;

  factory CopyWith$Input$StaffUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StaffUpdateInput;

  TRes call({
    String? firstName,
    String? lastName,
    String? email,
    bool? isActive,
    String? note,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    List<String>? addGroups,
    List<String>? removeGroups,
  });
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$StaffUpdateInput<TRes>
    implements CopyWith$Input$StaffUpdateInput<TRes> {
  _CopyWithImpl$Input$StaffUpdateInput(
    this._instance,
    this._then,
  );

  final Input$StaffUpdateInput _instance;

  final TRes Function(Input$StaffUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? firstName = _undefined,
    Object? lastName = _undefined,
    Object? email = _undefined,
    Object? isActive = _undefined,
    Object? note = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? addGroups = _undefined,
    Object? removeGroups = _undefined,
  }) =>
      _then(Input$StaffUpdateInput._({
        ..._instance._$data,
        if (firstName != _undefined) 'firstName': (firstName as String?),
        if (lastName != _undefined) 'lastName': (lastName as String?),
        if (email != _undefined) 'email': (email as String?),
        if (isActive != _undefined) 'isActive': (isActive as bool?),
        if (note != _undefined) 'note': (note as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (addGroups != _undefined) 'addGroups': (addGroups as List<String>?),
        if (removeGroups != _undefined)
          'removeGroups': (removeGroups as List<String>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$StaffUpdateInput<TRes>
    implements CopyWith$Input$StaffUpdateInput<TRes> {
  _CopyWithStubImpl$Input$StaffUpdateInput(this._res);

  TRes _res;

  call({
    String? firstName,
    String? lastName,
    String? email,
    bool? isActive,
    String? note,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    List<String>? addGroups,
    List<String>? removeGroups,
  }) =>
      _res;

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$StaffUserInput {
  factory Input$StaffUserInput({
    Enum$StaffMemberStatus? status,
    String? search,
    List<String>? ids,
  }) =>
      Input$StaffUserInput._({
        if (status != null) r'status': status,
        if (search != null) r'search': search,
        if (ids != null) r'ids': ids,
      });

  Input$StaffUserInput._(this._$data);

  factory Input$StaffUserInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$StaffMemberStatus((l$status as String));
    }
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$StaffUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$StaffMemberStatus? get status =>
      (_$data['status'] as Enum$StaffMemberStatus?);

  String? get search => (_$data['search'] as String?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$StaffMemberStatus(l$status);
    }
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$StaffUserInput<Input$StaffUserInput> get copyWith =>
      CopyWith$Input$StaffUserInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$StaffUserInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$status = status;
    final l$search = search;
    final l$ids = ids;
    return Object.hashAll([
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$StaffUserInput<TRes> {
  factory CopyWith$Input$StaffUserInput(
    Input$StaffUserInput instance,
    TRes Function(Input$StaffUserInput) then,
  ) = _CopyWithImpl$Input$StaffUserInput;

  factory CopyWith$Input$StaffUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StaffUserInput;

  TRes call({
    Enum$StaffMemberStatus? status,
    String? search,
    List<String>? ids,
  });
}

class _CopyWithImpl$Input$StaffUserInput<TRes>
    implements CopyWith$Input$StaffUserInput<TRes> {
  _CopyWithImpl$Input$StaffUserInput(
    this._instance,
    this._then,
  );

  final Input$StaffUserInput _instance;

  final TRes Function(Input$StaffUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? status = _undefined,
    Object? search = _undefined,
    Object? ids = _undefined,
  }) =>
      _then(Input$StaffUserInput._({
        ..._instance._$data,
        if (status != _undefined) 'status': (status as Enum$StaffMemberStatus?),
        if (search != _undefined) 'search': (search as String?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$StaffUserInput<TRes>
    implements CopyWith$Input$StaffUserInput<TRes> {
  _CopyWithStubImpl$Input$StaffUserInput(this._res);

  TRes _res;

  call({
    Enum$StaffMemberStatus? status,
    String? search,
    List<String>? ids,
  }) =>
      _res;
}

class Input$StockBulkUpdateInput {
  factory Input$StockBulkUpdateInput({
    String? variantId,
    String? variantExternalReference,
    String? warehouseId,
    String? warehouseExternalReference,
    required int quantity,
  }) =>
      Input$StockBulkUpdateInput._({
        if (variantId != null) r'variantId': variantId,
        if (variantExternalReference != null)
          r'variantExternalReference': variantExternalReference,
        if (warehouseId != null) r'warehouseId': warehouseId,
        if (warehouseExternalReference != null)
          r'warehouseExternalReference': warehouseExternalReference,
        r'quantity': quantity,
      });

  Input$StockBulkUpdateInput._(this._$data);

  factory Input$StockBulkUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('variantId')) {
      final l$variantId = data['variantId'];
      result$data['variantId'] = (l$variantId as String?);
    }
    if (data.containsKey('variantExternalReference')) {
      final l$variantExternalReference = data['variantExternalReference'];
      result$data['variantExternalReference'] =
          (l$variantExternalReference as String?);
    }
    if (data.containsKey('warehouseId')) {
      final l$warehouseId = data['warehouseId'];
      result$data['warehouseId'] = (l$warehouseId as String?);
    }
    if (data.containsKey('warehouseExternalReference')) {
      final l$warehouseExternalReference = data['warehouseExternalReference'];
      result$data['warehouseExternalReference'] =
          (l$warehouseExternalReference as String?);
    }
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    return Input$StockBulkUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get variantId => (_$data['variantId'] as String?);

  String? get variantExternalReference =>
      (_$data['variantExternalReference'] as String?);

  String? get warehouseId => (_$data['warehouseId'] as String?);

  String? get warehouseExternalReference =>
      (_$data['warehouseExternalReference'] as String?);

  int get quantity => (_$data['quantity'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('variantId')) {
      final l$variantId = variantId;
      result$data['variantId'] = l$variantId;
    }
    if (_$data.containsKey('variantExternalReference')) {
      final l$variantExternalReference = variantExternalReference;
      result$data['variantExternalReference'] = l$variantExternalReference;
    }
    if (_$data.containsKey('warehouseId')) {
      final l$warehouseId = warehouseId;
      result$data['warehouseId'] = l$warehouseId;
    }
    if (_$data.containsKey('warehouseExternalReference')) {
      final l$warehouseExternalReference = warehouseExternalReference;
      result$data['warehouseExternalReference'] = l$warehouseExternalReference;
    }
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    return result$data;
  }

  CopyWith$Input$StockBulkUpdateInput<Input$StockBulkUpdateInput>
      get copyWith => CopyWith$Input$StockBulkUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$StockBulkUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$variantId = variantId;
    final lOther$variantId = other.variantId;
    if (_$data.containsKey('variantId') !=
        other._$data.containsKey('variantId')) {
      return false;
    }
    if (l$variantId != lOther$variantId) {
      return false;
    }
    final l$variantExternalReference = variantExternalReference;
    final lOther$variantExternalReference = other.variantExternalReference;
    if (_$data.containsKey('variantExternalReference') !=
        other._$data.containsKey('variantExternalReference')) {
      return false;
    }
    if (l$variantExternalReference != lOther$variantExternalReference) {
      return false;
    }
    final l$warehouseId = warehouseId;
    final lOther$warehouseId = other.warehouseId;
    if (_$data.containsKey('warehouseId') !=
        other._$data.containsKey('warehouseId')) {
      return false;
    }
    if (l$warehouseId != lOther$warehouseId) {
      return false;
    }
    final l$warehouseExternalReference = warehouseExternalReference;
    final lOther$warehouseExternalReference = other.warehouseExternalReference;
    if (_$data.containsKey('warehouseExternalReference') !=
        other._$data.containsKey('warehouseExternalReference')) {
      return false;
    }
    if (l$warehouseExternalReference != lOther$warehouseExternalReference) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$variantId = variantId;
    final l$variantExternalReference = variantExternalReference;
    final l$warehouseId = warehouseId;
    final l$warehouseExternalReference = warehouseExternalReference;
    final l$quantity = quantity;
    return Object.hashAll([
      _$data.containsKey('variantId') ? l$variantId : const {},
      _$data.containsKey('variantExternalReference')
          ? l$variantExternalReference
          : const {},
      _$data.containsKey('warehouseId') ? l$warehouseId : const {},
      _$data.containsKey('warehouseExternalReference')
          ? l$warehouseExternalReference
          : const {},
      l$quantity,
    ]);
  }
}

abstract class CopyWith$Input$StockBulkUpdateInput<TRes> {
  factory CopyWith$Input$StockBulkUpdateInput(
    Input$StockBulkUpdateInput instance,
    TRes Function(Input$StockBulkUpdateInput) then,
  ) = _CopyWithImpl$Input$StockBulkUpdateInput;

  factory CopyWith$Input$StockBulkUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StockBulkUpdateInput;

  TRes call({
    String? variantId,
    String? variantExternalReference,
    String? warehouseId,
    String? warehouseExternalReference,
    int? quantity,
  });
}

class _CopyWithImpl$Input$StockBulkUpdateInput<TRes>
    implements CopyWith$Input$StockBulkUpdateInput<TRes> {
  _CopyWithImpl$Input$StockBulkUpdateInput(
    this._instance,
    this._then,
  );

  final Input$StockBulkUpdateInput _instance;

  final TRes Function(Input$StockBulkUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? variantId = _undefined,
    Object? variantExternalReference = _undefined,
    Object? warehouseId = _undefined,
    Object? warehouseExternalReference = _undefined,
    Object? quantity = _undefined,
  }) =>
      _then(Input$StockBulkUpdateInput._({
        ..._instance._$data,
        if (variantId != _undefined) 'variantId': (variantId as String?),
        if (variantExternalReference != _undefined)
          'variantExternalReference': (variantExternalReference as String?),
        if (warehouseId != _undefined) 'warehouseId': (warehouseId as String?),
        if (warehouseExternalReference != _undefined)
          'warehouseExternalReference': (warehouseExternalReference as String?),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
      }));
}

class _CopyWithStubImpl$Input$StockBulkUpdateInput<TRes>
    implements CopyWith$Input$StockBulkUpdateInput<TRes> {
  _CopyWithStubImpl$Input$StockBulkUpdateInput(this._res);

  TRes _res;

  call({
    String? variantId,
    String? variantExternalReference,
    String? warehouseId,
    String? warehouseExternalReference,
    int? quantity,
  }) =>
      _res;
}

class Input$StockFilterInput {
  factory Input$StockFilterInput({
    double? quantity,
    String? search,
  }) =>
      Input$StockFilterInput._({
        if (quantity != null) r'quantity': quantity,
        if (search != null) r'search': search,
      });

  Input$StockFilterInput._(this._$data);

  factory Input$StockFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = (l$quantity as num?)?.toDouble();
    }
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    return Input$StockFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get quantity => (_$data['quantity'] as double?);

  String? get search => (_$data['search'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity;
    }
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    return result$data;
  }

  CopyWith$Input$StockFilterInput<Input$StockFilterInput> get copyWith =>
      CopyWith$Input$StockFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$StockFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$search = search;
    return Object.hashAll([
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('search') ? l$search : const {},
    ]);
  }
}

abstract class CopyWith$Input$StockFilterInput<TRes> {
  factory CopyWith$Input$StockFilterInput(
    Input$StockFilterInput instance,
    TRes Function(Input$StockFilterInput) then,
  ) = _CopyWithImpl$Input$StockFilterInput;

  factory CopyWith$Input$StockFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StockFilterInput;

  TRes call({
    double? quantity,
    String? search,
  });
}

class _CopyWithImpl$Input$StockFilterInput<TRes>
    implements CopyWith$Input$StockFilterInput<TRes> {
  _CopyWithImpl$Input$StockFilterInput(
    this._instance,
    this._then,
  );

  final Input$StockFilterInput _instance;

  final TRes Function(Input$StockFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? search = _undefined,
  }) =>
      _then(Input$StockFilterInput._({
        ..._instance._$data,
        if (quantity != _undefined) 'quantity': (quantity as double?),
        if (search != _undefined) 'search': (search as String?),
      }));
}

class _CopyWithStubImpl$Input$StockFilterInput<TRes>
    implements CopyWith$Input$StockFilterInput<TRes> {
  _CopyWithStubImpl$Input$StockFilterInput(this._res);

  TRes _res;

  call({
    double? quantity,
    String? search,
  }) =>
      _res;
}

class Input$StockInput {
  factory Input$StockInput({
    required String warehouse,
    required int quantity,
  }) =>
      Input$StockInput._({
        r'warehouse': warehouse,
        r'quantity': quantity,
      });

  Input$StockInput._(this._$data);

  factory Input$StockInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$warehouse = data['warehouse'];
    result$data['warehouse'] = (l$warehouse as String);
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    return Input$StockInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get warehouse => (_$data['warehouse'] as String);

  int get quantity => (_$data['quantity'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$warehouse = warehouse;
    result$data['warehouse'] = l$warehouse;
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    return result$data;
  }

  CopyWith$Input$StockInput<Input$StockInput> get copyWith =>
      CopyWith$Input$StockInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$StockInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$warehouse = warehouse;
    final lOther$warehouse = other.warehouse;
    if (l$warehouse != lOther$warehouse) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$warehouse = warehouse;
    final l$quantity = quantity;
    return Object.hashAll([
      l$warehouse,
      l$quantity,
    ]);
  }
}

abstract class CopyWith$Input$StockInput<TRes> {
  factory CopyWith$Input$StockInput(
    Input$StockInput instance,
    TRes Function(Input$StockInput) then,
  ) = _CopyWithImpl$Input$StockInput;

  factory CopyWith$Input$StockInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StockInput;

  TRes call({
    String? warehouse,
    int? quantity,
  });
}

class _CopyWithImpl$Input$StockInput<TRes>
    implements CopyWith$Input$StockInput<TRes> {
  _CopyWithImpl$Input$StockInput(
    this._instance,
    this._then,
  );

  final Input$StockInput _instance;

  final TRes Function(Input$StockInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? warehouse = _undefined,
    Object? quantity = _undefined,
  }) =>
      _then(Input$StockInput._({
        ..._instance._$data,
        if (warehouse != _undefined && warehouse != null)
          'warehouse': (warehouse as String),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
      }));
}

class _CopyWithStubImpl$Input$StockInput<TRes>
    implements CopyWith$Input$StockInput<TRes> {
  _CopyWithStubImpl$Input$StockInput(this._res);

  TRes _res;

  call({
    String? warehouse,
    int? quantity,
  }) =>
      _res;
}

class Input$StockSettingsInput {
  factory Input$StockSettingsInput(
          {required Enum$AllocationStrategyEnum allocationStrategy}) =>
      Input$StockSettingsInput._({
        r'allocationStrategy': allocationStrategy,
      });

  Input$StockSettingsInput._(this._$data);

  factory Input$StockSettingsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$allocationStrategy = data['allocationStrategy'];
    result$data['allocationStrategy'] =
        fromJson$Enum$AllocationStrategyEnum((l$allocationStrategy as String));
    return Input$StockSettingsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$AllocationStrategyEnum get allocationStrategy =>
      (_$data['allocationStrategy'] as Enum$AllocationStrategyEnum);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$allocationStrategy = allocationStrategy;
    result$data['allocationStrategy'] =
        toJson$Enum$AllocationStrategyEnum(l$allocationStrategy);
    return result$data;
  }

  CopyWith$Input$StockSettingsInput<Input$StockSettingsInput> get copyWith =>
      CopyWith$Input$StockSettingsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$StockSettingsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$allocationStrategy = allocationStrategy;
    final lOther$allocationStrategy = other.allocationStrategy;
    if (l$allocationStrategy != lOther$allocationStrategy) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$allocationStrategy = allocationStrategy;
    return Object.hashAll([l$allocationStrategy]);
  }
}

abstract class CopyWith$Input$StockSettingsInput<TRes> {
  factory CopyWith$Input$StockSettingsInput(
    Input$StockSettingsInput instance,
    TRes Function(Input$StockSettingsInput) then,
  ) = _CopyWithImpl$Input$StockSettingsInput;

  factory CopyWith$Input$StockSettingsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StockSettingsInput;

  TRes call({Enum$AllocationStrategyEnum? allocationStrategy});
}

class _CopyWithImpl$Input$StockSettingsInput<TRes>
    implements CopyWith$Input$StockSettingsInput<TRes> {
  _CopyWithImpl$Input$StockSettingsInput(
    this._instance,
    this._then,
  );

  final Input$StockSettingsInput _instance;

  final TRes Function(Input$StockSettingsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? allocationStrategy = _undefined}) =>
      _then(Input$StockSettingsInput._({
        ..._instance._$data,
        if (allocationStrategy != _undefined && allocationStrategy != null)
          'allocationStrategy':
              (allocationStrategy as Enum$AllocationStrategyEnum),
      }));
}

class _CopyWithStubImpl$Input$StockSettingsInput<TRes>
    implements CopyWith$Input$StockSettingsInput<TRes> {
  _CopyWithStubImpl$Input$StockSettingsInput(this._res);

  TRes _res;

  call({Enum$AllocationStrategyEnum? allocationStrategy}) => _res;
}

class Input$StockUpdateInput {
  factory Input$StockUpdateInput({
    required String stock,
    required int quantity,
  }) =>
      Input$StockUpdateInput._({
        r'stock': stock,
        r'quantity': quantity,
      });

  Input$StockUpdateInput._(this._$data);

  factory Input$StockUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$stock = data['stock'];
    result$data['stock'] = (l$stock as String);
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    return Input$StockUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get stock => (_$data['stock'] as String);

  int get quantity => (_$data['quantity'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$stock = stock;
    result$data['stock'] = l$stock;
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    return result$data;
  }

  CopyWith$Input$StockUpdateInput<Input$StockUpdateInput> get copyWith =>
      CopyWith$Input$StockUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$StockUpdateInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$stock = stock;
    final lOther$stock = other.stock;
    if (l$stock != lOther$stock) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$stock = stock;
    final l$quantity = quantity;
    return Object.hashAll([
      l$stock,
      l$quantity,
    ]);
  }
}

abstract class CopyWith$Input$StockUpdateInput<TRes> {
  factory CopyWith$Input$StockUpdateInput(
    Input$StockUpdateInput instance,
    TRes Function(Input$StockUpdateInput) then,
  ) = _CopyWithImpl$Input$StockUpdateInput;

  factory CopyWith$Input$StockUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StockUpdateInput;

  TRes call({
    String? stock,
    int? quantity,
  });
}

class _CopyWithImpl$Input$StockUpdateInput<TRes>
    implements CopyWith$Input$StockUpdateInput<TRes> {
  _CopyWithImpl$Input$StockUpdateInput(
    this._instance,
    this._then,
  );

  final Input$StockUpdateInput _instance;

  final TRes Function(Input$StockUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? stock = _undefined,
    Object? quantity = _undefined,
  }) =>
      _then(Input$StockUpdateInput._({
        ..._instance._$data,
        if (stock != _undefined && stock != null) 'stock': (stock as String),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
      }));
}

class _CopyWithStubImpl$Input$StockUpdateInput<TRes>
    implements CopyWith$Input$StockUpdateInput<TRes> {
  _CopyWithStubImpl$Input$StockUpdateInput(this._res);

  TRes _res;

  call({
    String? stock,
    int? quantity,
  }) =>
      _res;
}

class Input$StringFilterInput {
  factory Input$StringFilterInput({
    String? eq,
    List<String>? oneOf,
  }) =>
      Input$StringFilterInput._({
        if (eq != null) r'eq': eq,
        if (oneOf != null) r'oneOf': oneOf,
      });

  Input$StringFilterInput._(this._$data);

  factory Input$StringFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('oneOf')) {
      final l$oneOf = data['oneOf'];
      result$data['oneOf'] =
          (l$oneOf as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$StringFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get eq => (_$data['eq'] as String?);

  List<String>? get oneOf => (_$data['oneOf'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('oneOf')) {
      final l$oneOf = oneOf;
      result$data['oneOf'] = l$oneOf?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$StringFilterInput<Input$StringFilterInput> get copyWith =>
      CopyWith$Input$StringFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$StringFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$oneOf = oneOf;
    final lOther$oneOf = other.oneOf;
    if (_$data.containsKey('oneOf') != other._$data.containsKey('oneOf')) {
      return false;
    }
    if (l$oneOf != null && lOther$oneOf != null) {
      if (l$oneOf.length != lOther$oneOf.length) {
        return false;
      }
      for (int i = 0; i < l$oneOf.length; i++) {
        final l$oneOf$entry = l$oneOf[i];
        final lOther$oneOf$entry = lOther$oneOf[i];
        if (l$oneOf$entry != lOther$oneOf$entry) {
          return false;
        }
      }
    } else if (l$oneOf != lOther$oneOf) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$oneOf = oneOf;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('oneOf')
          ? l$oneOf == null
              ? null
              : Object.hashAll(l$oneOf.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringFilterInput<TRes> {
  factory CopyWith$Input$StringFilterInput(
    Input$StringFilterInput instance,
    TRes Function(Input$StringFilterInput) then,
  ) = _CopyWithImpl$Input$StringFilterInput;

  factory CopyWith$Input$StringFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StringFilterInput;

  TRes call({
    String? eq,
    List<String>? oneOf,
  });
}

class _CopyWithImpl$Input$StringFilterInput<TRes>
    implements CopyWith$Input$StringFilterInput<TRes> {
  _CopyWithImpl$Input$StringFilterInput(
    this._instance,
    this._then,
  );

  final Input$StringFilterInput _instance;

  final TRes Function(Input$StringFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? oneOf = _undefined,
  }) =>
      _then(Input$StringFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as String?),
        if (oneOf != _undefined) 'oneOf': (oneOf as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$StringFilterInput<TRes>
    implements CopyWith$Input$StringFilterInput<TRes> {
  _CopyWithStubImpl$Input$StringFilterInput(this._res);

  TRes _res;

  call({
    String? eq,
    List<String>? oneOf,
  }) =>
      _res;
}

class Input$TaxClassCreateInput {
  factory Input$TaxClassCreateInput({
    required String name,
    List<Input$CountryRateInput>? createCountryRates,
  }) =>
      Input$TaxClassCreateInput._({
        r'name': name,
        if (createCountryRates != null)
          r'createCountryRates': createCountryRates,
      });

  Input$TaxClassCreateInput._(this._$data);

  factory Input$TaxClassCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('createCountryRates')) {
      final l$createCountryRates = data['createCountryRates'];
      result$data['createCountryRates'] =
          (l$createCountryRates as List<dynamic>?)
              ?.map((e) =>
                  Input$CountryRateInput.fromJson((e as Map<String, dynamic>)))
              .toList();
    }
    return Input$TaxClassCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  List<Input$CountryRateInput>? get createCountryRates =>
      (_$data['createCountryRates'] as List<Input$CountryRateInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('createCountryRates')) {
      final l$createCountryRates = createCountryRates;
      result$data['createCountryRates'] =
          l$createCountryRates?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$TaxClassCreateInput<Input$TaxClassCreateInput> get copyWith =>
      CopyWith$Input$TaxClassCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TaxClassCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$createCountryRates = createCountryRates;
    final lOther$createCountryRates = other.createCountryRates;
    if (_$data.containsKey('createCountryRates') !=
        other._$data.containsKey('createCountryRates')) {
      return false;
    }
    if (l$createCountryRates != null && lOther$createCountryRates != null) {
      if (l$createCountryRates.length != lOther$createCountryRates.length) {
        return false;
      }
      for (int i = 0; i < l$createCountryRates.length; i++) {
        final l$createCountryRates$entry = l$createCountryRates[i];
        final lOther$createCountryRates$entry = lOther$createCountryRates[i];
        if (l$createCountryRates$entry != lOther$createCountryRates$entry) {
          return false;
        }
      }
    } else if (l$createCountryRates != lOther$createCountryRates) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$createCountryRates = createCountryRates;
    return Object.hashAll([
      l$name,
      _$data.containsKey('createCountryRates')
          ? l$createCountryRates == null
              ? null
              : Object.hashAll(l$createCountryRates.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TaxClassCreateInput<TRes> {
  factory CopyWith$Input$TaxClassCreateInput(
    Input$TaxClassCreateInput instance,
    TRes Function(Input$TaxClassCreateInput) then,
  ) = _CopyWithImpl$Input$TaxClassCreateInput;

  factory CopyWith$Input$TaxClassCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TaxClassCreateInput;

  TRes call({
    String? name,
    List<Input$CountryRateInput>? createCountryRates,
  });
  TRes createCountryRates(
      Iterable<Input$CountryRateInput>? Function(
              Iterable<
                  CopyWith$Input$CountryRateInput<Input$CountryRateInput>>?)
          _fn);
}

class _CopyWithImpl$Input$TaxClassCreateInput<TRes>
    implements CopyWith$Input$TaxClassCreateInput<TRes> {
  _CopyWithImpl$Input$TaxClassCreateInput(
    this._instance,
    this._then,
  );

  final Input$TaxClassCreateInput _instance;

  final TRes Function(Input$TaxClassCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? createCountryRates = _undefined,
  }) =>
      _then(Input$TaxClassCreateInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (createCountryRates != _undefined)
          'createCountryRates':
              (createCountryRates as List<Input$CountryRateInput>?),
      }));

  TRes createCountryRates(
          Iterable<Input$CountryRateInput>? Function(
                  Iterable<
                      CopyWith$Input$CountryRateInput<Input$CountryRateInput>>?)
              _fn) =>
      call(
          createCountryRates: _fn(_instance.createCountryRates
              ?.map((e) => CopyWith$Input$CountryRateInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TaxClassCreateInput<TRes>
    implements CopyWith$Input$TaxClassCreateInput<TRes> {
  _CopyWithStubImpl$Input$TaxClassCreateInput(this._res);

  TRes _res;

  call({
    String? name,
    List<Input$CountryRateInput>? createCountryRates,
  }) =>
      _res;

  createCountryRates(_fn) => _res;
}

class Input$TaxClassFilterInput {
  factory Input$TaxClassFilterInput({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<Enum$CountryCode>? countries,
  }) =>
      Input$TaxClassFilterInput._({
        if (metadata != null) r'metadata': metadata,
        if (ids != null) r'ids': ids,
        if (countries != null) r'countries': countries,
      });

  Input$TaxClassFilterInput._(this._$data);

  factory Input$TaxClassFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('countries')) {
      final l$countries = data['countries'];
      result$data['countries'] = (l$countries as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CountryCode((e as String)))
          .toList();
    }
    return Input$TaxClassFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  List<Enum$CountryCode>? get countries =>
      (_$data['countries'] as List<Enum$CountryCode>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('countries')) {
      final l$countries = countries;
      result$data['countries'] =
          l$countries?.map((e) => toJson$Enum$CountryCode(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$TaxClassFilterInput<Input$TaxClassFilterInput> get copyWith =>
      CopyWith$Input$TaxClassFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TaxClassFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$countries = countries;
    final lOther$countries = other.countries;
    if (_$data.containsKey('countries') !=
        other._$data.containsKey('countries')) {
      return false;
    }
    if (l$countries != null && lOther$countries != null) {
      if (l$countries.length != lOther$countries.length) {
        return false;
      }
      for (int i = 0; i < l$countries.length; i++) {
        final l$countries$entry = l$countries[i];
        final lOther$countries$entry = lOther$countries[i];
        if (l$countries$entry != lOther$countries$entry) {
          return false;
        }
      }
    } else if (l$countries != lOther$countries) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$metadata = metadata;
    final l$ids = ids;
    final l$countries = countries;
    return Object.hashAll([
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('countries')
          ? l$countries == null
              ? null
              : Object.hashAll(l$countries.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TaxClassFilterInput<TRes> {
  factory CopyWith$Input$TaxClassFilterInput(
    Input$TaxClassFilterInput instance,
    TRes Function(Input$TaxClassFilterInput) then,
  ) = _CopyWithImpl$Input$TaxClassFilterInput;

  factory CopyWith$Input$TaxClassFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TaxClassFilterInput;

  TRes call({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<Enum$CountryCode>? countries,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
}

class _CopyWithImpl$Input$TaxClassFilterInput<TRes>
    implements CopyWith$Input$TaxClassFilterInput<TRes> {
  _CopyWithImpl$Input$TaxClassFilterInput(
    this._instance,
    this._then,
  );

  final Input$TaxClassFilterInput _instance;

  final TRes Function(Input$TaxClassFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? metadata = _undefined,
    Object? ids = _undefined,
    Object? countries = _undefined,
  }) =>
      _then(Input$TaxClassFilterInput._({
        ..._instance._$data,
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (countries != _undefined)
          'countries': (countries as List<Enum$CountryCode>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TaxClassFilterInput<TRes>
    implements CopyWith$Input$TaxClassFilterInput<TRes> {
  _CopyWithStubImpl$Input$TaxClassFilterInput(this._res);

  TRes _res;

  call({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
    List<Enum$CountryCode>? countries,
  }) =>
      _res;

  metadata(_fn) => _res;
}

class Input$TaxClassRateInput {
  factory Input$TaxClassRateInput({
    String? taxClassId,
    double? rate,
  }) =>
      Input$TaxClassRateInput._({
        if (taxClassId != null) r'taxClassId': taxClassId,
        if (rate != null) r'rate': rate,
      });

  Input$TaxClassRateInput._(this._$data);

  factory Input$TaxClassRateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('taxClassId')) {
      final l$taxClassId = data['taxClassId'];
      result$data['taxClassId'] = (l$taxClassId as String?);
    }
    if (data.containsKey('rate')) {
      final l$rate = data['rate'];
      result$data['rate'] = (l$rate as num?)?.toDouble();
    }
    return Input$TaxClassRateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get taxClassId => (_$data['taxClassId'] as String?);

  double? get rate => (_$data['rate'] as double?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('taxClassId')) {
      final l$taxClassId = taxClassId;
      result$data['taxClassId'] = l$taxClassId;
    }
    if (_$data.containsKey('rate')) {
      final l$rate = rate;
      result$data['rate'] = l$rate;
    }
    return result$data;
  }

  CopyWith$Input$TaxClassRateInput<Input$TaxClassRateInput> get copyWith =>
      CopyWith$Input$TaxClassRateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TaxClassRateInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$taxClassId = taxClassId;
    final lOther$taxClassId = other.taxClassId;
    if (_$data.containsKey('taxClassId') !=
        other._$data.containsKey('taxClassId')) {
      return false;
    }
    if (l$taxClassId != lOther$taxClassId) {
      return false;
    }
    final l$rate = rate;
    final lOther$rate = other.rate;
    if (_$data.containsKey('rate') != other._$data.containsKey('rate')) {
      return false;
    }
    if (l$rate != lOther$rate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$taxClassId = taxClassId;
    final l$rate = rate;
    return Object.hashAll([
      _$data.containsKey('taxClassId') ? l$taxClassId : const {},
      _$data.containsKey('rate') ? l$rate : const {},
    ]);
  }
}

abstract class CopyWith$Input$TaxClassRateInput<TRes> {
  factory CopyWith$Input$TaxClassRateInput(
    Input$TaxClassRateInput instance,
    TRes Function(Input$TaxClassRateInput) then,
  ) = _CopyWithImpl$Input$TaxClassRateInput;

  factory CopyWith$Input$TaxClassRateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TaxClassRateInput;

  TRes call({
    String? taxClassId,
    double? rate,
  });
}

class _CopyWithImpl$Input$TaxClassRateInput<TRes>
    implements CopyWith$Input$TaxClassRateInput<TRes> {
  _CopyWithImpl$Input$TaxClassRateInput(
    this._instance,
    this._then,
  );

  final Input$TaxClassRateInput _instance;

  final TRes Function(Input$TaxClassRateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? taxClassId = _undefined,
    Object? rate = _undefined,
  }) =>
      _then(Input$TaxClassRateInput._({
        ..._instance._$data,
        if (taxClassId != _undefined) 'taxClassId': (taxClassId as String?),
        if (rate != _undefined) 'rate': (rate as double?),
      }));
}

class _CopyWithStubImpl$Input$TaxClassRateInput<TRes>
    implements CopyWith$Input$TaxClassRateInput<TRes> {
  _CopyWithStubImpl$Input$TaxClassRateInput(this._res);

  TRes _res;

  call({
    String? taxClassId,
    double? rate,
  }) =>
      _res;
}

class Input$TaxClassSortingInput {
  factory Input$TaxClassSortingInput({
    required Enum$OrderDirection direction,
    required Enum$TaxClassSortField field,
  }) =>
      Input$TaxClassSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$TaxClassSortingInput._(this._$data);

  factory Input$TaxClassSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$TaxClassSortField((l$field as String));
    return Input$TaxClassSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$TaxClassSortField get field =>
      (_$data['field'] as Enum$TaxClassSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$TaxClassSortField(l$field);
    return result$data;
  }

  CopyWith$Input$TaxClassSortingInput<Input$TaxClassSortingInput>
      get copyWith => CopyWith$Input$TaxClassSortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TaxClassSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$TaxClassSortingInput<TRes> {
  factory CopyWith$Input$TaxClassSortingInput(
    Input$TaxClassSortingInput instance,
    TRes Function(Input$TaxClassSortingInput) then,
  ) = _CopyWithImpl$Input$TaxClassSortingInput;

  factory CopyWith$Input$TaxClassSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TaxClassSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$TaxClassSortField? field,
  });
}

class _CopyWithImpl$Input$TaxClassSortingInput<TRes>
    implements CopyWith$Input$TaxClassSortingInput<TRes> {
  _CopyWithImpl$Input$TaxClassSortingInput(
    this._instance,
    this._then,
  );

  final Input$TaxClassSortingInput _instance;

  final TRes Function(Input$TaxClassSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$TaxClassSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$TaxClassSortField),
      }));
}

class _CopyWithStubImpl$Input$TaxClassSortingInput<TRes>
    implements CopyWith$Input$TaxClassSortingInput<TRes> {
  _CopyWithStubImpl$Input$TaxClassSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$TaxClassSortField? field,
  }) =>
      _res;
}

class Input$TaxClassUpdateInput {
  factory Input$TaxClassUpdateInput({
    String? name,
    List<Input$CountryRateUpdateInput>? updateCountryRates,
    List<Enum$CountryCode>? removeCountryRates,
  }) =>
      Input$TaxClassUpdateInput._({
        if (name != null) r'name': name,
        if (updateCountryRates != null)
          r'updateCountryRates': updateCountryRates,
        if (removeCountryRates != null)
          r'removeCountryRates': removeCountryRates,
      });

  Input$TaxClassUpdateInput._(this._$data);

  factory Input$TaxClassUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('updateCountryRates')) {
      final l$updateCountryRates = data['updateCountryRates'];
      result$data['updateCountryRates'] =
          (l$updateCountryRates as List<dynamic>?)
              ?.map((e) => Input$CountryRateUpdateInput.fromJson(
                  (e as Map<String, dynamic>)))
              .toList();
    }
    if (data.containsKey('removeCountryRates')) {
      final l$removeCountryRates = data['removeCountryRates'];
      result$data['removeCountryRates'] =
          (l$removeCountryRates as List<dynamic>?)
              ?.map((e) => fromJson$Enum$CountryCode((e as String)))
              .toList();
    }
    return Input$TaxClassUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  List<Input$CountryRateUpdateInput>? get updateCountryRates =>
      (_$data['updateCountryRates'] as List<Input$CountryRateUpdateInput>?);

  List<Enum$CountryCode>? get removeCountryRates =>
      (_$data['removeCountryRates'] as List<Enum$CountryCode>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('updateCountryRates')) {
      final l$updateCountryRates = updateCountryRates;
      result$data['updateCountryRates'] =
          l$updateCountryRates?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('removeCountryRates')) {
      final l$removeCountryRates = removeCountryRates;
      result$data['removeCountryRates'] =
          l$removeCountryRates?.map((e) => toJson$Enum$CountryCode(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$TaxClassUpdateInput<Input$TaxClassUpdateInput> get copyWith =>
      CopyWith$Input$TaxClassUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TaxClassUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$updateCountryRates = updateCountryRates;
    final lOther$updateCountryRates = other.updateCountryRates;
    if (_$data.containsKey('updateCountryRates') !=
        other._$data.containsKey('updateCountryRates')) {
      return false;
    }
    if (l$updateCountryRates != null && lOther$updateCountryRates != null) {
      if (l$updateCountryRates.length != lOther$updateCountryRates.length) {
        return false;
      }
      for (int i = 0; i < l$updateCountryRates.length; i++) {
        final l$updateCountryRates$entry = l$updateCountryRates[i];
        final lOther$updateCountryRates$entry = lOther$updateCountryRates[i];
        if (l$updateCountryRates$entry != lOther$updateCountryRates$entry) {
          return false;
        }
      }
    } else if (l$updateCountryRates != lOther$updateCountryRates) {
      return false;
    }
    final l$removeCountryRates = removeCountryRates;
    final lOther$removeCountryRates = other.removeCountryRates;
    if (_$data.containsKey('removeCountryRates') !=
        other._$data.containsKey('removeCountryRates')) {
      return false;
    }
    if (l$removeCountryRates != null && lOther$removeCountryRates != null) {
      if (l$removeCountryRates.length != lOther$removeCountryRates.length) {
        return false;
      }
      for (int i = 0; i < l$removeCountryRates.length; i++) {
        final l$removeCountryRates$entry = l$removeCountryRates[i];
        final lOther$removeCountryRates$entry = lOther$removeCountryRates[i];
        if (l$removeCountryRates$entry != lOther$removeCountryRates$entry) {
          return false;
        }
      }
    } else if (l$removeCountryRates != lOther$removeCountryRates) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$updateCountryRates = updateCountryRates;
    final l$removeCountryRates = removeCountryRates;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('updateCountryRates')
          ? l$updateCountryRates == null
              ? null
              : Object.hashAll(l$updateCountryRates.map((v) => v))
          : const {},
      _$data.containsKey('removeCountryRates')
          ? l$removeCountryRates == null
              ? null
              : Object.hashAll(l$removeCountryRates.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TaxClassUpdateInput<TRes> {
  factory CopyWith$Input$TaxClassUpdateInput(
    Input$TaxClassUpdateInput instance,
    TRes Function(Input$TaxClassUpdateInput) then,
  ) = _CopyWithImpl$Input$TaxClassUpdateInput;

  factory CopyWith$Input$TaxClassUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TaxClassUpdateInput;

  TRes call({
    String? name,
    List<Input$CountryRateUpdateInput>? updateCountryRates,
    List<Enum$CountryCode>? removeCountryRates,
  });
  TRes updateCountryRates(
      Iterable<Input$CountryRateUpdateInput>? Function(
              Iterable<
                  CopyWith$Input$CountryRateUpdateInput<
                      Input$CountryRateUpdateInput>>?)
          _fn);
}

class _CopyWithImpl$Input$TaxClassUpdateInput<TRes>
    implements CopyWith$Input$TaxClassUpdateInput<TRes> {
  _CopyWithImpl$Input$TaxClassUpdateInput(
    this._instance,
    this._then,
  );

  final Input$TaxClassUpdateInput _instance;

  final TRes Function(Input$TaxClassUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? updateCountryRates = _undefined,
    Object? removeCountryRates = _undefined,
  }) =>
      _then(Input$TaxClassUpdateInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (updateCountryRates != _undefined)
          'updateCountryRates':
              (updateCountryRates as List<Input$CountryRateUpdateInput>?),
        if (removeCountryRates != _undefined)
          'removeCountryRates': (removeCountryRates as List<Enum$CountryCode>?),
      }));

  TRes updateCountryRates(
          Iterable<Input$CountryRateUpdateInput>? Function(
                  Iterable<
                      CopyWith$Input$CountryRateUpdateInput<
                          Input$CountryRateUpdateInput>>?)
              _fn) =>
      call(
          updateCountryRates: _fn(_instance.updateCountryRates
              ?.map((e) => CopyWith$Input$CountryRateUpdateInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TaxClassUpdateInput<TRes>
    implements CopyWith$Input$TaxClassUpdateInput<TRes> {
  _CopyWithStubImpl$Input$TaxClassUpdateInput(this._res);

  TRes _res;

  call({
    String? name,
    List<Input$CountryRateUpdateInput>? updateCountryRates,
    List<Enum$CountryCode>? removeCountryRates,
  }) =>
      _res;

  updateCountryRates(_fn) => _res;
}

class Input$TaxConfigurationFilterInput {
  factory Input$TaxConfigurationFilterInput({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
  }) =>
      Input$TaxConfigurationFilterInput._({
        if (metadata != null) r'metadata': metadata,
        if (ids != null) r'ids': ids,
      });

  Input$TaxConfigurationFilterInput._(this._$data);

  factory Input$TaxConfigurationFilterInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$TaxConfigurationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$TaxConfigurationFilterInput<Input$TaxConfigurationFilterInput>
      get copyWith => CopyWith$Input$TaxConfigurationFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TaxConfigurationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$metadata = metadata;
    final l$ids = ids;
    return Object.hashAll([
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TaxConfigurationFilterInput<TRes> {
  factory CopyWith$Input$TaxConfigurationFilterInput(
    Input$TaxConfigurationFilterInput instance,
    TRes Function(Input$TaxConfigurationFilterInput) then,
  ) = _CopyWithImpl$Input$TaxConfigurationFilterInput;

  factory CopyWith$Input$TaxConfigurationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TaxConfigurationFilterInput;

  TRes call({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
}

class _CopyWithImpl$Input$TaxConfigurationFilterInput<TRes>
    implements CopyWith$Input$TaxConfigurationFilterInput<TRes> {
  _CopyWithImpl$Input$TaxConfigurationFilterInput(
    this._instance,
    this._then,
  );

  final Input$TaxConfigurationFilterInput _instance;

  final TRes Function(Input$TaxConfigurationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? metadata = _undefined,
    Object? ids = _undefined,
  }) =>
      _then(Input$TaxConfigurationFilterInput._({
        ..._instance._$data,
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TaxConfigurationFilterInput<TRes>
    implements CopyWith$Input$TaxConfigurationFilterInput<TRes> {
  _CopyWithStubImpl$Input$TaxConfigurationFilterInput(this._res);

  TRes _res;

  call({
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
  }) =>
      _res;

  metadata(_fn) => _res;
}

class Input$TaxConfigurationPerCountryInput {
  factory Input$TaxConfigurationPerCountryInput({
    required Enum$CountryCode countryCode,
    required bool chargeTaxes,
    Enum$TaxCalculationStrategy? taxCalculationStrategy,
    required bool displayGrossPrices,
    String? taxAppId,
    bool? useWeightedTaxForShipping,
  }) =>
      Input$TaxConfigurationPerCountryInput._({
        r'countryCode': countryCode,
        r'chargeTaxes': chargeTaxes,
        if (taxCalculationStrategy != null)
          r'taxCalculationStrategy': taxCalculationStrategy,
        r'displayGrossPrices': displayGrossPrices,
        if (taxAppId != null) r'taxAppId': taxAppId,
        if (useWeightedTaxForShipping != null)
          r'useWeightedTaxForShipping': useWeightedTaxForShipping,
      });

  Input$TaxConfigurationPerCountryInput._(this._$data);

  factory Input$TaxConfigurationPerCountryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$countryCode = data['countryCode'];
    result$data['countryCode'] =
        fromJson$Enum$CountryCode((l$countryCode as String));
    final l$chargeTaxes = data['chargeTaxes'];
    result$data['chargeTaxes'] = (l$chargeTaxes as bool);
    if (data.containsKey('taxCalculationStrategy')) {
      final l$taxCalculationStrategy = data['taxCalculationStrategy'];
      result$data['taxCalculationStrategy'] = l$taxCalculationStrategy == null
          ? null
          : fromJson$Enum$TaxCalculationStrategy(
              (l$taxCalculationStrategy as String));
    }
    final l$displayGrossPrices = data['displayGrossPrices'];
    result$data['displayGrossPrices'] = (l$displayGrossPrices as bool);
    if (data.containsKey('taxAppId')) {
      final l$taxAppId = data['taxAppId'];
      result$data['taxAppId'] = (l$taxAppId as String?);
    }
    if (data.containsKey('useWeightedTaxForShipping')) {
      final l$useWeightedTaxForShipping = data['useWeightedTaxForShipping'];
      result$data['useWeightedTaxForShipping'] =
          (l$useWeightedTaxForShipping as bool?);
    }
    return Input$TaxConfigurationPerCountryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CountryCode get countryCode =>
      (_$data['countryCode'] as Enum$CountryCode);

  bool get chargeTaxes => (_$data['chargeTaxes'] as bool);

  Enum$TaxCalculationStrategy? get taxCalculationStrategy =>
      (_$data['taxCalculationStrategy'] as Enum$TaxCalculationStrategy?);

  bool get displayGrossPrices => (_$data['displayGrossPrices'] as bool);

  String? get taxAppId => (_$data['taxAppId'] as String?);

  bool? get useWeightedTaxForShipping =>
      (_$data['useWeightedTaxForShipping'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$countryCode = countryCode;
    result$data['countryCode'] = toJson$Enum$CountryCode(l$countryCode);
    final l$chargeTaxes = chargeTaxes;
    result$data['chargeTaxes'] = l$chargeTaxes;
    if (_$data.containsKey('taxCalculationStrategy')) {
      final l$taxCalculationStrategy = taxCalculationStrategy;
      result$data['taxCalculationStrategy'] = l$taxCalculationStrategy == null
          ? null
          : toJson$Enum$TaxCalculationStrategy(l$taxCalculationStrategy);
    }
    final l$displayGrossPrices = displayGrossPrices;
    result$data['displayGrossPrices'] = l$displayGrossPrices;
    if (_$data.containsKey('taxAppId')) {
      final l$taxAppId = taxAppId;
      result$data['taxAppId'] = l$taxAppId;
    }
    if (_$data.containsKey('useWeightedTaxForShipping')) {
      final l$useWeightedTaxForShipping = useWeightedTaxForShipping;
      result$data['useWeightedTaxForShipping'] = l$useWeightedTaxForShipping;
    }
    return result$data;
  }

  CopyWith$Input$TaxConfigurationPerCountryInput<
          Input$TaxConfigurationPerCountryInput>
      get copyWith => CopyWith$Input$TaxConfigurationPerCountryInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TaxConfigurationPerCountryInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$countryCode = countryCode;
    final lOther$countryCode = other.countryCode;
    if (l$countryCode != lOther$countryCode) {
      return false;
    }
    final l$chargeTaxes = chargeTaxes;
    final lOther$chargeTaxes = other.chargeTaxes;
    if (l$chargeTaxes != lOther$chargeTaxes) {
      return false;
    }
    final l$taxCalculationStrategy = taxCalculationStrategy;
    final lOther$taxCalculationStrategy = other.taxCalculationStrategy;
    if (_$data.containsKey('taxCalculationStrategy') !=
        other._$data.containsKey('taxCalculationStrategy')) {
      return false;
    }
    if (l$taxCalculationStrategy != lOther$taxCalculationStrategy) {
      return false;
    }
    final l$displayGrossPrices = displayGrossPrices;
    final lOther$displayGrossPrices = other.displayGrossPrices;
    if (l$displayGrossPrices != lOther$displayGrossPrices) {
      return false;
    }
    final l$taxAppId = taxAppId;
    final lOther$taxAppId = other.taxAppId;
    if (_$data.containsKey('taxAppId') !=
        other._$data.containsKey('taxAppId')) {
      return false;
    }
    if (l$taxAppId != lOther$taxAppId) {
      return false;
    }
    final l$useWeightedTaxForShipping = useWeightedTaxForShipping;
    final lOther$useWeightedTaxForShipping = other.useWeightedTaxForShipping;
    if (_$data.containsKey('useWeightedTaxForShipping') !=
        other._$data.containsKey('useWeightedTaxForShipping')) {
      return false;
    }
    if (l$useWeightedTaxForShipping != lOther$useWeightedTaxForShipping) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$countryCode = countryCode;
    final l$chargeTaxes = chargeTaxes;
    final l$taxCalculationStrategy = taxCalculationStrategy;
    final l$displayGrossPrices = displayGrossPrices;
    final l$taxAppId = taxAppId;
    final l$useWeightedTaxForShipping = useWeightedTaxForShipping;
    return Object.hashAll([
      l$countryCode,
      l$chargeTaxes,
      _$data.containsKey('taxCalculationStrategy')
          ? l$taxCalculationStrategy
          : const {},
      l$displayGrossPrices,
      _$data.containsKey('taxAppId') ? l$taxAppId : const {},
      _$data.containsKey('useWeightedTaxForShipping')
          ? l$useWeightedTaxForShipping
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TaxConfigurationPerCountryInput<TRes> {
  factory CopyWith$Input$TaxConfigurationPerCountryInput(
    Input$TaxConfigurationPerCountryInput instance,
    TRes Function(Input$TaxConfigurationPerCountryInput) then,
  ) = _CopyWithImpl$Input$TaxConfigurationPerCountryInput;

  factory CopyWith$Input$TaxConfigurationPerCountryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TaxConfigurationPerCountryInput;

  TRes call({
    Enum$CountryCode? countryCode,
    bool? chargeTaxes,
    Enum$TaxCalculationStrategy? taxCalculationStrategy,
    bool? displayGrossPrices,
    String? taxAppId,
    bool? useWeightedTaxForShipping,
  });
}

class _CopyWithImpl$Input$TaxConfigurationPerCountryInput<TRes>
    implements CopyWith$Input$TaxConfigurationPerCountryInput<TRes> {
  _CopyWithImpl$Input$TaxConfigurationPerCountryInput(
    this._instance,
    this._then,
  );

  final Input$TaxConfigurationPerCountryInput _instance;

  final TRes Function(Input$TaxConfigurationPerCountryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? countryCode = _undefined,
    Object? chargeTaxes = _undefined,
    Object? taxCalculationStrategy = _undefined,
    Object? displayGrossPrices = _undefined,
    Object? taxAppId = _undefined,
    Object? useWeightedTaxForShipping = _undefined,
  }) =>
      _then(Input$TaxConfigurationPerCountryInput._({
        ..._instance._$data,
        if (countryCode != _undefined && countryCode != null)
          'countryCode': (countryCode as Enum$CountryCode),
        if (chargeTaxes != _undefined && chargeTaxes != null)
          'chargeTaxes': (chargeTaxes as bool),
        if (taxCalculationStrategy != _undefined)
          'taxCalculationStrategy':
              (taxCalculationStrategy as Enum$TaxCalculationStrategy?),
        if (displayGrossPrices != _undefined && displayGrossPrices != null)
          'displayGrossPrices': (displayGrossPrices as bool),
        if (taxAppId != _undefined) 'taxAppId': (taxAppId as String?),
        if (useWeightedTaxForShipping != _undefined)
          'useWeightedTaxForShipping': (useWeightedTaxForShipping as bool?),
      }));
}

class _CopyWithStubImpl$Input$TaxConfigurationPerCountryInput<TRes>
    implements CopyWith$Input$TaxConfigurationPerCountryInput<TRes> {
  _CopyWithStubImpl$Input$TaxConfigurationPerCountryInput(this._res);

  TRes _res;

  call({
    Enum$CountryCode? countryCode,
    bool? chargeTaxes,
    Enum$TaxCalculationStrategy? taxCalculationStrategy,
    bool? displayGrossPrices,
    String? taxAppId,
    bool? useWeightedTaxForShipping,
  }) =>
      _res;
}

class Input$TaxConfigurationUpdateInput {
  factory Input$TaxConfigurationUpdateInput({
    bool? chargeTaxes,
    Enum$TaxCalculationStrategy? taxCalculationStrategy,
    bool? displayGrossPrices,
    bool? pricesEnteredWithTax,
    List<Input$TaxConfigurationPerCountryInput>? updateCountriesConfiguration,
    List<Enum$CountryCode>? removeCountriesConfiguration,
    bool? useWeightedTaxForShipping,
    String? taxAppId,
  }) =>
      Input$TaxConfigurationUpdateInput._({
        if (chargeTaxes != null) r'chargeTaxes': chargeTaxes,
        if (taxCalculationStrategy != null)
          r'taxCalculationStrategy': taxCalculationStrategy,
        if (displayGrossPrices != null)
          r'displayGrossPrices': displayGrossPrices,
        if (pricesEnteredWithTax != null)
          r'pricesEnteredWithTax': pricesEnteredWithTax,
        if (updateCountriesConfiguration != null)
          r'updateCountriesConfiguration': updateCountriesConfiguration,
        if (removeCountriesConfiguration != null)
          r'removeCountriesConfiguration': removeCountriesConfiguration,
        if (useWeightedTaxForShipping != null)
          r'useWeightedTaxForShipping': useWeightedTaxForShipping,
        if (taxAppId != null) r'taxAppId': taxAppId,
      });

  Input$TaxConfigurationUpdateInput._(this._$data);

  factory Input$TaxConfigurationUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('chargeTaxes')) {
      final l$chargeTaxes = data['chargeTaxes'];
      result$data['chargeTaxes'] = (l$chargeTaxes as bool?);
    }
    if (data.containsKey('taxCalculationStrategy')) {
      final l$taxCalculationStrategy = data['taxCalculationStrategy'];
      result$data['taxCalculationStrategy'] = l$taxCalculationStrategy == null
          ? null
          : fromJson$Enum$TaxCalculationStrategy(
              (l$taxCalculationStrategy as String));
    }
    if (data.containsKey('displayGrossPrices')) {
      final l$displayGrossPrices = data['displayGrossPrices'];
      result$data['displayGrossPrices'] = (l$displayGrossPrices as bool?);
    }
    if (data.containsKey('pricesEnteredWithTax')) {
      final l$pricesEnteredWithTax = data['pricesEnteredWithTax'];
      result$data['pricesEnteredWithTax'] = (l$pricesEnteredWithTax as bool?);
    }
    if (data.containsKey('updateCountriesConfiguration')) {
      final l$updateCountriesConfiguration =
          data['updateCountriesConfiguration'];
      result$data['updateCountriesConfiguration'] =
          (l$updateCountriesConfiguration as List<dynamic>?)
              ?.map((e) => Input$TaxConfigurationPerCountryInput.fromJson(
                  (e as Map<String, dynamic>)))
              .toList();
    }
    if (data.containsKey('removeCountriesConfiguration')) {
      final l$removeCountriesConfiguration =
          data['removeCountriesConfiguration'];
      result$data['removeCountriesConfiguration'] =
          (l$removeCountriesConfiguration as List<dynamic>?)
              ?.map((e) => fromJson$Enum$CountryCode((e as String)))
              .toList();
    }
    if (data.containsKey('useWeightedTaxForShipping')) {
      final l$useWeightedTaxForShipping = data['useWeightedTaxForShipping'];
      result$data['useWeightedTaxForShipping'] =
          (l$useWeightedTaxForShipping as bool?);
    }
    if (data.containsKey('taxAppId')) {
      final l$taxAppId = data['taxAppId'];
      result$data['taxAppId'] = (l$taxAppId as String?);
    }
    return Input$TaxConfigurationUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get chargeTaxes => (_$data['chargeTaxes'] as bool?);

  Enum$TaxCalculationStrategy? get taxCalculationStrategy =>
      (_$data['taxCalculationStrategy'] as Enum$TaxCalculationStrategy?);

  bool? get displayGrossPrices => (_$data['displayGrossPrices'] as bool?);

  bool? get pricesEnteredWithTax => (_$data['pricesEnteredWithTax'] as bool?);

  List<Input$TaxConfigurationPerCountryInput>?
      get updateCountriesConfiguration =>
          (_$data['updateCountriesConfiguration']
              as List<Input$TaxConfigurationPerCountryInput>?);

  List<Enum$CountryCode>? get removeCountriesConfiguration =>
      (_$data['removeCountriesConfiguration'] as List<Enum$CountryCode>?);

  bool? get useWeightedTaxForShipping =>
      (_$data['useWeightedTaxForShipping'] as bool?);

  String? get taxAppId => (_$data['taxAppId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('chargeTaxes')) {
      final l$chargeTaxes = chargeTaxes;
      result$data['chargeTaxes'] = l$chargeTaxes;
    }
    if (_$data.containsKey('taxCalculationStrategy')) {
      final l$taxCalculationStrategy = taxCalculationStrategy;
      result$data['taxCalculationStrategy'] = l$taxCalculationStrategy == null
          ? null
          : toJson$Enum$TaxCalculationStrategy(l$taxCalculationStrategy);
    }
    if (_$data.containsKey('displayGrossPrices')) {
      final l$displayGrossPrices = displayGrossPrices;
      result$data['displayGrossPrices'] = l$displayGrossPrices;
    }
    if (_$data.containsKey('pricesEnteredWithTax')) {
      final l$pricesEnteredWithTax = pricesEnteredWithTax;
      result$data['pricesEnteredWithTax'] = l$pricesEnteredWithTax;
    }
    if (_$data.containsKey('updateCountriesConfiguration')) {
      final l$updateCountriesConfiguration = updateCountriesConfiguration;
      result$data['updateCountriesConfiguration'] =
          l$updateCountriesConfiguration?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('removeCountriesConfiguration')) {
      final l$removeCountriesConfiguration = removeCountriesConfiguration;
      result$data['removeCountriesConfiguration'] =
          l$removeCountriesConfiguration
              ?.map((e) => toJson$Enum$CountryCode(e))
              .toList();
    }
    if (_$data.containsKey('useWeightedTaxForShipping')) {
      final l$useWeightedTaxForShipping = useWeightedTaxForShipping;
      result$data['useWeightedTaxForShipping'] = l$useWeightedTaxForShipping;
    }
    if (_$data.containsKey('taxAppId')) {
      final l$taxAppId = taxAppId;
      result$data['taxAppId'] = l$taxAppId;
    }
    return result$data;
  }

  CopyWith$Input$TaxConfigurationUpdateInput<Input$TaxConfigurationUpdateInput>
      get copyWith => CopyWith$Input$TaxConfigurationUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TaxConfigurationUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$chargeTaxes = chargeTaxes;
    final lOther$chargeTaxes = other.chargeTaxes;
    if (_$data.containsKey('chargeTaxes') !=
        other._$data.containsKey('chargeTaxes')) {
      return false;
    }
    if (l$chargeTaxes != lOther$chargeTaxes) {
      return false;
    }
    final l$taxCalculationStrategy = taxCalculationStrategy;
    final lOther$taxCalculationStrategy = other.taxCalculationStrategy;
    if (_$data.containsKey('taxCalculationStrategy') !=
        other._$data.containsKey('taxCalculationStrategy')) {
      return false;
    }
    if (l$taxCalculationStrategy != lOther$taxCalculationStrategy) {
      return false;
    }
    final l$displayGrossPrices = displayGrossPrices;
    final lOther$displayGrossPrices = other.displayGrossPrices;
    if (_$data.containsKey('displayGrossPrices') !=
        other._$data.containsKey('displayGrossPrices')) {
      return false;
    }
    if (l$displayGrossPrices != lOther$displayGrossPrices) {
      return false;
    }
    final l$pricesEnteredWithTax = pricesEnteredWithTax;
    final lOther$pricesEnteredWithTax = other.pricesEnteredWithTax;
    if (_$data.containsKey('pricesEnteredWithTax') !=
        other._$data.containsKey('pricesEnteredWithTax')) {
      return false;
    }
    if (l$pricesEnteredWithTax != lOther$pricesEnteredWithTax) {
      return false;
    }
    final l$updateCountriesConfiguration = updateCountriesConfiguration;
    final lOther$updateCountriesConfiguration =
        other.updateCountriesConfiguration;
    if (_$data.containsKey('updateCountriesConfiguration') !=
        other._$data.containsKey('updateCountriesConfiguration')) {
      return false;
    }
    if (l$updateCountriesConfiguration != null &&
        lOther$updateCountriesConfiguration != null) {
      if (l$updateCountriesConfiguration.length !=
          lOther$updateCountriesConfiguration.length) {
        return false;
      }
      for (int i = 0; i < l$updateCountriesConfiguration.length; i++) {
        final l$updateCountriesConfiguration$entry =
            l$updateCountriesConfiguration[i];
        final lOther$updateCountriesConfiguration$entry =
            lOther$updateCountriesConfiguration[i];
        if (l$updateCountriesConfiguration$entry !=
            lOther$updateCountriesConfiguration$entry) {
          return false;
        }
      }
    } else if (l$updateCountriesConfiguration !=
        lOther$updateCountriesConfiguration) {
      return false;
    }
    final l$removeCountriesConfiguration = removeCountriesConfiguration;
    final lOther$removeCountriesConfiguration =
        other.removeCountriesConfiguration;
    if (_$data.containsKey('removeCountriesConfiguration') !=
        other._$data.containsKey('removeCountriesConfiguration')) {
      return false;
    }
    if (l$removeCountriesConfiguration != null &&
        lOther$removeCountriesConfiguration != null) {
      if (l$removeCountriesConfiguration.length !=
          lOther$removeCountriesConfiguration.length) {
        return false;
      }
      for (int i = 0; i < l$removeCountriesConfiguration.length; i++) {
        final l$removeCountriesConfiguration$entry =
            l$removeCountriesConfiguration[i];
        final lOther$removeCountriesConfiguration$entry =
            lOther$removeCountriesConfiguration[i];
        if (l$removeCountriesConfiguration$entry !=
            lOther$removeCountriesConfiguration$entry) {
          return false;
        }
      }
    } else if (l$removeCountriesConfiguration !=
        lOther$removeCountriesConfiguration) {
      return false;
    }
    final l$useWeightedTaxForShipping = useWeightedTaxForShipping;
    final lOther$useWeightedTaxForShipping = other.useWeightedTaxForShipping;
    if (_$data.containsKey('useWeightedTaxForShipping') !=
        other._$data.containsKey('useWeightedTaxForShipping')) {
      return false;
    }
    if (l$useWeightedTaxForShipping != lOther$useWeightedTaxForShipping) {
      return false;
    }
    final l$taxAppId = taxAppId;
    final lOther$taxAppId = other.taxAppId;
    if (_$data.containsKey('taxAppId') !=
        other._$data.containsKey('taxAppId')) {
      return false;
    }
    if (l$taxAppId != lOther$taxAppId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$chargeTaxes = chargeTaxes;
    final l$taxCalculationStrategy = taxCalculationStrategy;
    final l$displayGrossPrices = displayGrossPrices;
    final l$pricesEnteredWithTax = pricesEnteredWithTax;
    final l$updateCountriesConfiguration = updateCountriesConfiguration;
    final l$removeCountriesConfiguration = removeCountriesConfiguration;
    final l$useWeightedTaxForShipping = useWeightedTaxForShipping;
    final l$taxAppId = taxAppId;
    return Object.hashAll([
      _$data.containsKey('chargeTaxes') ? l$chargeTaxes : const {},
      _$data.containsKey('taxCalculationStrategy')
          ? l$taxCalculationStrategy
          : const {},
      _$data.containsKey('displayGrossPrices')
          ? l$displayGrossPrices
          : const {},
      _$data.containsKey('pricesEnteredWithTax')
          ? l$pricesEnteredWithTax
          : const {},
      _$data.containsKey('updateCountriesConfiguration')
          ? l$updateCountriesConfiguration == null
              ? null
              : Object.hashAll(l$updateCountriesConfiguration.map((v) => v))
          : const {},
      _$data.containsKey('removeCountriesConfiguration')
          ? l$removeCountriesConfiguration == null
              ? null
              : Object.hashAll(l$removeCountriesConfiguration.map((v) => v))
          : const {},
      _$data.containsKey('useWeightedTaxForShipping')
          ? l$useWeightedTaxForShipping
          : const {},
      _$data.containsKey('taxAppId') ? l$taxAppId : const {},
    ]);
  }
}

abstract class CopyWith$Input$TaxConfigurationUpdateInput<TRes> {
  factory CopyWith$Input$TaxConfigurationUpdateInput(
    Input$TaxConfigurationUpdateInput instance,
    TRes Function(Input$TaxConfigurationUpdateInput) then,
  ) = _CopyWithImpl$Input$TaxConfigurationUpdateInput;

  factory CopyWith$Input$TaxConfigurationUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TaxConfigurationUpdateInput;

  TRes call({
    bool? chargeTaxes,
    Enum$TaxCalculationStrategy? taxCalculationStrategy,
    bool? displayGrossPrices,
    bool? pricesEnteredWithTax,
    List<Input$TaxConfigurationPerCountryInput>? updateCountriesConfiguration,
    List<Enum$CountryCode>? removeCountriesConfiguration,
    bool? useWeightedTaxForShipping,
    String? taxAppId,
  });
  TRes updateCountriesConfiguration(
      Iterable<Input$TaxConfigurationPerCountryInput>? Function(
              Iterable<
                  CopyWith$Input$TaxConfigurationPerCountryInput<
                      Input$TaxConfigurationPerCountryInput>>?)
          _fn);
}

class _CopyWithImpl$Input$TaxConfigurationUpdateInput<TRes>
    implements CopyWith$Input$TaxConfigurationUpdateInput<TRes> {
  _CopyWithImpl$Input$TaxConfigurationUpdateInput(
    this._instance,
    this._then,
  );

  final Input$TaxConfigurationUpdateInput _instance;

  final TRes Function(Input$TaxConfigurationUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? chargeTaxes = _undefined,
    Object? taxCalculationStrategy = _undefined,
    Object? displayGrossPrices = _undefined,
    Object? pricesEnteredWithTax = _undefined,
    Object? updateCountriesConfiguration = _undefined,
    Object? removeCountriesConfiguration = _undefined,
    Object? useWeightedTaxForShipping = _undefined,
    Object? taxAppId = _undefined,
  }) =>
      _then(Input$TaxConfigurationUpdateInput._({
        ..._instance._$data,
        if (chargeTaxes != _undefined) 'chargeTaxes': (chargeTaxes as bool?),
        if (taxCalculationStrategy != _undefined)
          'taxCalculationStrategy':
              (taxCalculationStrategy as Enum$TaxCalculationStrategy?),
        if (displayGrossPrices != _undefined)
          'displayGrossPrices': (displayGrossPrices as bool?),
        if (pricesEnteredWithTax != _undefined)
          'pricesEnteredWithTax': (pricesEnteredWithTax as bool?),
        if (updateCountriesConfiguration != _undefined)
          'updateCountriesConfiguration': (updateCountriesConfiguration
              as List<Input$TaxConfigurationPerCountryInput>?),
        if (removeCountriesConfiguration != _undefined)
          'removeCountriesConfiguration':
              (removeCountriesConfiguration as List<Enum$CountryCode>?),
        if (useWeightedTaxForShipping != _undefined)
          'useWeightedTaxForShipping': (useWeightedTaxForShipping as bool?),
        if (taxAppId != _undefined) 'taxAppId': (taxAppId as String?),
      }));

  TRes updateCountriesConfiguration(
          Iterable<Input$TaxConfigurationPerCountryInput>? Function(
                  Iterable<
                      CopyWith$Input$TaxConfigurationPerCountryInput<
                          Input$TaxConfigurationPerCountryInput>>?)
              _fn) =>
      call(
          updateCountriesConfiguration: _fn(_instance
              .updateCountriesConfiguration
              ?.map((e) => CopyWith$Input$TaxConfigurationPerCountryInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TaxConfigurationUpdateInput<TRes>
    implements CopyWith$Input$TaxConfigurationUpdateInput<TRes> {
  _CopyWithStubImpl$Input$TaxConfigurationUpdateInput(this._res);

  TRes _res;

  call({
    bool? chargeTaxes,
    Enum$TaxCalculationStrategy? taxCalculationStrategy,
    bool? displayGrossPrices,
    bool? pricesEnteredWithTax,
    List<Input$TaxConfigurationPerCountryInput>? updateCountriesConfiguration,
    List<Enum$CountryCode>? removeCountriesConfiguration,
    bool? useWeightedTaxForShipping,
    String? taxAppId,
  }) =>
      _res;

  updateCountriesConfiguration(_fn) => _res;
}

class Input$TaxedMoneyInput {
  factory Input$TaxedMoneyInput({
    required String gross,
    required String net,
  }) =>
      Input$TaxedMoneyInput._({
        r'gross': gross,
        r'net': net,
      });

  Input$TaxedMoneyInput._(this._$data);

  factory Input$TaxedMoneyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$gross = data['gross'];
    result$data['gross'] = (l$gross as String);
    final l$net = data['net'];
    result$data['net'] = (l$net as String);
    return Input$TaxedMoneyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get gross => (_$data['gross'] as String);

  String get net => (_$data['net'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$gross = gross;
    result$data['gross'] = l$gross;
    final l$net = net;
    result$data['net'] = l$net;
    return result$data;
  }

  CopyWith$Input$TaxedMoneyInput<Input$TaxedMoneyInput> get copyWith =>
      CopyWith$Input$TaxedMoneyInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TaxedMoneyInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$gross = gross;
    final lOther$gross = other.gross;
    if (l$gross != lOther$gross) {
      return false;
    }
    final l$net = net;
    final lOther$net = other.net;
    if (l$net != lOther$net) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$gross = gross;
    final l$net = net;
    return Object.hashAll([
      l$gross,
      l$net,
    ]);
  }
}

abstract class CopyWith$Input$TaxedMoneyInput<TRes> {
  factory CopyWith$Input$TaxedMoneyInput(
    Input$TaxedMoneyInput instance,
    TRes Function(Input$TaxedMoneyInput) then,
  ) = _CopyWithImpl$Input$TaxedMoneyInput;

  factory CopyWith$Input$TaxedMoneyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TaxedMoneyInput;

  TRes call({
    String? gross,
    String? net,
  });
}

class _CopyWithImpl$Input$TaxedMoneyInput<TRes>
    implements CopyWith$Input$TaxedMoneyInput<TRes> {
  _CopyWithImpl$Input$TaxedMoneyInput(
    this._instance,
    this._then,
  );

  final Input$TaxedMoneyInput _instance;

  final TRes Function(Input$TaxedMoneyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? gross = _undefined,
    Object? net = _undefined,
  }) =>
      _then(Input$TaxedMoneyInput._({
        ..._instance._$data,
        if (gross != _undefined && gross != null) 'gross': (gross as String),
        if (net != _undefined && net != null) 'net': (net as String),
      }));
}

class _CopyWithStubImpl$Input$TaxedMoneyInput<TRes>
    implements CopyWith$Input$TaxedMoneyInput<TRes> {
  _CopyWithStubImpl$Input$TaxedMoneyInput(this._res);

  TRes _res;

  call({
    String? gross,
    String? net,
  }) =>
      _res;
}

class Input$TimePeriodInputType {
  factory Input$TimePeriodInputType({
    required int amount,
    required Enum$TimePeriodTypeEnum type,
  }) =>
      Input$TimePeriodInputType._({
        r'amount': amount,
        r'type': type,
      });

  Input$TimePeriodInputType._(this._$data);

  factory Input$TimePeriodInputType.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$amount = data['amount'];
    result$data['amount'] = (l$amount as int);
    final l$type = data['type'];
    result$data['type'] = fromJson$Enum$TimePeriodTypeEnum((l$type as String));
    return Input$TimePeriodInputType._(result$data);
  }

  Map<String, dynamic> _$data;

  int get amount => (_$data['amount'] as int);

  Enum$TimePeriodTypeEnum get type =>
      (_$data['type'] as Enum$TimePeriodTypeEnum);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$amount = amount;
    result$data['amount'] = l$amount;
    final l$type = type;
    result$data['type'] = toJson$Enum$TimePeriodTypeEnum(l$type);
    return result$data;
  }

  CopyWith$Input$TimePeriodInputType<Input$TimePeriodInputType> get copyWith =>
      CopyWith$Input$TimePeriodInputType(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TimePeriodInputType ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$type = type;
    return Object.hashAll([
      l$amount,
      l$type,
    ]);
  }
}

abstract class CopyWith$Input$TimePeriodInputType<TRes> {
  factory CopyWith$Input$TimePeriodInputType(
    Input$TimePeriodInputType instance,
    TRes Function(Input$TimePeriodInputType) then,
  ) = _CopyWithImpl$Input$TimePeriodInputType;

  factory CopyWith$Input$TimePeriodInputType.stub(TRes res) =
      _CopyWithStubImpl$Input$TimePeriodInputType;

  TRes call({
    int? amount,
    Enum$TimePeriodTypeEnum? type,
  });
}

class _CopyWithImpl$Input$TimePeriodInputType<TRes>
    implements CopyWith$Input$TimePeriodInputType<TRes> {
  _CopyWithImpl$Input$TimePeriodInputType(
    this._instance,
    this._then,
  );

  final Input$TimePeriodInputType _instance;

  final TRes Function(Input$TimePeriodInputType) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? type = _undefined,
  }) =>
      _then(Input$TimePeriodInputType._({
        ..._instance._$data,
        if (amount != _undefined && amount != null) 'amount': (amount as int),
        if (type != _undefined && type != null)
          'type': (type as Enum$TimePeriodTypeEnum),
      }));
}

class _CopyWithStubImpl$Input$TimePeriodInputType<TRes>
    implements CopyWith$Input$TimePeriodInputType<TRes> {
  _CopyWithStubImpl$Input$TimePeriodInputType(this._res);

  TRes _res;

  call({
    int? amount,
    Enum$TimePeriodTypeEnum? type,
  }) =>
      _res;
}

class Input$TransactionCreateInput {
  factory Input$TransactionCreateInput({
    String? name,
    String? message,
    String? pspReference,
    List<Enum$TransactionActionEnum>? availableActions,
    Input$MoneyInput? amountAuthorized,
    Input$MoneyInput? amountCharged,
    Input$MoneyInput? amountRefunded,
    Input$MoneyInput? amountCanceled,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalUrl,
  }) =>
      Input$TransactionCreateInput._({
        if (name != null) r'name': name,
        if (message != null) r'message': message,
        if (pspReference != null) r'pspReference': pspReference,
        if (availableActions != null) r'availableActions': availableActions,
        if (amountAuthorized != null) r'amountAuthorized': amountAuthorized,
        if (amountCharged != null) r'amountCharged': amountCharged,
        if (amountRefunded != null) r'amountRefunded': amountRefunded,
        if (amountCanceled != null) r'amountCanceled': amountCanceled,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (externalUrl != null) r'externalUrl': externalUrl,
      });

  Input$TransactionCreateInput._(this._$data);

  factory Input$TransactionCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = (l$message as String?);
    }
    if (data.containsKey('pspReference')) {
      final l$pspReference = data['pspReference'];
      result$data['pspReference'] = (l$pspReference as String?);
    }
    if (data.containsKey('availableActions')) {
      final l$availableActions = data['availableActions'];
      result$data['availableActions'] = (l$availableActions as List<dynamic>?)
          ?.map((e) => fromJson$Enum$TransactionActionEnum((e as String)))
          .toList();
    }
    if (data.containsKey('amountAuthorized')) {
      final l$amountAuthorized = data['amountAuthorized'];
      result$data['amountAuthorized'] = l$amountAuthorized == null
          ? null
          : Input$MoneyInput.fromJson(
              (l$amountAuthorized as Map<String, dynamic>));
    }
    if (data.containsKey('amountCharged')) {
      final l$amountCharged = data['amountCharged'];
      result$data['amountCharged'] = l$amountCharged == null
          ? null
          : Input$MoneyInput.fromJson(
              (l$amountCharged as Map<String, dynamic>));
    }
    if (data.containsKey('amountRefunded')) {
      final l$amountRefunded = data['amountRefunded'];
      result$data['amountRefunded'] = l$amountRefunded == null
          ? null
          : Input$MoneyInput.fromJson(
              (l$amountRefunded as Map<String, dynamic>));
    }
    if (data.containsKey('amountCanceled')) {
      final l$amountCanceled = data['amountCanceled'];
      result$data['amountCanceled'] = l$amountCanceled == null
          ? null
          : Input$MoneyInput.fromJson(
              (l$amountCanceled as Map<String, dynamic>));
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('externalUrl')) {
      final l$externalUrl = data['externalUrl'];
      result$data['externalUrl'] = (l$externalUrl as String?);
    }
    return Input$TransactionCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get message => (_$data['message'] as String?);

  String? get pspReference => (_$data['pspReference'] as String?);

  List<Enum$TransactionActionEnum>? get availableActions =>
      (_$data['availableActions'] as List<Enum$TransactionActionEnum>?);

  Input$MoneyInput? get amountAuthorized =>
      (_$data['amountAuthorized'] as Input$MoneyInput?);

  Input$MoneyInput? get amountCharged =>
      (_$data['amountCharged'] as Input$MoneyInput?);

  Input$MoneyInput? get amountRefunded =>
      (_$data['amountRefunded'] as Input$MoneyInput?);

  Input$MoneyInput? get amountCanceled =>
      (_$data['amountCanceled'] as Input$MoneyInput?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  String? get externalUrl => (_$data['externalUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message;
    }
    if (_$data.containsKey('pspReference')) {
      final l$pspReference = pspReference;
      result$data['pspReference'] = l$pspReference;
    }
    if (_$data.containsKey('availableActions')) {
      final l$availableActions = availableActions;
      result$data['availableActions'] = l$availableActions
          ?.map((e) => toJson$Enum$TransactionActionEnum(e))
          .toList();
    }
    if (_$data.containsKey('amountAuthorized')) {
      final l$amountAuthorized = amountAuthorized;
      result$data['amountAuthorized'] = l$amountAuthorized?.toJson();
    }
    if (_$data.containsKey('amountCharged')) {
      final l$amountCharged = amountCharged;
      result$data['amountCharged'] = l$amountCharged?.toJson();
    }
    if (_$data.containsKey('amountRefunded')) {
      final l$amountRefunded = amountRefunded;
      result$data['amountRefunded'] = l$amountRefunded?.toJson();
    }
    if (_$data.containsKey('amountCanceled')) {
      final l$amountCanceled = amountCanceled;
      result$data['amountCanceled'] = l$amountCanceled?.toJson();
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('externalUrl')) {
      final l$externalUrl = externalUrl;
      result$data['externalUrl'] = l$externalUrl;
    }
    return result$data;
  }

  CopyWith$Input$TransactionCreateInput<Input$TransactionCreateInput>
      get copyWith => CopyWith$Input$TransactionCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TransactionCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$pspReference = pspReference;
    final lOther$pspReference = other.pspReference;
    if (_$data.containsKey('pspReference') !=
        other._$data.containsKey('pspReference')) {
      return false;
    }
    if (l$pspReference != lOther$pspReference) {
      return false;
    }
    final l$availableActions = availableActions;
    final lOther$availableActions = other.availableActions;
    if (_$data.containsKey('availableActions') !=
        other._$data.containsKey('availableActions')) {
      return false;
    }
    if (l$availableActions != null && lOther$availableActions != null) {
      if (l$availableActions.length != lOther$availableActions.length) {
        return false;
      }
      for (int i = 0; i < l$availableActions.length; i++) {
        final l$availableActions$entry = l$availableActions[i];
        final lOther$availableActions$entry = lOther$availableActions[i];
        if (l$availableActions$entry != lOther$availableActions$entry) {
          return false;
        }
      }
    } else if (l$availableActions != lOther$availableActions) {
      return false;
    }
    final l$amountAuthorized = amountAuthorized;
    final lOther$amountAuthorized = other.amountAuthorized;
    if (_$data.containsKey('amountAuthorized') !=
        other._$data.containsKey('amountAuthorized')) {
      return false;
    }
    if (l$amountAuthorized != lOther$amountAuthorized) {
      return false;
    }
    final l$amountCharged = amountCharged;
    final lOther$amountCharged = other.amountCharged;
    if (_$data.containsKey('amountCharged') !=
        other._$data.containsKey('amountCharged')) {
      return false;
    }
    if (l$amountCharged != lOther$amountCharged) {
      return false;
    }
    final l$amountRefunded = amountRefunded;
    final lOther$amountRefunded = other.amountRefunded;
    if (_$data.containsKey('amountRefunded') !=
        other._$data.containsKey('amountRefunded')) {
      return false;
    }
    if (l$amountRefunded != lOther$amountRefunded) {
      return false;
    }
    final l$amountCanceled = amountCanceled;
    final lOther$amountCanceled = other.amountCanceled;
    if (_$data.containsKey('amountCanceled') !=
        other._$data.containsKey('amountCanceled')) {
      return false;
    }
    if (l$amountCanceled != lOther$amountCanceled) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$externalUrl = externalUrl;
    final lOther$externalUrl = other.externalUrl;
    if (_$data.containsKey('externalUrl') !=
        other._$data.containsKey('externalUrl')) {
      return false;
    }
    if (l$externalUrl != lOther$externalUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$message = message;
    final l$pspReference = pspReference;
    final l$availableActions = availableActions;
    final l$amountAuthorized = amountAuthorized;
    final l$amountCharged = amountCharged;
    final l$amountRefunded = amountRefunded;
    final l$amountCanceled = amountCanceled;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$externalUrl = externalUrl;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('pspReference') ? l$pspReference : const {},
      _$data.containsKey('availableActions')
          ? l$availableActions == null
              ? null
              : Object.hashAll(l$availableActions.map((v) => v))
          : const {},
      _$data.containsKey('amountAuthorized') ? l$amountAuthorized : const {},
      _$data.containsKey('amountCharged') ? l$amountCharged : const {},
      _$data.containsKey('amountRefunded') ? l$amountRefunded : const {},
      _$data.containsKey('amountCanceled') ? l$amountCanceled : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('externalUrl') ? l$externalUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionCreateInput<TRes> {
  factory CopyWith$Input$TransactionCreateInput(
    Input$TransactionCreateInput instance,
    TRes Function(Input$TransactionCreateInput) then,
  ) = _CopyWithImpl$Input$TransactionCreateInput;

  factory CopyWith$Input$TransactionCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionCreateInput;

  TRes call({
    String? name,
    String? message,
    String? pspReference,
    List<Enum$TransactionActionEnum>? availableActions,
    Input$MoneyInput? amountAuthorized,
    Input$MoneyInput? amountCharged,
    Input$MoneyInput? amountRefunded,
    Input$MoneyInput? amountCanceled,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalUrl,
  });
  CopyWith$Input$MoneyInput<TRes> get amountAuthorized;
  CopyWith$Input$MoneyInput<TRes> get amountCharged;
  CopyWith$Input$MoneyInput<TRes> get amountRefunded;
  CopyWith$Input$MoneyInput<TRes> get amountCanceled;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$TransactionCreateInput<TRes>
    implements CopyWith$Input$TransactionCreateInput<TRes> {
  _CopyWithImpl$Input$TransactionCreateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionCreateInput _instance;

  final TRes Function(Input$TransactionCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? message = _undefined,
    Object? pspReference = _undefined,
    Object? availableActions = _undefined,
    Object? amountAuthorized = _undefined,
    Object? amountCharged = _undefined,
    Object? amountRefunded = _undefined,
    Object? amountCanceled = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? externalUrl = _undefined,
  }) =>
      _then(Input$TransactionCreateInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (message != _undefined) 'message': (message as String?),
        if (pspReference != _undefined)
          'pspReference': (pspReference as String?),
        if (availableActions != _undefined)
          'availableActions':
              (availableActions as List<Enum$TransactionActionEnum>?),
        if (amountAuthorized != _undefined)
          'amountAuthorized': (amountAuthorized as Input$MoneyInput?),
        if (amountCharged != _undefined)
          'amountCharged': (amountCharged as Input$MoneyInput?),
        if (amountRefunded != _undefined)
          'amountRefunded': (amountRefunded as Input$MoneyInput?),
        if (amountCanceled != _undefined)
          'amountCanceled': (amountCanceled as Input$MoneyInput?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (externalUrl != _undefined) 'externalUrl': (externalUrl as String?),
      }));

  CopyWith$Input$MoneyInput<TRes> get amountAuthorized {
    final local$amountAuthorized = _instance.amountAuthorized;
    return local$amountAuthorized == null
        ? CopyWith$Input$MoneyInput.stub(_then(_instance))
        : CopyWith$Input$MoneyInput(
            local$amountAuthorized, (e) => call(amountAuthorized: e));
  }

  CopyWith$Input$MoneyInput<TRes> get amountCharged {
    final local$amountCharged = _instance.amountCharged;
    return local$amountCharged == null
        ? CopyWith$Input$MoneyInput.stub(_then(_instance))
        : CopyWith$Input$MoneyInput(
            local$amountCharged, (e) => call(amountCharged: e));
  }

  CopyWith$Input$MoneyInput<TRes> get amountRefunded {
    final local$amountRefunded = _instance.amountRefunded;
    return local$amountRefunded == null
        ? CopyWith$Input$MoneyInput.stub(_then(_instance))
        : CopyWith$Input$MoneyInput(
            local$amountRefunded, (e) => call(amountRefunded: e));
  }

  CopyWith$Input$MoneyInput<TRes> get amountCanceled {
    final local$amountCanceled = _instance.amountCanceled;
    return local$amountCanceled == null
        ? CopyWith$Input$MoneyInput.stub(_then(_instance))
        : CopyWith$Input$MoneyInput(
            local$amountCanceled, (e) => call(amountCanceled: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TransactionCreateInput<TRes>
    implements CopyWith$Input$TransactionCreateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionCreateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? message,
    String? pspReference,
    List<Enum$TransactionActionEnum>? availableActions,
    Input$MoneyInput? amountAuthorized,
    Input$MoneyInput? amountCharged,
    Input$MoneyInput? amountRefunded,
    Input$MoneyInput? amountCanceled,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalUrl,
  }) =>
      _res;

  CopyWith$Input$MoneyInput<TRes> get amountAuthorized =>
      CopyWith$Input$MoneyInput.stub(_res);

  CopyWith$Input$MoneyInput<TRes> get amountCharged =>
      CopyWith$Input$MoneyInput.stub(_res);

  CopyWith$Input$MoneyInput<TRes> get amountRefunded =>
      CopyWith$Input$MoneyInput.stub(_res);

  CopyWith$Input$MoneyInput<TRes> get amountCanceled =>
      CopyWith$Input$MoneyInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$TransactionEventInput {
  factory Input$TransactionEventInput({
    String? pspReference,
    String? message,
  }) =>
      Input$TransactionEventInput._({
        if (pspReference != null) r'pspReference': pspReference,
        if (message != null) r'message': message,
      });

  Input$TransactionEventInput._(this._$data);

  factory Input$TransactionEventInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('pspReference')) {
      final l$pspReference = data['pspReference'];
      result$data['pspReference'] = (l$pspReference as String?);
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = (l$message as String?);
    }
    return Input$TransactionEventInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get pspReference => (_$data['pspReference'] as String?);

  String? get message => (_$data['message'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('pspReference')) {
      final l$pspReference = pspReference;
      result$data['pspReference'] = l$pspReference;
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message;
    }
    return result$data;
  }

  CopyWith$Input$TransactionEventInput<Input$TransactionEventInput>
      get copyWith => CopyWith$Input$TransactionEventInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TransactionEventInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pspReference = pspReference;
    final lOther$pspReference = other.pspReference;
    if (_$data.containsKey('pspReference') !=
        other._$data.containsKey('pspReference')) {
      return false;
    }
    if (l$pspReference != lOther$pspReference) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pspReference = pspReference;
    final l$message = message;
    return Object.hashAll([
      _$data.containsKey('pspReference') ? l$pspReference : const {},
      _$data.containsKey('message') ? l$message : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionEventInput<TRes> {
  factory CopyWith$Input$TransactionEventInput(
    Input$TransactionEventInput instance,
    TRes Function(Input$TransactionEventInput) then,
  ) = _CopyWithImpl$Input$TransactionEventInput;

  factory CopyWith$Input$TransactionEventInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionEventInput;

  TRes call({
    String? pspReference,
    String? message,
  });
}

class _CopyWithImpl$Input$TransactionEventInput<TRes>
    implements CopyWith$Input$TransactionEventInput<TRes> {
  _CopyWithImpl$Input$TransactionEventInput(
    this._instance,
    this._then,
  );

  final Input$TransactionEventInput _instance;

  final TRes Function(Input$TransactionEventInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? pspReference = _undefined,
    Object? message = _undefined,
  }) =>
      _then(Input$TransactionEventInput._({
        ..._instance._$data,
        if (pspReference != _undefined)
          'pspReference': (pspReference as String?),
        if (message != _undefined) 'message': (message as String?),
      }));
}

class _CopyWithStubImpl$Input$TransactionEventInput<TRes>
    implements CopyWith$Input$TransactionEventInput<TRes> {
  _CopyWithStubImpl$Input$TransactionEventInput(this._res);

  TRes _res;

  call({
    String? pspReference,
    String? message,
  }) =>
      _res;
}

class Input$TransactionUpdateInput {
  factory Input$TransactionUpdateInput({
    String? name,
    String? message,
    String? pspReference,
    List<Enum$TransactionActionEnum>? availableActions,
    Input$MoneyInput? amountAuthorized,
    Input$MoneyInput? amountCharged,
    Input$MoneyInput? amountRefunded,
    Input$MoneyInput? amountCanceled,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalUrl,
  }) =>
      Input$TransactionUpdateInput._({
        if (name != null) r'name': name,
        if (message != null) r'message': message,
        if (pspReference != null) r'pspReference': pspReference,
        if (availableActions != null) r'availableActions': availableActions,
        if (amountAuthorized != null) r'amountAuthorized': amountAuthorized,
        if (amountCharged != null) r'amountCharged': amountCharged,
        if (amountRefunded != null) r'amountRefunded': amountRefunded,
        if (amountCanceled != null) r'amountCanceled': amountCanceled,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (externalUrl != null) r'externalUrl': externalUrl,
      });

  Input$TransactionUpdateInput._(this._$data);

  factory Input$TransactionUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = (l$message as String?);
    }
    if (data.containsKey('pspReference')) {
      final l$pspReference = data['pspReference'];
      result$data['pspReference'] = (l$pspReference as String?);
    }
    if (data.containsKey('availableActions')) {
      final l$availableActions = data['availableActions'];
      result$data['availableActions'] = (l$availableActions as List<dynamic>?)
          ?.map((e) => fromJson$Enum$TransactionActionEnum((e as String)))
          .toList();
    }
    if (data.containsKey('amountAuthorized')) {
      final l$amountAuthorized = data['amountAuthorized'];
      result$data['amountAuthorized'] = l$amountAuthorized == null
          ? null
          : Input$MoneyInput.fromJson(
              (l$amountAuthorized as Map<String, dynamic>));
    }
    if (data.containsKey('amountCharged')) {
      final l$amountCharged = data['amountCharged'];
      result$data['amountCharged'] = l$amountCharged == null
          ? null
          : Input$MoneyInput.fromJson(
              (l$amountCharged as Map<String, dynamic>));
    }
    if (data.containsKey('amountRefunded')) {
      final l$amountRefunded = data['amountRefunded'];
      result$data['amountRefunded'] = l$amountRefunded == null
          ? null
          : Input$MoneyInput.fromJson(
              (l$amountRefunded as Map<String, dynamic>));
    }
    if (data.containsKey('amountCanceled')) {
      final l$amountCanceled = data['amountCanceled'];
      result$data['amountCanceled'] = l$amountCanceled == null
          ? null
          : Input$MoneyInput.fromJson(
              (l$amountCanceled as Map<String, dynamic>));
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('externalUrl')) {
      final l$externalUrl = data['externalUrl'];
      result$data['externalUrl'] = (l$externalUrl as String?);
    }
    return Input$TransactionUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get message => (_$data['message'] as String?);

  String? get pspReference => (_$data['pspReference'] as String?);

  List<Enum$TransactionActionEnum>? get availableActions =>
      (_$data['availableActions'] as List<Enum$TransactionActionEnum>?);

  Input$MoneyInput? get amountAuthorized =>
      (_$data['amountAuthorized'] as Input$MoneyInput?);

  Input$MoneyInput? get amountCharged =>
      (_$data['amountCharged'] as Input$MoneyInput?);

  Input$MoneyInput? get amountRefunded =>
      (_$data['amountRefunded'] as Input$MoneyInput?);

  Input$MoneyInput? get amountCanceled =>
      (_$data['amountCanceled'] as Input$MoneyInput?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  String? get externalUrl => (_$data['externalUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message;
    }
    if (_$data.containsKey('pspReference')) {
      final l$pspReference = pspReference;
      result$data['pspReference'] = l$pspReference;
    }
    if (_$data.containsKey('availableActions')) {
      final l$availableActions = availableActions;
      result$data['availableActions'] = l$availableActions
          ?.map((e) => toJson$Enum$TransactionActionEnum(e))
          .toList();
    }
    if (_$data.containsKey('amountAuthorized')) {
      final l$amountAuthorized = amountAuthorized;
      result$data['amountAuthorized'] = l$amountAuthorized?.toJson();
    }
    if (_$data.containsKey('amountCharged')) {
      final l$amountCharged = amountCharged;
      result$data['amountCharged'] = l$amountCharged?.toJson();
    }
    if (_$data.containsKey('amountRefunded')) {
      final l$amountRefunded = amountRefunded;
      result$data['amountRefunded'] = l$amountRefunded?.toJson();
    }
    if (_$data.containsKey('amountCanceled')) {
      final l$amountCanceled = amountCanceled;
      result$data['amountCanceled'] = l$amountCanceled?.toJson();
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('externalUrl')) {
      final l$externalUrl = externalUrl;
      result$data['externalUrl'] = l$externalUrl;
    }
    return result$data;
  }

  CopyWith$Input$TransactionUpdateInput<Input$TransactionUpdateInput>
      get copyWith => CopyWith$Input$TransactionUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TransactionUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$pspReference = pspReference;
    final lOther$pspReference = other.pspReference;
    if (_$data.containsKey('pspReference') !=
        other._$data.containsKey('pspReference')) {
      return false;
    }
    if (l$pspReference != lOther$pspReference) {
      return false;
    }
    final l$availableActions = availableActions;
    final lOther$availableActions = other.availableActions;
    if (_$data.containsKey('availableActions') !=
        other._$data.containsKey('availableActions')) {
      return false;
    }
    if (l$availableActions != null && lOther$availableActions != null) {
      if (l$availableActions.length != lOther$availableActions.length) {
        return false;
      }
      for (int i = 0; i < l$availableActions.length; i++) {
        final l$availableActions$entry = l$availableActions[i];
        final lOther$availableActions$entry = lOther$availableActions[i];
        if (l$availableActions$entry != lOther$availableActions$entry) {
          return false;
        }
      }
    } else if (l$availableActions != lOther$availableActions) {
      return false;
    }
    final l$amountAuthorized = amountAuthorized;
    final lOther$amountAuthorized = other.amountAuthorized;
    if (_$data.containsKey('amountAuthorized') !=
        other._$data.containsKey('amountAuthorized')) {
      return false;
    }
    if (l$amountAuthorized != lOther$amountAuthorized) {
      return false;
    }
    final l$amountCharged = amountCharged;
    final lOther$amountCharged = other.amountCharged;
    if (_$data.containsKey('amountCharged') !=
        other._$data.containsKey('amountCharged')) {
      return false;
    }
    if (l$amountCharged != lOther$amountCharged) {
      return false;
    }
    final l$amountRefunded = amountRefunded;
    final lOther$amountRefunded = other.amountRefunded;
    if (_$data.containsKey('amountRefunded') !=
        other._$data.containsKey('amountRefunded')) {
      return false;
    }
    if (l$amountRefunded != lOther$amountRefunded) {
      return false;
    }
    final l$amountCanceled = amountCanceled;
    final lOther$amountCanceled = other.amountCanceled;
    if (_$data.containsKey('amountCanceled') !=
        other._$data.containsKey('amountCanceled')) {
      return false;
    }
    if (l$amountCanceled != lOther$amountCanceled) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$externalUrl = externalUrl;
    final lOther$externalUrl = other.externalUrl;
    if (_$data.containsKey('externalUrl') !=
        other._$data.containsKey('externalUrl')) {
      return false;
    }
    if (l$externalUrl != lOther$externalUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$message = message;
    final l$pspReference = pspReference;
    final l$availableActions = availableActions;
    final l$amountAuthorized = amountAuthorized;
    final l$amountCharged = amountCharged;
    final l$amountRefunded = amountRefunded;
    final l$amountCanceled = amountCanceled;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$externalUrl = externalUrl;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('pspReference') ? l$pspReference : const {},
      _$data.containsKey('availableActions')
          ? l$availableActions == null
              ? null
              : Object.hashAll(l$availableActions.map((v) => v))
          : const {},
      _$data.containsKey('amountAuthorized') ? l$amountAuthorized : const {},
      _$data.containsKey('amountCharged') ? l$amountCharged : const {},
      _$data.containsKey('amountRefunded') ? l$amountRefunded : const {},
      _$data.containsKey('amountCanceled') ? l$amountCanceled : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('externalUrl') ? l$externalUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionUpdateInput<TRes> {
  factory CopyWith$Input$TransactionUpdateInput(
    Input$TransactionUpdateInput instance,
    TRes Function(Input$TransactionUpdateInput) then,
  ) = _CopyWithImpl$Input$TransactionUpdateInput;

  factory CopyWith$Input$TransactionUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionUpdateInput;

  TRes call({
    String? name,
    String? message,
    String? pspReference,
    List<Enum$TransactionActionEnum>? availableActions,
    Input$MoneyInput? amountAuthorized,
    Input$MoneyInput? amountCharged,
    Input$MoneyInput? amountRefunded,
    Input$MoneyInput? amountCanceled,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalUrl,
  });
  CopyWith$Input$MoneyInput<TRes> get amountAuthorized;
  CopyWith$Input$MoneyInput<TRes> get amountCharged;
  CopyWith$Input$MoneyInput<TRes> get amountRefunded;
  CopyWith$Input$MoneyInput<TRes> get amountCanceled;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$TransactionUpdateInput<TRes>
    implements CopyWith$Input$TransactionUpdateInput<TRes> {
  _CopyWithImpl$Input$TransactionUpdateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionUpdateInput _instance;

  final TRes Function(Input$TransactionUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? message = _undefined,
    Object? pspReference = _undefined,
    Object? availableActions = _undefined,
    Object? amountAuthorized = _undefined,
    Object? amountCharged = _undefined,
    Object? amountRefunded = _undefined,
    Object? amountCanceled = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? externalUrl = _undefined,
  }) =>
      _then(Input$TransactionUpdateInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (message != _undefined) 'message': (message as String?),
        if (pspReference != _undefined)
          'pspReference': (pspReference as String?),
        if (availableActions != _undefined)
          'availableActions':
              (availableActions as List<Enum$TransactionActionEnum>?),
        if (amountAuthorized != _undefined)
          'amountAuthorized': (amountAuthorized as Input$MoneyInput?),
        if (amountCharged != _undefined)
          'amountCharged': (amountCharged as Input$MoneyInput?),
        if (amountRefunded != _undefined)
          'amountRefunded': (amountRefunded as Input$MoneyInput?),
        if (amountCanceled != _undefined)
          'amountCanceled': (amountCanceled as Input$MoneyInput?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (externalUrl != _undefined) 'externalUrl': (externalUrl as String?),
      }));

  CopyWith$Input$MoneyInput<TRes> get amountAuthorized {
    final local$amountAuthorized = _instance.amountAuthorized;
    return local$amountAuthorized == null
        ? CopyWith$Input$MoneyInput.stub(_then(_instance))
        : CopyWith$Input$MoneyInput(
            local$amountAuthorized, (e) => call(amountAuthorized: e));
  }

  CopyWith$Input$MoneyInput<TRes> get amountCharged {
    final local$amountCharged = _instance.amountCharged;
    return local$amountCharged == null
        ? CopyWith$Input$MoneyInput.stub(_then(_instance))
        : CopyWith$Input$MoneyInput(
            local$amountCharged, (e) => call(amountCharged: e));
  }

  CopyWith$Input$MoneyInput<TRes> get amountRefunded {
    final local$amountRefunded = _instance.amountRefunded;
    return local$amountRefunded == null
        ? CopyWith$Input$MoneyInput.stub(_then(_instance))
        : CopyWith$Input$MoneyInput(
            local$amountRefunded, (e) => call(amountRefunded: e));
  }

  CopyWith$Input$MoneyInput<TRes> get amountCanceled {
    final local$amountCanceled = _instance.amountCanceled;
    return local$amountCanceled == null
        ? CopyWith$Input$MoneyInput.stub(_then(_instance))
        : CopyWith$Input$MoneyInput(
            local$amountCanceled, (e) => call(amountCanceled: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TransactionUpdateInput<TRes>
    implements CopyWith$Input$TransactionUpdateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionUpdateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? message,
    String? pspReference,
    List<Enum$TransactionActionEnum>? availableActions,
    Input$MoneyInput? amountAuthorized,
    Input$MoneyInput? amountCharged,
    Input$MoneyInput? amountRefunded,
    Input$MoneyInput? amountCanceled,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    String? externalUrl,
  }) =>
      _res;

  CopyWith$Input$MoneyInput<TRes> get amountAuthorized =>
      CopyWith$Input$MoneyInput.stub(_res);

  CopyWith$Input$MoneyInput<TRes> get amountCharged =>
      CopyWith$Input$MoneyInput.stub(_res);

  CopyWith$Input$MoneyInput<TRes> get amountRefunded =>
      CopyWith$Input$MoneyInput.stub(_res);

  CopyWith$Input$MoneyInput<TRes> get amountCanceled =>
      CopyWith$Input$MoneyInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$TranslationInput {
  factory Input$TranslationInput({
    String? slug,
    String? seoTitle,
    String? seoDescription,
    String? name,
    String? description,
  }) =>
      Input$TranslationInput._({
        if (slug != null) r'slug': slug,
        if (seoTitle != null) r'seoTitle': seoTitle,
        if (seoDescription != null) r'seoDescription': seoDescription,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
      });

  Input$TranslationInput._(this._$data);

  factory Input$TranslationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('seoTitle')) {
      final l$seoTitle = data['seoTitle'];
      result$data['seoTitle'] = (l$seoTitle as String?);
    }
    if (data.containsKey('seoDescription')) {
      final l$seoDescription = data['seoDescription'];
      result$data['seoDescription'] = (l$seoDescription as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    return Input$TranslationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get slug => (_$data['slug'] as String?);

  String? get seoTitle => (_$data['seoTitle'] as String?);

  String? get seoDescription => (_$data['seoDescription'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('seoTitle')) {
      final l$seoTitle = seoTitle;
      result$data['seoTitle'] = l$seoTitle;
    }
    if (_$data.containsKey('seoDescription')) {
      final l$seoDescription = seoDescription;
      result$data['seoDescription'] = l$seoDescription;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    return result$data;
  }

  CopyWith$Input$TranslationInput<Input$TranslationInput> get copyWith =>
      CopyWith$Input$TranslationInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TranslationInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$seoTitle = seoTitle;
    final lOther$seoTitle = other.seoTitle;
    if (_$data.containsKey('seoTitle') !=
        other._$data.containsKey('seoTitle')) {
      return false;
    }
    if (l$seoTitle != lOther$seoTitle) {
      return false;
    }
    final l$seoDescription = seoDescription;
    final lOther$seoDescription = other.seoDescription;
    if (_$data.containsKey('seoDescription') !=
        other._$data.containsKey('seoDescription')) {
      return false;
    }
    if (l$seoDescription != lOther$seoDescription) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$slug = slug;
    final l$seoTitle = seoTitle;
    final l$seoDescription = seoDescription;
    final l$name = name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('seoTitle') ? l$seoTitle : const {},
      _$data.containsKey('seoDescription') ? l$seoDescription : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$TranslationInput<TRes> {
  factory CopyWith$Input$TranslationInput(
    Input$TranslationInput instance,
    TRes Function(Input$TranslationInput) then,
  ) = _CopyWithImpl$Input$TranslationInput;

  factory CopyWith$Input$TranslationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TranslationInput;

  TRes call({
    String? slug,
    String? seoTitle,
    String? seoDescription,
    String? name,
    String? description,
  });
}

class _CopyWithImpl$Input$TranslationInput<TRes>
    implements CopyWith$Input$TranslationInput<TRes> {
  _CopyWithImpl$Input$TranslationInput(
    this._instance,
    this._then,
  );

  final Input$TranslationInput _instance;

  final TRes Function(Input$TranslationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? slug = _undefined,
    Object? seoTitle = _undefined,
    Object? seoDescription = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$TranslationInput._({
        ..._instance._$data,
        if (slug != _undefined) 'slug': (slug as String?),
        if (seoTitle != _undefined) 'seoTitle': (seoTitle as String?),
        if (seoDescription != _undefined)
          'seoDescription': (seoDescription as String?),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
      }));
}

class _CopyWithStubImpl$Input$TranslationInput<TRes>
    implements CopyWith$Input$TranslationInput<TRes> {
  _CopyWithStubImpl$Input$TranslationInput(this._res);

  TRes _res;

  call({
    String? slug,
    String? seoTitle,
    String? seoDescription,
    String? name,
    String? description,
  }) =>
      _res;
}

class Input$UpdateInvoiceInput {
  factory Input$UpdateInvoiceInput({
    String? number,
    String? url,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  }) =>
      Input$UpdateInvoiceInput._({
        if (number != null) r'number': number,
        if (url != null) r'url': url,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
      });

  Input$UpdateInvoiceInput._(this._$data);

  factory Input$UpdateInvoiceInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('number')) {
      final l$number = data['number'];
      result$data['number'] = (l$number as String?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$UpdateInvoiceInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get number => (_$data['number'] as String?);

  String? get url => (_$data['url'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('number')) {
      final l$number = number;
      result$data['number'] = l$number;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$UpdateInvoiceInput<Input$UpdateInvoiceInput> get copyWith =>
      CopyWith$Input$UpdateInvoiceInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateInvoiceInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$number = number;
    final lOther$number = other.number;
    if (_$data.containsKey('number') != other._$data.containsKey('number')) {
      return false;
    }
    if (l$number != lOther$number) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$number = number;
    final l$url = url;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    return Object.hashAll([
      _$data.containsKey('number') ? l$number : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateInvoiceInput<TRes> {
  factory CopyWith$Input$UpdateInvoiceInput(
    Input$UpdateInvoiceInput instance,
    TRes Function(Input$UpdateInvoiceInput) then,
  ) = _CopyWithImpl$Input$UpdateInvoiceInput;

  factory CopyWith$Input$UpdateInvoiceInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateInvoiceInput;

  TRes call({
    String? number,
    String? url,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  });
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$UpdateInvoiceInput<TRes>
    implements CopyWith$Input$UpdateInvoiceInput<TRes> {
  _CopyWithImpl$Input$UpdateInvoiceInput(
    this._instance,
    this._then,
  );

  final Input$UpdateInvoiceInput _instance;

  final TRes Function(Input$UpdateInvoiceInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? number = _undefined,
    Object? url = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
  }) =>
      _then(Input$UpdateInvoiceInput._({
        ..._instance._$data,
        if (number != _undefined) 'number': (number as String?),
        if (url != _undefined) 'url': (url as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$UpdateInvoiceInput<TRes>
    implements CopyWith$Input$UpdateInvoiceInput<TRes> {
  _CopyWithStubImpl$Input$UpdateInvoiceInput(this._res);

  TRes _res;

  call({
    String? number,
    String? url,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
  }) =>
      _res;

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$UserCreateInput {
  factory Input$UserCreateInput({
    Input$AddressInput? defaultBillingAddress,
    Input$AddressInput? defaultShippingAddress,
    String? firstName,
    String? lastName,
    String? email,
    bool? isActive,
    String? note,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Enum$LanguageCodeEnum? languageCode,
    String? externalReference,
    bool? isConfirmed,
    String? redirectUrl,
    String? channel,
  }) =>
      Input$UserCreateInput._({
        if (defaultBillingAddress != null)
          r'defaultBillingAddress': defaultBillingAddress,
        if (defaultShippingAddress != null)
          r'defaultShippingAddress': defaultShippingAddress,
        if (firstName != null) r'firstName': firstName,
        if (lastName != null) r'lastName': lastName,
        if (email != null) r'email': email,
        if (isActive != null) r'isActive': isActive,
        if (note != null) r'note': note,
        if (metadata != null) r'metadata': metadata,
        if (privateMetadata != null) r'privateMetadata': privateMetadata,
        if (languageCode != null) r'languageCode': languageCode,
        if (externalReference != null) r'externalReference': externalReference,
        if (isConfirmed != null) r'isConfirmed': isConfirmed,
        if (redirectUrl != null) r'redirectUrl': redirectUrl,
        if (channel != null) r'channel': channel,
      });

  Input$UserCreateInput._(this._$data);

  factory Input$UserCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('defaultBillingAddress')) {
      final l$defaultBillingAddress = data['defaultBillingAddress'];
      result$data['defaultBillingAddress'] = l$defaultBillingAddress == null
          ? null
          : Input$AddressInput.fromJson(
              (l$defaultBillingAddress as Map<String, dynamic>));
    }
    if (data.containsKey('defaultShippingAddress')) {
      final l$defaultShippingAddress = data['defaultShippingAddress'];
      result$data['defaultShippingAddress'] = l$defaultShippingAddress == null
          ? null
          : Input$AddressInput.fromJson(
              (l$defaultShippingAddress as Map<String, dynamic>));
    }
    if (data.containsKey('firstName')) {
      final l$firstName = data['firstName'];
      result$data['firstName'] = (l$firstName as String?);
    }
    if (data.containsKey('lastName')) {
      final l$lastName = data['lastName'];
      result$data['lastName'] = (l$lastName as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = (l$isActive as bool?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('privateMetadata')) {
      final l$privateMetadata = data['privateMetadata'];
      result$data['privateMetadata'] = (l$privateMetadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('languageCode')) {
      final l$languageCode = data['languageCode'];
      result$data['languageCode'] = l$languageCode == null
          ? null
          : fromJson$Enum$LanguageCodeEnum((l$languageCode as String));
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    if (data.containsKey('isConfirmed')) {
      final l$isConfirmed = data['isConfirmed'];
      result$data['isConfirmed'] = (l$isConfirmed as bool?);
    }
    if (data.containsKey('redirectUrl')) {
      final l$redirectUrl = data['redirectUrl'];
      result$data['redirectUrl'] = (l$redirectUrl as String?);
    }
    if (data.containsKey('channel')) {
      final l$channel = data['channel'];
      result$data['channel'] = (l$channel as String?);
    }
    return Input$UserCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$AddressInput? get defaultBillingAddress =>
      (_$data['defaultBillingAddress'] as Input$AddressInput?);

  Input$AddressInput? get defaultShippingAddress =>
      (_$data['defaultShippingAddress'] as Input$AddressInput?);

  String? get firstName => (_$data['firstName'] as String?);

  String? get lastName => (_$data['lastName'] as String?);

  String? get email => (_$data['email'] as String?);

  bool? get isActive => (_$data['isActive'] as bool?);

  String? get note => (_$data['note'] as String?);

  List<Input$MetadataInput>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataInput>?);

  List<Input$MetadataInput>? get privateMetadata =>
      (_$data['privateMetadata'] as List<Input$MetadataInput>?);

  Enum$LanguageCodeEnum? get languageCode =>
      (_$data['languageCode'] as Enum$LanguageCodeEnum?);

  String? get externalReference => (_$data['externalReference'] as String?);

  bool? get isConfirmed => (_$data['isConfirmed'] as bool?);

  String? get redirectUrl => (_$data['redirectUrl'] as String?);

  String? get channel => (_$data['channel'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('defaultBillingAddress')) {
      final l$defaultBillingAddress = defaultBillingAddress;
      result$data['defaultBillingAddress'] = l$defaultBillingAddress?.toJson();
    }
    if (_$data.containsKey('defaultShippingAddress')) {
      final l$defaultShippingAddress = defaultShippingAddress;
      result$data['defaultShippingAddress'] =
          l$defaultShippingAddress?.toJson();
    }
    if (_$data.containsKey('firstName')) {
      final l$firstName = firstName;
      result$data['firstName'] = l$firstName;
    }
    if (_$data.containsKey('lastName')) {
      final l$lastName = lastName;
      result$data['lastName'] = l$lastName;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('privateMetadata')) {
      final l$privateMetadata = privateMetadata;
      result$data['privateMetadata'] =
          l$privateMetadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('languageCode')) {
      final l$languageCode = languageCode;
      result$data['languageCode'] = l$languageCode == null
          ? null
          : toJson$Enum$LanguageCodeEnum(l$languageCode);
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    if (_$data.containsKey('isConfirmed')) {
      final l$isConfirmed = isConfirmed;
      result$data['isConfirmed'] = l$isConfirmed;
    }
    if (_$data.containsKey('redirectUrl')) {
      final l$redirectUrl = redirectUrl;
      result$data['redirectUrl'] = l$redirectUrl;
    }
    if (_$data.containsKey('channel')) {
      final l$channel = channel;
      result$data['channel'] = l$channel;
    }
    return result$data;
  }

  CopyWith$Input$UserCreateInput<Input$UserCreateInput> get copyWith =>
      CopyWith$Input$UserCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UserCreateInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$defaultBillingAddress = defaultBillingAddress;
    final lOther$defaultBillingAddress = other.defaultBillingAddress;
    if (_$data.containsKey('defaultBillingAddress') !=
        other._$data.containsKey('defaultBillingAddress')) {
      return false;
    }
    if (l$defaultBillingAddress != lOther$defaultBillingAddress) {
      return false;
    }
    final l$defaultShippingAddress = defaultShippingAddress;
    final lOther$defaultShippingAddress = other.defaultShippingAddress;
    if (_$data.containsKey('defaultShippingAddress') !=
        other._$data.containsKey('defaultShippingAddress')) {
      return false;
    }
    if (l$defaultShippingAddress != lOther$defaultShippingAddress) {
      return false;
    }
    final l$firstName = firstName;
    final lOther$firstName = other.firstName;
    if (_$data.containsKey('firstName') !=
        other._$data.containsKey('firstName')) {
      return false;
    }
    if (l$firstName != lOther$firstName) {
      return false;
    }
    final l$lastName = lastName;
    final lOther$lastName = other.lastName;
    if (_$data.containsKey('lastName') !=
        other._$data.containsKey('lastName')) {
      return false;
    }
    if (l$lastName != lOther$lastName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$privateMetadata = privateMetadata;
    final lOther$privateMetadata = other.privateMetadata;
    if (_$data.containsKey('privateMetadata') !=
        other._$data.containsKey('privateMetadata')) {
      return false;
    }
    if (l$privateMetadata != null && lOther$privateMetadata != null) {
      if (l$privateMetadata.length != lOther$privateMetadata.length) {
        return false;
      }
      for (int i = 0; i < l$privateMetadata.length; i++) {
        final l$privateMetadata$entry = l$privateMetadata[i];
        final lOther$privateMetadata$entry = lOther$privateMetadata[i];
        if (l$privateMetadata$entry != lOther$privateMetadata$entry) {
          return false;
        }
      }
    } else if (l$privateMetadata != lOther$privateMetadata) {
      return false;
    }
    final l$languageCode = languageCode;
    final lOther$languageCode = other.languageCode;
    if (_$data.containsKey('languageCode') !=
        other._$data.containsKey('languageCode')) {
      return false;
    }
    if (l$languageCode != lOther$languageCode) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$isConfirmed = isConfirmed;
    final lOther$isConfirmed = other.isConfirmed;
    if (_$data.containsKey('isConfirmed') !=
        other._$data.containsKey('isConfirmed')) {
      return false;
    }
    if (l$isConfirmed != lOther$isConfirmed) {
      return false;
    }
    final l$redirectUrl = redirectUrl;
    final lOther$redirectUrl = other.redirectUrl;
    if (_$data.containsKey('redirectUrl') !=
        other._$data.containsKey('redirectUrl')) {
      return false;
    }
    if (l$redirectUrl != lOther$redirectUrl) {
      return false;
    }
    final l$channel = channel;
    final lOther$channel = other.channel;
    if (_$data.containsKey('channel') != other._$data.containsKey('channel')) {
      return false;
    }
    if (l$channel != lOther$channel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$defaultBillingAddress = defaultBillingAddress;
    final l$defaultShippingAddress = defaultShippingAddress;
    final l$firstName = firstName;
    final l$lastName = lastName;
    final l$email = email;
    final l$isActive = isActive;
    final l$note = note;
    final l$metadata = metadata;
    final l$privateMetadata = privateMetadata;
    final l$languageCode = languageCode;
    final l$externalReference = externalReference;
    final l$isConfirmed = isConfirmed;
    final l$redirectUrl = redirectUrl;
    final l$channel = channel;
    return Object.hashAll([
      _$data.containsKey('defaultBillingAddress')
          ? l$defaultBillingAddress
          : const {},
      _$data.containsKey('defaultShippingAddress')
          ? l$defaultShippingAddress
          : const {},
      _$data.containsKey('firstName') ? l$firstName : const {},
      _$data.containsKey('lastName') ? l$lastName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('note') ? l$note : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('privateMetadata')
          ? l$privateMetadata == null
              ? null
              : Object.hashAll(l$privateMetadata.map((v) => v))
          : const {},
      _$data.containsKey('languageCode') ? l$languageCode : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      _$data.containsKey('isConfirmed') ? l$isConfirmed : const {},
      _$data.containsKey('redirectUrl') ? l$redirectUrl : const {},
      _$data.containsKey('channel') ? l$channel : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserCreateInput<TRes> {
  factory CopyWith$Input$UserCreateInput(
    Input$UserCreateInput instance,
    TRes Function(Input$UserCreateInput) then,
  ) = _CopyWithImpl$Input$UserCreateInput;

  factory CopyWith$Input$UserCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserCreateInput;

  TRes call({
    Input$AddressInput? defaultBillingAddress,
    Input$AddressInput? defaultShippingAddress,
    String? firstName,
    String? lastName,
    String? email,
    bool? isActive,
    String? note,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Enum$LanguageCodeEnum? languageCode,
    String? externalReference,
    bool? isConfirmed,
    String? redirectUrl,
    String? channel,
  });
  CopyWith$Input$AddressInput<TRes> get defaultBillingAddress;
  CopyWith$Input$AddressInput<TRes> get defaultShippingAddress;
  TRes metadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
  TRes privateMetadata(
      Iterable<Input$MetadataInput>? Function(
              Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
          _fn);
}

class _CopyWithImpl$Input$UserCreateInput<TRes>
    implements CopyWith$Input$UserCreateInput<TRes> {
  _CopyWithImpl$Input$UserCreateInput(
    this._instance,
    this._then,
  );

  final Input$UserCreateInput _instance;

  final TRes Function(Input$UserCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? defaultBillingAddress = _undefined,
    Object? defaultShippingAddress = _undefined,
    Object? firstName = _undefined,
    Object? lastName = _undefined,
    Object? email = _undefined,
    Object? isActive = _undefined,
    Object? note = _undefined,
    Object? metadata = _undefined,
    Object? privateMetadata = _undefined,
    Object? languageCode = _undefined,
    Object? externalReference = _undefined,
    Object? isConfirmed = _undefined,
    Object? redirectUrl = _undefined,
    Object? channel = _undefined,
  }) =>
      _then(Input$UserCreateInput._({
        ..._instance._$data,
        if (defaultBillingAddress != _undefined)
          'defaultBillingAddress':
              (defaultBillingAddress as Input$AddressInput?),
        if (defaultShippingAddress != _undefined)
          'defaultShippingAddress':
              (defaultShippingAddress as Input$AddressInput?),
        if (firstName != _undefined) 'firstName': (firstName as String?),
        if (lastName != _undefined) 'lastName': (lastName as String?),
        if (email != _undefined) 'email': (email as String?),
        if (isActive != _undefined) 'isActive': (isActive as bool?),
        if (note != _undefined) 'note': (note as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataInput>?),
        if (privateMetadata != _undefined)
          'privateMetadata': (privateMetadata as List<Input$MetadataInput>?),
        if (languageCode != _undefined)
          'languageCode': (languageCode as Enum$LanguageCodeEnum?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (isConfirmed != _undefined) 'isConfirmed': (isConfirmed as bool?),
        if (redirectUrl != _undefined) 'redirectUrl': (redirectUrl as String?),
        if (channel != _undefined) 'channel': (channel as String?),
      }));

  CopyWith$Input$AddressInput<TRes> get defaultBillingAddress {
    final local$defaultBillingAddress = _instance.defaultBillingAddress;
    return local$defaultBillingAddress == null
        ? CopyWith$Input$AddressInput.stub(_then(_instance))
        : CopyWith$Input$AddressInput(
            local$defaultBillingAddress, (e) => call(defaultBillingAddress: e));
  }

  CopyWith$Input$AddressInput<TRes> get defaultShippingAddress {
    final local$defaultShippingAddress = _instance.defaultShippingAddress;
    return local$defaultShippingAddress == null
        ? CopyWith$Input$AddressInput.stub(_then(_instance))
        : CopyWith$Input$AddressInput(local$defaultShippingAddress,
            (e) => call(defaultShippingAddress: e));
  }

  TRes metadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes privateMetadata(
          Iterable<Input$MetadataInput>? Function(
                  Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>?)
              _fn) =>
      call(
          privateMetadata: _fn(_instance.privateMetadata
              ?.map((e) => CopyWith$Input$MetadataInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$UserCreateInput<TRes>
    implements CopyWith$Input$UserCreateInput<TRes> {
  _CopyWithStubImpl$Input$UserCreateInput(this._res);

  TRes _res;

  call({
    Input$AddressInput? defaultBillingAddress,
    Input$AddressInput? defaultShippingAddress,
    String? firstName,
    String? lastName,
    String? email,
    bool? isActive,
    String? note,
    List<Input$MetadataInput>? metadata,
    List<Input$MetadataInput>? privateMetadata,
    Enum$LanguageCodeEnum? languageCode,
    String? externalReference,
    bool? isConfirmed,
    String? redirectUrl,
    String? channel,
  }) =>
      _res;

  CopyWith$Input$AddressInput<TRes> get defaultBillingAddress =>
      CopyWith$Input$AddressInput.stub(_res);

  CopyWith$Input$AddressInput<TRes> get defaultShippingAddress =>
      CopyWith$Input$AddressInput.stub(_res);

  metadata(_fn) => _res;

  privateMetadata(_fn) => _res;
}

class Input$UserSortingInput {
  factory Input$UserSortingInput({
    required Enum$OrderDirection direction,
    required Enum$UserSortField field,
  }) =>
      Input$UserSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$UserSortingInput._(this._$data);

  factory Input$UserSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$UserSortField((l$field as String));
    return Input$UserSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$UserSortField get field => (_$data['field'] as Enum$UserSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$UserSortField(l$field);
    return result$data;
  }

  CopyWith$Input$UserSortingInput<Input$UserSortingInput> get copyWith =>
      CopyWith$Input$UserSortingInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UserSortingInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$UserSortingInput<TRes> {
  factory CopyWith$Input$UserSortingInput(
    Input$UserSortingInput instance,
    TRes Function(Input$UserSortingInput) then,
  ) = _CopyWithImpl$Input$UserSortingInput;

  factory CopyWith$Input$UserSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$UserSortField? field,
  });
}

class _CopyWithImpl$Input$UserSortingInput<TRes>
    implements CopyWith$Input$UserSortingInput<TRes> {
  _CopyWithImpl$Input$UserSortingInput(
    this._instance,
    this._then,
  );

  final Input$UserSortingInput _instance;

  final TRes Function(Input$UserSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$UserSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$UserSortField),
      }));
}

class _CopyWithStubImpl$Input$UserSortingInput<TRes>
    implements CopyWith$Input$UserSortingInput<TRes> {
  _CopyWithStubImpl$Input$UserSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$UserSortField? field,
  }) =>
      _res;
}

class Input$UUIDFilterInput {
  factory Input$UUIDFilterInput({
    String? eq,
    List<String>? oneOf,
  }) =>
      Input$UUIDFilterInput._({
        if (eq != null) r'eq': eq,
        if (oneOf != null) r'oneOf': oneOf,
      });

  Input$UUIDFilterInput._(this._$data);

  factory Input$UUIDFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('oneOf')) {
      final l$oneOf = data['oneOf'];
      result$data['oneOf'] =
          (l$oneOf as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$UUIDFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get eq => (_$data['eq'] as String?);

  List<String>? get oneOf => (_$data['oneOf'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('oneOf')) {
      final l$oneOf = oneOf;
      result$data['oneOf'] = l$oneOf?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$UUIDFilterInput<Input$UUIDFilterInput> get copyWith =>
      CopyWith$Input$UUIDFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UUIDFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$oneOf = oneOf;
    final lOther$oneOf = other.oneOf;
    if (_$data.containsKey('oneOf') != other._$data.containsKey('oneOf')) {
      return false;
    }
    if (l$oneOf != null && lOther$oneOf != null) {
      if (l$oneOf.length != lOther$oneOf.length) {
        return false;
      }
      for (int i = 0; i < l$oneOf.length; i++) {
        final l$oneOf$entry = l$oneOf[i];
        final lOther$oneOf$entry = lOther$oneOf[i];
        if (l$oneOf$entry != lOther$oneOf$entry) {
          return false;
        }
      }
    } else if (l$oneOf != lOther$oneOf) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$oneOf = oneOf;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('oneOf')
          ? l$oneOf == null
              ? null
              : Object.hashAll(l$oneOf.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UUIDFilterInput<TRes> {
  factory CopyWith$Input$UUIDFilterInput(
    Input$UUIDFilterInput instance,
    TRes Function(Input$UUIDFilterInput) then,
  ) = _CopyWithImpl$Input$UUIDFilterInput;

  factory CopyWith$Input$UUIDFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UUIDFilterInput;

  TRes call({
    String? eq,
    List<String>? oneOf,
  });
}

class _CopyWithImpl$Input$UUIDFilterInput<TRes>
    implements CopyWith$Input$UUIDFilterInput<TRes> {
  _CopyWithImpl$Input$UUIDFilterInput(
    this._instance,
    this._then,
  );

  final Input$UUIDFilterInput _instance;

  final TRes Function(Input$UUIDFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? oneOf = _undefined,
  }) =>
      _then(Input$UUIDFilterInput._({
        ..._instance._$data,
        if (eq != _undefined) 'eq': (eq as String?),
        if (oneOf != _undefined) 'oneOf': (oneOf as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$UUIDFilterInput<TRes>
    implements CopyWith$Input$UUIDFilterInput<TRes> {
  _CopyWithStubImpl$Input$UUIDFilterInput(this._res);

  TRes _res;

  call({
    String? eq,
    List<String>? oneOf,
  }) =>
      _res;
}

class Input$VoucherChannelListingAddInput {
  factory Input$VoucherChannelListingAddInput({
    required String channelId,
    String? discountValue,
    String? minAmountSpent,
  }) =>
      Input$VoucherChannelListingAddInput._({
        r'channelId': channelId,
        if (discountValue != null) r'discountValue': discountValue,
        if (minAmountSpent != null) r'minAmountSpent': minAmountSpent,
      });

  Input$VoucherChannelListingAddInput._(this._$data);

  factory Input$VoucherChannelListingAddInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$channelId = data['channelId'];
    result$data['channelId'] = (l$channelId as String);
    if (data.containsKey('discountValue')) {
      final l$discountValue = data['discountValue'];
      result$data['discountValue'] = (l$discountValue as String?);
    }
    if (data.containsKey('minAmountSpent')) {
      final l$minAmountSpent = data['minAmountSpent'];
      result$data['minAmountSpent'] = (l$minAmountSpent as String?);
    }
    return Input$VoucherChannelListingAddInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get channelId => (_$data['channelId'] as String);

  String? get discountValue => (_$data['discountValue'] as String?);

  String? get minAmountSpent => (_$data['minAmountSpent'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$channelId = channelId;
    result$data['channelId'] = l$channelId;
    if (_$data.containsKey('discountValue')) {
      final l$discountValue = discountValue;
      result$data['discountValue'] = l$discountValue;
    }
    if (_$data.containsKey('minAmountSpent')) {
      final l$minAmountSpent = minAmountSpent;
      result$data['minAmountSpent'] = l$minAmountSpent;
    }
    return result$data;
  }

  CopyWith$Input$VoucherChannelListingAddInput<
          Input$VoucherChannelListingAddInput>
      get copyWith => CopyWith$Input$VoucherChannelListingAddInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$VoucherChannelListingAddInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$channelId = channelId;
    final lOther$channelId = other.channelId;
    if (l$channelId != lOther$channelId) {
      return false;
    }
    final l$discountValue = discountValue;
    final lOther$discountValue = other.discountValue;
    if (_$data.containsKey('discountValue') !=
        other._$data.containsKey('discountValue')) {
      return false;
    }
    if (l$discountValue != lOther$discountValue) {
      return false;
    }
    final l$minAmountSpent = minAmountSpent;
    final lOther$minAmountSpent = other.minAmountSpent;
    if (_$data.containsKey('minAmountSpent') !=
        other._$data.containsKey('minAmountSpent')) {
      return false;
    }
    if (l$minAmountSpent != lOther$minAmountSpent) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$channelId = channelId;
    final l$discountValue = discountValue;
    final l$minAmountSpent = minAmountSpent;
    return Object.hashAll([
      l$channelId,
      _$data.containsKey('discountValue') ? l$discountValue : const {},
      _$data.containsKey('minAmountSpent') ? l$minAmountSpent : const {},
    ]);
  }
}

abstract class CopyWith$Input$VoucherChannelListingAddInput<TRes> {
  factory CopyWith$Input$VoucherChannelListingAddInput(
    Input$VoucherChannelListingAddInput instance,
    TRes Function(Input$VoucherChannelListingAddInput) then,
  ) = _CopyWithImpl$Input$VoucherChannelListingAddInput;

  factory CopyWith$Input$VoucherChannelListingAddInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VoucherChannelListingAddInput;

  TRes call({
    String? channelId,
    String? discountValue,
    String? minAmountSpent,
  });
}

class _CopyWithImpl$Input$VoucherChannelListingAddInput<TRes>
    implements CopyWith$Input$VoucherChannelListingAddInput<TRes> {
  _CopyWithImpl$Input$VoucherChannelListingAddInput(
    this._instance,
    this._then,
  );

  final Input$VoucherChannelListingAddInput _instance;

  final TRes Function(Input$VoucherChannelListingAddInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? channelId = _undefined,
    Object? discountValue = _undefined,
    Object? minAmountSpent = _undefined,
  }) =>
      _then(Input$VoucherChannelListingAddInput._({
        ..._instance._$data,
        if (channelId != _undefined && channelId != null)
          'channelId': (channelId as String),
        if (discountValue != _undefined)
          'discountValue': (discountValue as String?),
        if (minAmountSpent != _undefined)
          'minAmountSpent': (minAmountSpent as String?),
      }));
}

class _CopyWithStubImpl$Input$VoucherChannelListingAddInput<TRes>
    implements CopyWith$Input$VoucherChannelListingAddInput<TRes> {
  _CopyWithStubImpl$Input$VoucherChannelListingAddInput(this._res);

  TRes _res;

  call({
    String? channelId,
    String? discountValue,
    String? minAmountSpent,
  }) =>
      _res;
}

class Input$VoucherChannelListingInput {
  factory Input$VoucherChannelListingInput({
    List<Input$VoucherChannelListingAddInput>? addChannels,
    List<String>? removeChannels,
  }) =>
      Input$VoucherChannelListingInput._({
        if (addChannels != null) r'addChannels': addChannels,
        if (removeChannels != null) r'removeChannels': removeChannels,
      });

  Input$VoucherChannelListingInput._(this._$data);

  factory Input$VoucherChannelListingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('addChannels')) {
      final l$addChannels = data['addChannels'];
      result$data['addChannels'] = (l$addChannels as List<dynamic>?)
          ?.map((e) => Input$VoucherChannelListingAddInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('removeChannels')) {
      final l$removeChannels = data['removeChannels'];
      result$data['removeChannels'] = (l$removeChannels as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$VoucherChannelListingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$VoucherChannelListingAddInput>? get addChannels =>
      (_$data['addChannels'] as List<Input$VoucherChannelListingAddInput>?);

  List<String>? get removeChannels =>
      (_$data['removeChannels'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('addChannels')) {
      final l$addChannels = addChannels;
      result$data['addChannels'] =
          l$addChannels?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('removeChannels')) {
      final l$removeChannels = removeChannels;
      result$data['removeChannels'] = l$removeChannels?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$VoucherChannelListingInput<Input$VoucherChannelListingInput>
      get copyWith => CopyWith$Input$VoucherChannelListingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$VoucherChannelListingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$addChannels = addChannels;
    final lOther$addChannels = other.addChannels;
    if (_$data.containsKey('addChannels') !=
        other._$data.containsKey('addChannels')) {
      return false;
    }
    if (l$addChannels != null && lOther$addChannels != null) {
      if (l$addChannels.length != lOther$addChannels.length) {
        return false;
      }
      for (int i = 0; i < l$addChannels.length; i++) {
        final l$addChannels$entry = l$addChannels[i];
        final lOther$addChannels$entry = lOther$addChannels[i];
        if (l$addChannels$entry != lOther$addChannels$entry) {
          return false;
        }
      }
    } else if (l$addChannels != lOther$addChannels) {
      return false;
    }
    final l$removeChannels = removeChannels;
    final lOther$removeChannels = other.removeChannels;
    if (_$data.containsKey('removeChannels') !=
        other._$data.containsKey('removeChannels')) {
      return false;
    }
    if (l$removeChannels != null && lOther$removeChannels != null) {
      if (l$removeChannels.length != lOther$removeChannels.length) {
        return false;
      }
      for (int i = 0; i < l$removeChannels.length; i++) {
        final l$removeChannels$entry = l$removeChannels[i];
        final lOther$removeChannels$entry = lOther$removeChannels[i];
        if (l$removeChannels$entry != lOther$removeChannels$entry) {
          return false;
        }
      }
    } else if (l$removeChannels != lOther$removeChannels) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$addChannels = addChannels;
    final l$removeChannels = removeChannels;
    return Object.hashAll([
      _$data.containsKey('addChannels')
          ? l$addChannels == null
              ? null
              : Object.hashAll(l$addChannels.map((v) => v))
          : const {},
      _$data.containsKey('removeChannels')
          ? l$removeChannels == null
              ? null
              : Object.hashAll(l$removeChannels.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$VoucherChannelListingInput<TRes> {
  factory CopyWith$Input$VoucherChannelListingInput(
    Input$VoucherChannelListingInput instance,
    TRes Function(Input$VoucherChannelListingInput) then,
  ) = _CopyWithImpl$Input$VoucherChannelListingInput;

  factory CopyWith$Input$VoucherChannelListingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VoucherChannelListingInput;

  TRes call({
    List<Input$VoucherChannelListingAddInput>? addChannels,
    List<String>? removeChannels,
  });
  TRes addChannels(
      Iterable<Input$VoucherChannelListingAddInput>? Function(
              Iterable<
                  CopyWith$Input$VoucherChannelListingAddInput<
                      Input$VoucherChannelListingAddInput>>?)
          _fn);
}

class _CopyWithImpl$Input$VoucherChannelListingInput<TRes>
    implements CopyWith$Input$VoucherChannelListingInput<TRes> {
  _CopyWithImpl$Input$VoucherChannelListingInput(
    this._instance,
    this._then,
  );

  final Input$VoucherChannelListingInput _instance;

  final TRes Function(Input$VoucherChannelListingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? addChannels = _undefined,
    Object? removeChannels = _undefined,
  }) =>
      _then(Input$VoucherChannelListingInput._({
        ..._instance._$data,
        if (addChannels != _undefined)
          'addChannels':
              (addChannels as List<Input$VoucherChannelListingAddInput>?),
        if (removeChannels != _undefined)
          'removeChannels': (removeChannels as List<String>?),
      }));

  TRes addChannels(
          Iterable<Input$VoucherChannelListingAddInput>? Function(
                  Iterable<
                      CopyWith$Input$VoucherChannelListingAddInput<
                          Input$VoucherChannelListingAddInput>>?)
              _fn) =>
      call(
          addChannels: _fn(_instance.addChannels
              ?.map((e) => CopyWith$Input$VoucherChannelListingAddInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$VoucherChannelListingInput<TRes>
    implements CopyWith$Input$VoucherChannelListingInput<TRes> {
  _CopyWithStubImpl$Input$VoucherChannelListingInput(this._res);

  TRes _res;

  call({
    List<Input$VoucherChannelListingAddInput>? addChannels,
    List<String>? removeChannels,
  }) =>
      _res;

  addChannels(_fn) => _res;
}

class Input$VoucherFilterInput {
  factory Input$VoucherFilterInput({
    List<Enum$DiscountStatusEnum>? status,
    Input$IntRangeInput? timesUsed,
    List<Enum$VoucherDiscountType>? discountType,
    Input$DateTimeRangeInput? started,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
  }) =>
      Input$VoucherFilterInput._({
        if (status != null) r'status': status,
        if (timesUsed != null) r'timesUsed': timesUsed,
        if (discountType != null) r'discountType': discountType,
        if (started != null) r'started': started,
        if (search != null) r'search': search,
        if (metadata != null) r'metadata': metadata,
        if (ids != null) r'ids': ids,
      });

  Input$VoucherFilterInput._(this._$data);

  factory Input$VoucherFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as List<dynamic>?)
          ?.map((e) => fromJson$Enum$DiscountStatusEnum((e as String)))
          .toList();
    }
    if (data.containsKey('timesUsed')) {
      final l$timesUsed = data['timesUsed'];
      result$data['timesUsed'] = l$timesUsed == null
          ? null
          : Input$IntRangeInput.fromJson((l$timesUsed as Map<String, dynamic>));
    }
    if (data.containsKey('discountType')) {
      final l$discountType = data['discountType'];
      result$data['discountType'] = (l$discountType as List<dynamic>?)
          ?.map((e) => fromJson$Enum$VoucherDiscountType((e as String)))
          .toList();
    }
    if (data.containsKey('started')) {
      final l$started = data['started'];
      result$data['started'] = l$started == null
          ? null
          : Input$DateTimeRangeInput.fromJson(
              (l$started as Map<String, dynamic>));
    }
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$VoucherFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$DiscountStatusEnum>? get status =>
      (_$data['status'] as List<Enum$DiscountStatusEnum>?);

  Input$IntRangeInput? get timesUsed =>
      (_$data['timesUsed'] as Input$IntRangeInput?);

  List<Enum$VoucherDiscountType>? get discountType =>
      (_$data['discountType'] as List<Enum$VoucherDiscountType>?);

  Input$DateTimeRangeInput? get started =>
      (_$data['started'] as Input$DateTimeRangeInput?);

  String? get search => (_$data['search'] as String?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status?.map((e) => toJson$Enum$DiscountStatusEnum(e)).toList();
    }
    if (_$data.containsKey('timesUsed')) {
      final l$timesUsed = timesUsed;
      result$data['timesUsed'] = l$timesUsed?.toJson();
    }
    if (_$data.containsKey('discountType')) {
      final l$discountType = discountType;
      result$data['discountType'] = l$discountType
          ?.map((e) => toJson$Enum$VoucherDiscountType(e))
          .toList();
    }
    if (_$data.containsKey('started')) {
      final l$started = started;
      result$data['started'] = l$started?.toJson();
    }
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$VoucherFilterInput<Input$VoucherFilterInput> get copyWith =>
      CopyWith$Input$VoucherFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$VoucherFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != null && lOther$status != null) {
      if (l$status.length != lOther$status.length) {
        return false;
      }
      for (int i = 0; i < l$status.length; i++) {
        final l$status$entry = l$status[i];
        final lOther$status$entry = lOther$status[i];
        if (l$status$entry != lOther$status$entry) {
          return false;
        }
      }
    } else if (l$status != lOther$status) {
      return false;
    }
    final l$timesUsed = timesUsed;
    final lOther$timesUsed = other.timesUsed;
    if (_$data.containsKey('timesUsed') !=
        other._$data.containsKey('timesUsed')) {
      return false;
    }
    if (l$timesUsed != lOther$timesUsed) {
      return false;
    }
    final l$discountType = discountType;
    final lOther$discountType = other.discountType;
    if (_$data.containsKey('discountType') !=
        other._$data.containsKey('discountType')) {
      return false;
    }
    if (l$discountType != null && lOther$discountType != null) {
      if (l$discountType.length != lOther$discountType.length) {
        return false;
      }
      for (int i = 0; i < l$discountType.length; i++) {
        final l$discountType$entry = l$discountType[i];
        final lOther$discountType$entry = lOther$discountType[i];
        if (l$discountType$entry != lOther$discountType$entry) {
          return false;
        }
      }
    } else if (l$discountType != lOther$discountType) {
      return false;
    }
    final l$started = started;
    final lOther$started = other.started;
    if (_$data.containsKey('started') != other._$data.containsKey('started')) {
      return false;
    }
    if (l$started != lOther$started) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$status = status;
    final l$timesUsed = timesUsed;
    final l$discountType = discountType;
    final l$started = started;
    final l$search = search;
    final l$metadata = metadata;
    final l$ids = ids;
    return Object.hashAll([
      _$data.containsKey('status')
          ? l$status == null
              ? null
              : Object.hashAll(l$status.map((v) => v))
          : const {},
      _$data.containsKey('timesUsed') ? l$timesUsed : const {},
      _$data.containsKey('discountType')
          ? l$discountType == null
              ? null
              : Object.hashAll(l$discountType.map((v) => v))
          : const {},
      _$data.containsKey('started') ? l$started : const {},
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$VoucherFilterInput<TRes> {
  factory CopyWith$Input$VoucherFilterInput(
    Input$VoucherFilterInput instance,
    TRes Function(Input$VoucherFilterInput) then,
  ) = _CopyWithImpl$Input$VoucherFilterInput;

  factory CopyWith$Input$VoucherFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VoucherFilterInput;

  TRes call({
    List<Enum$DiscountStatusEnum>? status,
    Input$IntRangeInput? timesUsed,
    List<Enum$VoucherDiscountType>? discountType,
    Input$DateTimeRangeInput? started,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
  });
  CopyWith$Input$IntRangeInput<TRes> get timesUsed;
  CopyWith$Input$DateTimeRangeInput<TRes> get started;
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
}

class _CopyWithImpl$Input$VoucherFilterInput<TRes>
    implements CopyWith$Input$VoucherFilterInput<TRes> {
  _CopyWithImpl$Input$VoucherFilterInput(
    this._instance,
    this._then,
  );

  final Input$VoucherFilterInput _instance;

  final TRes Function(Input$VoucherFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? status = _undefined,
    Object? timesUsed = _undefined,
    Object? discountType = _undefined,
    Object? started = _undefined,
    Object? search = _undefined,
    Object? metadata = _undefined,
    Object? ids = _undefined,
  }) =>
      _then(Input$VoucherFilterInput._({
        ..._instance._$data,
        if (status != _undefined)
          'status': (status as List<Enum$DiscountStatusEnum>?),
        if (timesUsed != _undefined)
          'timesUsed': (timesUsed as Input$IntRangeInput?),
        if (discountType != _undefined)
          'discountType': (discountType as List<Enum$VoucherDiscountType>?),
        if (started != _undefined)
          'started': (started as Input$DateTimeRangeInput?),
        if (search != _undefined) 'search': (search as String?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
      }));

  CopyWith$Input$IntRangeInput<TRes> get timesUsed {
    final local$timesUsed = _instance.timesUsed;
    return local$timesUsed == null
        ? CopyWith$Input$IntRangeInput.stub(_then(_instance))
        : CopyWith$Input$IntRangeInput(
            local$timesUsed, (e) => call(timesUsed: e));
  }

  CopyWith$Input$DateTimeRangeInput<TRes> get started {
    final local$started = _instance.started;
    return local$started == null
        ? CopyWith$Input$DateTimeRangeInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeRangeInput(
            local$started, (e) => call(started: e));
  }

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$VoucherFilterInput<TRes>
    implements CopyWith$Input$VoucherFilterInput<TRes> {
  _CopyWithStubImpl$Input$VoucherFilterInput(this._res);

  TRes _res;

  call({
    List<Enum$DiscountStatusEnum>? status,
    Input$IntRangeInput? timesUsed,
    List<Enum$VoucherDiscountType>? discountType,
    Input$DateTimeRangeInput? started,
    String? search,
    List<Input$MetadataFilter>? metadata,
    List<String>? ids,
  }) =>
      _res;

  CopyWith$Input$IntRangeInput<TRes> get timesUsed =>
      CopyWith$Input$IntRangeInput.stub(_res);

  CopyWith$Input$DateTimeRangeInput<TRes> get started =>
      CopyWith$Input$DateTimeRangeInput.stub(_res);

  metadata(_fn) => _res;
}

class Input$VoucherInput {
  factory Input$VoucherInput({
    Enum$VoucherTypeEnum? type,
    String? name,
    String? code,
    List<String>? addCodes,
    String? startDate,
    String? endDate,
    Enum$DiscountValueTypeEnum? discountValueType,
    List<String>? products,
    List<String>? variants,
    List<String>? collections,
    List<String>? categories,
    int? minCheckoutItemsQuantity,
    List<String>? countries,
    bool? applyOncePerOrder,
    bool? applyOncePerCustomer,
    bool? onlyForStaff,
    bool? singleUse,
    int? usageLimit,
  }) =>
      Input$VoucherInput._({
        if (type != null) r'type': type,
        if (name != null) r'name': name,
        if (code != null) r'code': code,
        if (addCodes != null) r'addCodes': addCodes,
        if (startDate != null) r'startDate': startDate,
        if (endDate != null) r'endDate': endDate,
        if (discountValueType != null) r'discountValueType': discountValueType,
        if (products != null) r'products': products,
        if (variants != null) r'variants': variants,
        if (collections != null) r'collections': collections,
        if (categories != null) r'categories': categories,
        if (minCheckoutItemsQuantity != null)
          r'minCheckoutItemsQuantity': minCheckoutItemsQuantity,
        if (countries != null) r'countries': countries,
        if (applyOncePerOrder != null) r'applyOncePerOrder': applyOncePerOrder,
        if (applyOncePerCustomer != null)
          r'applyOncePerCustomer': applyOncePerCustomer,
        if (onlyForStaff != null) r'onlyForStaff': onlyForStaff,
        if (singleUse != null) r'singleUse': singleUse,
        if (usageLimit != null) r'usageLimit': usageLimit,
      });

  Input$VoucherInput._(this._$data);

  factory Input$VoucherInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : fromJson$Enum$VoucherTypeEnum((l$type as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('code')) {
      final l$code = data['code'];
      result$data['code'] = (l$code as String?);
    }
    if (data.containsKey('addCodes')) {
      final l$addCodes = data['addCodes'];
      result$data['addCodes'] =
          (l$addCodes as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('startDate')) {
      final l$startDate = data['startDate'];
      result$data['startDate'] = (l$startDate as String?);
    }
    if (data.containsKey('endDate')) {
      final l$endDate = data['endDate'];
      result$data['endDate'] = (l$endDate as String?);
    }
    if (data.containsKey('discountValueType')) {
      final l$discountValueType = data['discountValueType'];
      result$data['discountValueType'] = l$discountValueType == null
          ? null
          : fromJson$Enum$DiscountValueTypeEnum(
              (l$discountValueType as String));
    }
    if (data.containsKey('products')) {
      final l$products = data['products'];
      result$data['products'] =
          (l$products as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('variants')) {
      final l$variants = data['variants'];
      result$data['variants'] =
          (l$variants as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('collections')) {
      final l$collections = data['collections'];
      result$data['collections'] =
          (l$collections as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('categories')) {
      final l$categories = data['categories'];
      result$data['categories'] =
          (l$categories as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('minCheckoutItemsQuantity')) {
      final l$minCheckoutItemsQuantity = data['minCheckoutItemsQuantity'];
      result$data['minCheckoutItemsQuantity'] =
          (l$minCheckoutItemsQuantity as int?);
    }
    if (data.containsKey('countries')) {
      final l$countries = data['countries'];
      result$data['countries'] =
          (l$countries as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('applyOncePerOrder')) {
      final l$applyOncePerOrder = data['applyOncePerOrder'];
      result$data['applyOncePerOrder'] = (l$applyOncePerOrder as bool?);
    }
    if (data.containsKey('applyOncePerCustomer')) {
      final l$applyOncePerCustomer = data['applyOncePerCustomer'];
      result$data['applyOncePerCustomer'] = (l$applyOncePerCustomer as bool?);
    }
    if (data.containsKey('onlyForStaff')) {
      final l$onlyForStaff = data['onlyForStaff'];
      result$data['onlyForStaff'] = (l$onlyForStaff as bool?);
    }
    if (data.containsKey('singleUse')) {
      final l$singleUse = data['singleUse'];
      result$data['singleUse'] = (l$singleUse as bool?);
    }
    if (data.containsKey('usageLimit')) {
      final l$usageLimit = data['usageLimit'];
      result$data['usageLimit'] = (l$usageLimit as int?);
    }
    return Input$VoucherInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$VoucherTypeEnum? get type => (_$data['type'] as Enum$VoucherTypeEnum?);

  String? get name => (_$data['name'] as String?);

  String? get code => (_$data['code'] as String?);

  List<String>? get addCodes => (_$data['addCodes'] as List<String>?);

  String? get startDate => (_$data['startDate'] as String?);

  String? get endDate => (_$data['endDate'] as String?);

  Enum$DiscountValueTypeEnum? get discountValueType =>
      (_$data['discountValueType'] as Enum$DiscountValueTypeEnum?);

  List<String>? get products => (_$data['products'] as List<String>?);

  List<String>? get variants => (_$data['variants'] as List<String>?);

  List<String>? get collections => (_$data['collections'] as List<String>?);

  List<String>? get categories => (_$data['categories'] as List<String>?);

  int? get minCheckoutItemsQuantity =>
      (_$data['minCheckoutItemsQuantity'] as int?);

  List<String>? get countries => (_$data['countries'] as List<String>?);

  bool? get applyOncePerOrder => (_$data['applyOncePerOrder'] as bool?);

  bool? get applyOncePerCustomer => (_$data['applyOncePerCustomer'] as bool?);

  bool? get onlyForStaff => (_$data['onlyForStaff'] as bool?);

  bool? get singleUse => (_$data['singleUse'] as bool?);

  int? get usageLimit => (_$data['usageLimit'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] =
          l$type == null ? null : toJson$Enum$VoucherTypeEnum(l$type);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('code')) {
      final l$code = code;
      result$data['code'] = l$code;
    }
    if (_$data.containsKey('addCodes')) {
      final l$addCodes = addCodes;
      result$data['addCodes'] = l$addCodes?.map((e) => e).toList();
    }
    if (_$data.containsKey('startDate')) {
      final l$startDate = startDate;
      result$data['startDate'] = l$startDate;
    }
    if (_$data.containsKey('endDate')) {
      final l$endDate = endDate;
      result$data['endDate'] = l$endDate;
    }
    if (_$data.containsKey('discountValueType')) {
      final l$discountValueType = discountValueType;
      result$data['discountValueType'] = l$discountValueType == null
          ? null
          : toJson$Enum$DiscountValueTypeEnum(l$discountValueType);
    }
    if (_$data.containsKey('products')) {
      final l$products = products;
      result$data['products'] = l$products?.map((e) => e).toList();
    }
    if (_$data.containsKey('variants')) {
      final l$variants = variants;
      result$data['variants'] = l$variants?.map((e) => e).toList();
    }
    if (_$data.containsKey('collections')) {
      final l$collections = collections;
      result$data['collections'] = l$collections?.map((e) => e).toList();
    }
    if (_$data.containsKey('categories')) {
      final l$categories = categories;
      result$data['categories'] = l$categories?.map((e) => e).toList();
    }
    if (_$data.containsKey('minCheckoutItemsQuantity')) {
      final l$minCheckoutItemsQuantity = minCheckoutItemsQuantity;
      result$data['minCheckoutItemsQuantity'] = l$minCheckoutItemsQuantity;
    }
    if (_$data.containsKey('countries')) {
      final l$countries = countries;
      result$data['countries'] = l$countries?.map((e) => e).toList();
    }
    if (_$data.containsKey('applyOncePerOrder')) {
      final l$applyOncePerOrder = applyOncePerOrder;
      result$data['applyOncePerOrder'] = l$applyOncePerOrder;
    }
    if (_$data.containsKey('applyOncePerCustomer')) {
      final l$applyOncePerCustomer = applyOncePerCustomer;
      result$data['applyOncePerCustomer'] = l$applyOncePerCustomer;
    }
    if (_$data.containsKey('onlyForStaff')) {
      final l$onlyForStaff = onlyForStaff;
      result$data['onlyForStaff'] = l$onlyForStaff;
    }
    if (_$data.containsKey('singleUse')) {
      final l$singleUse = singleUse;
      result$data['singleUse'] = l$singleUse;
    }
    if (_$data.containsKey('usageLimit')) {
      final l$usageLimit = usageLimit;
      result$data['usageLimit'] = l$usageLimit;
    }
    return result$data;
  }

  CopyWith$Input$VoucherInput<Input$VoucherInput> get copyWith =>
      CopyWith$Input$VoucherInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$VoucherInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$code = code;
    final lOther$code = other.code;
    if (_$data.containsKey('code') != other._$data.containsKey('code')) {
      return false;
    }
    if (l$code != lOther$code) {
      return false;
    }
    final l$addCodes = addCodes;
    final lOther$addCodes = other.addCodes;
    if (_$data.containsKey('addCodes') !=
        other._$data.containsKey('addCodes')) {
      return false;
    }
    if (l$addCodes != null && lOther$addCodes != null) {
      if (l$addCodes.length != lOther$addCodes.length) {
        return false;
      }
      for (int i = 0; i < l$addCodes.length; i++) {
        final l$addCodes$entry = l$addCodes[i];
        final lOther$addCodes$entry = lOther$addCodes[i];
        if (l$addCodes$entry != lOther$addCodes$entry) {
          return false;
        }
      }
    } else if (l$addCodes != lOther$addCodes) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (_$data.containsKey('startDate') !=
        other._$data.containsKey('startDate')) {
      return false;
    }
    if (l$startDate != lOther$startDate) {
      return false;
    }
    final l$endDate = endDate;
    final lOther$endDate = other.endDate;
    if (_$data.containsKey('endDate') != other._$data.containsKey('endDate')) {
      return false;
    }
    if (l$endDate != lOther$endDate) {
      return false;
    }
    final l$discountValueType = discountValueType;
    final lOther$discountValueType = other.discountValueType;
    if (_$data.containsKey('discountValueType') !=
        other._$data.containsKey('discountValueType')) {
      return false;
    }
    if (l$discountValueType != lOther$discountValueType) {
      return false;
    }
    final l$products = products;
    final lOther$products = other.products;
    if (_$data.containsKey('products') !=
        other._$data.containsKey('products')) {
      return false;
    }
    if (l$products != null && lOther$products != null) {
      if (l$products.length != lOther$products.length) {
        return false;
      }
      for (int i = 0; i < l$products.length; i++) {
        final l$products$entry = l$products[i];
        final lOther$products$entry = lOther$products[i];
        if (l$products$entry != lOther$products$entry) {
          return false;
        }
      }
    } else if (l$products != lOther$products) {
      return false;
    }
    final l$variants = variants;
    final lOther$variants = other.variants;
    if (_$data.containsKey('variants') !=
        other._$data.containsKey('variants')) {
      return false;
    }
    if (l$variants != null && lOther$variants != null) {
      if (l$variants.length != lOther$variants.length) {
        return false;
      }
      for (int i = 0; i < l$variants.length; i++) {
        final l$variants$entry = l$variants[i];
        final lOther$variants$entry = lOther$variants[i];
        if (l$variants$entry != lOther$variants$entry) {
          return false;
        }
      }
    } else if (l$variants != lOther$variants) {
      return false;
    }
    final l$collections = collections;
    final lOther$collections = other.collections;
    if (_$data.containsKey('collections') !=
        other._$data.containsKey('collections')) {
      return false;
    }
    if (l$collections != null && lOther$collections != null) {
      if (l$collections.length != lOther$collections.length) {
        return false;
      }
      for (int i = 0; i < l$collections.length; i++) {
        final l$collections$entry = l$collections[i];
        final lOther$collections$entry = lOther$collections[i];
        if (l$collections$entry != lOther$collections$entry) {
          return false;
        }
      }
    } else if (l$collections != lOther$collections) {
      return false;
    }
    final l$categories = categories;
    final lOther$categories = other.categories;
    if (_$data.containsKey('categories') !=
        other._$data.containsKey('categories')) {
      return false;
    }
    if (l$categories != null && lOther$categories != null) {
      if (l$categories.length != lOther$categories.length) {
        return false;
      }
      for (int i = 0; i < l$categories.length; i++) {
        final l$categories$entry = l$categories[i];
        final lOther$categories$entry = lOther$categories[i];
        if (l$categories$entry != lOther$categories$entry) {
          return false;
        }
      }
    } else if (l$categories != lOther$categories) {
      return false;
    }
    final l$minCheckoutItemsQuantity = minCheckoutItemsQuantity;
    final lOther$minCheckoutItemsQuantity = other.minCheckoutItemsQuantity;
    if (_$data.containsKey('minCheckoutItemsQuantity') !=
        other._$data.containsKey('minCheckoutItemsQuantity')) {
      return false;
    }
    if (l$minCheckoutItemsQuantity != lOther$minCheckoutItemsQuantity) {
      return false;
    }
    final l$countries = countries;
    final lOther$countries = other.countries;
    if (_$data.containsKey('countries') !=
        other._$data.containsKey('countries')) {
      return false;
    }
    if (l$countries != null && lOther$countries != null) {
      if (l$countries.length != lOther$countries.length) {
        return false;
      }
      for (int i = 0; i < l$countries.length; i++) {
        final l$countries$entry = l$countries[i];
        final lOther$countries$entry = lOther$countries[i];
        if (l$countries$entry != lOther$countries$entry) {
          return false;
        }
      }
    } else if (l$countries != lOther$countries) {
      return false;
    }
    final l$applyOncePerOrder = applyOncePerOrder;
    final lOther$applyOncePerOrder = other.applyOncePerOrder;
    if (_$data.containsKey('applyOncePerOrder') !=
        other._$data.containsKey('applyOncePerOrder')) {
      return false;
    }
    if (l$applyOncePerOrder != lOther$applyOncePerOrder) {
      return false;
    }
    final l$applyOncePerCustomer = applyOncePerCustomer;
    final lOther$applyOncePerCustomer = other.applyOncePerCustomer;
    if (_$data.containsKey('applyOncePerCustomer') !=
        other._$data.containsKey('applyOncePerCustomer')) {
      return false;
    }
    if (l$applyOncePerCustomer != lOther$applyOncePerCustomer) {
      return false;
    }
    final l$onlyForStaff = onlyForStaff;
    final lOther$onlyForStaff = other.onlyForStaff;
    if (_$data.containsKey('onlyForStaff') !=
        other._$data.containsKey('onlyForStaff')) {
      return false;
    }
    if (l$onlyForStaff != lOther$onlyForStaff) {
      return false;
    }
    final l$singleUse = singleUse;
    final lOther$singleUse = other.singleUse;
    if (_$data.containsKey('singleUse') !=
        other._$data.containsKey('singleUse')) {
      return false;
    }
    if (l$singleUse != lOther$singleUse) {
      return false;
    }
    final l$usageLimit = usageLimit;
    final lOther$usageLimit = other.usageLimit;
    if (_$data.containsKey('usageLimit') !=
        other._$data.containsKey('usageLimit')) {
      return false;
    }
    if (l$usageLimit != lOther$usageLimit) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$type = type;
    final l$name = name;
    final l$code = code;
    final l$addCodes = addCodes;
    final l$startDate = startDate;
    final l$endDate = endDate;
    final l$discountValueType = discountValueType;
    final l$products = products;
    final l$variants = variants;
    final l$collections = collections;
    final l$categories = categories;
    final l$minCheckoutItemsQuantity = minCheckoutItemsQuantity;
    final l$countries = countries;
    final l$applyOncePerOrder = applyOncePerOrder;
    final l$applyOncePerCustomer = applyOncePerCustomer;
    final l$onlyForStaff = onlyForStaff;
    final l$singleUse = singleUse;
    final l$usageLimit = usageLimit;
    return Object.hashAll([
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('code') ? l$code : const {},
      _$data.containsKey('addCodes')
          ? l$addCodes == null
              ? null
              : Object.hashAll(l$addCodes.map((v) => v))
          : const {},
      _$data.containsKey('startDate') ? l$startDate : const {},
      _$data.containsKey('endDate') ? l$endDate : const {},
      _$data.containsKey('discountValueType') ? l$discountValueType : const {},
      _$data.containsKey('products')
          ? l$products == null
              ? null
              : Object.hashAll(l$products.map((v) => v))
          : const {},
      _$data.containsKey('variants')
          ? l$variants == null
              ? null
              : Object.hashAll(l$variants.map((v) => v))
          : const {},
      _$data.containsKey('collections')
          ? l$collections == null
              ? null
              : Object.hashAll(l$collections.map((v) => v))
          : const {},
      _$data.containsKey('categories')
          ? l$categories == null
              ? null
              : Object.hashAll(l$categories.map((v) => v))
          : const {},
      _$data.containsKey('minCheckoutItemsQuantity')
          ? l$minCheckoutItemsQuantity
          : const {},
      _$data.containsKey('countries')
          ? l$countries == null
              ? null
              : Object.hashAll(l$countries.map((v) => v))
          : const {},
      _$data.containsKey('applyOncePerOrder') ? l$applyOncePerOrder : const {},
      _$data.containsKey('applyOncePerCustomer')
          ? l$applyOncePerCustomer
          : const {},
      _$data.containsKey('onlyForStaff') ? l$onlyForStaff : const {},
      _$data.containsKey('singleUse') ? l$singleUse : const {},
      _$data.containsKey('usageLimit') ? l$usageLimit : const {},
    ]);
  }
}

abstract class CopyWith$Input$VoucherInput<TRes> {
  factory CopyWith$Input$VoucherInput(
    Input$VoucherInput instance,
    TRes Function(Input$VoucherInput) then,
  ) = _CopyWithImpl$Input$VoucherInput;

  factory CopyWith$Input$VoucherInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VoucherInput;

  TRes call({
    Enum$VoucherTypeEnum? type,
    String? name,
    String? code,
    List<String>? addCodes,
    String? startDate,
    String? endDate,
    Enum$DiscountValueTypeEnum? discountValueType,
    List<String>? products,
    List<String>? variants,
    List<String>? collections,
    List<String>? categories,
    int? minCheckoutItemsQuantity,
    List<String>? countries,
    bool? applyOncePerOrder,
    bool? applyOncePerCustomer,
    bool? onlyForStaff,
    bool? singleUse,
    int? usageLimit,
  });
}

class _CopyWithImpl$Input$VoucherInput<TRes>
    implements CopyWith$Input$VoucherInput<TRes> {
  _CopyWithImpl$Input$VoucherInput(
    this._instance,
    this._then,
  );

  final Input$VoucherInput _instance;

  final TRes Function(Input$VoucherInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? type = _undefined,
    Object? name = _undefined,
    Object? code = _undefined,
    Object? addCodes = _undefined,
    Object? startDate = _undefined,
    Object? endDate = _undefined,
    Object? discountValueType = _undefined,
    Object? products = _undefined,
    Object? variants = _undefined,
    Object? collections = _undefined,
    Object? categories = _undefined,
    Object? minCheckoutItemsQuantity = _undefined,
    Object? countries = _undefined,
    Object? applyOncePerOrder = _undefined,
    Object? applyOncePerCustomer = _undefined,
    Object? onlyForStaff = _undefined,
    Object? singleUse = _undefined,
    Object? usageLimit = _undefined,
  }) =>
      _then(Input$VoucherInput._({
        ..._instance._$data,
        if (type != _undefined) 'type': (type as Enum$VoucherTypeEnum?),
        if (name != _undefined) 'name': (name as String?),
        if (code != _undefined) 'code': (code as String?),
        if (addCodes != _undefined) 'addCodes': (addCodes as List<String>?),
        if (startDate != _undefined) 'startDate': (startDate as String?),
        if (endDate != _undefined) 'endDate': (endDate as String?),
        if (discountValueType != _undefined)
          'discountValueType':
              (discountValueType as Enum$DiscountValueTypeEnum?),
        if (products != _undefined) 'products': (products as List<String>?),
        if (variants != _undefined) 'variants': (variants as List<String>?),
        if (collections != _undefined)
          'collections': (collections as List<String>?),
        if (categories != _undefined)
          'categories': (categories as List<String>?),
        if (minCheckoutItemsQuantity != _undefined)
          'minCheckoutItemsQuantity': (minCheckoutItemsQuantity as int?),
        if (countries != _undefined) 'countries': (countries as List<String>?),
        if (applyOncePerOrder != _undefined)
          'applyOncePerOrder': (applyOncePerOrder as bool?),
        if (applyOncePerCustomer != _undefined)
          'applyOncePerCustomer': (applyOncePerCustomer as bool?),
        if (onlyForStaff != _undefined) 'onlyForStaff': (onlyForStaff as bool?),
        if (singleUse != _undefined) 'singleUse': (singleUse as bool?),
        if (usageLimit != _undefined) 'usageLimit': (usageLimit as int?),
      }));
}

class _CopyWithStubImpl$Input$VoucherInput<TRes>
    implements CopyWith$Input$VoucherInput<TRes> {
  _CopyWithStubImpl$Input$VoucherInput(this._res);

  TRes _res;

  call({
    Enum$VoucherTypeEnum? type,
    String? name,
    String? code,
    List<String>? addCodes,
    String? startDate,
    String? endDate,
    Enum$DiscountValueTypeEnum? discountValueType,
    List<String>? products,
    List<String>? variants,
    List<String>? collections,
    List<String>? categories,
    int? minCheckoutItemsQuantity,
    List<String>? countries,
    bool? applyOncePerOrder,
    bool? applyOncePerCustomer,
    bool? onlyForStaff,
    bool? singleUse,
    int? usageLimit,
  }) =>
      _res;
}

class Input$VoucherSortingInput {
  factory Input$VoucherSortingInput({
    required Enum$OrderDirection direction,
    String? channel,
    required Enum$VoucherSortField field,
  }) =>
      Input$VoucherSortingInput._({
        r'direction': direction,
        if (channel != null) r'channel': channel,
        r'field': field,
      });

  Input$VoucherSortingInput._(this._$data);

  factory Input$VoucherSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    if (data.containsKey('channel')) {
      final l$channel = data['channel'];
      result$data['channel'] = (l$channel as String?);
    }
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$VoucherSortField((l$field as String));
    return Input$VoucherSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  String? get channel => (_$data['channel'] as String?);

  Enum$VoucherSortField get field => (_$data['field'] as Enum$VoucherSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    if (_$data.containsKey('channel')) {
      final l$channel = channel;
      result$data['channel'] = l$channel;
    }
    final l$field = field;
    result$data['field'] = toJson$Enum$VoucherSortField(l$field);
    return result$data;
  }

  CopyWith$Input$VoucherSortingInput<Input$VoucherSortingInput> get copyWith =>
      CopyWith$Input$VoucherSortingInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$VoucherSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$channel = channel;
    final lOther$channel = other.channel;
    if (_$data.containsKey('channel') != other._$data.containsKey('channel')) {
      return false;
    }
    if (l$channel != lOther$channel) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$channel = channel;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      _$data.containsKey('channel') ? l$channel : const {},
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$VoucherSortingInput<TRes> {
  factory CopyWith$Input$VoucherSortingInput(
    Input$VoucherSortingInput instance,
    TRes Function(Input$VoucherSortingInput) then,
  ) = _CopyWithImpl$Input$VoucherSortingInput;

  factory CopyWith$Input$VoucherSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VoucherSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    String? channel,
    Enum$VoucherSortField? field,
  });
}

class _CopyWithImpl$Input$VoucherSortingInput<TRes>
    implements CopyWith$Input$VoucherSortingInput<TRes> {
  _CopyWithImpl$Input$VoucherSortingInput(
    this._instance,
    this._then,
  );

  final Input$VoucherSortingInput _instance;

  final TRes Function(Input$VoucherSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? channel = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$VoucherSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (channel != _undefined) 'channel': (channel as String?),
        if (field != _undefined && field != null)
          'field': (field as Enum$VoucherSortField),
      }));
}

class _CopyWithStubImpl$Input$VoucherSortingInput<TRes>
    implements CopyWith$Input$VoucherSortingInput<TRes> {
  _CopyWithStubImpl$Input$VoucherSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    String? channel,
    Enum$VoucherSortField? field,
  }) =>
      _res;
}

class Input$WarehouseCreateInput {
  factory Input$WarehouseCreateInput({
    String? slug,
    String? email,
    String? externalReference,
    required String name,
    required Input$AddressInput address,
    List<String>? shippingZones,
  }) =>
      Input$WarehouseCreateInput._({
        if (slug != null) r'slug': slug,
        if (email != null) r'email': email,
        if (externalReference != null) r'externalReference': externalReference,
        r'name': name,
        r'address': address,
        if (shippingZones != null) r'shippingZones': shippingZones,
      });

  Input$WarehouseCreateInput._(this._$data);

  factory Input$WarehouseCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$address = data['address'];
    result$data['address'] =
        Input$AddressInput.fromJson((l$address as Map<String, dynamic>));
    if (data.containsKey('shippingZones')) {
      final l$shippingZones = data['shippingZones'];
      result$data['shippingZones'] = (l$shippingZones as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$WarehouseCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get slug => (_$data['slug'] as String?);

  String? get email => (_$data['email'] as String?);

  String? get externalReference => (_$data['externalReference'] as String?);

  String get name => (_$data['name'] as String);

  Input$AddressInput get address => (_$data['address'] as Input$AddressInput);

  List<String>? get shippingZones => (_$data['shippingZones'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    final l$name = name;
    result$data['name'] = l$name;
    final l$address = address;
    result$data['address'] = l$address.toJson();
    if (_$data.containsKey('shippingZones')) {
      final l$shippingZones = shippingZones;
      result$data['shippingZones'] = l$shippingZones?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$WarehouseCreateInput<Input$WarehouseCreateInput>
      get copyWith => CopyWith$Input$WarehouseCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$WarehouseCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) {
      return false;
    }
    final l$shippingZones = shippingZones;
    final lOther$shippingZones = other.shippingZones;
    if (_$data.containsKey('shippingZones') !=
        other._$data.containsKey('shippingZones')) {
      return false;
    }
    if (l$shippingZones != null && lOther$shippingZones != null) {
      if (l$shippingZones.length != lOther$shippingZones.length) {
        return false;
      }
      for (int i = 0; i < l$shippingZones.length; i++) {
        final l$shippingZones$entry = l$shippingZones[i];
        final lOther$shippingZones$entry = lOther$shippingZones[i];
        if (l$shippingZones$entry != lOther$shippingZones$entry) {
          return false;
        }
      }
    } else if (l$shippingZones != lOther$shippingZones) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$slug = slug;
    final l$email = email;
    final l$externalReference = externalReference;
    final l$name = name;
    final l$address = address;
    final l$shippingZones = shippingZones;
    return Object.hashAll([
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      l$name,
      l$address,
      _$data.containsKey('shippingZones')
          ? l$shippingZones == null
              ? null
              : Object.hashAll(l$shippingZones.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$WarehouseCreateInput<TRes> {
  factory CopyWith$Input$WarehouseCreateInput(
    Input$WarehouseCreateInput instance,
    TRes Function(Input$WarehouseCreateInput) then,
  ) = _CopyWithImpl$Input$WarehouseCreateInput;

  factory CopyWith$Input$WarehouseCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WarehouseCreateInput;

  TRes call({
    String? slug,
    String? email,
    String? externalReference,
    String? name,
    Input$AddressInput? address,
    List<String>? shippingZones,
  });
  CopyWith$Input$AddressInput<TRes> get address;
}

class _CopyWithImpl$Input$WarehouseCreateInput<TRes>
    implements CopyWith$Input$WarehouseCreateInput<TRes> {
  _CopyWithImpl$Input$WarehouseCreateInput(
    this._instance,
    this._then,
  );

  final Input$WarehouseCreateInput _instance;

  final TRes Function(Input$WarehouseCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? slug = _undefined,
    Object? email = _undefined,
    Object? externalReference = _undefined,
    Object? name = _undefined,
    Object? address = _undefined,
    Object? shippingZones = _undefined,
  }) =>
      _then(Input$WarehouseCreateInput._({
        ..._instance._$data,
        if (slug != _undefined) 'slug': (slug as String?),
        if (email != _undefined) 'email': (email as String?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (address != _undefined && address != null)
          'address': (address as Input$AddressInput),
        if (shippingZones != _undefined)
          'shippingZones': (shippingZones as List<String>?),
      }));

  CopyWith$Input$AddressInput<TRes> get address {
    final local$address = _instance.address;
    return CopyWith$Input$AddressInput(local$address, (e) => call(address: e));
  }
}

class _CopyWithStubImpl$Input$WarehouseCreateInput<TRes>
    implements CopyWith$Input$WarehouseCreateInput<TRes> {
  _CopyWithStubImpl$Input$WarehouseCreateInput(this._res);

  TRes _res;

  call({
    String? slug,
    String? email,
    String? externalReference,
    String? name,
    Input$AddressInput? address,
    List<String>? shippingZones,
  }) =>
      _res;

  CopyWith$Input$AddressInput<TRes> get address =>
      CopyWith$Input$AddressInput.stub(_res);
}

class Input$WarehouseFilterInput {
  factory Input$WarehouseFilterInput({
    Enum$WarehouseClickAndCollectOptionEnum? clickAndCollectOption,
    List<Input$MetadataFilter>? metadata,
    String? search,
    List<String>? ids,
    bool? isPrivate,
    List<String>? channels,
    List<String>? slugs,
  }) =>
      Input$WarehouseFilterInput._({
        if (clickAndCollectOption != null)
          r'clickAndCollectOption': clickAndCollectOption,
        if (metadata != null) r'metadata': metadata,
        if (search != null) r'search': search,
        if (ids != null) r'ids': ids,
        if (isPrivate != null) r'isPrivate': isPrivate,
        if (channels != null) r'channels': channels,
        if (slugs != null) r'slugs': slugs,
      });

  Input$WarehouseFilterInput._(this._$data);

  factory Input$WarehouseFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clickAndCollectOption')) {
      final l$clickAndCollectOption = data['clickAndCollectOption'];
      result$data['clickAndCollectOption'] = l$clickAndCollectOption == null
          ? null
          : fromJson$Enum$WarehouseClickAndCollectOptionEnum(
              (l$clickAndCollectOption as String));
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
              (e) => Input$MetadataFilter.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('search')) {
      final l$search = data['search'];
      result$data['search'] = (l$search as String?);
    }
    if (data.containsKey('ids')) {
      final l$ids = data['ids'];
      result$data['ids'] =
          (l$ids as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('isPrivate')) {
      final l$isPrivate = data['isPrivate'];
      result$data['isPrivate'] = (l$isPrivate as bool?);
    }
    if (data.containsKey('channels')) {
      final l$channels = data['channels'];
      result$data['channels'] =
          (l$channels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('slugs')) {
      final l$slugs = data['slugs'];
      result$data['slugs'] =
          (l$slugs as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$WarehouseFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$WarehouseClickAndCollectOptionEnum? get clickAndCollectOption =>
      (_$data['clickAndCollectOption']
          as Enum$WarehouseClickAndCollectOptionEnum?);

  List<Input$MetadataFilter>? get metadata =>
      (_$data['metadata'] as List<Input$MetadataFilter>?);

  String? get search => (_$data['search'] as String?);

  List<String>? get ids => (_$data['ids'] as List<String>?);

  bool? get isPrivate => (_$data['isPrivate'] as bool?);

  List<String>? get channels => (_$data['channels'] as List<String>?);

  List<String>? get slugs => (_$data['slugs'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clickAndCollectOption')) {
      final l$clickAndCollectOption = clickAndCollectOption;
      result$data['clickAndCollectOption'] = l$clickAndCollectOption == null
          ? null
          : toJson$Enum$WarehouseClickAndCollectOptionEnum(
              l$clickAndCollectOption);
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('search')) {
      final l$search = search;
      result$data['search'] = l$search;
    }
    if (_$data.containsKey('ids')) {
      final l$ids = ids;
      result$data['ids'] = l$ids?.map((e) => e).toList();
    }
    if (_$data.containsKey('isPrivate')) {
      final l$isPrivate = isPrivate;
      result$data['isPrivate'] = l$isPrivate;
    }
    if (_$data.containsKey('channels')) {
      final l$channels = channels;
      result$data['channels'] = l$channels?.map((e) => e).toList();
    }
    if (_$data.containsKey('slugs')) {
      final l$slugs = slugs;
      result$data['slugs'] = l$slugs?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$WarehouseFilterInput<Input$WarehouseFilterInput>
      get copyWith => CopyWith$Input$WarehouseFilterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$WarehouseFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clickAndCollectOption = clickAndCollectOption;
    final lOther$clickAndCollectOption = other.clickAndCollectOption;
    if (_$data.containsKey('clickAndCollectOption') !=
        other._$data.containsKey('clickAndCollectOption')) {
      return false;
    }
    if (l$clickAndCollectOption != lOther$clickAndCollectOption) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$search = search;
    final lOther$search = other.search;
    if (_$data.containsKey('search') != other._$data.containsKey('search')) {
      return false;
    }
    if (l$search != lOther$search) {
      return false;
    }
    final l$ids = ids;
    final lOther$ids = other.ids;
    if (_$data.containsKey('ids') != other._$data.containsKey('ids')) {
      return false;
    }
    if (l$ids != null && lOther$ids != null) {
      if (l$ids.length != lOther$ids.length) {
        return false;
      }
      for (int i = 0; i < l$ids.length; i++) {
        final l$ids$entry = l$ids[i];
        final lOther$ids$entry = lOther$ids[i];
        if (l$ids$entry != lOther$ids$entry) {
          return false;
        }
      }
    } else if (l$ids != lOther$ids) {
      return false;
    }
    final l$isPrivate = isPrivate;
    final lOther$isPrivate = other.isPrivate;
    if (_$data.containsKey('isPrivate') !=
        other._$data.containsKey('isPrivate')) {
      return false;
    }
    if (l$isPrivate != lOther$isPrivate) {
      return false;
    }
    final l$channels = channels;
    final lOther$channels = other.channels;
    if (_$data.containsKey('channels') !=
        other._$data.containsKey('channels')) {
      return false;
    }
    if (l$channels != null && lOther$channels != null) {
      if (l$channels.length != lOther$channels.length) {
        return false;
      }
      for (int i = 0; i < l$channels.length; i++) {
        final l$channels$entry = l$channels[i];
        final lOther$channels$entry = lOther$channels[i];
        if (l$channels$entry != lOther$channels$entry) {
          return false;
        }
      }
    } else if (l$channels != lOther$channels) {
      return false;
    }
    final l$slugs = slugs;
    final lOther$slugs = other.slugs;
    if (_$data.containsKey('slugs') != other._$data.containsKey('slugs')) {
      return false;
    }
    if (l$slugs != null && lOther$slugs != null) {
      if (l$slugs.length != lOther$slugs.length) {
        return false;
      }
      for (int i = 0; i < l$slugs.length; i++) {
        final l$slugs$entry = l$slugs[i];
        final lOther$slugs$entry = lOther$slugs[i];
        if (l$slugs$entry != lOther$slugs$entry) {
          return false;
        }
      }
    } else if (l$slugs != lOther$slugs) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clickAndCollectOption = clickAndCollectOption;
    final l$metadata = metadata;
    final l$search = search;
    final l$ids = ids;
    final l$isPrivate = isPrivate;
    final l$channels = channels;
    final l$slugs = slugs;
    return Object.hashAll([
      _$data.containsKey('clickAndCollectOption')
          ? l$clickAndCollectOption
          : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('search') ? l$search : const {},
      _$data.containsKey('ids')
          ? l$ids == null
              ? null
              : Object.hashAll(l$ids.map((v) => v))
          : const {},
      _$data.containsKey('isPrivate') ? l$isPrivate : const {},
      _$data.containsKey('channels')
          ? l$channels == null
              ? null
              : Object.hashAll(l$channels.map((v) => v))
          : const {},
      _$data.containsKey('slugs')
          ? l$slugs == null
              ? null
              : Object.hashAll(l$slugs.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$WarehouseFilterInput<TRes> {
  factory CopyWith$Input$WarehouseFilterInput(
    Input$WarehouseFilterInput instance,
    TRes Function(Input$WarehouseFilterInput) then,
  ) = _CopyWithImpl$Input$WarehouseFilterInput;

  factory CopyWith$Input$WarehouseFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WarehouseFilterInput;

  TRes call({
    Enum$WarehouseClickAndCollectOptionEnum? clickAndCollectOption,
    List<Input$MetadataFilter>? metadata,
    String? search,
    List<String>? ids,
    bool? isPrivate,
    List<String>? channels,
    List<String>? slugs,
  });
  TRes metadata(
      Iterable<Input$MetadataFilter>? Function(
              Iterable<CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
          _fn);
}

class _CopyWithImpl$Input$WarehouseFilterInput<TRes>
    implements CopyWith$Input$WarehouseFilterInput<TRes> {
  _CopyWithImpl$Input$WarehouseFilterInput(
    this._instance,
    this._then,
  );

  final Input$WarehouseFilterInput _instance;

  final TRes Function(Input$WarehouseFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clickAndCollectOption = _undefined,
    Object? metadata = _undefined,
    Object? search = _undefined,
    Object? ids = _undefined,
    Object? isPrivate = _undefined,
    Object? channels = _undefined,
    Object? slugs = _undefined,
  }) =>
      _then(Input$WarehouseFilterInput._({
        ..._instance._$data,
        if (clickAndCollectOption != _undefined)
          'clickAndCollectOption': (clickAndCollectOption
              as Enum$WarehouseClickAndCollectOptionEnum?),
        if (metadata != _undefined)
          'metadata': (metadata as List<Input$MetadataFilter>?),
        if (search != _undefined) 'search': (search as String?),
        if (ids != _undefined) 'ids': (ids as List<String>?),
        if (isPrivate != _undefined) 'isPrivate': (isPrivate as bool?),
        if (channels != _undefined) 'channels': (channels as List<String>?),
        if (slugs != _undefined) 'slugs': (slugs as List<String>?),
      }));

  TRes metadata(
          Iterable<Input$MetadataFilter>? Function(
                  Iterable<
                      CopyWith$Input$MetadataFilter<Input$MetadataFilter>>?)
              _fn) =>
      call(
          metadata:
              _fn(_instance.metadata?.map((e) => CopyWith$Input$MetadataFilter(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$WarehouseFilterInput<TRes>
    implements CopyWith$Input$WarehouseFilterInput<TRes> {
  _CopyWithStubImpl$Input$WarehouseFilterInput(this._res);

  TRes _res;

  call({
    Enum$WarehouseClickAndCollectOptionEnum? clickAndCollectOption,
    List<Input$MetadataFilter>? metadata,
    String? search,
    List<String>? ids,
    bool? isPrivate,
    List<String>? channels,
    List<String>? slugs,
  }) =>
      _res;

  metadata(_fn) => _res;
}

class Input$WarehouseSortingInput {
  factory Input$WarehouseSortingInput({
    required Enum$OrderDirection direction,
    required Enum$WarehouseSortField field,
  }) =>
      Input$WarehouseSortingInput._({
        r'direction': direction,
        r'field': field,
      });

  Input$WarehouseSortingInput._(this._$data);

  factory Input$WarehouseSortingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$WarehouseSortField((l$field as String));
    return Input$WarehouseSortingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Enum$WarehouseSortField get field =>
      (_$data['field'] as Enum$WarehouseSortField);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$WarehouseSortField(l$field);
    return result$data;
  }

  CopyWith$Input$WarehouseSortingInput<Input$WarehouseSortingInput>
      get copyWith => CopyWith$Input$WarehouseSortingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$WarehouseSortingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$WarehouseSortingInput<TRes> {
  factory CopyWith$Input$WarehouseSortingInput(
    Input$WarehouseSortingInput instance,
    TRes Function(Input$WarehouseSortingInput) then,
  ) = _CopyWithImpl$Input$WarehouseSortingInput;

  factory CopyWith$Input$WarehouseSortingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WarehouseSortingInput;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$WarehouseSortField? field,
  });
}

class _CopyWithImpl$Input$WarehouseSortingInput<TRes>
    implements CopyWith$Input$WarehouseSortingInput<TRes> {
  _CopyWithImpl$Input$WarehouseSortingInput(
    this._instance,
    this._then,
  );

  final Input$WarehouseSortingInput _instance;

  final TRes Function(Input$WarehouseSortingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$WarehouseSortingInput._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$WarehouseSortField),
      }));
}

class _CopyWithStubImpl$Input$WarehouseSortingInput<TRes>
    implements CopyWith$Input$WarehouseSortingInput<TRes> {
  _CopyWithStubImpl$Input$WarehouseSortingInput(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$WarehouseSortField? field,
  }) =>
      _res;
}

class Input$WarehouseUpdateInput {
  factory Input$WarehouseUpdateInput({
    String? slug,
    String? email,
    String? externalReference,
    String? name,
    Input$AddressInput? address,
    Enum$WarehouseClickAndCollectOptionEnum? clickAndCollectOption,
    bool? isPrivate,
  }) =>
      Input$WarehouseUpdateInput._({
        if (slug != null) r'slug': slug,
        if (email != null) r'email': email,
        if (externalReference != null) r'externalReference': externalReference,
        if (name != null) r'name': name,
        if (address != null) r'address': address,
        if (clickAndCollectOption != null)
          r'clickAndCollectOption': clickAndCollectOption,
        if (isPrivate != null) r'isPrivate': isPrivate,
      });

  Input$WarehouseUpdateInput._(this._$data);

  factory Input$WarehouseUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('externalReference')) {
      final l$externalReference = data['externalReference'];
      result$data['externalReference'] = (l$externalReference as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : Input$AddressInput.fromJson((l$address as Map<String, dynamic>));
    }
    if (data.containsKey('clickAndCollectOption')) {
      final l$clickAndCollectOption = data['clickAndCollectOption'];
      result$data['clickAndCollectOption'] = l$clickAndCollectOption == null
          ? null
          : fromJson$Enum$WarehouseClickAndCollectOptionEnum(
              (l$clickAndCollectOption as String));
    }
    if (data.containsKey('isPrivate')) {
      final l$isPrivate = data['isPrivate'];
      result$data['isPrivate'] = (l$isPrivate as bool?);
    }
    return Input$WarehouseUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get slug => (_$data['slug'] as String?);

  String? get email => (_$data['email'] as String?);

  String? get externalReference => (_$data['externalReference'] as String?);

  String? get name => (_$data['name'] as String?);

  Input$AddressInput? get address => (_$data['address'] as Input$AddressInput?);

  Enum$WarehouseClickAndCollectOptionEnum? get clickAndCollectOption =>
      (_$data['clickAndCollectOption']
          as Enum$WarehouseClickAndCollectOptionEnum?);

  bool? get isPrivate => (_$data['isPrivate'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('externalReference')) {
      final l$externalReference = externalReference;
      result$data['externalReference'] = l$externalReference;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address?.toJson();
    }
    if (_$data.containsKey('clickAndCollectOption')) {
      final l$clickAndCollectOption = clickAndCollectOption;
      result$data['clickAndCollectOption'] = l$clickAndCollectOption == null
          ? null
          : toJson$Enum$WarehouseClickAndCollectOptionEnum(
              l$clickAndCollectOption);
    }
    if (_$data.containsKey('isPrivate')) {
      final l$isPrivate = isPrivate;
      result$data['isPrivate'] = l$isPrivate;
    }
    return result$data;
  }

  CopyWith$Input$WarehouseUpdateInput<Input$WarehouseUpdateInput>
      get copyWith => CopyWith$Input$WarehouseUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$WarehouseUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$externalReference = externalReference;
    final lOther$externalReference = other.externalReference;
    if (_$data.containsKey('externalReference') !=
        other._$data.containsKey('externalReference')) {
      return false;
    }
    if (l$externalReference != lOther$externalReference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$clickAndCollectOption = clickAndCollectOption;
    final lOther$clickAndCollectOption = other.clickAndCollectOption;
    if (_$data.containsKey('clickAndCollectOption') !=
        other._$data.containsKey('clickAndCollectOption')) {
      return false;
    }
    if (l$clickAndCollectOption != lOther$clickAndCollectOption) {
      return false;
    }
    final l$isPrivate = isPrivate;
    final lOther$isPrivate = other.isPrivate;
    if (_$data.containsKey('isPrivate') !=
        other._$data.containsKey('isPrivate')) {
      return false;
    }
    if (l$isPrivate != lOther$isPrivate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$slug = slug;
    final l$email = email;
    final l$externalReference = externalReference;
    final l$name = name;
    final l$address = address;
    final l$clickAndCollectOption = clickAndCollectOption;
    final l$isPrivate = isPrivate;
    return Object.hashAll([
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('externalReference') ? l$externalReference : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('clickAndCollectOption')
          ? l$clickAndCollectOption
          : const {},
      _$data.containsKey('isPrivate') ? l$isPrivate : const {},
    ]);
  }
}

abstract class CopyWith$Input$WarehouseUpdateInput<TRes> {
  factory CopyWith$Input$WarehouseUpdateInput(
    Input$WarehouseUpdateInput instance,
    TRes Function(Input$WarehouseUpdateInput) then,
  ) = _CopyWithImpl$Input$WarehouseUpdateInput;

  factory CopyWith$Input$WarehouseUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WarehouseUpdateInput;

  TRes call({
    String? slug,
    String? email,
    String? externalReference,
    String? name,
    Input$AddressInput? address,
    Enum$WarehouseClickAndCollectOptionEnum? clickAndCollectOption,
    bool? isPrivate,
  });
  CopyWith$Input$AddressInput<TRes> get address;
}

class _CopyWithImpl$Input$WarehouseUpdateInput<TRes>
    implements CopyWith$Input$WarehouseUpdateInput<TRes> {
  _CopyWithImpl$Input$WarehouseUpdateInput(
    this._instance,
    this._then,
  );

  final Input$WarehouseUpdateInput _instance;

  final TRes Function(Input$WarehouseUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? slug = _undefined,
    Object? email = _undefined,
    Object? externalReference = _undefined,
    Object? name = _undefined,
    Object? address = _undefined,
    Object? clickAndCollectOption = _undefined,
    Object? isPrivate = _undefined,
  }) =>
      _then(Input$WarehouseUpdateInput._({
        ..._instance._$data,
        if (slug != _undefined) 'slug': (slug as String?),
        if (email != _undefined) 'email': (email as String?),
        if (externalReference != _undefined)
          'externalReference': (externalReference as String?),
        if (name != _undefined) 'name': (name as String?),
        if (address != _undefined) 'address': (address as Input$AddressInput?),
        if (clickAndCollectOption != _undefined)
          'clickAndCollectOption': (clickAndCollectOption
              as Enum$WarehouseClickAndCollectOptionEnum?),
        if (isPrivate != _undefined) 'isPrivate': (isPrivate as bool?),
      }));

  CopyWith$Input$AddressInput<TRes> get address {
    final local$address = _instance.address;
    return local$address == null
        ? CopyWith$Input$AddressInput.stub(_then(_instance))
        : CopyWith$Input$AddressInput(local$address, (e) => call(address: e));
  }
}

class _CopyWithStubImpl$Input$WarehouseUpdateInput<TRes>
    implements CopyWith$Input$WarehouseUpdateInput<TRes> {
  _CopyWithStubImpl$Input$WarehouseUpdateInput(this._res);

  TRes _res;

  call({
    String? slug,
    String? email,
    String? externalReference,
    String? name,
    Input$AddressInput? address,
    Enum$WarehouseClickAndCollectOptionEnum? clickAndCollectOption,
    bool? isPrivate,
  }) =>
      _res;

  CopyWith$Input$AddressInput<TRes> get address =>
      CopyWith$Input$AddressInput.stub(_res);
}

class Input$WebhookCreateInput {
  factory Input$WebhookCreateInput({
    String? name,
    String? targetUrl,
    List<Enum$WebhookEventTypeEnum>? events,
    List<Enum$WebhookEventTypeAsyncEnum>? asyncEvents,
    List<Enum$WebhookEventTypeSyncEnum>? syncEvents,
    String? app,
    bool? isActive,
    String? secretKey,
    String? query,
    String? customHeaders,
  }) =>
      Input$WebhookCreateInput._({
        if (name != null) r'name': name,
        if (targetUrl != null) r'targetUrl': targetUrl,
        if (events != null) r'events': events,
        if (asyncEvents != null) r'asyncEvents': asyncEvents,
        if (syncEvents != null) r'syncEvents': syncEvents,
        if (app != null) r'app': app,
        if (isActive != null) r'isActive': isActive,
        if (secretKey != null) r'secretKey': secretKey,
        if (query != null) r'query': query,
        if (customHeaders != null) r'customHeaders': customHeaders,
      });

  Input$WebhookCreateInput._(this._$data);

  factory Input$WebhookCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('targetUrl')) {
      final l$targetUrl = data['targetUrl'];
      result$data['targetUrl'] = (l$targetUrl as String?);
    }
    if (data.containsKey('events')) {
      final l$events = data['events'];
      result$data['events'] = (l$events as List<dynamic>?)
          ?.map((e) => fromJson$Enum$WebhookEventTypeEnum((e as String)))
          .toList();
    }
    if (data.containsKey('asyncEvents')) {
      final l$asyncEvents = data['asyncEvents'];
      result$data['asyncEvents'] = (l$asyncEvents as List<dynamic>?)
          ?.map((e) => fromJson$Enum$WebhookEventTypeAsyncEnum((e as String)))
          .toList();
    }
    if (data.containsKey('syncEvents')) {
      final l$syncEvents = data['syncEvents'];
      result$data['syncEvents'] = (l$syncEvents as List<dynamic>?)
          ?.map((e) => fromJson$Enum$WebhookEventTypeSyncEnum((e as String)))
          .toList();
    }
    if (data.containsKey('app')) {
      final l$app = data['app'];
      result$data['app'] = (l$app as String?);
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = (l$isActive as bool?);
    }
    if (data.containsKey('secretKey')) {
      final l$secretKey = data['secretKey'];
      result$data['secretKey'] = (l$secretKey as String?);
    }
    if (data.containsKey('query')) {
      final l$query = data['query'];
      result$data['query'] = (l$query as String?);
    }
    if (data.containsKey('customHeaders')) {
      final l$customHeaders = data['customHeaders'];
      result$data['customHeaders'] = (l$customHeaders as String?);
    }
    return Input$WebhookCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get targetUrl => (_$data['targetUrl'] as String?);

  List<Enum$WebhookEventTypeEnum>? get events =>
      (_$data['events'] as List<Enum$WebhookEventTypeEnum>?);

  List<Enum$WebhookEventTypeAsyncEnum>? get asyncEvents =>
      (_$data['asyncEvents'] as List<Enum$WebhookEventTypeAsyncEnum>?);

  List<Enum$WebhookEventTypeSyncEnum>? get syncEvents =>
      (_$data['syncEvents'] as List<Enum$WebhookEventTypeSyncEnum>?);

  String? get app => (_$data['app'] as String?);

  bool? get isActive => (_$data['isActive'] as bool?);

  String? get secretKey => (_$data['secretKey'] as String?);

  String? get query => (_$data['query'] as String?);

  String? get customHeaders => (_$data['customHeaders'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('targetUrl')) {
      final l$targetUrl = targetUrl;
      result$data['targetUrl'] = l$targetUrl;
    }
    if (_$data.containsKey('events')) {
      final l$events = events;
      result$data['events'] =
          l$events?.map((e) => toJson$Enum$WebhookEventTypeEnum(e)).toList();
    }
    if (_$data.containsKey('asyncEvents')) {
      final l$asyncEvents = asyncEvents;
      result$data['asyncEvents'] = l$asyncEvents
          ?.map((e) => toJson$Enum$WebhookEventTypeAsyncEnum(e))
          .toList();
    }
    if (_$data.containsKey('syncEvents')) {
      final l$syncEvents = syncEvents;
      result$data['syncEvents'] = l$syncEvents
          ?.map((e) => toJson$Enum$WebhookEventTypeSyncEnum(e))
          .toList();
    }
    if (_$data.containsKey('app')) {
      final l$app = app;
      result$data['app'] = l$app;
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive;
    }
    if (_$data.containsKey('secretKey')) {
      final l$secretKey = secretKey;
      result$data['secretKey'] = l$secretKey;
    }
    if (_$data.containsKey('query')) {
      final l$query = query;
      result$data['query'] = l$query;
    }
    if (_$data.containsKey('customHeaders')) {
      final l$customHeaders = customHeaders;
      result$data['customHeaders'] = l$customHeaders;
    }
    return result$data;
  }

  CopyWith$Input$WebhookCreateInput<Input$WebhookCreateInput> get copyWith =>
      CopyWith$Input$WebhookCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$WebhookCreateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$targetUrl = targetUrl;
    final lOther$targetUrl = other.targetUrl;
    if (_$data.containsKey('targetUrl') !=
        other._$data.containsKey('targetUrl')) {
      return false;
    }
    if (l$targetUrl != lOther$targetUrl) {
      return false;
    }
    final l$events = events;
    final lOther$events = other.events;
    if (_$data.containsKey('events') != other._$data.containsKey('events')) {
      return false;
    }
    if (l$events != null && lOther$events != null) {
      if (l$events.length != lOther$events.length) {
        return false;
      }
      for (int i = 0; i < l$events.length; i++) {
        final l$events$entry = l$events[i];
        final lOther$events$entry = lOther$events[i];
        if (l$events$entry != lOther$events$entry) {
          return false;
        }
      }
    } else if (l$events != lOther$events) {
      return false;
    }
    final l$asyncEvents = asyncEvents;
    final lOther$asyncEvents = other.asyncEvents;
    if (_$data.containsKey('asyncEvents') !=
        other._$data.containsKey('asyncEvents')) {
      return false;
    }
    if (l$asyncEvents != null && lOther$asyncEvents != null) {
      if (l$asyncEvents.length != lOther$asyncEvents.length) {
        return false;
      }
      for (int i = 0; i < l$asyncEvents.length; i++) {
        final l$asyncEvents$entry = l$asyncEvents[i];
        final lOther$asyncEvents$entry = lOther$asyncEvents[i];
        if (l$asyncEvents$entry != lOther$asyncEvents$entry) {
          return false;
        }
      }
    } else if (l$asyncEvents != lOther$asyncEvents) {
      return false;
    }
    final l$syncEvents = syncEvents;
    final lOther$syncEvents = other.syncEvents;
    if (_$data.containsKey('syncEvents') !=
        other._$data.containsKey('syncEvents')) {
      return false;
    }
    if (l$syncEvents != null && lOther$syncEvents != null) {
      if (l$syncEvents.length != lOther$syncEvents.length) {
        return false;
      }
      for (int i = 0; i < l$syncEvents.length; i++) {
        final l$syncEvents$entry = l$syncEvents[i];
        final lOther$syncEvents$entry = lOther$syncEvents[i];
        if (l$syncEvents$entry != lOther$syncEvents$entry) {
          return false;
        }
      }
    } else if (l$syncEvents != lOther$syncEvents) {
      return false;
    }
    final l$app = app;
    final lOther$app = other.app;
    if (_$data.containsKey('app') != other._$data.containsKey('app')) {
      return false;
    }
    if (l$app != lOther$app) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$secretKey = secretKey;
    final lOther$secretKey = other.secretKey;
    if (_$data.containsKey('secretKey') !=
        other._$data.containsKey('secretKey')) {
      return false;
    }
    if (l$secretKey != lOther$secretKey) {
      return false;
    }
    final l$query = query;
    final lOther$query = other.query;
    if (_$data.containsKey('query') != other._$data.containsKey('query')) {
      return false;
    }
    if (l$query != lOther$query) {
      return false;
    }
    final l$customHeaders = customHeaders;
    final lOther$customHeaders = other.customHeaders;
    if (_$data.containsKey('customHeaders') !=
        other._$data.containsKey('customHeaders')) {
      return false;
    }
    if (l$customHeaders != lOther$customHeaders) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$targetUrl = targetUrl;
    final l$events = events;
    final l$asyncEvents = asyncEvents;
    final l$syncEvents = syncEvents;
    final l$app = app;
    final l$isActive = isActive;
    final l$secretKey = secretKey;
    final l$query = query;
    final l$customHeaders = customHeaders;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('targetUrl') ? l$targetUrl : const {},
      _$data.containsKey('events')
          ? l$events == null
              ? null
              : Object.hashAll(l$events.map((v) => v))
          : const {},
      _$data.containsKey('asyncEvents')
          ? l$asyncEvents == null
              ? null
              : Object.hashAll(l$asyncEvents.map((v) => v))
          : const {},
      _$data.containsKey('syncEvents')
          ? l$syncEvents == null
              ? null
              : Object.hashAll(l$syncEvents.map((v) => v))
          : const {},
      _$data.containsKey('app') ? l$app : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('secretKey') ? l$secretKey : const {},
      _$data.containsKey('query') ? l$query : const {},
      _$data.containsKey('customHeaders') ? l$customHeaders : const {},
    ]);
  }
}

abstract class CopyWith$Input$WebhookCreateInput<TRes> {
  factory CopyWith$Input$WebhookCreateInput(
    Input$WebhookCreateInput instance,
    TRes Function(Input$WebhookCreateInput) then,
  ) = _CopyWithImpl$Input$WebhookCreateInput;

  factory CopyWith$Input$WebhookCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WebhookCreateInput;

  TRes call({
    String? name,
    String? targetUrl,
    List<Enum$WebhookEventTypeEnum>? events,
    List<Enum$WebhookEventTypeAsyncEnum>? asyncEvents,
    List<Enum$WebhookEventTypeSyncEnum>? syncEvents,
    String? app,
    bool? isActive,
    String? secretKey,
    String? query,
    String? customHeaders,
  });
}

class _CopyWithImpl$Input$WebhookCreateInput<TRes>
    implements CopyWith$Input$WebhookCreateInput<TRes> {
  _CopyWithImpl$Input$WebhookCreateInput(
    this._instance,
    this._then,
  );

  final Input$WebhookCreateInput _instance;

  final TRes Function(Input$WebhookCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? targetUrl = _undefined,
    Object? events = _undefined,
    Object? asyncEvents = _undefined,
    Object? syncEvents = _undefined,
    Object? app = _undefined,
    Object? isActive = _undefined,
    Object? secretKey = _undefined,
    Object? query = _undefined,
    Object? customHeaders = _undefined,
  }) =>
      _then(Input$WebhookCreateInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (targetUrl != _undefined) 'targetUrl': (targetUrl as String?),
        if (events != _undefined)
          'events': (events as List<Enum$WebhookEventTypeEnum>?),
        if (asyncEvents != _undefined)
          'asyncEvents': (asyncEvents as List<Enum$WebhookEventTypeAsyncEnum>?),
        if (syncEvents != _undefined)
          'syncEvents': (syncEvents as List<Enum$WebhookEventTypeSyncEnum>?),
        if (app != _undefined) 'app': (app as String?),
        if (isActive != _undefined) 'isActive': (isActive as bool?),
        if (secretKey != _undefined) 'secretKey': (secretKey as String?),
        if (query != _undefined) 'query': (query as String?),
        if (customHeaders != _undefined)
          'customHeaders': (customHeaders as String?),
      }));
}

class _CopyWithStubImpl$Input$WebhookCreateInput<TRes>
    implements CopyWith$Input$WebhookCreateInput<TRes> {
  _CopyWithStubImpl$Input$WebhookCreateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? targetUrl,
    List<Enum$WebhookEventTypeEnum>? events,
    List<Enum$WebhookEventTypeAsyncEnum>? asyncEvents,
    List<Enum$WebhookEventTypeSyncEnum>? syncEvents,
    String? app,
    bool? isActive,
    String? secretKey,
    String? query,
    String? customHeaders,
  }) =>
      _res;
}

class Input$WebhookUpdateInput {
  factory Input$WebhookUpdateInput({
    String? name,
    String? targetUrl,
    List<Enum$WebhookEventTypeEnum>? events,
    List<Enum$WebhookEventTypeAsyncEnum>? asyncEvents,
    List<Enum$WebhookEventTypeSyncEnum>? syncEvents,
    String? app,
    bool? isActive,
    String? secretKey,
    String? query,
    String? customHeaders,
  }) =>
      Input$WebhookUpdateInput._({
        if (name != null) r'name': name,
        if (targetUrl != null) r'targetUrl': targetUrl,
        if (events != null) r'events': events,
        if (asyncEvents != null) r'asyncEvents': asyncEvents,
        if (syncEvents != null) r'syncEvents': syncEvents,
        if (app != null) r'app': app,
        if (isActive != null) r'isActive': isActive,
        if (secretKey != null) r'secretKey': secretKey,
        if (query != null) r'query': query,
        if (customHeaders != null) r'customHeaders': customHeaders,
      });

  Input$WebhookUpdateInput._(this._$data);

  factory Input$WebhookUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('targetUrl')) {
      final l$targetUrl = data['targetUrl'];
      result$data['targetUrl'] = (l$targetUrl as String?);
    }
    if (data.containsKey('events')) {
      final l$events = data['events'];
      result$data['events'] = (l$events as List<dynamic>?)
          ?.map((e) => fromJson$Enum$WebhookEventTypeEnum((e as String)))
          .toList();
    }
    if (data.containsKey('asyncEvents')) {
      final l$asyncEvents = data['asyncEvents'];
      result$data['asyncEvents'] = (l$asyncEvents as List<dynamic>?)
          ?.map((e) => fromJson$Enum$WebhookEventTypeAsyncEnum((e as String)))
          .toList();
    }
    if (data.containsKey('syncEvents')) {
      final l$syncEvents = data['syncEvents'];
      result$data['syncEvents'] = (l$syncEvents as List<dynamic>?)
          ?.map((e) => fromJson$Enum$WebhookEventTypeSyncEnum((e as String)))
          .toList();
    }
    if (data.containsKey('app')) {
      final l$app = data['app'];
      result$data['app'] = (l$app as String?);
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = (l$isActive as bool?);
    }
    if (data.containsKey('secretKey')) {
      final l$secretKey = data['secretKey'];
      result$data['secretKey'] = (l$secretKey as String?);
    }
    if (data.containsKey('query')) {
      final l$query = data['query'];
      result$data['query'] = (l$query as String?);
    }
    if (data.containsKey('customHeaders')) {
      final l$customHeaders = data['customHeaders'];
      result$data['customHeaders'] = (l$customHeaders as String?);
    }
    return Input$WebhookUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get targetUrl => (_$data['targetUrl'] as String?);

  List<Enum$WebhookEventTypeEnum>? get events =>
      (_$data['events'] as List<Enum$WebhookEventTypeEnum>?);

  List<Enum$WebhookEventTypeAsyncEnum>? get asyncEvents =>
      (_$data['asyncEvents'] as List<Enum$WebhookEventTypeAsyncEnum>?);

  List<Enum$WebhookEventTypeSyncEnum>? get syncEvents =>
      (_$data['syncEvents'] as List<Enum$WebhookEventTypeSyncEnum>?);

  String? get app => (_$data['app'] as String?);

  bool? get isActive => (_$data['isActive'] as bool?);

  String? get secretKey => (_$data['secretKey'] as String?);

  String? get query => (_$data['query'] as String?);

  String? get customHeaders => (_$data['customHeaders'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('targetUrl')) {
      final l$targetUrl = targetUrl;
      result$data['targetUrl'] = l$targetUrl;
    }
    if (_$data.containsKey('events')) {
      final l$events = events;
      result$data['events'] =
          l$events?.map((e) => toJson$Enum$WebhookEventTypeEnum(e)).toList();
    }
    if (_$data.containsKey('asyncEvents')) {
      final l$asyncEvents = asyncEvents;
      result$data['asyncEvents'] = l$asyncEvents
          ?.map((e) => toJson$Enum$WebhookEventTypeAsyncEnum(e))
          .toList();
    }
    if (_$data.containsKey('syncEvents')) {
      final l$syncEvents = syncEvents;
      result$data['syncEvents'] = l$syncEvents
          ?.map((e) => toJson$Enum$WebhookEventTypeSyncEnum(e))
          .toList();
    }
    if (_$data.containsKey('app')) {
      final l$app = app;
      result$data['app'] = l$app;
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive;
    }
    if (_$data.containsKey('secretKey')) {
      final l$secretKey = secretKey;
      result$data['secretKey'] = l$secretKey;
    }
    if (_$data.containsKey('query')) {
      final l$query = query;
      result$data['query'] = l$query;
    }
    if (_$data.containsKey('customHeaders')) {
      final l$customHeaders = customHeaders;
      result$data['customHeaders'] = l$customHeaders;
    }
    return result$data;
  }

  CopyWith$Input$WebhookUpdateInput<Input$WebhookUpdateInput> get copyWith =>
      CopyWith$Input$WebhookUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$WebhookUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$targetUrl = targetUrl;
    final lOther$targetUrl = other.targetUrl;
    if (_$data.containsKey('targetUrl') !=
        other._$data.containsKey('targetUrl')) {
      return false;
    }
    if (l$targetUrl != lOther$targetUrl) {
      return false;
    }
    final l$events = events;
    final lOther$events = other.events;
    if (_$data.containsKey('events') != other._$data.containsKey('events')) {
      return false;
    }
    if (l$events != null && lOther$events != null) {
      if (l$events.length != lOther$events.length) {
        return false;
      }
      for (int i = 0; i < l$events.length; i++) {
        final l$events$entry = l$events[i];
        final lOther$events$entry = lOther$events[i];
        if (l$events$entry != lOther$events$entry) {
          return false;
        }
      }
    } else if (l$events != lOther$events) {
      return false;
    }
    final l$asyncEvents = asyncEvents;
    final lOther$asyncEvents = other.asyncEvents;
    if (_$data.containsKey('asyncEvents') !=
        other._$data.containsKey('asyncEvents')) {
      return false;
    }
    if (l$asyncEvents != null && lOther$asyncEvents != null) {
      if (l$asyncEvents.length != lOther$asyncEvents.length) {
        return false;
      }
      for (int i = 0; i < l$asyncEvents.length; i++) {
        final l$asyncEvents$entry = l$asyncEvents[i];
        final lOther$asyncEvents$entry = lOther$asyncEvents[i];
        if (l$asyncEvents$entry != lOther$asyncEvents$entry) {
          return false;
        }
      }
    } else if (l$asyncEvents != lOther$asyncEvents) {
      return false;
    }
    final l$syncEvents = syncEvents;
    final lOther$syncEvents = other.syncEvents;
    if (_$data.containsKey('syncEvents') !=
        other._$data.containsKey('syncEvents')) {
      return false;
    }
    if (l$syncEvents != null && lOther$syncEvents != null) {
      if (l$syncEvents.length != lOther$syncEvents.length) {
        return false;
      }
      for (int i = 0; i < l$syncEvents.length; i++) {
        final l$syncEvents$entry = l$syncEvents[i];
        final lOther$syncEvents$entry = lOther$syncEvents[i];
        if (l$syncEvents$entry != lOther$syncEvents$entry) {
          return false;
        }
      }
    } else if (l$syncEvents != lOther$syncEvents) {
      return false;
    }
    final l$app = app;
    final lOther$app = other.app;
    if (_$data.containsKey('app') != other._$data.containsKey('app')) {
      return false;
    }
    if (l$app != lOther$app) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$secretKey = secretKey;
    final lOther$secretKey = other.secretKey;
    if (_$data.containsKey('secretKey') !=
        other._$data.containsKey('secretKey')) {
      return false;
    }
    if (l$secretKey != lOther$secretKey) {
      return false;
    }
    final l$query = query;
    final lOther$query = other.query;
    if (_$data.containsKey('query') != other._$data.containsKey('query')) {
      return false;
    }
    if (l$query != lOther$query) {
      return false;
    }
    final l$customHeaders = customHeaders;
    final lOther$customHeaders = other.customHeaders;
    if (_$data.containsKey('customHeaders') !=
        other._$data.containsKey('customHeaders')) {
      return false;
    }
    if (l$customHeaders != lOther$customHeaders) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$targetUrl = targetUrl;
    final l$events = events;
    final l$asyncEvents = asyncEvents;
    final l$syncEvents = syncEvents;
    final l$app = app;
    final l$isActive = isActive;
    final l$secretKey = secretKey;
    final l$query = query;
    final l$customHeaders = customHeaders;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('targetUrl') ? l$targetUrl : const {},
      _$data.containsKey('events')
          ? l$events == null
              ? null
              : Object.hashAll(l$events.map((v) => v))
          : const {},
      _$data.containsKey('asyncEvents')
          ? l$asyncEvents == null
              ? null
              : Object.hashAll(l$asyncEvents.map((v) => v))
          : const {},
      _$data.containsKey('syncEvents')
          ? l$syncEvents == null
              ? null
              : Object.hashAll(l$syncEvents.map((v) => v))
          : const {},
      _$data.containsKey('app') ? l$app : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('secretKey') ? l$secretKey : const {},
      _$data.containsKey('query') ? l$query : const {},
      _$data.containsKey('customHeaders') ? l$customHeaders : const {},
    ]);
  }
}

abstract class CopyWith$Input$WebhookUpdateInput<TRes> {
  factory CopyWith$Input$WebhookUpdateInput(
    Input$WebhookUpdateInput instance,
    TRes Function(Input$WebhookUpdateInput) then,
  ) = _CopyWithImpl$Input$WebhookUpdateInput;

  factory CopyWith$Input$WebhookUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WebhookUpdateInput;

  TRes call({
    String? name,
    String? targetUrl,
    List<Enum$WebhookEventTypeEnum>? events,
    List<Enum$WebhookEventTypeAsyncEnum>? asyncEvents,
    List<Enum$WebhookEventTypeSyncEnum>? syncEvents,
    String? app,
    bool? isActive,
    String? secretKey,
    String? query,
    String? customHeaders,
  });
}

class _CopyWithImpl$Input$WebhookUpdateInput<TRes>
    implements CopyWith$Input$WebhookUpdateInput<TRes> {
  _CopyWithImpl$Input$WebhookUpdateInput(
    this._instance,
    this._then,
  );

  final Input$WebhookUpdateInput _instance;

  final TRes Function(Input$WebhookUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? targetUrl = _undefined,
    Object? events = _undefined,
    Object? asyncEvents = _undefined,
    Object? syncEvents = _undefined,
    Object? app = _undefined,
    Object? isActive = _undefined,
    Object? secretKey = _undefined,
    Object? query = _undefined,
    Object? customHeaders = _undefined,
  }) =>
      _then(Input$WebhookUpdateInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (targetUrl != _undefined) 'targetUrl': (targetUrl as String?),
        if (events != _undefined)
          'events': (events as List<Enum$WebhookEventTypeEnum>?),
        if (asyncEvents != _undefined)
          'asyncEvents': (asyncEvents as List<Enum$WebhookEventTypeAsyncEnum>?),
        if (syncEvents != _undefined)
          'syncEvents': (syncEvents as List<Enum$WebhookEventTypeSyncEnum>?),
        if (app != _undefined) 'app': (app as String?),
        if (isActive != _undefined) 'isActive': (isActive as bool?),
        if (secretKey != _undefined) 'secretKey': (secretKey as String?),
        if (query != _undefined) 'query': (query as String?),
        if (customHeaders != _undefined)
          'customHeaders': (customHeaders as String?),
      }));
}

class _CopyWithStubImpl$Input$WebhookUpdateInput<TRes>
    implements CopyWith$Input$WebhookUpdateInput<TRes> {
  _CopyWithStubImpl$Input$WebhookUpdateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? targetUrl,
    List<Enum$WebhookEventTypeEnum>? events,
    List<Enum$WebhookEventTypeAsyncEnum>? asyncEvents,
    List<Enum$WebhookEventTypeSyncEnum>? syncEvents,
    String? app,
    bool? isActive,
    String? secretKey,
    String? query,
    String? customHeaders,
  }) =>
      _res;
}

enum Enum$AccountErrorCode {
  ACTIVATE_OWN_ACCOUNT,
  ACTIVATE_SUPERUSER_ACCOUNT,
  DUPLICATED_INPUT_ITEM,
  DEACTIVATE_OWN_ACCOUNT,
  DEACTIVATE_SUPERUSER_ACCOUNT,
  DELETE_NON_STAFF_USER,
  DELETE_OWN_ACCOUNT,
  DELETE_STAFF_ACCOUNT,
  DELETE_SUPERUSER_ACCOUNT,
  GRAPHQL_ERROR,
  INACTIVE,
  INVALID,
  INVALID_PASSWORD,
  LEFT_NOT_MANAGEABLE_PERMISSION,
  INVALID_CREDENTIALS,
  NOT_FOUND,
  OUT_OF_SCOPE_USER,
  OUT_OF_SCOPE_GROUP,
  OUT_OF_SCOPE_PERMISSION,
  PASSWORD_ENTIRELY_NUMERIC,
  PASSWORD_TOO_COMMON,
  PASSWORD_TOO_SHORT,
  PASSWORD_TOO_SIMILAR,
  PASSWORD_RESET_ALREADY_REQUESTED,
  REQUIRED,
  UNIQUE,
  JWT_SIGNATURE_EXPIRED,
  JWT_INVALID_TOKEN,
  JWT_DECODE_ERROR,
  JWT_MISSING_TOKEN,
  JWT_INVALID_CSRF_TOKEN,
  CHANNEL_INACTIVE,
  MISSING_CHANNEL_SLUG,
  ACCOUNT_NOT_CONFIRMED,
  LOGIN_ATTEMPT_DELAYED,
  UNKNOWN_IP_ADDRESS,
  $unknown;

  factory Enum$AccountErrorCode.fromJson(String value) =>
      fromJson$Enum$AccountErrorCode(value);

  String toJson() => toJson$Enum$AccountErrorCode(this);
}

String toJson$Enum$AccountErrorCode(Enum$AccountErrorCode e) {
  switch (e) {
    case Enum$AccountErrorCode.ACTIVATE_OWN_ACCOUNT:
      return r'ACTIVATE_OWN_ACCOUNT';
    case Enum$AccountErrorCode.ACTIVATE_SUPERUSER_ACCOUNT:
      return r'ACTIVATE_SUPERUSER_ACCOUNT';
    case Enum$AccountErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$AccountErrorCode.DEACTIVATE_OWN_ACCOUNT:
      return r'DEACTIVATE_OWN_ACCOUNT';
    case Enum$AccountErrorCode.DEACTIVATE_SUPERUSER_ACCOUNT:
      return r'DEACTIVATE_SUPERUSER_ACCOUNT';
    case Enum$AccountErrorCode.DELETE_NON_STAFF_USER:
      return r'DELETE_NON_STAFF_USER';
    case Enum$AccountErrorCode.DELETE_OWN_ACCOUNT:
      return r'DELETE_OWN_ACCOUNT';
    case Enum$AccountErrorCode.DELETE_STAFF_ACCOUNT:
      return r'DELETE_STAFF_ACCOUNT';
    case Enum$AccountErrorCode.DELETE_SUPERUSER_ACCOUNT:
      return r'DELETE_SUPERUSER_ACCOUNT';
    case Enum$AccountErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$AccountErrorCode.INACTIVE:
      return r'INACTIVE';
    case Enum$AccountErrorCode.INVALID:
      return r'INVALID';
    case Enum$AccountErrorCode.INVALID_PASSWORD:
      return r'INVALID_PASSWORD';
    case Enum$AccountErrorCode.LEFT_NOT_MANAGEABLE_PERMISSION:
      return r'LEFT_NOT_MANAGEABLE_PERMISSION';
    case Enum$AccountErrorCode.INVALID_CREDENTIALS:
      return r'INVALID_CREDENTIALS';
    case Enum$AccountErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$AccountErrorCode.OUT_OF_SCOPE_USER:
      return r'OUT_OF_SCOPE_USER';
    case Enum$AccountErrorCode.OUT_OF_SCOPE_GROUP:
      return r'OUT_OF_SCOPE_GROUP';
    case Enum$AccountErrorCode.OUT_OF_SCOPE_PERMISSION:
      return r'OUT_OF_SCOPE_PERMISSION';
    case Enum$AccountErrorCode.PASSWORD_ENTIRELY_NUMERIC:
      return r'PASSWORD_ENTIRELY_NUMERIC';
    case Enum$AccountErrorCode.PASSWORD_TOO_COMMON:
      return r'PASSWORD_TOO_COMMON';
    case Enum$AccountErrorCode.PASSWORD_TOO_SHORT:
      return r'PASSWORD_TOO_SHORT';
    case Enum$AccountErrorCode.PASSWORD_TOO_SIMILAR:
      return r'PASSWORD_TOO_SIMILAR';
    case Enum$AccountErrorCode.PASSWORD_RESET_ALREADY_REQUESTED:
      return r'PASSWORD_RESET_ALREADY_REQUESTED';
    case Enum$AccountErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$AccountErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$AccountErrorCode.JWT_SIGNATURE_EXPIRED:
      return r'JWT_SIGNATURE_EXPIRED';
    case Enum$AccountErrorCode.JWT_INVALID_TOKEN:
      return r'JWT_INVALID_TOKEN';
    case Enum$AccountErrorCode.JWT_DECODE_ERROR:
      return r'JWT_DECODE_ERROR';
    case Enum$AccountErrorCode.JWT_MISSING_TOKEN:
      return r'JWT_MISSING_TOKEN';
    case Enum$AccountErrorCode.JWT_INVALID_CSRF_TOKEN:
      return r'JWT_INVALID_CSRF_TOKEN';
    case Enum$AccountErrorCode.CHANNEL_INACTIVE:
      return r'CHANNEL_INACTIVE';
    case Enum$AccountErrorCode.MISSING_CHANNEL_SLUG:
      return r'MISSING_CHANNEL_SLUG';
    case Enum$AccountErrorCode.ACCOUNT_NOT_CONFIRMED:
      return r'ACCOUNT_NOT_CONFIRMED';
    case Enum$AccountErrorCode.LOGIN_ATTEMPT_DELAYED:
      return r'LOGIN_ATTEMPT_DELAYED';
    case Enum$AccountErrorCode.UNKNOWN_IP_ADDRESS:
      return r'UNKNOWN_IP_ADDRESS';
    case Enum$AccountErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$AccountErrorCode fromJson$Enum$AccountErrorCode(String value) {
  switch (value) {
    case r'ACTIVATE_OWN_ACCOUNT':
      return Enum$AccountErrorCode.ACTIVATE_OWN_ACCOUNT;
    case r'ACTIVATE_SUPERUSER_ACCOUNT':
      return Enum$AccountErrorCode.ACTIVATE_SUPERUSER_ACCOUNT;
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$AccountErrorCode.DUPLICATED_INPUT_ITEM;
    case r'DEACTIVATE_OWN_ACCOUNT':
      return Enum$AccountErrorCode.DEACTIVATE_OWN_ACCOUNT;
    case r'DEACTIVATE_SUPERUSER_ACCOUNT':
      return Enum$AccountErrorCode.DEACTIVATE_SUPERUSER_ACCOUNT;
    case r'DELETE_NON_STAFF_USER':
      return Enum$AccountErrorCode.DELETE_NON_STAFF_USER;
    case r'DELETE_OWN_ACCOUNT':
      return Enum$AccountErrorCode.DELETE_OWN_ACCOUNT;
    case r'DELETE_STAFF_ACCOUNT':
      return Enum$AccountErrorCode.DELETE_STAFF_ACCOUNT;
    case r'DELETE_SUPERUSER_ACCOUNT':
      return Enum$AccountErrorCode.DELETE_SUPERUSER_ACCOUNT;
    case r'GRAPHQL_ERROR':
      return Enum$AccountErrorCode.GRAPHQL_ERROR;
    case r'INACTIVE':
      return Enum$AccountErrorCode.INACTIVE;
    case r'INVALID':
      return Enum$AccountErrorCode.INVALID;
    case r'INVALID_PASSWORD':
      return Enum$AccountErrorCode.INVALID_PASSWORD;
    case r'LEFT_NOT_MANAGEABLE_PERMISSION':
      return Enum$AccountErrorCode.LEFT_NOT_MANAGEABLE_PERMISSION;
    case r'INVALID_CREDENTIALS':
      return Enum$AccountErrorCode.INVALID_CREDENTIALS;
    case r'NOT_FOUND':
      return Enum$AccountErrorCode.NOT_FOUND;
    case r'OUT_OF_SCOPE_USER':
      return Enum$AccountErrorCode.OUT_OF_SCOPE_USER;
    case r'OUT_OF_SCOPE_GROUP':
      return Enum$AccountErrorCode.OUT_OF_SCOPE_GROUP;
    case r'OUT_OF_SCOPE_PERMISSION':
      return Enum$AccountErrorCode.OUT_OF_SCOPE_PERMISSION;
    case r'PASSWORD_ENTIRELY_NUMERIC':
      return Enum$AccountErrorCode.PASSWORD_ENTIRELY_NUMERIC;
    case r'PASSWORD_TOO_COMMON':
      return Enum$AccountErrorCode.PASSWORD_TOO_COMMON;
    case r'PASSWORD_TOO_SHORT':
      return Enum$AccountErrorCode.PASSWORD_TOO_SHORT;
    case r'PASSWORD_TOO_SIMILAR':
      return Enum$AccountErrorCode.PASSWORD_TOO_SIMILAR;
    case r'PASSWORD_RESET_ALREADY_REQUESTED':
      return Enum$AccountErrorCode.PASSWORD_RESET_ALREADY_REQUESTED;
    case r'REQUIRED':
      return Enum$AccountErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$AccountErrorCode.UNIQUE;
    case r'JWT_SIGNATURE_EXPIRED':
      return Enum$AccountErrorCode.JWT_SIGNATURE_EXPIRED;
    case r'JWT_INVALID_TOKEN':
      return Enum$AccountErrorCode.JWT_INVALID_TOKEN;
    case r'JWT_DECODE_ERROR':
      return Enum$AccountErrorCode.JWT_DECODE_ERROR;
    case r'JWT_MISSING_TOKEN':
      return Enum$AccountErrorCode.JWT_MISSING_TOKEN;
    case r'JWT_INVALID_CSRF_TOKEN':
      return Enum$AccountErrorCode.JWT_INVALID_CSRF_TOKEN;
    case r'CHANNEL_INACTIVE':
      return Enum$AccountErrorCode.CHANNEL_INACTIVE;
    case r'MISSING_CHANNEL_SLUG':
      return Enum$AccountErrorCode.MISSING_CHANNEL_SLUG;
    case r'ACCOUNT_NOT_CONFIRMED':
      return Enum$AccountErrorCode.ACCOUNT_NOT_CONFIRMED;
    case r'LOGIN_ATTEMPT_DELAYED':
      return Enum$AccountErrorCode.LOGIN_ATTEMPT_DELAYED;
    case r'UNKNOWN_IP_ADDRESS':
      return Enum$AccountErrorCode.UNKNOWN_IP_ADDRESS;
    default:
      return Enum$AccountErrorCode.$unknown;
  }
}

enum Enum$AddressTypeEnum {
  BILLING,
  SHIPPING,
  $unknown;

  factory Enum$AddressTypeEnum.fromJson(String value) =>
      fromJson$Enum$AddressTypeEnum(value);

  String toJson() => toJson$Enum$AddressTypeEnum(this);
}

String toJson$Enum$AddressTypeEnum(Enum$AddressTypeEnum e) {
  switch (e) {
    case Enum$AddressTypeEnum.BILLING:
      return r'BILLING';
    case Enum$AddressTypeEnum.SHIPPING:
      return r'SHIPPING';
    case Enum$AddressTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$AddressTypeEnum fromJson$Enum$AddressTypeEnum(String value) {
  switch (value) {
    case r'BILLING':
      return Enum$AddressTypeEnum.BILLING;
    case r'SHIPPING':
      return Enum$AddressTypeEnum.SHIPPING;
    default:
      return Enum$AddressTypeEnum.$unknown;
  }
}

enum Enum$AllocationStrategyEnum {
  PRIORITIZE_SORTING_ORDER,
  PRIORITIZE_HIGH_STOCK,
  $unknown;

  factory Enum$AllocationStrategyEnum.fromJson(String value) =>
      fromJson$Enum$AllocationStrategyEnum(value);

  String toJson() => toJson$Enum$AllocationStrategyEnum(this);
}

String toJson$Enum$AllocationStrategyEnum(Enum$AllocationStrategyEnum e) {
  switch (e) {
    case Enum$AllocationStrategyEnum.PRIORITIZE_SORTING_ORDER:
      return r'PRIORITIZE_SORTING_ORDER';
    case Enum$AllocationStrategyEnum.PRIORITIZE_HIGH_STOCK:
      return r'PRIORITIZE_HIGH_STOCK';
    case Enum$AllocationStrategyEnum.$unknown:
      return r'$unknown';
  }
}

Enum$AllocationStrategyEnum fromJson$Enum$AllocationStrategyEnum(String value) {
  switch (value) {
    case r'PRIORITIZE_SORTING_ORDER':
      return Enum$AllocationStrategyEnum.PRIORITIZE_SORTING_ORDER;
    case r'PRIORITIZE_HIGH_STOCK':
      return Enum$AllocationStrategyEnum.PRIORITIZE_HIGH_STOCK;
    default:
      return Enum$AllocationStrategyEnum.$unknown;
  }
}

enum Enum$AppErrorCode {
  FORBIDDEN,
  GRAPHQL_ERROR,
  INVALID,
  INVALID_STATUS,
  INVALID_PERMISSION,
  INVALID_URL_FORMAT,
  INVALID_MANIFEST_FORMAT,
  INVALID_CUSTOM_HEADERS,
  MANIFEST_URL_CANT_CONNECT,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  OUT_OF_SCOPE_APP,
  OUT_OF_SCOPE_PERMISSION,
  UNSUPPORTED_SALEOR_VERSION,
  $unknown;

  factory Enum$AppErrorCode.fromJson(String value) =>
      fromJson$Enum$AppErrorCode(value);

  String toJson() => toJson$Enum$AppErrorCode(this);
}

String toJson$Enum$AppErrorCode(Enum$AppErrorCode e) {
  switch (e) {
    case Enum$AppErrorCode.FORBIDDEN:
      return r'FORBIDDEN';
    case Enum$AppErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$AppErrorCode.INVALID:
      return r'INVALID';
    case Enum$AppErrorCode.INVALID_STATUS:
      return r'INVALID_STATUS';
    case Enum$AppErrorCode.INVALID_PERMISSION:
      return r'INVALID_PERMISSION';
    case Enum$AppErrorCode.INVALID_URL_FORMAT:
      return r'INVALID_URL_FORMAT';
    case Enum$AppErrorCode.INVALID_MANIFEST_FORMAT:
      return r'INVALID_MANIFEST_FORMAT';
    case Enum$AppErrorCode.INVALID_CUSTOM_HEADERS:
      return r'INVALID_CUSTOM_HEADERS';
    case Enum$AppErrorCode.MANIFEST_URL_CANT_CONNECT:
      return r'MANIFEST_URL_CANT_CONNECT';
    case Enum$AppErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$AppErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$AppErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$AppErrorCode.OUT_OF_SCOPE_APP:
      return r'OUT_OF_SCOPE_APP';
    case Enum$AppErrorCode.OUT_OF_SCOPE_PERMISSION:
      return r'OUT_OF_SCOPE_PERMISSION';
    case Enum$AppErrorCode.UNSUPPORTED_SALEOR_VERSION:
      return r'UNSUPPORTED_SALEOR_VERSION';
    case Enum$AppErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$AppErrorCode fromJson$Enum$AppErrorCode(String value) {
  switch (value) {
    case r'FORBIDDEN':
      return Enum$AppErrorCode.FORBIDDEN;
    case r'GRAPHQL_ERROR':
      return Enum$AppErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$AppErrorCode.INVALID;
    case r'INVALID_STATUS':
      return Enum$AppErrorCode.INVALID_STATUS;
    case r'INVALID_PERMISSION':
      return Enum$AppErrorCode.INVALID_PERMISSION;
    case r'INVALID_URL_FORMAT':
      return Enum$AppErrorCode.INVALID_URL_FORMAT;
    case r'INVALID_MANIFEST_FORMAT':
      return Enum$AppErrorCode.INVALID_MANIFEST_FORMAT;
    case r'INVALID_CUSTOM_HEADERS':
      return Enum$AppErrorCode.INVALID_CUSTOM_HEADERS;
    case r'MANIFEST_URL_CANT_CONNECT':
      return Enum$AppErrorCode.MANIFEST_URL_CANT_CONNECT;
    case r'NOT_FOUND':
      return Enum$AppErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$AppErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$AppErrorCode.UNIQUE;
    case r'OUT_OF_SCOPE_APP':
      return Enum$AppErrorCode.OUT_OF_SCOPE_APP;
    case r'OUT_OF_SCOPE_PERMISSION':
      return Enum$AppErrorCode.OUT_OF_SCOPE_PERMISSION;
    case r'UNSUPPORTED_SALEOR_VERSION':
      return Enum$AppErrorCode.UNSUPPORTED_SALEOR_VERSION;
    default:
      return Enum$AppErrorCode.$unknown;
  }
}

enum Enum$AppExtensionMountEnum {
  CATEGORY_OVERVIEW_CREATE,
  CATEGORY_OVERVIEW_MORE_ACTIONS,
  CATEGORY_DETAILS_MORE_ACTIONS,
  COLLECTION_OVERVIEW_CREATE,
  COLLECTION_OVERVIEW_MORE_ACTIONS,
  COLLECTION_DETAILS_MORE_ACTIONS,
  COLLECTION_DETAILS_WIDGETS,
  GIFT_CARD_OVERVIEW_CREATE,
  GIFT_CARD_OVERVIEW_MORE_ACTIONS,
  GIFT_CARD_DETAILS_MORE_ACTIONS,
  GIFT_CARD_DETAILS_WIDGETS,
  CUSTOMER_OVERVIEW_CREATE,
  CUSTOMER_OVERVIEW_MORE_ACTIONS,
  CUSTOMER_DETAILS_MORE_ACTIONS,
  CUSTOMER_DETAILS_WIDGETS,
  PRODUCT_OVERVIEW_CREATE,
  PRODUCT_OVERVIEW_MORE_ACTIONS,
  PRODUCT_DETAILS_MORE_ACTIONS,
  PRODUCT_DETAILS_WIDGETS,
  NAVIGATION_CATALOG,
  NAVIGATION_ORDERS,
  NAVIGATION_CUSTOMERS,
  NAVIGATION_DISCOUNTS,
  NAVIGATION_TRANSLATIONS,
  NAVIGATION_PAGES,
  ORDER_DETAILS_MORE_ACTIONS,
  ORDER_OVERVIEW_CREATE,
  ORDER_OVERVIEW_MORE_ACTIONS,
  ORDER_DETAILS_WIDGETS,
  DRAFT_ORDER_DETAILS_MORE_ACTIONS,
  DRAFT_ORDER_OVERVIEW_CREATE,
  DRAFT_ORDER_OVERVIEW_MORE_ACTIONS,
  DRAFT_ORDER_DETAILS_WIDGETS,
  DISCOUNT_DETAILS_MORE_ACTIONS,
  DISCOUNT_OVERVIEW_CREATE,
  DISCOUNT_OVERVIEW_MORE_ACTIONS,
  VOUCHER_DETAILS_MORE_ACTIONS,
  VOUCHER_OVERVIEW_CREATE,
  VOUCHER_OVERVIEW_MORE_ACTIONS,
  VOUCHER_DETAILS_WIDGETS,
  PAGE_DETAILS_MORE_ACTIONS,
  PAGE_OVERVIEW_CREATE,
  PAGE_OVERVIEW_MORE_ACTIONS,
  PAGE_TYPE_OVERVIEW_CREATE,
  PAGE_TYPE_OVERVIEW_MORE_ACTIONS,
  PAGE_TYPE_DETAILS_MORE_ACTIONS,
  MENU_OVERVIEW_CREATE,
  MENU_OVERVIEW_MORE_ACTIONS,
  MENU_DETAILS_MORE_ACTIONS,
  $unknown;

  factory Enum$AppExtensionMountEnum.fromJson(String value) =>
      fromJson$Enum$AppExtensionMountEnum(value);

  String toJson() => toJson$Enum$AppExtensionMountEnum(this);
}

String toJson$Enum$AppExtensionMountEnum(Enum$AppExtensionMountEnum e) {
  switch (e) {
    case Enum$AppExtensionMountEnum.CATEGORY_OVERVIEW_CREATE:
      return r'CATEGORY_OVERVIEW_CREATE';
    case Enum$AppExtensionMountEnum.CATEGORY_OVERVIEW_MORE_ACTIONS:
      return r'CATEGORY_OVERVIEW_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.CATEGORY_DETAILS_MORE_ACTIONS:
      return r'CATEGORY_DETAILS_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.COLLECTION_OVERVIEW_CREATE:
      return r'COLLECTION_OVERVIEW_CREATE';
    case Enum$AppExtensionMountEnum.COLLECTION_OVERVIEW_MORE_ACTIONS:
      return r'COLLECTION_OVERVIEW_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.COLLECTION_DETAILS_MORE_ACTIONS:
      return r'COLLECTION_DETAILS_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.COLLECTION_DETAILS_WIDGETS:
      return r'COLLECTION_DETAILS_WIDGETS';
    case Enum$AppExtensionMountEnum.GIFT_CARD_OVERVIEW_CREATE:
      return r'GIFT_CARD_OVERVIEW_CREATE';
    case Enum$AppExtensionMountEnum.GIFT_CARD_OVERVIEW_MORE_ACTIONS:
      return r'GIFT_CARD_OVERVIEW_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.GIFT_CARD_DETAILS_MORE_ACTIONS:
      return r'GIFT_CARD_DETAILS_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.GIFT_CARD_DETAILS_WIDGETS:
      return r'GIFT_CARD_DETAILS_WIDGETS';
    case Enum$AppExtensionMountEnum.CUSTOMER_OVERVIEW_CREATE:
      return r'CUSTOMER_OVERVIEW_CREATE';
    case Enum$AppExtensionMountEnum.CUSTOMER_OVERVIEW_MORE_ACTIONS:
      return r'CUSTOMER_OVERVIEW_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.CUSTOMER_DETAILS_MORE_ACTIONS:
      return r'CUSTOMER_DETAILS_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.CUSTOMER_DETAILS_WIDGETS:
      return r'CUSTOMER_DETAILS_WIDGETS';
    case Enum$AppExtensionMountEnum.PRODUCT_OVERVIEW_CREATE:
      return r'PRODUCT_OVERVIEW_CREATE';
    case Enum$AppExtensionMountEnum.PRODUCT_OVERVIEW_MORE_ACTIONS:
      return r'PRODUCT_OVERVIEW_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.PRODUCT_DETAILS_MORE_ACTIONS:
      return r'PRODUCT_DETAILS_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.PRODUCT_DETAILS_WIDGETS:
      return r'PRODUCT_DETAILS_WIDGETS';
    case Enum$AppExtensionMountEnum.NAVIGATION_CATALOG:
      return r'NAVIGATION_CATALOG';
    case Enum$AppExtensionMountEnum.NAVIGATION_ORDERS:
      return r'NAVIGATION_ORDERS';
    case Enum$AppExtensionMountEnum.NAVIGATION_CUSTOMERS:
      return r'NAVIGATION_CUSTOMERS';
    case Enum$AppExtensionMountEnum.NAVIGATION_DISCOUNTS:
      return r'NAVIGATION_DISCOUNTS';
    case Enum$AppExtensionMountEnum.NAVIGATION_TRANSLATIONS:
      return r'NAVIGATION_TRANSLATIONS';
    case Enum$AppExtensionMountEnum.NAVIGATION_PAGES:
      return r'NAVIGATION_PAGES';
    case Enum$AppExtensionMountEnum.ORDER_DETAILS_MORE_ACTIONS:
      return r'ORDER_DETAILS_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.ORDER_OVERVIEW_CREATE:
      return r'ORDER_OVERVIEW_CREATE';
    case Enum$AppExtensionMountEnum.ORDER_OVERVIEW_MORE_ACTIONS:
      return r'ORDER_OVERVIEW_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.ORDER_DETAILS_WIDGETS:
      return r'ORDER_DETAILS_WIDGETS';
    case Enum$AppExtensionMountEnum.DRAFT_ORDER_DETAILS_MORE_ACTIONS:
      return r'DRAFT_ORDER_DETAILS_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.DRAFT_ORDER_OVERVIEW_CREATE:
      return r'DRAFT_ORDER_OVERVIEW_CREATE';
    case Enum$AppExtensionMountEnum.DRAFT_ORDER_OVERVIEW_MORE_ACTIONS:
      return r'DRAFT_ORDER_OVERVIEW_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.DRAFT_ORDER_DETAILS_WIDGETS:
      return r'DRAFT_ORDER_DETAILS_WIDGETS';
    case Enum$AppExtensionMountEnum.DISCOUNT_DETAILS_MORE_ACTIONS:
      return r'DISCOUNT_DETAILS_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.DISCOUNT_OVERVIEW_CREATE:
      return r'DISCOUNT_OVERVIEW_CREATE';
    case Enum$AppExtensionMountEnum.DISCOUNT_OVERVIEW_MORE_ACTIONS:
      return r'DISCOUNT_OVERVIEW_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.VOUCHER_DETAILS_MORE_ACTIONS:
      return r'VOUCHER_DETAILS_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.VOUCHER_OVERVIEW_CREATE:
      return r'VOUCHER_OVERVIEW_CREATE';
    case Enum$AppExtensionMountEnum.VOUCHER_OVERVIEW_MORE_ACTIONS:
      return r'VOUCHER_OVERVIEW_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.VOUCHER_DETAILS_WIDGETS:
      return r'VOUCHER_DETAILS_WIDGETS';
    case Enum$AppExtensionMountEnum.PAGE_DETAILS_MORE_ACTIONS:
      return r'PAGE_DETAILS_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.PAGE_OVERVIEW_CREATE:
      return r'PAGE_OVERVIEW_CREATE';
    case Enum$AppExtensionMountEnum.PAGE_OVERVIEW_MORE_ACTIONS:
      return r'PAGE_OVERVIEW_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.PAGE_TYPE_OVERVIEW_CREATE:
      return r'PAGE_TYPE_OVERVIEW_CREATE';
    case Enum$AppExtensionMountEnum.PAGE_TYPE_OVERVIEW_MORE_ACTIONS:
      return r'PAGE_TYPE_OVERVIEW_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.PAGE_TYPE_DETAILS_MORE_ACTIONS:
      return r'PAGE_TYPE_DETAILS_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.MENU_OVERVIEW_CREATE:
      return r'MENU_OVERVIEW_CREATE';
    case Enum$AppExtensionMountEnum.MENU_OVERVIEW_MORE_ACTIONS:
      return r'MENU_OVERVIEW_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.MENU_DETAILS_MORE_ACTIONS:
      return r'MENU_DETAILS_MORE_ACTIONS';
    case Enum$AppExtensionMountEnum.$unknown:
      return r'$unknown';
  }
}

Enum$AppExtensionMountEnum fromJson$Enum$AppExtensionMountEnum(String value) {
  switch (value) {
    case r'CATEGORY_OVERVIEW_CREATE':
      return Enum$AppExtensionMountEnum.CATEGORY_OVERVIEW_CREATE;
    case r'CATEGORY_OVERVIEW_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.CATEGORY_OVERVIEW_MORE_ACTIONS;
    case r'CATEGORY_DETAILS_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.CATEGORY_DETAILS_MORE_ACTIONS;
    case r'COLLECTION_OVERVIEW_CREATE':
      return Enum$AppExtensionMountEnum.COLLECTION_OVERVIEW_CREATE;
    case r'COLLECTION_OVERVIEW_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.COLLECTION_OVERVIEW_MORE_ACTIONS;
    case r'COLLECTION_DETAILS_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.COLLECTION_DETAILS_MORE_ACTIONS;
    case r'COLLECTION_DETAILS_WIDGETS':
      return Enum$AppExtensionMountEnum.COLLECTION_DETAILS_WIDGETS;
    case r'GIFT_CARD_OVERVIEW_CREATE':
      return Enum$AppExtensionMountEnum.GIFT_CARD_OVERVIEW_CREATE;
    case r'GIFT_CARD_OVERVIEW_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.GIFT_CARD_OVERVIEW_MORE_ACTIONS;
    case r'GIFT_CARD_DETAILS_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.GIFT_CARD_DETAILS_MORE_ACTIONS;
    case r'GIFT_CARD_DETAILS_WIDGETS':
      return Enum$AppExtensionMountEnum.GIFT_CARD_DETAILS_WIDGETS;
    case r'CUSTOMER_OVERVIEW_CREATE':
      return Enum$AppExtensionMountEnum.CUSTOMER_OVERVIEW_CREATE;
    case r'CUSTOMER_OVERVIEW_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.CUSTOMER_OVERVIEW_MORE_ACTIONS;
    case r'CUSTOMER_DETAILS_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.CUSTOMER_DETAILS_MORE_ACTIONS;
    case r'CUSTOMER_DETAILS_WIDGETS':
      return Enum$AppExtensionMountEnum.CUSTOMER_DETAILS_WIDGETS;
    case r'PRODUCT_OVERVIEW_CREATE':
      return Enum$AppExtensionMountEnum.PRODUCT_OVERVIEW_CREATE;
    case r'PRODUCT_OVERVIEW_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.PRODUCT_OVERVIEW_MORE_ACTIONS;
    case r'PRODUCT_DETAILS_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.PRODUCT_DETAILS_MORE_ACTIONS;
    case r'PRODUCT_DETAILS_WIDGETS':
      return Enum$AppExtensionMountEnum.PRODUCT_DETAILS_WIDGETS;
    case r'NAVIGATION_CATALOG':
      return Enum$AppExtensionMountEnum.NAVIGATION_CATALOG;
    case r'NAVIGATION_ORDERS':
      return Enum$AppExtensionMountEnum.NAVIGATION_ORDERS;
    case r'NAVIGATION_CUSTOMERS':
      return Enum$AppExtensionMountEnum.NAVIGATION_CUSTOMERS;
    case r'NAVIGATION_DISCOUNTS':
      return Enum$AppExtensionMountEnum.NAVIGATION_DISCOUNTS;
    case r'NAVIGATION_TRANSLATIONS':
      return Enum$AppExtensionMountEnum.NAVIGATION_TRANSLATIONS;
    case r'NAVIGATION_PAGES':
      return Enum$AppExtensionMountEnum.NAVIGATION_PAGES;
    case r'ORDER_DETAILS_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.ORDER_DETAILS_MORE_ACTIONS;
    case r'ORDER_OVERVIEW_CREATE':
      return Enum$AppExtensionMountEnum.ORDER_OVERVIEW_CREATE;
    case r'ORDER_OVERVIEW_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.ORDER_OVERVIEW_MORE_ACTIONS;
    case r'ORDER_DETAILS_WIDGETS':
      return Enum$AppExtensionMountEnum.ORDER_DETAILS_WIDGETS;
    case r'DRAFT_ORDER_DETAILS_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.DRAFT_ORDER_DETAILS_MORE_ACTIONS;
    case r'DRAFT_ORDER_OVERVIEW_CREATE':
      return Enum$AppExtensionMountEnum.DRAFT_ORDER_OVERVIEW_CREATE;
    case r'DRAFT_ORDER_OVERVIEW_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.DRAFT_ORDER_OVERVIEW_MORE_ACTIONS;
    case r'DRAFT_ORDER_DETAILS_WIDGETS':
      return Enum$AppExtensionMountEnum.DRAFT_ORDER_DETAILS_WIDGETS;
    case r'DISCOUNT_DETAILS_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.DISCOUNT_DETAILS_MORE_ACTIONS;
    case r'DISCOUNT_OVERVIEW_CREATE':
      return Enum$AppExtensionMountEnum.DISCOUNT_OVERVIEW_CREATE;
    case r'DISCOUNT_OVERVIEW_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.DISCOUNT_OVERVIEW_MORE_ACTIONS;
    case r'VOUCHER_DETAILS_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.VOUCHER_DETAILS_MORE_ACTIONS;
    case r'VOUCHER_OVERVIEW_CREATE':
      return Enum$AppExtensionMountEnum.VOUCHER_OVERVIEW_CREATE;
    case r'VOUCHER_OVERVIEW_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.VOUCHER_OVERVIEW_MORE_ACTIONS;
    case r'VOUCHER_DETAILS_WIDGETS':
      return Enum$AppExtensionMountEnum.VOUCHER_DETAILS_WIDGETS;
    case r'PAGE_DETAILS_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.PAGE_DETAILS_MORE_ACTIONS;
    case r'PAGE_OVERVIEW_CREATE':
      return Enum$AppExtensionMountEnum.PAGE_OVERVIEW_CREATE;
    case r'PAGE_OVERVIEW_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.PAGE_OVERVIEW_MORE_ACTIONS;
    case r'PAGE_TYPE_OVERVIEW_CREATE':
      return Enum$AppExtensionMountEnum.PAGE_TYPE_OVERVIEW_CREATE;
    case r'PAGE_TYPE_OVERVIEW_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.PAGE_TYPE_OVERVIEW_MORE_ACTIONS;
    case r'PAGE_TYPE_DETAILS_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.PAGE_TYPE_DETAILS_MORE_ACTIONS;
    case r'MENU_OVERVIEW_CREATE':
      return Enum$AppExtensionMountEnum.MENU_OVERVIEW_CREATE;
    case r'MENU_OVERVIEW_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.MENU_OVERVIEW_MORE_ACTIONS;
    case r'MENU_DETAILS_MORE_ACTIONS':
      return Enum$AppExtensionMountEnum.MENU_DETAILS_MORE_ACTIONS;
    default:
      return Enum$AppExtensionMountEnum.$unknown;
  }
}

enum Enum$AppExtensionTargetEnum {
  POPUP,
  APP_PAGE,
  NEW_TAB,
  WIDGET,
  $unknown;

  factory Enum$AppExtensionTargetEnum.fromJson(String value) =>
      fromJson$Enum$AppExtensionTargetEnum(value);

  String toJson() => toJson$Enum$AppExtensionTargetEnum(this);
}

String toJson$Enum$AppExtensionTargetEnum(Enum$AppExtensionTargetEnum e) {
  switch (e) {
    case Enum$AppExtensionTargetEnum.POPUP:
      return r'POPUP';
    case Enum$AppExtensionTargetEnum.APP_PAGE:
      return r'APP_PAGE';
    case Enum$AppExtensionTargetEnum.NEW_TAB:
      return r'NEW_TAB';
    case Enum$AppExtensionTargetEnum.WIDGET:
      return r'WIDGET';
    case Enum$AppExtensionTargetEnum.$unknown:
      return r'$unknown';
  }
}

Enum$AppExtensionTargetEnum fromJson$Enum$AppExtensionTargetEnum(String value) {
  switch (value) {
    case r'POPUP':
      return Enum$AppExtensionTargetEnum.POPUP;
    case r'APP_PAGE':
      return Enum$AppExtensionTargetEnum.APP_PAGE;
    case r'NEW_TAB':
      return Enum$AppExtensionTargetEnum.NEW_TAB;
    case r'WIDGET':
      return Enum$AppExtensionTargetEnum.WIDGET;
    default:
      return Enum$AppExtensionTargetEnum.$unknown;
  }
}

enum Enum$AppSortField {
  NAME,
  CREATION_DATE,
  $unknown;

  factory Enum$AppSortField.fromJson(String value) =>
      fromJson$Enum$AppSortField(value);

  String toJson() => toJson$Enum$AppSortField(this);
}

String toJson$Enum$AppSortField(Enum$AppSortField e) {
  switch (e) {
    case Enum$AppSortField.NAME:
      return r'NAME';
    case Enum$AppSortField.CREATION_DATE:
      return r'CREATION_DATE';
    case Enum$AppSortField.$unknown:
      return r'$unknown';
  }
}

Enum$AppSortField fromJson$Enum$AppSortField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$AppSortField.NAME;
    case r'CREATION_DATE':
      return Enum$AppSortField.CREATION_DATE;
    default:
      return Enum$AppSortField.$unknown;
  }
}

enum Enum$AppTypeEnum {
  LOCAL,
  THIRDPARTY,
  $unknown;

  factory Enum$AppTypeEnum.fromJson(String value) =>
      fromJson$Enum$AppTypeEnum(value);

  String toJson() => toJson$Enum$AppTypeEnum(this);
}

String toJson$Enum$AppTypeEnum(Enum$AppTypeEnum e) {
  switch (e) {
    case Enum$AppTypeEnum.LOCAL:
      return r'LOCAL';
    case Enum$AppTypeEnum.THIRDPARTY:
      return r'THIRDPARTY';
    case Enum$AppTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$AppTypeEnum fromJson$Enum$AppTypeEnum(String value) {
  switch (value) {
    case r'LOCAL':
      return Enum$AppTypeEnum.LOCAL;
    case r'THIRDPARTY':
      return Enum$AppTypeEnum.THIRDPARTY;
    default:
      return Enum$AppTypeEnum.$unknown;
  }
}

enum Enum$AreaUnitsEnum {
  SQ_MM,
  SQ_CM,
  SQ_DM,
  SQ_M,
  SQ_KM,
  SQ_FT,
  SQ_YD,
  SQ_INCH,
  $unknown;

  factory Enum$AreaUnitsEnum.fromJson(String value) =>
      fromJson$Enum$AreaUnitsEnum(value);

  String toJson() => toJson$Enum$AreaUnitsEnum(this);
}

String toJson$Enum$AreaUnitsEnum(Enum$AreaUnitsEnum e) {
  switch (e) {
    case Enum$AreaUnitsEnum.SQ_MM:
      return r'SQ_MM';
    case Enum$AreaUnitsEnum.SQ_CM:
      return r'SQ_CM';
    case Enum$AreaUnitsEnum.SQ_DM:
      return r'SQ_DM';
    case Enum$AreaUnitsEnum.SQ_M:
      return r'SQ_M';
    case Enum$AreaUnitsEnum.SQ_KM:
      return r'SQ_KM';
    case Enum$AreaUnitsEnum.SQ_FT:
      return r'SQ_FT';
    case Enum$AreaUnitsEnum.SQ_YD:
      return r'SQ_YD';
    case Enum$AreaUnitsEnum.SQ_INCH:
      return r'SQ_INCH';
    case Enum$AreaUnitsEnum.$unknown:
      return r'$unknown';
  }
}

Enum$AreaUnitsEnum fromJson$Enum$AreaUnitsEnum(String value) {
  switch (value) {
    case r'SQ_MM':
      return Enum$AreaUnitsEnum.SQ_MM;
    case r'SQ_CM':
      return Enum$AreaUnitsEnum.SQ_CM;
    case r'SQ_DM':
      return Enum$AreaUnitsEnum.SQ_DM;
    case r'SQ_M':
      return Enum$AreaUnitsEnum.SQ_M;
    case r'SQ_KM':
      return Enum$AreaUnitsEnum.SQ_KM;
    case r'SQ_FT':
      return Enum$AreaUnitsEnum.SQ_FT;
    case r'SQ_YD':
      return Enum$AreaUnitsEnum.SQ_YD;
    case r'SQ_INCH':
      return Enum$AreaUnitsEnum.SQ_INCH;
    default:
      return Enum$AreaUnitsEnum.$unknown;
  }
}

enum Enum$AttributeBulkCreateErrorCode {
  ALREADY_EXISTS,
  BLANK,
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  DUPLICATED_INPUT_ITEM,
  MAX_LENGTH,
  $unknown;

  factory Enum$AttributeBulkCreateErrorCode.fromJson(String value) =>
      fromJson$Enum$AttributeBulkCreateErrorCode(value);

  String toJson() => toJson$Enum$AttributeBulkCreateErrorCode(this);
}

String toJson$Enum$AttributeBulkCreateErrorCode(
    Enum$AttributeBulkCreateErrorCode e) {
  switch (e) {
    case Enum$AttributeBulkCreateErrorCode.ALREADY_EXISTS:
      return r'ALREADY_EXISTS';
    case Enum$AttributeBulkCreateErrorCode.BLANK:
      return r'BLANK';
    case Enum$AttributeBulkCreateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$AttributeBulkCreateErrorCode.INVALID:
      return r'INVALID';
    case Enum$AttributeBulkCreateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$AttributeBulkCreateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$AttributeBulkCreateErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$AttributeBulkCreateErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$AttributeBulkCreateErrorCode.MAX_LENGTH:
      return r'MAX_LENGTH';
    case Enum$AttributeBulkCreateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$AttributeBulkCreateErrorCode fromJson$Enum$AttributeBulkCreateErrorCode(
    String value) {
  switch (value) {
    case r'ALREADY_EXISTS':
      return Enum$AttributeBulkCreateErrorCode.ALREADY_EXISTS;
    case r'BLANK':
      return Enum$AttributeBulkCreateErrorCode.BLANK;
    case r'GRAPHQL_ERROR':
      return Enum$AttributeBulkCreateErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$AttributeBulkCreateErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$AttributeBulkCreateErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$AttributeBulkCreateErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$AttributeBulkCreateErrorCode.UNIQUE;
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$AttributeBulkCreateErrorCode.DUPLICATED_INPUT_ITEM;
    case r'MAX_LENGTH':
      return Enum$AttributeBulkCreateErrorCode.MAX_LENGTH;
    default:
      return Enum$AttributeBulkCreateErrorCode.$unknown;
  }
}

enum Enum$AttributeBulkUpdateErrorCode {
  ALREADY_EXISTS,
  BLANK,
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  DUPLICATED_INPUT_ITEM,
  MAX_LENGTH,
  $unknown;

  factory Enum$AttributeBulkUpdateErrorCode.fromJson(String value) =>
      fromJson$Enum$AttributeBulkUpdateErrorCode(value);

  String toJson() => toJson$Enum$AttributeBulkUpdateErrorCode(this);
}

String toJson$Enum$AttributeBulkUpdateErrorCode(
    Enum$AttributeBulkUpdateErrorCode e) {
  switch (e) {
    case Enum$AttributeBulkUpdateErrorCode.ALREADY_EXISTS:
      return r'ALREADY_EXISTS';
    case Enum$AttributeBulkUpdateErrorCode.BLANK:
      return r'BLANK';
    case Enum$AttributeBulkUpdateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$AttributeBulkUpdateErrorCode.INVALID:
      return r'INVALID';
    case Enum$AttributeBulkUpdateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$AttributeBulkUpdateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$AttributeBulkUpdateErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$AttributeBulkUpdateErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$AttributeBulkUpdateErrorCode.MAX_LENGTH:
      return r'MAX_LENGTH';
    case Enum$AttributeBulkUpdateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$AttributeBulkUpdateErrorCode fromJson$Enum$AttributeBulkUpdateErrorCode(
    String value) {
  switch (value) {
    case r'ALREADY_EXISTS':
      return Enum$AttributeBulkUpdateErrorCode.ALREADY_EXISTS;
    case r'BLANK':
      return Enum$AttributeBulkUpdateErrorCode.BLANK;
    case r'GRAPHQL_ERROR':
      return Enum$AttributeBulkUpdateErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$AttributeBulkUpdateErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$AttributeBulkUpdateErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$AttributeBulkUpdateErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$AttributeBulkUpdateErrorCode.UNIQUE;
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$AttributeBulkUpdateErrorCode.DUPLICATED_INPUT_ITEM;
    case r'MAX_LENGTH':
      return Enum$AttributeBulkUpdateErrorCode.MAX_LENGTH;
    default:
      return Enum$AttributeBulkUpdateErrorCode.$unknown;
  }
}

enum Enum$AttributeChoicesSortField {
  NAME,
  SLUG,
  $unknown;

  factory Enum$AttributeChoicesSortField.fromJson(String value) =>
      fromJson$Enum$AttributeChoicesSortField(value);

  String toJson() => toJson$Enum$AttributeChoicesSortField(this);
}

String toJson$Enum$AttributeChoicesSortField(Enum$AttributeChoicesSortField e) {
  switch (e) {
    case Enum$AttributeChoicesSortField.NAME:
      return r'NAME';
    case Enum$AttributeChoicesSortField.SLUG:
      return r'SLUG';
    case Enum$AttributeChoicesSortField.$unknown:
      return r'$unknown';
  }
}

Enum$AttributeChoicesSortField fromJson$Enum$AttributeChoicesSortField(
    String value) {
  switch (value) {
    case r'NAME':
      return Enum$AttributeChoicesSortField.NAME;
    case r'SLUG':
      return Enum$AttributeChoicesSortField.SLUG;
    default:
      return Enum$AttributeChoicesSortField.$unknown;
  }
}

enum Enum$AttributeEntityTypeEnum {
  PAGE,
  PRODUCT,
  PRODUCT_VARIANT,
  $unknown;

  factory Enum$AttributeEntityTypeEnum.fromJson(String value) =>
      fromJson$Enum$AttributeEntityTypeEnum(value);

  String toJson() => toJson$Enum$AttributeEntityTypeEnum(this);
}

String toJson$Enum$AttributeEntityTypeEnum(Enum$AttributeEntityTypeEnum e) {
  switch (e) {
    case Enum$AttributeEntityTypeEnum.PAGE:
      return r'PAGE';
    case Enum$AttributeEntityTypeEnum.PRODUCT:
      return r'PRODUCT';
    case Enum$AttributeEntityTypeEnum.PRODUCT_VARIANT:
      return r'PRODUCT_VARIANT';
    case Enum$AttributeEntityTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$AttributeEntityTypeEnum fromJson$Enum$AttributeEntityTypeEnum(
    String value) {
  switch (value) {
    case r'PAGE':
      return Enum$AttributeEntityTypeEnum.PAGE;
    case r'PRODUCT':
      return Enum$AttributeEntityTypeEnum.PRODUCT;
    case r'PRODUCT_VARIANT':
      return Enum$AttributeEntityTypeEnum.PRODUCT_VARIANT;
    default:
      return Enum$AttributeEntityTypeEnum.$unknown;
  }
}

enum Enum$AttributeErrorCode {
  ALREADY_EXISTS,
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  $unknown;

  factory Enum$AttributeErrorCode.fromJson(String value) =>
      fromJson$Enum$AttributeErrorCode(value);

  String toJson() => toJson$Enum$AttributeErrorCode(this);
}

String toJson$Enum$AttributeErrorCode(Enum$AttributeErrorCode e) {
  switch (e) {
    case Enum$AttributeErrorCode.ALREADY_EXISTS:
      return r'ALREADY_EXISTS';
    case Enum$AttributeErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$AttributeErrorCode.INVALID:
      return r'INVALID';
    case Enum$AttributeErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$AttributeErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$AttributeErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$AttributeErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$AttributeErrorCode fromJson$Enum$AttributeErrorCode(String value) {
  switch (value) {
    case r'ALREADY_EXISTS':
      return Enum$AttributeErrorCode.ALREADY_EXISTS;
    case r'GRAPHQL_ERROR':
      return Enum$AttributeErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$AttributeErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$AttributeErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$AttributeErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$AttributeErrorCode.UNIQUE;
    default:
      return Enum$AttributeErrorCode.$unknown;
  }
}

enum Enum$AttributeInputTypeEnum {
  DROPDOWN,
  MULTISELECT,
  FILE,
  REFERENCE,
  NUMERIC,
  RICH_TEXT,
  PLAIN_TEXT,
  SWATCH,
  BOOLEAN,
  DATE,
  DATE_TIME,
  $unknown;

  factory Enum$AttributeInputTypeEnum.fromJson(String value) =>
      fromJson$Enum$AttributeInputTypeEnum(value);

  String toJson() => toJson$Enum$AttributeInputTypeEnum(this);
}

String toJson$Enum$AttributeInputTypeEnum(Enum$AttributeInputTypeEnum e) {
  switch (e) {
    case Enum$AttributeInputTypeEnum.DROPDOWN:
      return r'DROPDOWN';
    case Enum$AttributeInputTypeEnum.MULTISELECT:
      return r'MULTISELECT';
    case Enum$AttributeInputTypeEnum.FILE:
      return r'FILE';
    case Enum$AttributeInputTypeEnum.REFERENCE:
      return r'REFERENCE';
    case Enum$AttributeInputTypeEnum.NUMERIC:
      return r'NUMERIC';
    case Enum$AttributeInputTypeEnum.RICH_TEXT:
      return r'RICH_TEXT';
    case Enum$AttributeInputTypeEnum.PLAIN_TEXT:
      return r'PLAIN_TEXT';
    case Enum$AttributeInputTypeEnum.SWATCH:
      return r'SWATCH';
    case Enum$AttributeInputTypeEnum.BOOLEAN:
      return r'BOOLEAN';
    case Enum$AttributeInputTypeEnum.DATE:
      return r'DATE';
    case Enum$AttributeInputTypeEnum.DATE_TIME:
      return r'DATE_TIME';
    case Enum$AttributeInputTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$AttributeInputTypeEnum fromJson$Enum$AttributeInputTypeEnum(String value) {
  switch (value) {
    case r'DROPDOWN':
      return Enum$AttributeInputTypeEnum.DROPDOWN;
    case r'MULTISELECT':
      return Enum$AttributeInputTypeEnum.MULTISELECT;
    case r'FILE':
      return Enum$AttributeInputTypeEnum.FILE;
    case r'REFERENCE':
      return Enum$AttributeInputTypeEnum.REFERENCE;
    case r'NUMERIC':
      return Enum$AttributeInputTypeEnum.NUMERIC;
    case r'RICH_TEXT':
      return Enum$AttributeInputTypeEnum.RICH_TEXT;
    case r'PLAIN_TEXT':
      return Enum$AttributeInputTypeEnum.PLAIN_TEXT;
    case r'SWATCH':
      return Enum$AttributeInputTypeEnum.SWATCH;
    case r'BOOLEAN':
      return Enum$AttributeInputTypeEnum.BOOLEAN;
    case r'DATE':
      return Enum$AttributeInputTypeEnum.DATE;
    case r'DATE_TIME':
      return Enum$AttributeInputTypeEnum.DATE_TIME;
    default:
      return Enum$AttributeInputTypeEnum.$unknown;
  }
}

enum Enum$AttributeSortField {
  NAME,
  SLUG,
  VALUE_REQUIRED,
  IS_VARIANT_ONLY,
  VISIBLE_IN_STOREFRONT,
  FILTERABLE_IN_STOREFRONT,
  FILTERABLE_IN_DASHBOARD,
  STOREFRONT_SEARCH_POSITION,
  AVAILABLE_IN_GRID,
  $unknown;

  factory Enum$AttributeSortField.fromJson(String value) =>
      fromJson$Enum$AttributeSortField(value);

  String toJson() => toJson$Enum$AttributeSortField(this);
}

String toJson$Enum$AttributeSortField(Enum$AttributeSortField e) {
  switch (e) {
    case Enum$AttributeSortField.NAME:
      return r'NAME';
    case Enum$AttributeSortField.SLUG:
      return r'SLUG';
    case Enum$AttributeSortField.VALUE_REQUIRED:
      return r'VALUE_REQUIRED';
    case Enum$AttributeSortField.IS_VARIANT_ONLY:
      return r'IS_VARIANT_ONLY';
    case Enum$AttributeSortField.VISIBLE_IN_STOREFRONT:
      return r'VISIBLE_IN_STOREFRONT';
    case Enum$AttributeSortField.FILTERABLE_IN_STOREFRONT:
      return r'FILTERABLE_IN_STOREFRONT';
    case Enum$AttributeSortField.FILTERABLE_IN_DASHBOARD:
      return r'FILTERABLE_IN_DASHBOARD';
    case Enum$AttributeSortField.STOREFRONT_SEARCH_POSITION:
      return r'STOREFRONT_SEARCH_POSITION';
    case Enum$AttributeSortField.AVAILABLE_IN_GRID:
      return r'AVAILABLE_IN_GRID';
    case Enum$AttributeSortField.$unknown:
      return r'$unknown';
  }
}

Enum$AttributeSortField fromJson$Enum$AttributeSortField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$AttributeSortField.NAME;
    case r'SLUG':
      return Enum$AttributeSortField.SLUG;
    case r'VALUE_REQUIRED':
      return Enum$AttributeSortField.VALUE_REQUIRED;
    case r'IS_VARIANT_ONLY':
      return Enum$AttributeSortField.IS_VARIANT_ONLY;
    case r'VISIBLE_IN_STOREFRONT':
      return Enum$AttributeSortField.VISIBLE_IN_STOREFRONT;
    case r'FILTERABLE_IN_STOREFRONT':
      return Enum$AttributeSortField.FILTERABLE_IN_STOREFRONT;
    case r'FILTERABLE_IN_DASHBOARD':
      return Enum$AttributeSortField.FILTERABLE_IN_DASHBOARD;
    case r'STOREFRONT_SEARCH_POSITION':
      return Enum$AttributeSortField.STOREFRONT_SEARCH_POSITION;
    case r'AVAILABLE_IN_GRID':
      return Enum$AttributeSortField.AVAILABLE_IN_GRID;
    default:
      return Enum$AttributeSortField.$unknown;
  }
}

enum Enum$AttributeTranslateErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  $unknown;

  factory Enum$AttributeTranslateErrorCode.fromJson(String value) =>
      fromJson$Enum$AttributeTranslateErrorCode(value);

  String toJson() => toJson$Enum$AttributeTranslateErrorCode(this);
}

String toJson$Enum$AttributeTranslateErrorCode(
    Enum$AttributeTranslateErrorCode e) {
  switch (e) {
    case Enum$AttributeTranslateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$AttributeTranslateErrorCode.INVALID:
      return r'INVALID';
    case Enum$AttributeTranslateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$AttributeTranslateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$AttributeTranslateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$AttributeTranslateErrorCode fromJson$Enum$AttributeTranslateErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$AttributeTranslateErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$AttributeTranslateErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$AttributeTranslateErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$AttributeTranslateErrorCode.REQUIRED;
    default:
      return Enum$AttributeTranslateErrorCode.$unknown;
  }
}

enum Enum$AttributeTypeEnum {
  PRODUCT_TYPE,
  PAGE_TYPE,
  $unknown;

  factory Enum$AttributeTypeEnum.fromJson(String value) =>
      fromJson$Enum$AttributeTypeEnum(value);

  String toJson() => toJson$Enum$AttributeTypeEnum(this);
}

String toJson$Enum$AttributeTypeEnum(Enum$AttributeTypeEnum e) {
  switch (e) {
    case Enum$AttributeTypeEnum.PRODUCT_TYPE:
      return r'PRODUCT_TYPE';
    case Enum$AttributeTypeEnum.PAGE_TYPE:
      return r'PAGE_TYPE';
    case Enum$AttributeTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$AttributeTypeEnum fromJson$Enum$AttributeTypeEnum(String value) {
  switch (value) {
    case r'PRODUCT_TYPE':
      return Enum$AttributeTypeEnum.PRODUCT_TYPE;
    case r'PAGE_TYPE':
      return Enum$AttributeTypeEnum.PAGE_TYPE;
    default:
      return Enum$AttributeTypeEnum.$unknown;
  }
}

enum Enum$AttributeValueTranslateErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  $unknown;

  factory Enum$AttributeValueTranslateErrorCode.fromJson(String value) =>
      fromJson$Enum$AttributeValueTranslateErrorCode(value);

  String toJson() => toJson$Enum$AttributeValueTranslateErrorCode(this);
}

String toJson$Enum$AttributeValueTranslateErrorCode(
    Enum$AttributeValueTranslateErrorCode e) {
  switch (e) {
    case Enum$AttributeValueTranslateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$AttributeValueTranslateErrorCode.INVALID:
      return r'INVALID';
    case Enum$AttributeValueTranslateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$AttributeValueTranslateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$AttributeValueTranslateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$AttributeValueTranslateErrorCode
    fromJson$Enum$AttributeValueTranslateErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$AttributeValueTranslateErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$AttributeValueTranslateErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$AttributeValueTranslateErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$AttributeValueTranslateErrorCode.REQUIRED;
    default:
      return Enum$AttributeValueTranslateErrorCode.$unknown;
  }
}

enum Enum$CategorySortField {
  NAME,
  PRODUCT_COUNT,
  SUBCATEGORY_COUNT,
  $unknown;

  factory Enum$CategorySortField.fromJson(String value) =>
      fromJson$Enum$CategorySortField(value);

  String toJson() => toJson$Enum$CategorySortField(this);
}

String toJson$Enum$CategorySortField(Enum$CategorySortField e) {
  switch (e) {
    case Enum$CategorySortField.NAME:
      return r'NAME';
    case Enum$CategorySortField.PRODUCT_COUNT:
      return r'PRODUCT_COUNT';
    case Enum$CategorySortField.SUBCATEGORY_COUNT:
      return r'SUBCATEGORY_COUNT';
    case Enum$CategorySortField.$unknown:
      return r'$unknown';
  }
}

Enum$CategorySortField fromJson$Enum$CategorySortField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$CategorySortField.NAME;
    case r'PRODUCT_COUNT':
      return Enum$CategorySortField.PRODUCT_COUNT;
    case r'SUBCATEGORY_COUNT':
      return Enum$CategorySortField.SUBCATEGORY_COUNT;
    default:
      return Enum$CategorySortField.$unknown;
  }
}

enum Enum$ChannelErrorCode {
  ALREADY_EXISTS,
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  CHANNELS_CURRENCY_MUST_BE_THE_SAME,
  CHANNEL_WITH_ORDERS,
  DUPLICATED_INPUT_ITEM,
  $unknown;

  factory Enum$ChannelErrorCode.fromJson(String value) =>
      fromJson$Enum$ChannelErrorCode(value);

  String toJson() => toJson$Enum$ChannelErrorCode(this);
}

String toJson$Enum$ChannelErrorCode(Enum$ChannelErrorCode e) {
  switch (e) {
    case Enum$ChannelErrorCode.ALREADY_EXISTS:
      return r'ALREADY_EXISTS';
    case Enum$ChannelErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$ChannelErrorCode.INVALID:
      return r'INVALID';
    case Enum$ChannelErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$ChannelErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$ChannelErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$ChannelErrorCode.CHANNELS_CURRENCY_MUST_BE_THE_SAME:
      return r'CHANNELS_CURRENCY_MUST_BE_THE_SAME';
    case Enum$ChannelErrorCode.CHANNEL_WITH_ORDERS:
      return r'CHANNEL_WITH_ORDERS';
    case Enum$ChannelErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$ChannelErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$ChannelErrorCode fromJson$Enum$ChannelErrorCode(String value) {
  switch (value) {
    case r'ALREADY_EXISTS':
      return Enum$ChannelErrorCode.ALREADY_EXISTS;
    case r'GRAPHQL_ERROR':
      return Enum$ChannelErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$ChannelErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$ChannelErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$ChannelErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$ChannelErrorCode.UNIQUE;
    case r'CHANNELS_CURRENCY_MUST_BE_THE_SAME':
      return Enum$ChannelErrorCode.CHANNELS_CURRENCY_MUST_BE_THE_SAME;
    case r'CHANNEL_WITH_ORDERS':
      return Enum$ChannelErrorCode.CHANNEL_WITH_ORDERS;
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$ChannelErrorCode.DUPLICATED_INPUT_ITEM;
    default:
      return Enum$ChannelErrorCode.$unknown;
  }
}

enum Enum$CheckoutAuthorizeStatusEnum {
  NONE,
  PARTIAL,
  FULL,
  $unknown;

  factory Enum$CheckoutAuthorizeStatusEnum.fromJson(String value) =>
      fromJson$Enum$CheckoutAuthorizeStatusEnum(value);

  String toJson() => toJson$Enum$CheckoutAuthorizeStatusEnum(this);
}

String toJson$Enum$CheckoutAuthorizeStatusEnum(
    Enum$CheckoutAuthorizeStatusEnum e) {
  switch (e) {
    case Enum$CheckoutAuthorizeStatusEnum.NONE:
      return r'NONE';
    case Enum$CheckoutAuthorizeStatusEnum.PARTIAL:
      return r'PARTIAL';
    case Enum$CheckoutAuthorizeStatusEnum.FULL:
      return r'FULL';
    case Enum$CheckoutAuthorizeStatusEnum.$unknown:
      return r'$unknown';
  }
}

Enum$CheckoutAuthorizeStatusEnum fromJson$Enum$CheckoutAuthorizeStatusEnum(
    String value) {
  switch (value) {
    case r'NONE':
      return Enum$CheckoutAuthorizeStatusEnum.NONE;
    case r'PARTIAL':
      return Enum$CheckoutAuthorizeStatusEnum.PARTIAL;
    case r'FULL':
      return Enum$CheckoutAuthorizeStatusEnum.FULL;
    default:
      return Enum$CheckoutAuthorizeStatusEnum.$unknown;
  }
}

enum Enum$CheckoutChargeStatusEnum {
  NONE,
  PARTIAL,
  FULL,
  OVERCHARGED,
  $unknown;

  factory Enum$CheckoutChargeStatusEnum.fromJson(String value) =>
      fromJson$Enum$CheckoutChargeStatusEnum(value);

  String toJson() => toJson$Enum$CheckoutChargeStatusEnum(this);
}

String toJson$Enum$CheckoutChargeStatusEnum(Enum$CheckoutChargeStatusEnum e) {
  switch (e) {
    case Enum$CheckoutChargeStatusEnum.NONE:
      return r'NONE';
    case Enum$CheckoutChargeStatusEnum.PARTIAL:
      return r'PARTIAL';
    case Enum$CheckoutChargeStatusEnum.FULL:
      return r'FULL';
    case Enum$CheckoutChargeStatusEnum.OVERCHARGED:
      return r'OVERCHARGED';
    case Enum$CheckoutChargeStatusEnum.$unknown:
      return r'$unknown';
  }
}

Enum$CheckoutChargeStatusEnum fromJson$Enum$CheckoutChargeStatusEnum(
    String value) {
  switch (value) {
    case r'NONE':
      return Enum$CheckoutChargeStatusEnum.NONE;
    case r'PARTIAL':
      return Enum$CheckoutChargeStatusEnum.PARTIAL;
    case r'FULL':
      return Enum$CheckoutChargeStatusEnum.FULL;
    case r'OVERCHARGED':
      return Enum$CheckoutChargeStatusEnum.OVERCHARGED;
    default:
      return Enum$CheckoutChargeStatusEnum.$unknown;
  }
}

enum Enum$CheckoutCreateFromOrderErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  ORDER_NOT_FOUND,
  CHANNEL_INACTIVE,
  TAX_ERROR,
  $unknown;

  factory Enum$CheckoutCreateFromOrderErrorCode.fromJson(String value) =>
      fromJson$Enum$CheckoutCreateFromOrderErrorCode(value);

  String toJson() => toJson$Enum$CheckoutCreateFromOrderErrorCode(this);
}

String toJson$Enum$CheckoutCreateFromOrderErrorCode(
    Enum$CheckoutCreateFromOrderErrorCode e) {
  switch (e) {
    case Enum$CheckoutCreateFromOrderErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$CheckoutCreateFromOrderErrorCode.INVALID:
      return r'INVALID';
    case Enum$CheckoutCreateFromOrderErrorCode.ORDER_NOT_FOUND:
      return r'ORDER_NOT_FOUND';
    case Enum$CheckoutCreateFromOrderErrorCode.CHANNEL_INACTIVE:
      return r'CHANNEL_INACTIVE';
    case Enum$CheckoutCreateFromOrderErrorCode.TAX_ERROR:
      return r'TAX_ERROR';
    case Enum$CheckoutCreateFromOrderErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$CheckoutCreateFromOrderErrorCode
    fromJson$Enum$CheckoutCreateFromOrderErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$CheckoutCreateFromOrderErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$CheckoutCreateFromOrderErrorCode.INVALID;
    case r'ORDER_NOT_FOUND':
      return Enum$CheckoutCreateFromOrderErrorCode.ORDER_NOT_FOUND;
    case r'CHANNEL_INACTIVE':
      return Enum$CheckoutCreateFromOrderErrorCode.CHANNEL_INACTIVE;
    case r'TAX_ERROR':
      return Enum$CheckoutCreateFromOrderErrorCode.TAX_ERROR;
    default:
      return Enum$CheckoutCreateFromOrderErrorCode.$unknown;
  }
}

enum Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode {
  NOT_FOUND,
  PRODUCT_UNAVAILABLE_FOR_PURCHASE,
  UNAVAILABLE_VARIANT_IN_CHANNEL,
  PRODUCT_NOT_PUBLISHED,
  QUANTITY_GREATER_THAN_LIMIT,
  INSUFFICIENT_STOCK,
  $unknown;

  factory Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode.fromJson(
          String value) =>
      fromJson$Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode(value);

  String toJson() =>
      toJson$Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode(this);
}

String toJson$Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode(
    Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode e) {
  switch (e) {
    case Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode
          .PRODUCT_UNAVAILABLE_FOR_PURCHASE:
      return r'PRODUCT_UNAVAILABLE_FOR_PURCHASE';
    case Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode
          .UNAVAILABLE_VARIANT_IN_CHANNEL:
      return r'UNAVAILABLE_VARIANT_IN_CHANNEL';
    case Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode
          .PRODUCT_NOT_PUBLISHED:
      return r'PRODUCT_NOT_PUBLISHED';
    case Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode
          .QUANTITY_GREATER_THAN_LIMIT:
      return r'QUANTITY_GREATER_THAN_LIMIT';
    case Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode
          .INSUFFICIENT_STOCK:
      return r'INSUFFICIENT_STOCK';
    case Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode
    fromJson$Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode(
        String value) {
  switch (value) {
    case r'NOT_FOUND':
      return Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode.NOT_FOUND;
    case r'PRODUCT_UNAVAILABLE_FOR_PURCHASE':
      return Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode
          .PRODUCT_UNAVAILABLE_FOR_PURCHASE;
    case r'UNAVAILABLE_VARIANT_IN_CHANNEL':
      return Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode
          .UNAVAILABLE_VARIANT_IN_CHANNEL;
    case r'PRODUCT_NOT_PUBLISHED':
      return Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode
          .PRODUCT_NOT_PUBLISHED;
    case r'QUANTITY_GREATER_THAN_LIMIT':
      return Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode
          .QUANTITY_GREATER_THAN_LIMIT;
    case r'INSUFFICIENT_STOCK':
      return Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode
          .INSUFFICIENT_STOCK;
    default:
      return Enum$CheckoutCreateFromOrderUnavailableVariantErrorCode.$unknown;
  }
}

enum Enum$CheckoutErrorCode {
  BILLING_ADDRESS_NOT_SET,
  CHECKOUT_NOT_FULLY_PAID,
  GRAPHQL_ERROR,
  PRODUCT_NOT_PUBLISHED,
  PRODUCT_UNAVAILABLE_FOR_PURCHASE,
  INSUFFICIENT_STOCK,
  INVALID,
  INVALID_SHIPPING_METHOD,
  NOT_FOUND,
  PAYMENT_ERROR,
  QUANTITY_GREATER_THAN_LIMIT,
  REQUIRED,
  SHIPPING_ADDRESS_NOT_SET,
  SHIPPING_METHOD_NOT_APPLICABLE,
  DELIVERY_METHOD_NOT_APPLICABLE,
  SHIPPING_METHOD_NOT_SET,
  SHIPPING_NOT_REQUIRED,
  TAX_ERROR,
  UNIQUE,
  VOUCHER_NOT_APPLICABLE,
  GIFT_CARD_NOT_APPLICABLE,
  ZERO_QUANTITY,
  MISSING_CHANNEL_SLUG,
  CHANNEL_INACTIVE,
  UNAVAILABLE_VARIANT_IN_CHANNEL,
  EMAIL_NOT_SET,
  NO_LINES,
  INACTIVE_PAYMENT,
  NON_EDITABLE_GIFT_LINE,
  NON_REMOVABLE_GIFT_LINE,
  SHIPPING_CHANGE_FORBIDDEN,
  MISSING_ADDRESS_DATA,
  $unknown;

  factory Enum$CheckoutErrorCode.fromJson(String value) =>
      fromJson$Enum$CheckoutErrorCode(value);

  String toJson() => toJson$Enum$CheckoutErrorCode(this);
}

String toJson$Enum$CheckoutErrorCode(Enum$CheckoutErrorCode e) {
  switch (e) {
    case Enum$CheckoutErrorCode.BILLING_ADDRESS_NOT_SET:
      return r'BILLING_ADDRESS_NOT_SET';
    case Enum$CheckoutErrorCode.CHECKOUT_NOT_FULLY_PAID:
      return r'CHECKOUT_NOT_FULLY_PAID';
    case Enum$CheckoutErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$CheckoutErrorCode.PRODUCT_NOT_PUBLISHED:
      return r'PRODUCT_NOT_PUBLISHED';
    case Enum$CheckoutErrorCode.PRODUCT_UNAVAILABLE_FOR_PURCHASE:
      return r'PRODUCT_UNAVAILABLE_FOR_PURCHASE';
    case Enum$CheckoutErrorCode.INSUFFICIENT_STOCK:
      return r'INSUFFICIENT_STOCK';
    case Enum$CheckoutErrorCode.INVALID:
      return r'INVALID';
    case Enum$CheckoutErrorCode.INVALID_SHIPPING_METHOD:
      return r'INVALID_SHIPPING_METHOD';
    case Enum$CheckoutErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$CheckoutErrorCode.PAYMENT_ERROR:
      return r'PAYMENT_ERROR';
    case Enum$CheckoutErrorCode.QUANTITY_GREATER_THAN_LIMIT:
      return r'QUANTITY_GREATER_THAN_LIMIT';
    case Enum$CheckoutErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$CheckoutErrorCode.SHIPPING_ADDRESS_NOT_SET:
      return r'SHIPPING_ADDRESS_NOT_SET';
    case Enum$CheckoutErrorCode.SHIPPING_METHOD_NOT_APPLICABLE:
      return r'SHIPPING_METHOD_NOT_APPLICABLE';
    case Enum$CheckoutErrorCode.DELIVERY_METHOD_NOT_APPLICABLE:
      return r'DELIVERY_METHOD_NOT_APPLICABLE';
    case Enum$CheckoutErrorCode.SHIPPING_METHOD_NOT_SET:
      return r'SHIPPING_METHOD_NOT_SET';
    case Enum$CheckoutErrorCode.SHIPPING_NOT_REQUIRED:
      return r'SHIPPING_NOT_REQUIRED';
    case Enum$CheckoutErrorCode.TAX_ERROR:
      return r'TAX_ERROR';
    case Enum$CheckoutErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$CheckoutErrorCode.VOUCHER_NOT_APPLICABLE:
      return r'VOUCHER_NOT_APPLICABLE';
    case Enum$CheckoutErrorCode.GIFT_CARD_NOT_APPLICABLE:
      return r'GIFT_CARD_NOT_APPLICABLE';
    case Enum$CheckoutErrorCode.ZERO_QUANTITY:
      return r'ZERO_QUANTITY';
    case Enum$CheckoutErrorCode.MISSING_CHANNEL_SLUG:
      return r'MISSING_CHANNEL_SLUG';
    case Enum$CheckoutErrorCode.CHANNEL_INACTIVE:
      return r'CHANNEL_INACTIVE';
    case Enum$CheckoutErrorCode.UNAVAILABLE_VARIANT_IN_CHANNEL:
      return r'UNAVAILABLE_VARIANT_IN_CHANNEL';
    case Enum$CheckoutErrorCode.EMAIL_NOT_SET:
      return r'EMAIL_NOT_SET';
    case Enum$CheckoutErrorCode.NO_LINES:
      return r'NO_LINES';
    case Enum$CheckoutErrorCode.INACTIVE_PAYMENT:
      return r'INACTIVE_PAYMENT';
    case Enum$CheckoutErrorCode.NON_EDITABLE_GIFT_LINE:
      return r'NON_EDITABLE_GIFT_LINE';
    case Enum$CheckoutErrorCode.NON_REMOVABLE_GIFT_LINE:
      return r'NON_REMOVABLE_GIFT_LINE';
    case Enum$CheckoutErrorCode.SHIPPING_CHANGE_FORBIDDEN:
      return r'SHIPPING_CHANGE_FORBIDDEN';
    case Enum$CheckoutErrorCode.MISSING_ADDRESS_DATA:
      return r'MISSING_ADDRESS_DATA';
    case Enum$CheckoutErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$CheckoutErrorCode fromJson$Enum$CheckoutErrorCode(String value) {
  switch (value) {
    case r'BILLING_ADDRESS_NOT_SET':
      return Enum$CheckoutErrorCode.BILLING_ADDRESS_NOT_SET;
    case r'CHECKOUT_NOT_FULLY_PAID':
      return Enum$CheckoutErrorCode.CHECKOUT_NOT_FULLY_PAID;
    case r'GRAPHQL_ERROR':
      return Enum$CheckoutErrorCode.GRAPHQL_ERROR;
    case r'PRODUCT_NOT_PUBLISHED':
      return Enum$CheckoutErrorCode.PRODUCT_NOT_PUBLISHED;
    case r'PRODUCT_UNAVAILABLE_FOR_PURCHASE':
      return Enum$CheckoutErrorCode.PRODUCT_UNAVAILABLE_FOR_PURCHASE;
    case r'INSUFFICIENT_STOCK':
      return Enum$CheckoutErrorCode.INSUFFICIENT_STOCK;
    case r'INVALID':
      return Enum$CheckoutErrorCode.INVALID;
    case r'INVALID_SHIPPING_METHOD':
      return Enum$CheckoutErrorCode.INVALID_SHIPPING_METHOD;
    case r'NOT_FOUND':
      return Enum$CheckoutErrorCode.NOT_FOUND;
    case r'PAYMENT_ERROR':
      return Enum$CheckoutErrorCode.PAYMENT_ERROR;
    case r'QUANTITY_GREATER_THAN_LIMIT':
      return Enum$CheckoutErrorCode.QUANTITY_GREATER_THAN_LIMIT;
    case r'REQUIRED':
      return Enum$CheckoutErrorCode.REQUIRED;
    case r'SHIPPING_ADDRESS_NOT_SET':
      return Enum$CheckoutErrorCode.SHIPPING_ADDRESS_NOT_SET;
    case r'SHIPPING_METHOD_NOT_APPLICABLE':
      return Enum$CheckoutErrorCode.SHIPPING_METHOD_NOT_APPLICABLE;
    case r'DELIVERY_METHOD_NOT_APPLICABLE':
      return Enum$CheckoutErrorCode.DELIVERY_METHOD_NOT_APPLICABLE;
    case r'SHIPPING_METHOD_NOT_SET':
      return Enum$CheckoutErrorCode.SHIPPING_METHOD_NOT_SET;
    case r'SHIPPING_NOT_REQUIRED':
      return Enum$CheckoutErrorCode.SHIPPING_NOT_REQUIRED;
    case r'TAX_ERROR':
      return Enum$CheckoutErrorCode.TAX_ERROR;
    case r'UNIQUE':
      return Enum$CheckoutErrorCode.UNIQUE;
    case r'VOUCHER_NOT_APPLICABLE':
      return Enum$CheckoutErrorCode.VOUCHER_NOT_APPLICABLE;
    case r'GIFT_CARD_NOT_APPLICABLE':
      return Enum$CheckoutErrorCode.GIFT_CARD_NOT_APPLICABLE;
    case r'ZERO_QUANTITY':
      return Enum$CheckoutErrorCode.ZERO_QUANTITY;
    case r'MISSING_CHANNEL_SLUG':
      return Enum$CheckoutErrorCode.MISSING_CHANNEL_SLUG;
    case r'CHANNEL_INACTIVE':
      return Enum$CheckoutErrorCode.CHANNEL_INACTIVE;
    case r'UNAVAILABLE_VARIANT_IN_CHANNEL':
      return Enum$CheckoutErrorCode.UNAVAILABLE_VARIANT_IN_CHANNEL;
    case r'EMAIL_NOT_SET':
      return Enum$CheckoutErrorCode.EMAIL_NOT_SET;
    case r'NO_LINES':
      return Enum$CheckoutErrorCode.NO_LINES;
    case r'INACTIVE_PAYMENT':
      return Enum$CheckoutErrorCode.INACTIVE_PAYMENT;
    case r'NON_EDITABLE_GIFT_LINE':
      return Enum$CheckoutErrorCode.NON_EDITABLE_GIFT_LINE;
    case r'NON_REMOVABLE_GIFT_LINE':
      return Enum$CheckoutErrorCode.NON_REMOVABLE_GIFT_LINE;
    case r'SHIPPING_CHANGE_FORBIDDEN':
      return Enum$CheckoutErrorCode.SHIPPING_CHANGE_FORBIDDEN;
    case r'MISSING_ADDRESS_DATA':
      return Enum$CheckoutErrorCode.MISSING_ADDRESS_DATA;
    default:
      return Enum$CheckoutErrorCode.$unknown;
  }
}

enum Enum$CheckoutSortField {
  CREATION_DATE,
  CUSTOMER,
  PAYMENT,
  $unknown;

  factory Enum$CheckoutSortField.fromJson(String value) =>
      fromJson$Enum$CheckoutSortField(value);

  String toJson() => toJson$Enum$CheckoutSortField(this);
}

String toJson$Enum$CheckoutSortField(Enum$CheckoutSortField e) {
  switch (e) {
    case Enum$CheckoutSortField.CREATION_DATE:
      return r'CREATION_DATE';
    case Enum$CheckoutSortField.CUSTOMER:
      return r'CUSTOMER';
    case Enum$CheckoutSortField.PAYMENT:
      return r'PAYMENT';
    case Enum$CheckoutSortField.$unknown:
      return r'$unknown';
  }
}

Enum$CheckoutSortField fromJson$Enum$CheckoutSortField(String value) {
  switch (value) {
    case r'CREATION_DATE':
      return Enum$CheckoutSortField.CREATION_DATE;
    case r'CUSTOMER':
      return Enum$CheckoutSortField.CUSTOMER;
    case r'PAYMENT':
      return Enum$CheckoutSortField.PAYMENT;
    default:
      return Enum$CheckoutSortField.$unknown;
  }
}

enum Enum$CircuitBreakerStateEnum {
  CLOSED,
  HALF_OPEN,
  OPEN,
  $unknown;

  factory Enum$CircuitBreakerStateEnum.fromJson(String value) =>
      fromJson$Enum$CircuitBreakerStateEnum(value);

  String toJson() => toJson$Enum$CircuitBreakerStateEnum(this);
}

String toJson$Enum$CircuitBreakerStateEnum(Enum$CircuitBreakerStateEnum e) {
  switch (e) {
    case Enum$CircuitBreakerStateEnum.CLOSED:
      return r'CLOSED';
    case Enum$CircuitBreakerStateEnum.HALF_OPEN:
      return r'HALF_OPEN';
    case Enum$CircuitBreakerStateEnum.OPEN:
      return r'OPEN';
    case Enum$CircuitBreakerStateEnum.$unknown:
      return r'$unknown';
  }
}

Enum$CircuitBreakerStateEnum fromJson$Enum$CircuitBreakerStateEnum(
    String value) {
  switch (value) {
    case r'CLOSED':
      return Enum$CircuitBreakerStateEnum.CLOSED;
    case r'HALF_OPEN':
      return Enum$CircuitBreakerStateEnum.HALF_OPEN;
    case r'OPEN':
      return Enum$CircuitBreakerStateEnum.OPEN;
    default:
      return Enum$CircuitBreakerStateEnum.$unknown;
  }
}

enum Enum$CollectionErrorCode {
  DUPLICATED_INPUT_ITEM,
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT,
  $unknown;

  factory Enum$CollectionErrorCode.fromJson(String value) =>
      fromJson$Enum$CollectionErrorCode(value);

  String toJson() => toJson$Enum$CollectionErrorCode(this);
}

String toJson$Enum$CollectionErrorCode(Enum$CollectionErrorCode e) {
  switch (e) {
    case Enum$CollectionErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$CollectionErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$CollectionErrorCode.INVALID:
      return r'INVALID';
    case Enum$CollectionErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$CollectionErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$CollectionErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$CollectionErrorCode.CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT:
      return r'CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT';
    case Enum$CollectionErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$CollectionErrorCode fromJson$Enum$CollectionErrorCode(String value) {
  switch (value) {
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$CollectionErrorCode.DUPLICATED_INPUT_ITEM;
    case r'GRAPHQL_ERROR':
      return Enum$CollectionErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$CollectionErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$CollectionErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$CollectionErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$CollectionErrorCode.UNIQUE;
    case r'CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT':
      return Enum$CollectionErrorCode.CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT;
    default:
      return Enum$CollectionErrorCode.$unknown;
  }
}

enum Enum$CollectionPublished {
  PUBLISHED,
  HIDDEN,
  $unknown;

  factory Enum$CollectionPublished.fromJson(String value) =>
      fromJson$Enum$CollectionPublished(value);

  String toJson() => toJson$Enum$CollectionPublished(this);
}

String toJson$Enum$CollectionPublished(Enum$CollectionPublished e) {
  switch (e) {
    case Enum$CollectionPublished.PUBLISHED:
      return r'PUBLISHED';
    case Enum$CollectionPublished.HIDDEN:
      return r'HIDDEN';
    case Enum$CollectionPublished.$unknown:
      return r'$unknown';
  }
}

Enum$CollectionPublished fromJson$Enum$CollectionPublished(String value) {
  switch (value) {
    case r'PUBLISHED':
      return Enum$CollectionPublished.PUBLISHED;
    case r'HIDDEN':
      return Enum$CollectionPublished.HIDDEN;
    default:
      return Enum$CollectionPublished.$unknown;
  }
}

enum Enum$CollectionSortField {
  NAME,
  AVAILABILITY,
  PRODUCT_COUNT,
  PUBLICATION_DATE,
  PUBLISHED_AT,
  $unknown;

  factory Enum$CollectionSortField.fromJson(String value) =>
      fromJson$Enum$CollectionSortField(value);

  String toJson() => toJson$Enum$CollectionSortField(this);
}

String toJson$Enum$CollectionSortField(Enum$CollectionSortField e) {
  switch (e) {
    case Enum$CollectionSortField.NAME:
      return r'NAME';
    case Enum$CollectionSortField.AVAILABILITY:
      return r'AVAILABILITY';
    case Enum$CollectionSortField.PRODUCT_COUNT:
      return r'PRODUCT_COUNT';
    case Enum$CollectionSortField.PUBLICATION_DATE:
      return r'PUBLICATION_DATE';
    case Enum$CollectionSortField.PUBLISHED_AT:
      return r'PUBLISHED_AT';
    case Enum$CollectionSortField.$unknown:
      return r'$unknown';
  }
}

Enum$CollectionSortField fromJson$Enum$CollectionSortField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$CollectionSortField.NAME;
    case r'AVAILABILITY':
      return Enum$CollectionSortField.AVAILABILITY;
    case r'PRODUCT_COUNT':
      return Enum$CollectionSortField.PRODUCT_COUNT;
    case r'PUBLICATION_DATE':
      return Enum$CollectionSortField.PUBLICATION_DATE;
    case r'PUBLISHED_AT':
      return Enum$CollectionSortField.PUBLISHED_AT;
    default:
      return Enum$CollectionSortField.$unknown;
  }
}

enum Enum$ConfigurationTypeFieldEnum {
  STRING,
  MULTILINE,
  BOOLEAN,
  SECRET,
  PASSWORD,
  SECRETMULTILINE,
  OUTPUT,
  $unknown;

  factory Enum$ConfigurationTypeFieldEnum.fromJson(String value) =>
      fromJson$Enum$ConfigurationTypeFieldEnum(value);

  String toJson() => toJson$Enum$ConfigurationTypeFieldEnum(this);
}

String toJson$Enum$ConfigurationTypeFieldEnum(
    Enum$ConfigurationTypeFieldEnum e) {
  switch (e) {
    case Enum$ConfigurationTypeFieldEnum.STRING:
      return r'STRING';
    case Enum$ConfigurationTypeFieldEnum.MULTILINE:
      return r'MULTILINE';
    case Enum$ConfigurationTypeFieldEnum.BOOLEAN:
      return r'BOOLEAN';
    case Enum$ConfigurationTypeFieldEnum.SECRET:
      return r'SECRET';
    case Enum$ConfigurationTypeFieldEnum.PASSWORD:
      return r'PASSWORD';
    case Enum$ConfigurationTypeFieldEnum.SECRETMULTILINE:
      return r'SECRETMULTILINE';
    case Enum$ConfigurationTypeFieldEnum.OUTPUT:
      return r'OUTPUT';
    case Enum$ConfigurationTypeFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ConfigurationTypeFieldEnum fromJson$Enum$ConfigurationTypeFieldEnum(
    String value) {
  switch (value) {
    case r'STRING':
      return Enum$ConfigurationTypeFieldEnum.STRING;
    case r'MULTILINE':
      return Enum$ConfigurationTypeFieldEnum.MULTILINE;
    case r'BOOLEAN':
      return Enum$ConfigurationTypeFieldEnum.BOOLEAN;
    case r'SECRET':
      return Enum$ConfigurationTypeFieldEnum.SECRET;
    case r'PASSWORD':
      return Enum$ConfigurationTypeFieldEnum.PASSWORD;
    case r'SECRETMULTILINE':
      return Enum$ConfigurationTypeFieldEnum.SECRETMULTILINE;
    case r'OUTPUT':
      return Enum$ConfigurationTypeFieldEnum.OUTPUT;
    default:
      return Enum$ConfigurationTypeFieldEnum.$unknown;
  }
}

enum Enum$CountryCode {
  AF,
  AX,
  AL,
  DZ,
  AS,
  AD,
  AO,
  AI,
  AQ,
  AG,
  AR,
  AM,
  AW,
  AU,
  AT,
  AZ,
  BS,
  BH,
  BD,
  BB,
  BY,
  BE,
  BZ,
  BJ,
  BM,
  BT,
  BO,
  BQ,
  BA,
  BW,
  BV,
  BR,
  IO,
  BN,
  BG,
  BF,
  BI,
  CV,
  KH,
  CM,
  CA,
  KY,
  CF,
  TD,
  CL,
  CN,
  CX,
  CC,
  CO,
  KM,
  CG,
  CD,
  CK,
  CR,
  CI,
  HR,
  CU,
  CW,
  CY,
  CZ,
  DK,
  DJ,
  DM,
  DO,
  EC,
  EG,
  SV,
  GQ,
  ER,
  EE,
  SZ,
  ET,
  EU,
  FK,
  FO,
  FJ,
  FI,
  FR,
  GF,
  PF,
  TF,
  GA,
  GM,
  GE,
  DE,
  GH,
  GI,
  GR,
  GL,
  GD,
  GP,
  GU,
  GT,
  GG,
  GN,
  GW,
  GY,
  HT,
  HM,
  VA,
  HN,
  HK,
  HU,
  IS,
  IN,
  ID,
  IR,
  IQ,
  IE,
  IM,
  IL,
  IT,
  JM,
  JP,
  JE,
  JO,
  KZ,
  KE,
  KI,
  KW,
  KG,
  LA,
  LV,
  LB,
  LS,
  LR,
  LY,
  LI,
  LT,
  LU,
  MO,
  MG,
  MW,
  MY,
  MV,
  ML,
  MT,
  MH,
  MQ,
  MR,
  MU,
  YT,
  MX,
  FM,
  MD,
  MC,
  MN,
  ME,
  MS,
  MA,
  MZ,
  MM,
  NA,
  NR,
  NP,
  NL,
  NC,
  NZ,
  NI,
  NE,
  NG,
  NU,
  NF,
  KP,
  MK,
  MP,
  NO,
  OM,
  PK,
  PW,
  PS,
  PA,
  PG,
  PY,
  PE,
  PH,
  PN,
  PL,
  PT,
  PR,
  QA,
  RE,
  RO,
  RU,
  RW,
  BL,
  SH,
  KN,
  LC,
  MF,
  PM,
  VC,
  WS,
  SM,
  ST,
  SA,
  SN,
  RS,
  SC,
  SL,
  SG,
  SX,
  SK,
  SI,
  SB,
  SO,
  ZA,
  GS,
  KR,
  SS,
  ES,
  LK,
  SD,
  SR,
  SJ,
  SE,
  CH,
  SY,
  TW,
  TJ,
  TZ,
  TH,
  TL,
  TG,
  TK,
  TO,
  TT,
  TN,
  TR,
  TM,
  TC,
  TV,
  UG,
  UA,
  AE,
  GB,
  UM,
  US,
  UY,
  UZ,
  VU,
  VE,
  VN,
  VG,
  VI,
  WF,
  EH,
  YE,
  ZM,
  ZW,
  $unknown;

  factory Enum$CountryCode.fromJson(String value) =>
      fromJson$Enum$CountryCode(value);

  String toJson() => toJson$Enum$CountryCode(this);
}

String toJson$Enum$CountryCode(Enum$CountryCode e) {
  switch (e) {
    case Enum$CountryCode.AF:
      return r'AF';
    case Enum$CountryCode.AX:
      return r'AX';
    case Enum$CountryCode.AL:
      return r'AL';
    case Enum$CountryCode.DZ:
      return r'DZ';
    case Enum$CountryCode.AS:
      return r'AS';
    case Enum$CountryCode.AD:
      return r'AD';
    case Enum$CountryCode.AO:
      return r'AO';
    case Enum$CountryCode.AI:
      return r'AI';
    case Enum$CountryCode.AQ:
      return r'AQ';
    case Enum$CountryCode.AG:
      return r'AG';
    case Enum$CountryCode.AR:
      return r'AR';
    case Enum$CountryCode.AM:
      return r'AM';
    case Enum$CountryCode.AW:
      return r'AW';
    case Enum$CountryCode.AU:
      return r'AU';
    case Enum$CountryCode.AT:
      return r'AT';
    case Enum$CountryCode.AZ:
      return r'AZ';
    case Enum$CountryCode.BS:
      return r'BS';
    case Enum$CountryCode.BH:
      return r'BH';
    case Enum$CountryCode.BD:
      return r'BD';
    case Enum$CountryCode.BB:
      return r'BB';
    case Enum$CountryCode.BY:
      return r'BY';
    case Enum$CountryCode.BE:
      return r'BE';
    case Enum$CountryCode.BZ:
      return r'BZ';
    case Enum$CountryCode.BJ:
      return r'BJ';
    case Enum$CountryCode.BM:
      return r'BM';
    case Enum$CountryCode.BT:
      return r'BT';
    case Enum$CountryCode.BO:
      return r'BO';
    case Enum$CountryCode.BQ:
      return r'BQ';
    case Enum$CountryCode.BA:
      return r'BA';
    case Enum$CountryCode.BW:
      return r'BW';
    case Enum$CountryCode.BV:
      return r'BV';
    case Enum$CountryCode.BR:
      return r'BR';
    case Enum$CountryCode.IO:
      return r'IO';
    case Enum$CountryCode.BN:
      return r'BN';
    case Enum$CountryCode.BG:
      return r'BG';
    case Enum$CountryCode.BF:
      return r'BF';
    case Enum$CountryCode.BI:
      return r'BI';
    case Enum$CountryCode.CV:
      return r'CV';
    case Enum$CountryCode.KH:
      return r'KH';
    case Enum$CountryCode.CM:
      return r'CM';
    case Enum$CountryCode.CA:
      return r'CA';
    case Enum$CountryCode.KY:
      return r'KY';
    case Enum$CountryCode.CF:
      return r'CF';
    case Enum$CountryCode.TD:
      return r'TD';
    case Enum$CountryCode.CL:
      return r'CL';
    case Enum$CountryCode.CN:
      return r'CN';
    case Enum$CountryCode.CX:
      return r'CX';
    case Enum$CountryCode.CC:
      return r'CC';
    case Enum$CountryCode.CO:
      return r'CO';
    case Enum$CountryCode.KM:
      return r'KM';
    case Enum$CountryCode.CG:
      return r'CG';
    case Enum$CountryCode.CD:
      return r'CD';
    case Enum$CountryCode.CK:
      return r'CK';
    case Enum$CountryCode.CR:
      return r'CR';
    case Enum$CountryCode.CI:
      return r'CI';
    case Enum$CountryCode.HR:
      return r'HR';
    case Enum$CountryCode.CU:
      return r'CU';
    case Enum$CountryCode.CW:
      return r'CW';
    case Enum$CountryCode.CY:
      return r'CY';
    case Enum$CountryCode.CZ:
      return r'CZ';
    case Enum$CountryCode.DK:
      return r'DK';
    case Enum$CountryCode.DJ:
      return r'DJ';
    case Enum$CountryCode.DM:
      return r'DM';
    case Enum$CountryCode.DO:
      return r'DO';
    case Enum$CountryCode.EC:
      return r'EC';
    case Enum$CountryCode.EG:
      return r'EG';
    case Enum$CountryCode.SV:
      return r'SV';
    case Enum$CountryCode.GQ:
      return r'GQ';
    case Enum$CountryCode.ER:
      return r'ER';
    case Enum$CountryCode.EE:
      return r'EE';
    case Enum$CountryCode.SZ:
      return r'SZ';
    case Enum$CountryCode.ET:
      return r'ET';
    case Enum$CountryCode.EU:
      return r'EU';
    case Enum$CountryCode.FK:
      return r'FK';
    case Enum$CountryCode.FO:
      return r'FO';
    case Enum$CountryCode.FJ:
      return r'FJ';
    case Enum$CountryCode.FI:
      return r'FI';
    case Enum$CountryCode.FR:
      return r'FR';
    case Enum$CountryCode.GF:
      return r'GF';
    case Enum$CountryCode.PF:
      return r'PF';
    case Enum$CountryCode.TF:
      return r'TF';
    case Enum$CountryCode.GA:
      return r'GA';
    case Enum$CountryCode.GM:
      return r'GM';
    case Enum$CountryCode.GE:
      return r'GE';
    case Enum$CountryCode.DE:
      return r'DE';
    case Enum$CountryCode.GH:
      return r'GH';
    case Enum$CountryCode.GI:
      return r'GI';
    case Enum$CountryCode.GR:
      return r'GR';
    case Enum$CountryCode.GL:
      return r'GL';
    case Enum$CountryCode.GD:
      return r'GD';
    case Enum$CountryCode.GP:
      return r'GP';
    case Enum$CountryCode.GU:
      return r'GU';
    case Enum$CountryCode.GT:
      return r'GT';
    case Enum$CountryCode.GG:
      return r'GG';
    case Enum$CountryCode.GN:
      return r'GN';
    case Enum$CountryCode.GW:
      return r'GW';
    case Enum$CountryCode.GY:
      return r'GY';
    case Enum$CountryCode.HT:
      return r'HT';
    case Enum$CountryCode.HM:
      return r'HM';
    case Enum$CountryCode.VA:
      return r'VA';
    case Enum$CountryCode.HN:
      return r'HN';
    case Enum$CountryCode.HK:
      return r'HK';
    case Enum$CountryCode.HU:
      return r'HU';
    case Enum$CountryCode.IS:
      return r'IS';
    case Enum$CountryCode.IN:
      return r'IN';
    case Enum$CountryCode.ID:
      return r'ID';
    case Enum$CountryCode.IR:
      return r'IR';
    case Enum$CountryCode.IQ:
      return r'IQ';
    case Enum$CountryCode.IE:
      return r'IE';
    case Enum$CountryCode.IM:
      return r'IM';
    case Enum$CountryCode.IL:
      return r'IL';
    case Enum$CountryCode.IT:
      return r'IT';
    case Enum$CountryCode.JM:
      return r'JM';
    case Enum$CountryCode.JP:
      return r'JP';
    case Enum$CountryCode.JE:
      return r'JE';
    case Enum$CountryCode.JO:
      return r'JO';
    case Enum$CountryCode.KZ:
      return r'KZ';
    case Enum$CountryCode.KE:
      return r'KE';
    case Enum$CountryCode.KI:
      return r'KI';
    case Enum$CountryCode.KW:
      return r'KW';
    case Enum$CountryCode.KG:
      return r'KG';
    case Enum$CountryCode.LA:
      return r'LA';
    case Enum$CountryCode.LV:
      return r'LV';
    case Enum$CountryCode.LB:
      return r'LB';
    case Enum$CountryCode.LS:
      return r'LS';
    case Enum$CountryCode.LR:
      return r'LR';
    case Enum$CountryCode.LY:
      return r'LY';
    case Enum$CountryCode.LI:
      return r'LI';
    case Enum$CountryCode.LT:
      return r'LT';
    case Enum$CountryCode.LU:
      return r'LU';
    case Enum$CountryCode.MO:
      return r'MO';
    case Enum$CountryCode.MG:
      return r'MG';
    case Enum$CountryCode.MW:
      return r'MW';
    case Enum$CountryCode.MY:
      return r'MY';
    case Enum$CountryCode.MV:
      return r'MV';
    case Enum$CountryCode.ML:
      return r'ML';
    case Enum$CountryCode.MT:
      return r'MT';
    case Enum$CountryCode.MH:
      return r'MH';
    case Enum$CountryCode.MQ:
      return r'MQ';
    case Enum$CountryCode.MR:
      return r'MR';
    case Enum$CountryCode.MU:
      return r'MU';
    case Enum$CountryCode.YT:
      return r'YT';
    case Enum$CountryCode.MX:
      return r'MX';
    case Enum$CountryCode.FM:
      return r'FM';
    case Enum$CountryCode.MD:
      return r'MD';
    case Enum$CountryCode.MC:
      return r'MC';
    case Enum$CountryCode.MN:
      return r'MN';
    case Enum$CountryCode.ME:
      return r'ME';
    case Enum$CountryCode.MS:
      return r'MS';
    case Enum$CountryCode.MA:
      return r'MA';
    case Enum$CountryCode.MZ:
      return r'MZ';
    case Enum$CountryCode.MM:
      return r'MM';
    case Enum$CountryCode.NA:
      return r'NA';
    case Enum$CountryCode.NR:
      return r'NR';
    case Enum$CountryCode.NP:
      return r'NP';
    case Enum$CountryCode.NL:
      return r'NL';
    case Enum$CountryCode.NC:
      return r'NC';
    case Enum$CountryCode.NZ:
      return r'NZ';
    case Enum$CountryCode.NI:
      return r'NI';
    case Enum$CountryCode.NE:
      return r'NE';
    case Enum$CountryCode.NG:
      return r'NG';
    case Enum$CountryCode.NU:
      return r'NU';
    case Enum$CountryCode.NF:
      return r'NF';
    case Enum$CountryCode.KP:
      return r'KP';
    case Enum$CountryCode.MK:
      return r'MK';
    case Enum$CountryCode.MP:
      return r'MP';
    case Enum$CountryCode.NO:
      return r'NO';
    case Enum$CountryCode.OM:
      return r'OM';
    case Enum$CountryCode.PK:
      return r'PK';
    case Enum$CountryCode.PW:
      return r'PW';
    case Enum$CountryCode.PS:
      return r'PS';
    case Enum$CountryCode.PA:
      return r'PA';
    case Enum$CountryCode.PG:
      return r'PG';
    case Enum$CountryCode.PY:
      return r'PY';
    case Enum$CountryCode.PE:
      return r'PE';
    case Enum$CountryCode.PH:
      return r'PH';
    case Enum$CountryCode.PN:
      return r'PN';
    case Enum$CountryCode.PL:
      return r'PL';
    case Enum$CountryCode.PT:
      return r'PT';
    case Enum$CountryCode.PR:
      return r'PR';
    case Enum$CountryCode.QA:
      return r'QA';
    case Enum$CountryCode.RE:
      return r'RE';
    case Enum$CountryCode.RO:
      return r'RO';
    case Enum$CountryCode.RU:
      return r'RU';
    case Enum$CountryCode.RW:
      return r'RW';
    case Enum$CountryCode.BL:
      return r'BL';
    case Enum$CountryCode.SH:
      return r'SH';
    case Enum$CountryCode.KN:
      return r'KN';
    case Enum$CountryCode.LC:
      return r'LC';
    case Enum$CountryCode.MF:
      return r'MF';
    case Enum$CountryCode.PM:
      return r'PM';
    case Enum$CountryCode.VC:
      return r'VC';
    case Enum$CountryCode.WS:
      return r'WS';
    case Enum$CountryCode.SM:
      return r'SM';
    case Enum$CountryCode.ST:
      return r'ST';
    case Enum$CountryCode.SA:
      return r'SA';
    case Enum$CountryCode.SN:
      return r'SN';
    case Enum$CountryCode.RS:
      return r'RS';
    case Enum$CountryCode.SC:
      return r'SC';
    case Enum$CountryCode.SL:
      return r'SL';
    case Enum$CountryCode.SG:
      return r'SG';
    case Enum$CountryCode.SX:
      return r'SX';
    case Enum$CountryCode.SK:
      return r'SK';
    case Enum$CountryCode.SI:
      return r'SI';
    case Enum$CountryCode.SB:
      return r'SB';
    case Enum$CountryCode.SO:
      return r'SO';
    case Enum$CountryCode.ZA:
      return r'ZA';
    case Enum$CountryCode.GS:
      return r'GS';
    case Enum$CountryCode.KR:
      return r'KR';
    case Enum$CountryCode.SS:
      return r'SS';
    case Enum$CountryCode.ES:
      return r'ES';
    case Enum$CountryCode.LK:
      return r'LK';
    case Enum$CountryCode.SD:
      return r'SD';
    case Enum$CountryCode.SR:
      return r'SR';
    case Enum$CountryCode.SJ:
      return r'SJ';
    case Enum$CountryCode.SE:
      return r'SE';
    case Enum$CountryCode.CH:
      return r'CH';
    case Enum$CountryCode.SY:
      return r'SY';
    case Enum$CountryCode.TW:
      return r'TW';
    case Enum$CountryCode.TJ:
      return r'TJ';
    case Enum$CountryCode.TZ:
      return r'TZ';
    case Enum$CountryCode.TH:
      return r'TH';
    case Enum$CountryCode.TL:
      return r'TL';
    case Enum$CountryCode.TG:
      return r'TG';
    case Enum$CountryCode.TK:
      return r'TK';
    case Enum$CountryCode.TO:
      return r'TO';
    case Enum$CountryCode.TT:
      return r'TT';
    case Enum$CountryCode.TN:
      return r'TN';
    case Enum$CountryCode.TR:
      return r'TR';
    case Enum$CountryCode.TM:
      return r'TM';
    case Enum$CountryCode.TC:
      return r'TC';
    case Enum$CountryCode.TV:
      return r'TV';
    case Enum$CountryCode.UG:
      return r'UG';
    case Enum$CountryCode.UA:
      return r'UA';
    case Enum$CountryCode.AE:
      return r'AE';
    case Enum$CountryCode.GB:
      return r'GB';
    case Enum$CountryCode.UM:
      return r'UM';
    case Enum$CountryCode.US:
      return r'US';
    case Enum$CountryCode.UY:
      return r'UY';
    case Enum$CountryCode.UZ:
      return r'UZ';
    case Enum$CountryCode.VU:
      return r'VU';
    case Enum$CountryCode.VE:
      return r'VE';
    case Enum$CountryCode.VN:
      return r'VN';
    case Enum$CountryCode.VG:
      return r'VG';
    case Enum$CountryCode.VI:
      return r'VI';
    case Enum$CountryCode.WF:
      return r'WF';
    case Enum$CountryCode.EH:
      return r'EH';
    case Enum$CountryCode.YE:
      return r'YE';
    case Enum$CountryCode.ZM:
      return r'ZM';
    case Enum$CountryCode.ZW:
      return r'ZW';
    case Enum$CountryCode.$unknown:
      return r'$unknown';
  }
}

Enum$CountryCode fromJson$Enum$CountryCode(String value) {
  switch (value) {
    case r'AF':
      return Enum$CountryCode.AF;
    case r'AX':
      return Enum$CountryCode.AX;
    case r'AL':
      return Enum$CountryCode.AL;
    case r'DZ':
      return Enum$CountryCode.DZ;
    case r'AS':
      return Enum$CountryCode.AS;
    case r'AD':
      return Enum$CountryCode.AD;
    case r'AO':
      return Enum$CountryCode.AO;
    case r'AI':
      return Enum$CountryCode.AI;
    case r'AQ':
      return Enum$CountryCode.AQ;
    case r'AG':
      return Enum$CountryCode.AG;
    case r'AR':
      return Enum$CountryCode.AR;
    case r'AM':
      return Enum$CountryCode.AM;
    case r'AW':
      return Enum$CountryCode.AW;
    case r'AU':
      return Enum$CountryCode.AU;
    case r'AT':
      return Enum$CountryCode.AT;
    case r'AZ':
      return Enum$CountryCode.AZ;
    case r'BS':
      return Enum$CountryCode.BS;
    case r'BH':
      return Enum$CountryCode.BH;
    case r'BD':
      return Enum$CountryCode.BD;
    case r'BB':
      return Enum$CountryCode.BB;
    case r'BY':
      return Enum$CountryCode.BY;
    case r'BE':
      return Enum$CountryCode.BE;
    case r'BZ':
      return Enum$CountryCode.BZ;
    case r'BJ':
      return Enum$CountryCode.BJ;
    case r'BM':
      return Enum$CountryCode.BM;
    case r'BT':
      return Enum$CountryCode.BT;
    case r'BO':
      return Enum$CountryCode.BO;
    case r'BQ':
      return Enum$CountryCode.BQ;
    case r'BA':
      return Enum$CountryCode.BA;
    case r'BW':
      return Enum$CountryCode.BW;
    case r'BV':
      return Enum$CountryCode.BV;
    case r'BR':
      return Enum$CountryCode.BR;
    case r'IO':
      return Enum$CountryCode.IO;
    case r'BN':
      return Enum$CountryCode.BN;
    case r'BG':
      return Enum$CountryCode.BG;
    case r'BF':
      return Enum$CountryCode.BF;
    case r'BI':
      return Enum$CountryCode.BI;
    case r'CV':
      return Enum$CountryCode.CV;
    case r'KH':
      return Enum$CountryCode.KH;
    case r'CM':
      return Enum$CountryCode.CM;
    case r'CA':
      return Enum$CountryCode.CA;
    case r'KY':
      return Enum$CountryCode.KY;
    case r'CF':
      return Enum$CountryCode.CF;
    case r'TD':
      return Enum$CountryCode.TD;
    case r'CL':
      return Enum$CountryCode.CL;
    case r'CN':
      return Enum$CountryCode.CN;
    case r'CX':
      return Enum$CountryCode.CX;
    case r'CC':
      return Enum$CountryCode.CC;
    case r'CO':
      return Enum$CountryCode.CO;
    case r'KM':
      return Enum$CountryCode.KM;
    case r'CG':
      return Enum$CountryCode.CG;
    case r'CD':
      return Enum$CountryCode.CD;
    case r'CK':
      return Enum$CountryCode.CK;
    case r'CR':
      return Enum$CountryCode.CR;
    case r'CI':
      return Enum$CountryCode.CI;
    case r'HR':
      return Enum$CountryCode.HR;
    case r'CU':
      return Enum$CountryCode.CU;
    case r'CW':
      return Enum$CountryCode.CW;
    case r'CY':
      return Enum$CountryCode.CY;
    case r'CZ':
      return Enum$CountryCode.CZ;
    case r'DK':
      return Enum$CountryCode.DK;
    case r'DJ':
      return Enum$CountryCode.DJ;
    case r'DM':
      return Enum$CountryCode.DM;
    case r'DO':
      return Enum$CountryCode.DO;
    case r'EC':
      return Enum$CountryCode.EC;
    case r'EG':
      return Enum$CountryCode.EG;
    case r'SV':
      return Enum$CountryCode.SV;
    case r'GQ':
      return Enum$CountryCode.GQ;
    case r'ER':
      return Enum$CountryCode.ER;
    case r'EE':
      return Enum$CountryCode.EE;
    case r'SZ':
      return Enum$CountryCode.SZ;
    case r'ET':
      return Enum$CountryCode.ET;
    case r'EU':
      return Enum$CountryCode.EU;
    case r'FK':
      return Enum$CountryCode.FK;
    case r'FO':
      return Enum$CountryCode.FO;
    case r'FJ':
      return Enum$CountryCode.FJ;
    case r'FI':
      return Enum$CountryCode.FI;
    case r'FR':
      return Enum$CountryCode.FR;
    case r'GF':
      return Enum$CountryCode.GF;
    case r'PF':
      return Enum$CountryCode.PF;
    case r'TF':
      return Enum$CountryCode.TF;
    case r'GA':
      return Enum$CountryCode.GA;
    case r'GM':
      return Enum$CountryCode.GM;
    case r'GE':
      return Enum$CountryCode.GE;
    case r'DE':
      return Enum$CountryCode.DE;
    case r'GH':
      return Enum$CountryCode.GH;
    case r'GI':
      return Enum$CountryCode.GI;
    case r'GR':
      return Enum$CountryCode.GR;
    case r'GL':
      return Enum$CountryCode.GL;
    case r'GD':
      return Enum$CountryCode.GD;
    case r'GP':
      return Enum$CountryCode.GP;
    case r'GU':
      return Enum$CountryCode.GU;
    case r'GT':
      return Enum$CountryCode.GT;
    case r'GG':
      return Enum$CountryCode.GG;
    case r'GN':
      return Enum$CountryCode.GN;
    case r'GW':
      return Enum$CountryCode.GW;
    case r'GY':
      return Enum$CountryCode.GY;
    case r'HT':
      return Enum$CountryCode.HT;
    case r'HM':
      return Enum$CountryCode.HM;
    case r'VA':
      return Enum$CountryCode.VA;
    case r'HN':
      return Enum$CountryCode.HN;
    case r'HK':
      return Enum$CountryCode.HK;
    case r'HU':
      return Enum$CountryCode.HU;
    case r'IS':
      return Enum$CountryCode.IS;
    case r'IN':
      return Enum$CountryCode.IN;
    case r'ID':
      return Enum$CountryCode.ID;
    case r'IR':
      return Enum$CountryCode.IR;
    case r'IQ':
      return Enum$CountryCode.IQ;
    case r'IE':
      return Enum$CountryCode.IE;
    case r'IM':
      return Enum$CountryCode.IM;
    case r'IL':
      return Enum$CountryCode.IL;
    case r'IT':
      return Enum$CountryCode.IT;
    case r'JM':
      return Enum$CountryCode.JM;
    case r'JP':
      return Enum$CountryCode.JP;
    case r'JE':
      return Enum$CountryCode.JE;
    case r'JO':
      return Enum$CountryCode.JO;
    case r'KZ':
      return Enum$CountryCode.KZ;
    case r'KE':
      return Enum$CountryCode.KE;
    case r'KI':
      return Enum$CountryCode.KI;
    case r'KW':
      return Enum$CountryCode.KW;
    case r'KG':
      return Enum$CountryCode.KG;
    case r'LA':
      return Enum$CountryCode.LA;
    case r'LV':
      return Enum$CountryCode.LV;
    case r'LB':
      return Enum$CountryCode.LB;
    case r'LS':
      return Enum$CountryCode.LS;
    case r'LR':
      return Enum$CountryCode.LR;
    case r'LY':
      return Enum$CountryCode.LY;
    case r'LI':
      return Enum$CountryCode.LI;
    case r'LT':
      return Enum$CountryCode.LT;
    case r'LU':
      return Enum$CountryCode.LU;
    case r'MO':
      return Enum$CountryCode.MO;
    case r'MG':
      return Enum$CountryCode.MG;
    case r'MW':
      return Enum$CountryCode.MW;
    case r'MY':
      return Enum$CountryCode.MY;
    case r'MV':
      return Enum$CountryCode.MV;
    case r'ML':
      return Enum$CountryCode.ML;
    case r'MT':
      return Enum$CountryCode.MT;
    case r'MH':
      return Enum$CountryCode.MH;
    case r'MQ':
      return Enum$CountryCode.MQ;
    case r'MR':
      return Enum$CountryCode.MR;
    case r'MU':
      return Enum$CountryCode.MU;
    case r'YT':
      return Enum$CountryCode.YT;
    case r'MX':
      return Enum$CountryCode.MX;
    case r'FM':
      return Enum$CountryCode.FM;
    case r'MD':
      return Enum$CountryCode.MD;
    case r'MC':
      return Enum$CountryCode.MC;
    case r'MN':
      return Enum$CountryCode.MN;
    case r'ME':
      return Enum$CountryCode.ME;
    case r'MS':
      return Enum$CountryCode.MS;
    case r'MA':
      return Enum$CountryCode.MA;
    case r'MZ':
      return Enum$CountryCode.MZ;
    case r'MM':
      return Enum$CountryCode.MM;
    case r'NA':
      return Enum$CountryCode.NA;
    case r'NR':
      return Enum$CountryCode.NR;
    case r'NP':
      return Enum$CountryCode.NP;
    case r'NL':
      return Enum$CountryCode.NL;
    case r'NC':
      return Enum$CountryCode.NC;
    case r'NZ':
      return Enum$CountryCode.NZ;
    case r'NI':
      return Enum$CountryCode.NI;
    case r'NE':
      return Enum$CountryCode.NE;
    case r'NG':
      return Enum$CountryCode.NG;
    case r'NU':
      return Enum$CountryCode.NU;
    case r'NF':
      return Enum$CountryCode.NF;
    case r'KP':
      return Enum$CountryCode.KP;
    case r'MK':
      return Enum$CountryCode.MK;
    case r'MP':
      return Enum$CountryCode.MP;
    case r'NO':
      return Enum$CountryCode.NO;
    case r'OM':
      return Enum$CountryCode.OM;
    case r'PK':
      return Enum$CountryCode.PK;
    case r'PW':
      return Enum$CountryCode.PW;
    case r'PS':
      return Enum$CountryCode.PS;
    case r'PA':
      return Enum$CountryCode.PA;
    case r'PG':
      return Enum$CountryCode.PG;
    case r'PY':
      return Enum$CountryCode.PY;
    case r'PE':
      return Enum$CountryCode.PE;
    case r'PH':
      return Enum$CountryCode.PH;
    case r'PN':
      return Enum$CountryCode.PN;
    case r'PL':
      return Enum$CountryCode.PL;
    case r'PT':
      return Enum$CountryCode.PT;
    case r'PR':
      return Enum$CountryCode.PR;
    case r'QA':
      return Enum$CountryCode.QA;
    case r'RE':
      return Enum$CountryCode.RE;
    case r'RO':
      return Enum$CountryCode.RO;
    case r'RU':
      return Enum$CountryCode.RU;
    case r'RW':
      return Enum$CountryCode.RW;
    case r'BL':
      return Enum$CountryCode.BL;
    case r'SH':
      return Enum$CountryCode.SH;
    case r'KN':
      return Enum$CountryCode.KN;
    case r'LC':
      return Enum$CountryCode.LC;
    case r'MF':
      return Enum$CountryCode.MF;
    case r'PM':
      return Enum$CountryCode.PM;
    case r'VC':
      return Enum$CountryCode.VC;
    case r'WS':
      return Enum$CountryCode.WS;
    case r'SM':
      return Enum$CountryCode.SM;
    case r'ST':
      return Enum$CountryCode.ST;
    case r'SA':
      return Enum$CountryCode.SA;
    case r'SN':
      return Enum$CountryCode.SN;
    case r'RS':
      return Enum$CountryCode.RS;
    case r'SC':
      return Enum$CountryCode.SC;
    case r'SL':
      return Enum$CountryCode.SL;
    case r'SG':
      return Enum$CountryCode.SG;
    case r'SX':
      return Enum$CountryCode.SX;
    case r'SK':
      return Enum$CountryCode.SK;
    case r'SI':
      return Enum$CountryCode.SI;
    case r'SB':
      return Enum$CountryCode.SB;
    case r'SO':
      return Enum$CountryCode.SO;
    case r'ZA':
      return Enum$CountryCode.ZA;
    case r'GS':
      return Enum$CountryCode.GS;
    case r'KR':
      return Enum$CountryCode.KR;
    case r'SS':
      return Enum$CountryCode.SS;
    case r'ES':
      return Enum$CountryCode.ES;
    case r'LK':
      return Enum$CountryCode.LK;
    case r'SD':
      return Enum$CountryCode.SD;
    case r'SR':
      return Enum$CountryCode.SR;
    case r'SJ':
      return Enum$CountryCode.SJ;
    case r'SE':
      return Enum$CountryCode.SE;
    case r'CH':
      return Enum$CountryCode.CH;
    case r'SY':
      return Enum$CountryCode.SY;
    case r'TW':
      return Enum$CountryCode.TW;
    case r'TJ':
      return Enum$CountryCode.TJ;
    case r'TZ':
      return Enum$CountryCode.TZ;
    case r'TH':
      return Enum$CountryCode.TH;
    case r'TL':
      return Enum$CountryCode.TL;
    case r'TG':
      return Enum$CountryCode.TG;
    case r'TK':
      return Enum$CountryCode.TK;
    case r'TO':
      return Enum$CountryCode.TO;
    case r'TT':
      return Enum$CountryCode.TT;
    case r'TN':
      return Enum$CountryCode.TN;
    case r'TR':
      return Enum$CountryCode.TR;
    case r'TM':
      return Enum$CountryCode.TM;
    case r'TC':
      return Enum$CountryCode.TC;
    case r'TV':
      return Enum$CountryCode.TV;
    case r'UG':
      return Enum$CountryCode.UG;
    case r'UA':
      return Enum$CountryCode.UA;
    case r'AE':
      return Enum$CountryCode.AE;
    case r'GB':
      return Enum$CountryCode.GB;
    case r'UM':
      return Enum$CountryCode.UM;
    case r'US':
      return Enum$CountryCode.US;
    case r'UY':
      return Enum$CountryCode.UY;
    case r'UZ':
      return Enum$CountryCode.UZ;
    case r'VU':
      return Enum$CountryCode.VU;
    case r'VE':
      return Enum$CountryCode.VE;
    case r'VN':
      return Enum$CountryCode.VN;
    case r'VG':
      return Enum$CountryCode.VG;
    case r'VI':
      return Enum$CountryCode.VI;
    case r'WF':
      return Enum$CountryCode.WF;
    case r'EH':
      return Enum$CountryCode.EH;
    case r'YE':
      return Enum$CountryCode.YE;
    case r'ZM':
      return Enum$CountryCode.ZM;
    case r'ZW':
      return Enum$CountryCode.ZW;
    default:
      return Enum$CountryCode.$unknown;
  }
}

enum Enum$CustomerBulkUpdateErrorCode {
  BLANK,
  DUPLICATED_INPUT_ITEM,
  GRAPHQL_ERROR,
  INVALID,
  REQUIRED,
  UNIQUE,
  NOT_FOUND,
  MAX_LENGTH,
  $unknown;

  factory Enum$CustomerBulkUpdateErrorCode.fromJson(String value) =>
      fromJson$Enum$CustomerBulkUpdateErrorCode(value);

  String toJson() => toJson$Enum$CustomerBulkUpdateErrorCode(this);
}

String toJson$Enum$CustomerBulkUpdateErrorCode(
    Enum$CustomerBulkUpdateErrorCode e) {
  switch (e) {
    case Enum$CustomerBulkUpdateErrorCode.BLANK:
      return r'BLANK';
    case Enum$CustomerBulkUpdateErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$CustomerBulkUpdateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$CustomerBulkUpdateErrorCode.INVALID:
      return r'INVALID';
    case Enum$CustomerBulkUpdateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$CustomerBulkUpdateErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$CustomerBulkUpdateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$CustomerBulkUpdateErrorCode.MAX_LENGTH:
      return r'MAX_LENGTH';
    case Enum$CustomerBulkUpdateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$CustomerBulkUpdateErrorCode fromJson$Enum$CustomerBulkUpdateErrorCode(
    String value) {
  switch (value) {
    case r'BLANK':
      return Enum$CustomerBulkUpdateErrorCode.BLANK;
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$CustomerBulkUpdateErrorCode.DUPLICATED_INPUT_ITEM;
    case r'GRAPHQL_ERROR':
      return Enum$CustomerBulkUpdateErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$CustomerBulkUpdateErrorCode.INVALID;
    case r'REQUIRED':
      return Enum$CustomerBulkUpdateErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$CustomerBulkUpdateErrorCode.UNIQUE;
    case r'NOT_FOUND':
      return Enum$CustomerBulkUpdateErrorCode.NOT_FOUND;
    case r'MAX_LENGTH':
      return Enum$CustomerBulkUpdateErrorCode.MAX_LENGTH;
    default:
      return Enum$CustomerBulkUpdateErrorCode.$unknown;
  }
}

enum Enum$CustomerEventsEnum {
  ACCOUNT_CREATED,
  ACCOUNT_ACTIVATED,
  ACCOUNT_DEACTIVATED,
  PASSWORD_RESET_LINK_SENT,
  PASSWORD_RESET,
  EMAIL_CHANGED_REQUEST,
  PASSWORD_CHANGED,
  EMAIL_CHANGED,
  PLACED_ORDER,
  NOTE_ADDED_TO_ORDER,
  DIGITAL_LINK_DOWNLOADED,
  CUSTOMER_DELETED,
  NAME_ASSIGNED,
  EMAIL_ASSIGNED,
  NOTE_ADDED,
  $unknown;

  factory Enum$CustomerEventsEnum.fromJson(String value) =>
      fromJson$Enum$CustomerEventsEnum(value);

  String toJson() => toJson$Enum$CustomerEventsEnum(this);
}

String toJson$Enum$CustomerEventsEnum(Enum$CustomerEventsEnum e) {
  switch (e) {
    case Enum$CustomerEventsEnum.ACCOUNT_CREATED:
      return r'ACCOUNT_CREATED';
    case Enum$CustomerEventsEnum.ACCOUNT_ACTIVATED:
      return r'ACCOUNT_ACTIVATED';
    case Enum$CustomerEventsEnum.ACCOUNT_DEACTIVATED:
      return r'ACCOUNT_DEACTIVATED';
    case Enum$CustomerEventsEnum.PASSWORD_RESET_LINK_SENT:
      return r'PASSWORD_RESET_LINK_SENT';
    case Enum$CustomerEventsEnum.PASSWORD_RESET:
      return r'PASSWORD_RESET';
    case Enum$CustomerEventsEnum.EMAIL_CHANGED_REQUEST:
      return r'EMAIL_CHANGED_REQUEST';
    case Enum$CustomerEventsEnum.PASSWORD_CHANGED:
      return r'PASSWORD_CHANGED';
    case Enum$CustomerEventsEnum.EMAIL_CHANGED:
      return r'EMAIL_CHANGED';
    case Enum$CustomerEventsEnum.PLACED_ORDER:
      return r'PLACED_ORDER';
    case Enum$CustomerEventsEnum.NOTE_ADDED_TO_ORDER:
      return r'NOTE_ADDED_TO_ORDER';
    case Enum$CustomerEventsEnum.DIGITAL_LINK_DOWNLOADED:
      return r'DIGITAL_LINK_DOWNLOADED';
    case Enum$CustomerEventsEnum.CUSTOMER_DELETED:
      return r'CUSTOMER_DELETED';
    case Enum$CustomerEventsEnum.NAME_ASSIGNED:
      return r'NAME_ASSIGNED';
    case Enum$CustomerEventsEnum.EMAIL_ASSIGNED:
      return r'EMAIL_ASSIGNED';
    case Enum$CustomerEventsEnum.NOTE_ADDED:
      return r'NOTE_ADDED';
    case Enum$CustomerEventsEnum.$unknown:
      return r'$unknown';
  }
}

Enum$CustomerEventsEnum fromJson$Enum$CustomerEventsEnum(String value) {
  switch (value) {
    case r'ACCOUNT_CREATED':
      return Enum$CustomerEventsEnum.ACCOUNT_CREATED;
    case r'ACCOUNT_ACTIVATED':
      return Enum$CustomerEventsEnum.ACCOUNT_ACTIVATED;
    case r'ACCOUNT_DEACTIVATED':
      return Enum$CustomerEventsEnum.ACCOUNT_DEACTIVATED;
    case r'PASSWORD_RESET_LINK_SENT':
      return Enum$CustomerEventsEnum.PASSWORD_RESET_LINK_SENT;
    case r'PASSWORD_RESET':
      return Enum$CustomerEventsEnum.PASSWORD_RESET;
    case r'EMAIL_CHANGED_REQUEST':
      return Enum$CustomerEventsEnum.EMAIL_CHANGED_REQUEST;
    case r'PASSWORD_CHANGED':
      return Enum$CustomerEventsEnum.PASSWORD_CHANGED;
    case r'EMAIL_CHANGED':
      return Enum$CustomerEventsEnum.EMAIL_CHANGED;
    case r'PLACED_ORDER':
      return Enum$CustomerEventsEnum.PLACED_ORDER;
    case r'NOTE_ADDED_TO_ORDER':
      return Enum$CustomerEventsEnum.NOTE_ADDED_TO_ORDER;
    case r'DIGITAL_LINK_DOWNLOADED':
      return Enum$CustomerEventsEnum.DIGITAL_LINK_DOWNLOADED;
    case r'CUSTOMER_DELETED':
      return Enum$CustomerEventsEnum.CUSTOMER_DELETED;
    case r'NAME_ASSIGNED':
      return Enum$CustomerEventsEnum.NAME_ASSIGNED;
    case r'EMAIL_ASSIGNED':
      return Enum$CustomerEventsEnum.EMAIL_ASSIGNED;
    case r'NOTE_ADDED':
      return Enum$CustomerEventsEnum.NOTE_ADDED;
    default:
      return Enum$CustomerEventsEnum.$unknown;
  }
}

enum Enum$DiscountErrorCode {
  ALREADY_EXISTS,
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT,
  DUPLICATED_INPUT_ITEM,
  VOUCHER_ALREADY_USED,
  $unknown;

  factory Enum$DiscountErrorCode.fromJson(String value) =>
      fromJson$Enum$DiscountErrorCode(value);

  String toJson() => toJson$Enum$DiscountErrorCode(this);
}

String toJson$Enum$DiscountErrorCode(Enum$DiscountErrorCode e) {
  switch (e) {
    case Enum$DiscountErrorCode.ALREADY_EXISTS:
      return r'ALREADY_EXISTS';
    case Enum$DiscountErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$DiscountErrorCode.INVALID:
      return r'INVALID';
    case Enum$DiscountErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$DiscountErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$DiscountErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$DiscountErrorCode.CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT:
      return r'CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT';
    case Enum$DiscountErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$DiscountErrorCode.VOUCHER_ALREADY_USED:
      return r'VOUCHER_ALREADY_USED';
    case Enum$DiscountErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$DiscountErrorCode fromJson$Enum$DiscountErrorCode(String value) {
  switch (value) {
    case r'ALREADY_EXISTS':
      return Enum$DiscountErrorCode.ALREADY_EXISTS;
    case r'GRAPHQL_ERROR':
      return Enum$DiscountErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$DiscountErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$DiscountErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$DiscountErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$DiscountErrorCode.UNIQUE;
    case r'CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT':
      return Enum$DiscountErrorCode.CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT;
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$DiscountErrorCode.DUPLICATED_INPUT_ITEM;
    case r'VOUCHER_ALREADY_USED':
      return Enum$DiscountErrorCode.VOUCHER_ALREADY_USED;
    default:
      return Enum$DiscountErrorCode.$unknown;
  }
}

enum Enum$DiscountStatusEnum {
  ACTIVE,
  EXPIRED,
  SCHEDULED,
  $unknown;

  factory Enum$DiscountStatusEnum.fromJson(String value) =>
      fromJson$Enum$DiscountStatusEnum(value);

  String toJson() => toJson$Enum$DiscountStatusEnum(this);
}

String toJson$Enum$DiscountStatusEnum(Enum$DiscountStatusEnum e) {
  switch (e) {
    case Enum$DiscountStatusEnum.ACTIVE:
      return r'ACTIVE';
    case Enum$DiscountStatusEnum.EXPIRED:
      return r'EXPIRED';
    case Enum$DiscountStatusEnum.SCHEDULED:
      return r'SCHEDULED';
    case Enum$DiscountStatusEnum.$unknown:
      return r'$unknown';
  }
}

Enum$DiscountStatusEnum fromJson$Enum$DiscountStatusEnum(String value) {
  switch (value) {
    case r'ACTIVE':
      return Enum$DiscountStatusEnum.ACTIVE;
    case r'EXPIRED':
      return Enum$DiscountStatusEnum.EXPIRED;
    case r'SCHEDULED':
      return Enum$DiscountStatusEnum.SCHEDULED;
    default:
      return Enum$DiscountStatusEnum.$unknown;
  }
}

enum Enum$DiscountValueTypeEnum {
  FIXED,
  PERCENTAGE,
  $unknown;

  factory Enum$DiscountValueTypeEnum.fromJson(String value) =>
      fromJson$Enum$DiscountValueTypeEnum(value);

  String toJson() => toJson$Enum$DiscountValueTypeEnum(this);
}

String toJson$Enum$DiscountValueTypeEnum(Enum$DiscountValueTypeEnum e) {
  switch (e) {
    case Enum$DiscountValueTypeEnum.FIXED:
      return r'FIXED';
    case Enum$DiscountValueTypeEnum.PERCENTAGE:
      return r'PERCENTAGE';
    case Enum$DiscountValueTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$DiscountValueTypeEnum fromJson$Enum$DiscountValueTypeEnum(String value) {
  switch (value) {
    case r'FIXED':
      return Enum$DiscountValueTypeEnum.FIXED;
    case r'PERCENTAGE':
      return Enum$DiscountValueTypeEnum.PERCENTAGE;
    default:
      return Enum$DiscountValueTypeEnum.$unknown;
  }
}

enum Enum$DistanceUnitsEnum {
  MM,
  CM,
  DM,
  M,
  KM,
  FT,
  YD,
  INCH,
  $unknown;

  factory Enum$DistanceUnitsEnum.fromJson(String value) =>
      fromJson$Enum$DistanceUnitsEnum(value);

  String toJson() => toJson$Enum$DistanceUnitsEnum(this);
}

String toJson$Enum$DistanceUnitsEnum(Enum$DistanceUnitsEnum e) {
  switch (e) {
    case Enum$DistanceUnitsEnum.MM:
      return r'MM';
    case Enum$DistanceUnitsEnum.CM:
      return r'CM';
    case Enum$DistanceUnitsEnum.DM:
      return r'DM';
    case Enum$DistanceUnitsEnum.M:
      return r'M';
    case Enum$DistanceUnitsEnum.KM:
      return r'KM';
    case Enum$DistanceUnitsEnum.FT:
      return r'FT';
    case Enum$DistanceUnitsEnum.YD:
      return r'YD';
    case Enum$DistanceUnitsEnum.INCH:
      return r'INCH';
    case Enum$DistanceUnitsEnum.$unknown:
      return r'$unknown';
  }
}

Enum$DistanceUnitsEnum fromJson$Enum$DistanceUnitsEnum(String value) {
  switch (value) {
    case r'MM':
      return Enum$DistanceUnitsEnum.MM;
    case r'CM':
      return Enum$DistanceUnitsEnum.CM;
    case r'DM':
      return Enum$DistanceUnitsEnum.DM;
    case r'M':
      return Enum$DistanceUnitsEnum.M;
    case r'KM':
      return Enum$DistanceUnitsEnum.KM;
    case r'FT':
      return Enum$DistanceUnitsEnum.FT;
    case r'YD':
      return Enum$DistanceUnitsEnum.YD;
    case r'INCH':
      return Enum$DistanceUnitsEnum.INCH;
    default:
      return Enum$DistanceUnitsEnum.$unknown;
  }
}

enum Enum$ErrorPolicyEnum {
  IGNORE_FAILED,
  REJECT_EVERYTHING,
  REJECT_FAILED_ROWS,
  $unknown;

  factory Enum$ErrorPolicyEnum.fromJson(String value) =>
      fromJson$Enum$ErrorPolicyEnum(value);

  String toJson() => toJson$Enum$ErrorPolicyEnum(this);
}

String toJson$Enum$ErrorPolicyEnum(Enum$ErrorPolicyEnum e) {
  switch (e) {
    case Enum$ErrorPolicyEnum.IGNORE_FAILED:
      return r'IGNORE_FAILED';
    case Enum$ErrorPolicyEnum.REJECT_EVERYTHING:
      return r'REJECT_EVERYTHING';
    case Enum$ErrorPolicyEnum.REJECT_FAILED_ROWS:
      return r'REJECT_FAILED_ROWS';
    case Enum$ErrorPolicyEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ErrorPolicyEnum fromJson$Enum$ErrorPolicyEnum(String value) {
  switch (value) {
    case r'IGNORE_FAILED':
      return Enum$ErrorPolicyEnum.IGNORE_FAILED;
    case r'REJECT_EVERYTHING':
      return Enum$ErrorPolicyEnum.REJECT_EVERYTHING;
    case r'REJECT_FAILED_ROWS':
      return Enum$ErrorPolicyEnum.REJECT_FAILED_ROWS;
    default:
      return Enum$ErrorPolicyEnum.$unknown;
  }
}

enum Enum$EventDeliveryAttemptSortField {
  CREATED_AT,
  $unknown;

  factory Enum$EventDeliveryAttemptSortField.fromJson(String value) =>
      fromJson$Enum$EventDeliveryAttemptSortField(value);

  String toJson() => toJson$Enum$EventDeliveryAttemptSortField(this);
}

String toJson$Enum$EventDeliveryAttemptSortField(
    Enum$EventDeliveryAttemptSortField e) {
  switch (e) {
    case Enum$EventDeliveryAttemptSortField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$EventDeliveryAttemptSortField.$unknown:
      return r'$unknown';
  }
}

Enum$EventDeliveryAttemptSortField fromJson$Enum$EventDeliveryAttemptSortField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$EventDeliveryAttemptSortField.CREATED_AT;
    default:
      return Enum$EventDeliveryAttemptSortField.$unknown;
  }
}

enum Enum$EventDeliverySortField {
  CREATED_AT,
  $unknown;

  factory Enum$EventDeliverySortField.fromJson(String value) =>
      fromJson$Enum$EventDeliverySortField(value);

  String toJson() => toJson$Enum$EventDeliverySortField(this);
}

String toJson$Enum$EventDeliverySortField(Enum$EventDeliverySortField e) {
  switch (e) {
    case Enum$EventDeliverySortField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$EventDeliverySortField.$unknown:
      return r'$unknown';
  }
}

Enum$EventDeliverySortField fromJson$Enum$EventDeliverySortField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$EventDeliverySortField.CREATED_AT;
    default:
      return Enum$EventDeliverySortField.$unknown;
  }
}

enum Enum$EventDeliveryStatusEnum {
  PENDING,
  SUCCESS,
  FAILED,
  $unknown;

  factory Enum$EventDeliveryStatusEnum.fromJson(String value) =>
      fromJson$Enum$EventDeliveryStatusEnum(value);

  String toJson() => toJson$Enum$EventDeliveryStatusEnum(this);
}

String toJson$Enum$EventDeliveryStatusEnum(Enum$EventDeliveryStatusEnum e) {
  switch (e) {
    case Enum$EventDeliveryStatusEnum.PENDING:
      return r'PENDING';
    case Enum$EventDeliveryStatusEnum.SUCCESS:
      return r'SUCCESS';
    case Enum$EventDeliveryStatusEnum.FAILED:
      return r'FAILED';
    case Enum$EventDeliveryStatusEnum.$unknown:
      return r'$unknown';
  }
}

Enum$EventDeliveryStatusEnum fromJson$Enum$EventDeliveryStatusEnum(
    String value) {
  switch (value) {
    case r'PENDING':
      return Enum$EventDeliveryStatusEnum.PENDING;
    case r'SUCCESS':
      return Enum$EventDeliveryStatusEnum.SUCCESS;
    case r'FAILED':
      return Enum$EventDeliveryStatusEnum.FAILED;
    default:
      return Enum$EventDeliveryStatusEnum.$unknown;
  }
}

enum Enum$ExportErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  $unknown;

  factory Enum$ExportErrorCode.fromJson(String value) =>
      fromJson$Enum$ExportErrorCode(value);

  String toJson() => toJson$Enum$ExportErrorCode(this);
}

String toJson$Enum$ExportErrorCode(Enum$ExportErrorCode e) {
  switch (e) {
    case Enum$ExportErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$ExportErrorCode.INVALID:
      return r'INVALID';
    case Enum$ExportErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$ExportErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$ExportErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$ExportErrorCode fromJson$Enum$ExportErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$ExportErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$ExportErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$ExportErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$ExportErrorCode.REQUIRED;
    default:
      return Enum$ExportErrorCode.$unknown;
  }
}

enum Enum$ExportEventsEnum {
  EXPORT_PENDING,
  EXPORT_SUCCESS,
  EXPORT_FAILED,
  EXPORT_DELETED,
  EXPORTED_FILE_SENT,
  EXPORT_FAILED_INFO_SENT,
  $unknown;

  factory Enum$ExportEventsEnum.fromJson(String value) =>
      fromJson$Enum$ExportEventsEnum(value);

  String toJson() => toJson$Enum$ExportEventsEnum(this);
}

String toJson$Enum$ExportEventsEnum(Enum$ExportEventsEnum e) {
  switch (e) {
    case Enum$ExportEventsEnum.EXPORT_PENDING:
      return r'EXPORT_PENDING';
    case Enum$ExportEventsEnum.EXPORT_SUCCESS:
      return r'EXPORT_SUCCESS';
    case Enum$ExportEventsEnum.EXPORT_FAILED:
      return r'EXPORT_FAILED';
    case Enum$ExportEventsEnum.EXPORT_DELETED:
      return r'EXPORT_DELETED';
    case Enum$ExportEventsEnum.EXPORTED_FILE_SENT:
      return r'EXPORTED_FILE_SENT';
    case Enum$ExportEventsEnum.EXPORT_FAILED_INFO_SENT:
      return r'EXPORT_FAILED_INFO_SENT';
    case Enum$ExportEventsEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ExportEventsEnum fromJson$Enum$ExportEventsEnum(String value) {
  switch (value) {
    case r'EXPORT_PENDING':
      return Enum$ExportEventsEnum.EXPORT_PENDING;
    case r'EXPORT_SUCCESS':
      return Enum$ExportEventsEnum.EXPORT_SUCCESS;
    case r'EXPORT_FAILED':
      return Enum$ExportEventsEnum.EXPORT_FAILED;
    case r'EXPORT_DELETED':
      return Enum$ExportEventsEnum.EXPORT_DELETED;
    case r'EXPORTED_FILE_SENT':
      return Enum$ExportEventsEnum.EXPORTED_FILE_SENT;
    case r'EXPORT_FAILED_INFO_SENT':
      return Enum$ExportEventsEnum.EXPORT_FAILED_INFO_SENT;
    default:
      return Enum$ExportEventsEnum.$unknown;
  }
}

enum Enum$ExportFileSortField {
  STATUS,
  CREATED_AT,
  UPDATED_AT,
  LAST_MODIFIED_AT,
  $unknown;

  factory Enum$ExportFileSortField.fromJson(String value) =>
      fromJson$Enum$ExportFileSortField(value);

  String toJson() => toJson$Enum$ExportFileSortField(this);
}

String toJson$Enum$ExportFileSortField(Enum$ExportFileSortField e) {
  switch (e) {
    case Enum$ExportFileSortField.STATUS:
      return r'STATUS';
    case Enum$ExportFileSortField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ExportFileSortField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$ExportFileSortField.LAST_MODIFIED_AT:
      return r'LAST_MODIFIED_AT';
    case Enum$ExportFileSortField.$unknown:
      return r'$unknown';
  }
}

Enum$ExportFileSortField fromJson$Enum$ExportFileSortField(String value) {
  switch (value) {
    case r'STATUS':
      return Enum$ExportFileSortField.STATUS;
    case r'CREATED_AT':
      return Enum$ExportFileSortField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$ExportFileSortField.UPDATED_AT;
    case r'LAST_MODIFIED_AT':
      return Enum$ExportFileSortField.LAST_MODIFIED_AT;
    default:
      return Enum$ExportFileSortField.$unknown;
  }
}

enum Enum$ExportScope {
  ALL,
  IDS,
  FILTER,
  $unknown;

  factory Enum$ExportScope.fromJson(String value) =>
      fromJson$Enum$ExportScope(value);

  String toJson() => toJson$Enum$ExportScope(this);
}

String toJson$Enum$ExportScope(Enum$ExportScope e) {
  switch (e) {
    case Enum$ExportScope.ALL:
      return r'ALL';
    case Enum$ExportScope.IDS:
      return r'IDS';
    case Enum$ExportScope.FILTER:
      return r'FILTER';
    case Enum$ExportScope.$unknown:
      return r'$unknown';
  }
}

Enum$ExportScope fromJson$Enum$ExportScope(String value) {
  switch (value) {
    case r'ALL':
      return Enum$ExportScope.ALL;
    case r'IDS':
      return Enum$ExportScope.IDS;
    case r'FILTER':
      return Enum$ExportScope.FILTER;
    default:
      return Enum$ExportScope.$unknown;
  }
}

enum Enum$ExternalNotificationErrorCodes {
  REQUIRED,
  INVALID_MODEL_TYPE,
  NOT_FOUND,
  CHANNEL_INACTIVE,
  $unknown;

  factory Enum$ExternalNotificationErrorCodes.fromJson(String value) =>
      fromJson$Enum$ExternalNotificationErrorCodes(value);

  String toJson() => toJson$Enum$ExternalNotificationErrorCodes(this);
}

String toJson$Enum$ExternalNotificationErrorCodes(
    Enum$ExternalNotificationErrorCodes e) {
  switch (e) {
    case Enum$ExternalNotificationErrorCodes.REQUIRED:
      return r'REQUIRED';
    case Enum$ExternalNotificationErrorCodes.INVALID_MODEL_TYPE:
      return r'INVALID_MODEL_TYPE';
    case Enum$ExternalNotificationErrorCodes.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$ExternalNotificationErrorCodes.CHANNEL_INACTIVE:
      return r'CHANNEL_INACTIVE';
    case Enum$ExternalNotificationErrorCodes.$unknown:
      return r'$unknown';
  }
}

Enum$ExternalNotificationErrorCodes
    fromJson$Enum$ExternalNotificationErrorCodes(String value) {
  switch (value) {
    case r'REQUIRED':
      return Enum$ExternalNotificationErrorCodes.REQUIRED;
    case r'INVALID_MODEL_TYPE':
      return Enum$ExternalNotificationErrorCodes.INVALID_MODEL_TYPE;
    case r'NOT_FOUND':
      return Enum$ExternalNotificationErrorCodes.NOT_FOUND;
    case r'CHANNEL_INACTIVE':
      return Enum$ExternalNotificationErrorCodes.CHANNEL_INACTIVE;
    default:
      return Enum$ExternalNotificationErrorCodes.$unknown;
  }
}

enum Enum$FileTypesEnum {
  CSV,
  XLSX,
  $unknown;

  factory Enum$FileTypesEnum.fromJson(String value) =>
      fromJson$Enum$FileTypesEnum(value);

  String toJson() => toJson$Enum$FileTypesEnum(this);
}

String toJson$Enum$FileTypesEnum(Enum$FileTypesEnum e) {
  switch (e) {
    case Enum$FileTypesEnum.CSV:
      return r'CSV';
    case Enum$FileTypesEnum.XLSX:
      return r'XLSX';
    case Enum$FileTypesEnum.$unknown:
      return r'$unknown';
  }
}

Enum$FileTypesEnum fromJson$Enum$FileTypesEnum(String value) {
  switch (value) {
    case r'CSV':
      return Enum$FileTypesEnum.CSV;
    case r'XLSX':
      return Enum$FileTypesEnum.XLSX;
    default:
      return Enum$FileTypesEnum.$unknown;
  }
}

enum Enum$FulfillmentStatus {
  FULFILLED,
  REFUNDED,
  RETURNED,
  REPLACED,
  REFUNDED_AND_RETURNED,
  CANCELED,
  WAITING_FOR_APPROVAL,
  $unknown;

  factory Enum$FulfillmentStatus.fromJson(String value) =>
      fromJson$Enum$FulfillmentStatus(value);

  String toJson() => toJson$Enum$FulfillmentStatus(this);
}

String toJson$Enum$FulfillmentStatus(Enum$FulfillmentStatus e) {
  switch (e) {
    case Enum$FulfillmentStatus.FULFILLED:
      return r'FULFILLED';
    case Enum$FulfillmentStatus.REFUNDED:
      return r'REFUNDED';
    case Enum$FulfillmentStatus.RETURNED:
      return r'RETURNED';
    case Enum$FulfillmentStatus.REPLACED:
      return r'REPLACED';
    case Enum$FulfillmentStatus.REFUNDED_AND_RETURNED:
      return r'REFUNDED_AND_RETURNED';
    case Enum$FulfillmentStatus.CANCELED:
      return r'CANCELED';
    case Enum$FulfillmentStatus.WAITING_FOR_APPROVAL:
      return r'WAITING_FOR_APPROVAL';
    case Enum$FulfillmentStatus.$unknown:
      return r'$unknown';
  }
}

Enum$FulfillmentStatus fromJson$Enum$FulfillmentStatus(String value) {
  switch (value) {
    case r'FULFILLED':
      return Enum$FulfillmentStatus.FULFILLED;
    case r'REFUNDED':
      return Enum$FulfillmentStatus.REFUNDED;
    case r'RETURNED':
      return Enum$FulfillmentStatus.RETURNED;
    case r'REPLACED':
      return Enum$FulfillmentStatus.REPLACED;
    case r'REFUNDED_AND_RETURNED':
      return Enum$FulfillmentStatus.REFUNDED_AND_RETURNED;
    case r'CANCELED':
      return Enum$FulfillmentStatus.CANCELED;
    case r'WAITING_FOR_APPROVAL':
      return Enum$FulfillmentStatus.WAITING_FOR_APPROVAL;
    default:
      return Enum$FulfillmentStatus.$unknown;
  }
}

enum Enum$GiftCardErrorCode {
  ALREADY_EXISTS,
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  EXPIRED_GIFT_CARD,
  DUPLICATED_INPUT_ITEM,
  $unknown;

  factory Enum$GiftCardErrorCode.fromJson(String value) =>
      fromJson$Enum$GiftCardErrorCode(value);

  String toJson() => toJson$Enum$GiftCardErrorCode(this);
}

String toJson$Enum$GiftCardErrorCode(Enum$GiftCardErrorCode e) {
  switch (e) {
    case Enum$GiftCardErrorCode.ALREADY_EXISTS:
      return r'ALREADY_EXISTS';
    case Enum$GiftCardErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$GiftCardErrorCode.INVALID:
      return r'INVALID';
    case Enum$GiftCardErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$GiftCardErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$GiftCardErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$GiftCardErrorCode.EXPIRED_GIFT_CARD:
      return r'EXPIRED_GIFT_CARD';
    case Enum$GiftCardErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$GiftCardErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$GiftCardErrorCode fromJson$Enum$GiftCardErrorCode(String value) {
  switch (value) {
    case r'ALREADY_EXISTS':
      return Enum$GiftCardErrorCode.ALREADY_EXISTS;
    case r'GRAPHQL_ERROR':
      return Enum$GiftCardErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$GiftCardErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$GiftCardErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$GiftCardErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$GiftCardErrorCode.UNIQUE;
    case r'EXPIRED_GIFT_CARD':
      return Enum$GiftCardErrorCode.EXPIRED_GIFT_CARD;
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$GiftCardErrorCode.DUPLICATED_INPUT_ITEM;
    default:
      return Enum$GiftCardErrorCode.$unknown;
  }
}

enum Enum$GiftCardEventsEnum {
  ISSUED,
  BOUGHT,
  UPDATED,
  ACTIVATED,
  DEACTIVATED,
  BALANCE_RESET,
  EXPIRY_DATE_UPDATED,
  TAGS_UPDATED,
  SENT_TO_CUSTOMER,
  RESENT,
  NOTE_ADDED,
  USED_IN_ORDER,
  $unknown;

  factory Enum$GiftCardEventsEnum.fromJson(String value) =>
      fromJson$Enum$GiftCardEventsEnum(value);

  String toJson() => toJson$Enum$GiftCardEventsEnum(this);
}

String toJson$Enum$GiftCardEventsEnum(Enum$GiftCardEventsEnum e) {
  switch (e) {
    case Enum$GiftCardEventsEnum.ISSUED:
      return r'ISSUED';
    case Enum$GiftCardEventsEnum.BOUGHT:
      return r'BOUGHT';
    case Enum$GiftCardEventsEnum.UPDATED:
      return r'UPDATED';
    case Enum$GiftCardEventsEnum.ACTIVATED:
      return r'ACTIVATED';
    case Enum$GiftCardEventsEnum.DEACTIVATED:
      return r'DEACTIVATED';
    case Enum$GiftCardEventsEnum.BALANCE_RESET:
      return r'BALANCE_RESET';
    case Enum$GiftCardEventsEnum.EXPIRY_DATE_UPDATED:
      return r'EXPIRY_DATE_UPDATED';
    case Enum$GiftCardEventsEnum.TAGS_UPDATED:
      return r'TAGS_UPDATED';
    case Enum$GiftCardEventsEnum.SENT_TO_CUSTOMER:
      return r'SENT_TO_CUSTOMER';
    case Enum$GiftCardEventsEnum.RESENT:
      return r'RESENT';
    case Enum$GiftCardEventsEnum.NOTE_ADDED:
      return r'NOTE_ADDED';
    case Enum$GiftCardEventsEnum.USED_IN_ORDER:
      return r'USED_IN_ORDER';
    case Enum$GiftCardEventsEnum.$unknown:
      return r'$unknown';
  }
}

Enum$GiftCardEventsEnum fromJson$Enum$GiftCardEventsEnum(String value) {
  switch (value) {
    case r'ISSUED':
      return Enum$GiftCardEventsEnum.ISSUED;
    case r'BOUGHT':
      return Enum$GiftCardEventsEnum.BOUGHT;
    case r'UPDATED':
      return Enum$GiftCardEventsEnum.UPDATED;
    case r'ACTIVATED':
      return Enum$GiftCardEventsEnum.ACTIVATED;
    case r'DEACTIVATED':
      return Enum$GiftCardEventsEnum.DEACTIVATED;
    case r'BALANCE_RESET':
      return Enum$GiftCardEventsEnum.BALANCE_RESET;
    case r'EXPIRY_DATE_UPDATED':
      return Enum$GiftCardEventsEnum.EXPIRY_DATE_UPDATED;
    case r'TAGS_UPDATED':
      return Enum$GiftCardEventsEnum.TAGS_UPDATED;
    case r'SENT_TO_CUSTOMER':
      return Enum$GiftCardEventsEnum.SENT_TO_CUSTOMER;
    case r'RESENT':
      return Enum$GiftCardEventsEnum.RESENT;
    case r'NOTE_ADDED':
      return Enum$GiftCardEventsEnum.NOTE_ADDED;
    case r'USED_IN_ORDER':
      return Enum$GiftCardEventsEnum.USED_IN_ORDER;
    default:
      return Enum$GiftCardEventsEnum.$unknown;
  }
}

enum Enum$GiftCardSettingsErrorCode {
  INVALID,
  REQUIRED,
  GRAPHQL_ERROR,
  $unknown;

  factory Enum$GiftCardSettingsErrorCode.fromJson(String value) =>
      fromJson$Enum$GiftCardSettingsErrorCode(value);

  String toJson() => toJson$Enum$GiftCardSettingsErrorCode(this);
}

String toJson$Enum$GiftCardSettingsErrorCode(Enum$GiftCardSettingsErrorCode e) {
  switch (e) {
    case Enum$GiftCardSettingsErrorCode.INVALID:
      return r'INVALID';
    case Enum$GiftCardSettingsErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$GiftCardSettingsErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$GiftCardSettingsErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$GiftCardSettingsErrorCode fromJson$Enum$GiftCardSettingsErrorCode(
    String value) {
  switch (value) {
    case r'INVALID':
      return Enum$GiftCardSettingsErrorCode.INVALID;
    case r'REQUIRED':
      return Enum$GiftCardSettingsErrorCode.REQUIRED;
    case r'GRAPHQL_ERROR':
      return Enum$GiftCardSettingsErrorCode.GRAPHQL_ERROR;
    default:
      return Enum$GiftCardSettingsErrorCode.$unknown;
  }
}

enum Enum$GiftCardSettingsExpiryTypeEnum {
  NEVER_EXPIRE,
  EXPIRY_PERIOD,
  $unknown;

  factory Enum$GiftCardSettingsExpiryTypeEnum.fromJson(String value) =>
      fromJson$Enum$GiftCardSettingsExpiryTypeEnum(value);

  String toJson() => toJson$Enum$GiftCardSettingsExpiryTypeEnum(this);
}

String toJson$Enum$GiftCardSettingsExpiryTypeEnum(
    Enum$GiftCardSettingsExpiryTypeEnum e) {
  switch (e) {
    case Enum$GiftCardSettingsExpiryTypeEnum.NEVER_EXPIRE:
      return r'NEVER_EXPIRE';
    case Enum$GiftCardSettingsExpiryTypeEnum.EXPIRY_PERIOD:
      return r'EXPIRY_PERIOD';
    case Enum$GiftCardSettingsExpiryTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$GiftCardSettingsExpiryTypeEnum
    fromJson$Enum$GiftCardSettingsExpiryTypeEnum(String value) {
  switch (value) {
    case r'NEVER_EXPIRE':
      return Enum$GiftCardSettingsExpiryTypeEnum.NEVER_EXPIRE;
    case r'EXPIRY_PERIOD':
      return Enum$GiftCardSettingsExpiryTypeEnum.EXPIRY_PERIOD;
    default:
      return Enum$GiftCardSettingsExpiryTypeEnum.$unknown;
  }
}

enum Enum$GiftCardSortField {
  PRODUCT,
  USED_BY,
  CURRENT_BALANCE,
  CREATED_AT,
  $unknown;

  factory Enum$GiftCardSortField.fromJson(String value) =>
      fromJson$Enum$GiftCardSortField(value);

  String toJson() => toJson$Enum$GiftCardSortField(this);
}

String toJson$Enum$GiftCardSortField(Enum$GiftCardSortField e) {
  switch (e) {
    case Enum$GiftCardSortField.PRODUCT:
      return r'PRODUCT';
    case Enum$GiftCardSortField.USED_BY:
      return r'USED_BY';
    case Enum$GiftCardSortField.CURRENT_BALANCE:
      return r'CURRENT_BALANCE';
    case Enum$GiftCardSortField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$GiftCardSortField.$unknown:
      return r'$unknown';
  }
}

Enum$GiftCardSortField fromJson$Enum$GiftCardSortField(String value) {
  switch (value) {
    case r'PRODUCT':
      return Enum$GiftCardSortField.PRODUCT;
    case r'USED_BY':
      return Enum$GiftCardSortField.USED_BY;
    case r'CURRENT_BALANCE':
      return Enum$GiftCardSortField.CURRENT_BALANCE;
    case r'CREATED_AT':
      return Enum$GiftCardSortField.CREATED_AT;
    default:
      return Enum$GiftCardSortField.$unknown;
  }
}

enum Enum$HttpMethod {
  POST,
  GET,
  $unknown;

  factory Enum$HttpMethod.fromJson(String value) =>
      fromJson$Enum$HttpMethod(value);

  String toJson() => toJson$Enum$HttpMethod(this);
}

String toJson$Enum$HttpMethod(Enum$HttpMethod e) {
  switch (e) {
    case Enum$HttpMethod.POST:
      return r'POST';
    case Enum$HttpMethod.GET:
      return r'GET';
    case Enum$HttpMethod.$unknown:
      return r'$unknown';
  }
}

Enum$HttpMethod fromJson$Enum$HttpMethod(String value) {
  switch (value) {
    case r'POST':
      return Enum$HttpMethod.POST;
    case r'GET':
      return Enum$HttpMethod.GET;
    default:
      return Enum$HttpMethod.$unknown;
  }
}

enum Enum$IconThumbnailFormatEnum {
  ORIGINAL,
  WEBP,
  $unknown;

  factory Enum$IconThumbnailFormatEnum.fromJson(String value) =>
      fromJson$Enum$IconThumbnailFormatEnum(value);

  String toJson() => toJson$Enum$IconThumbnailFormatEnum(this);
}

String toJson$Enum$IconThumbnailFormatEnum(Enum$IconThumbnailFormatEnum e) {
  switch (e) {
    case Enum$IconThumbnailFormatEnum.ORIGINAL:
      return r'ORIGINAL';
    case Enum$IconThumbnailFormatEnum.WEBP:
      return r'WEBP';
    case Enum$IconThumbnailFormatEnum.$unknown:
      return r'$unknown';
  }
}

Enum$IconThumbnailFormatEnum fromJson$Enum$IconThumbnailFormatEnum(
    String value) {
  switch (value) {
    case r'ORIGINAL':
      return Enum$IconThumbnailFormatEnum.ORIGINAL;
    case r'WEBP':
      return Enum$IconThumbnailFormatEnum.WEBP;
    default:
      return Enum$IconThumbnailFormatEnum.$unknown;
  }
}

enum Enum$InvoiceErrorCode {
  REQUIRED,
  NOT_READY,
  URL_NOT_SET,
  EMAIL_NOT_SET,
  NUMBER_NOT_SET,
  NOT_FOUND,
  INVALID_STATUS,
  NO_INVOICE_PLUGIN,
  $unknown;

  factory Enum$InvoiceErrorCode.fromJson(String value) =>
      fromJson$Enum$InvoiceErrorCode(value);

  String toJson() => toJson$Enum$InvoiceErrorCode(this);
}

String toJson$Enum$InvoiceErrorCode(Enum$InvoiceErrorCode e) {
  switch (e) {
    case Enum$InvoiceErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$InvoiceErrorCode.NOT_READY:
      return r'NOT_READY';
    case Enum$InvoiceErrorCode.URL_NOT_SET:
      return r'URL_NOT_SET';
    case Enum$InvoiceErrorCode.EMAIL_NOT_SET:
      return r'EMAIL_NOT_SET';
    case Enum$InvoiceErrorCode.NUMBER_NOT_SET:
      return r'NUMBER_NOT_SET';
    case Enum$InvoiceErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$InvoiceErrorCode.INVALID_STATUS:
      return r'INVALID_STATUS';
    case Enum$InvoiceErrorCode.NO_INVOICE_PLUGIN:
      return r'NO_INVOICE_PLUGIN';
    case Enum$InvoiceErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$InvoiceErrorCode fromJson$Enum$InvoiceErrorCode(String value) {
  switch (value) {
    case r'REQUIRED':
      return Enum$InvoiceErrorCode.REQUIRED;
    case r'NOT_READY':
      return Enum$InvoiceErrorCode.NOT_READY;
    case r'URL_NOT_SET':
      return Enum$InvoiceErrorCode.URL_NOT_SET;
    case r'EMAIL_NOT_SET':
      return Enum$InvoiceErrorCode.EMAIL_NOT_SET;
    case r'NUMBER_NOT_SET':
      return Enum$InvoiceErrorCode.NUMBER_NOT_SET;
    case r'NOT_FOUND':
      return Enum$InvoiceErrorCode.NOT_FOUND;
    case r'INVALID_STATUS':
      return Enum$InvoiceErrorCode.INVALID_STATUS;
    case r'NO_INVOICE_PLUGIN':
      return Enum$InvoiceErrorCode.NO_INVOICE_PLUGIN;
    default:
      return Enum$InvoiceErrorCode.$unknown;
  }
}

enum Enum$JobStatusEnum {
  PENDING,
  SUCCESS,
  FAILED,
  DELETED,
  $unknown;

  factory Enum$JobStatusEnum.fromJson(String value) =>
      fromJson$Enum$JobStatusEnum(value);

  String toJson() => toJson$Enum$JobStatusEnum(this);
}

String toJson$Enum$JobStatusEnum(Enum$JobStatusEnum e) {
  switch (e) {
    case Enum$JobStatusEnum.PENDING:
      return r'PENDING';
    case Enum$JobStatusEnum.SUCCESS:
      return r'SUCCESS';
    case Enum$JobStatusEnum.FAILED:
      return r'FAILED';
    case Enum$JobStatusEnum.DELETED:
      return r'DELETED';
    case Enum$JobStatusEnum.$unknown:
      return r'$unknown';
  }
}

Enum$JobStatusEnum fromJson$Enum$JobStatusEnum(String value) {
  switch (value) {
    case r'PENDING':
      return Enum$JobStatusEnum.PENDING;
    case r'SUCCESS':
      return Enum$JobStatusEnum.SUCCESS;
    case r'FAILED':
      return Enum$JobStatusEnum.FAILED;
    case r'DELETED':
      return Enum$JobStatusEnum.DELETED;
    default:
      return Enum$JobStatusEnum.$unknown;
  }
}

enum Enum$LanguageCodeEnum {
  AF,
  AF_NA,
  AF_ZA,
  AGQ,
  AGQ_CM,
  AK,
  AK_GH,
  AM,
  AM_ET,
  AR,
  AR_AE,
  AR_BH,
  AR_DJ,
  AR_DZ,
  AR_EG,
  AR_EH,
  AR_ER,
  AR_IL,
  AR_IQ,
  AR_JO,
  AR_KM,
  AR_KW,
  AR_LB,
  AR_LY,
  AR_MA,
  AR_MR,
  AR_OM,
  AR_PS,
  AR_QA,
  AR_SA,
  AR_SD,
  AR_SO,
  AR_SS,
  AR_SY,
  AR_TD,
  AR_TN,
  AR_YE,
  AS,
  AS_IN,
  ASA,
  ASA_TZ,
  AST,
  AST_ES,
  AZ,
  AZ_CYRL,
  AZ_CYRL_AZ,
  AZ_LATN,
  AZ_LATN_AZ,
  BAS,
  BAS_CM,
  BE,
  BE_BY,
  BEM,
  BEM_ZM,
  BEZ,
  BEZ_TZ,
  BG,
  BG_BG,
  BM,
  BM_ML,
  BN,
  BN_BD,
  BN_IN,
  BO,
  BO_CN,
  BO_IN,
  BR,
  BR_FR,
  BRX,
  BRX_IN,
  BS,
  BS_CYRL,
  BS_CYRL_BA,
  BS_LATN,
  BS_LATN_BA,
  CA,
  CA_AD,
  CA_ES,
  CA_ES_VALENCIA,
  CA_FR,
  CA_IT,
  CCP,
  CCP_BD,
  CCP_IN,
  CE,
  CE_RU,
  CEB,
  CEB_PH,
  CGG,
  CGG_UG,
  CHR,
  CHR_US,
  CKB,
  CKB_IQ,
  CKB_IR,
  CS,
  CS_CZ,
  CU,
  CU_RU,
  CY,
  CY_GB,
  DA,
  DA_DK,
  DA_GL,
  DAV,
  DAV_KE,
  DE,
  DE_AT,
  DE_BE,
  DE_CH,
  DE_DE,
  DE_IT,
  DE_LI,
  DE_LU,
  DJE,
  DJE_NE,
  DSB,
  DSB_DE,
  DUA,
  DUA_CM,
  DYO,
  DYO_SN,
  DZ,
  DZ_BT,
  EBU,
  EBU_KE,
  EE,
  EE_GH,
  EE_TG,
  EL,
  EL_CY,
  EL_GR,
  EN,
  EN_AE,
  EN_AG,
  EN_AI,
  EN_AS,
  EN_AT,
  EN_AU,
  EN_BB,
  EN_BE,
  EN_BI,
  EN_BM,
  EN_BS,
  EN_BW,
  EN_BZ,
  EN_CA,
  EN_CC,
  EN_CH,
  EN_CK,
  EN_CM,
  EN_CX,
  EN_CY,
  EN_DE,
  EN_DG,
  EN_DK,
  EN_DM,
  EN_ER,
  EN_FI,
  EN_FJ,
  EN_FK,
  EN_FM,
  EN_GB,
  EN_GD,
  EN_GG,
  EN_GH,
  EN_GI,
  EN_GM,
  EN_GU,
  EN_GY,
  EN_HK,
  EN_IE,
  EN_IL,
  EN_IM,
  EN_IN,
  EN_IO,
  EN_JE,
  EN_JM,
  EN_KE,
  EN_KI,
  EN_KN,
  EN_KY,
  EN_LC,
  EN_LR,
  EN_LS,
  EN_MG,
  EN_MH,
  EN_MO,
  EN_MP,
  EN_MS,
  EN_MT,
  EN_MU,
  EN_MW,
  EN_MY,
  EN_NA,
  EN_NF,
  EN_NG,
  EN_NL,
  EN_NR,
  EN_NU,
  EN_NZ,
  EN_PG,
  EN_PH,
  EN_PK,
  EN_PN,
  EN_PR,
  EN_PW,
  EN_RW,
  EN_SB,
  EN_SC,
  EN_SD,
  EN_SE,
  EN_SG,
  EN_SH,
  EN_SI,
  EN_SL,
  EN_SS,
  EN_SX,
  EN_SZ,
  EN_TC,
  EN_TK,
  EN_TO,
  EN_TT,
  EN_TV,
  EN_TZ,
  EN_UG,
  EN_UM,
  EN_US,
  EN_VC,
  EN_VG,
  EN_VI,
  EN_VU,
  EN_WS,
  EN_ZA,
  EN_ZM,
  EN_ZW,
  EO,
  ES,
  ES_AR,
  ES_BO,
  ES_BR,
  ES_BZ,
  ES_CL,
  ES_CO,
  ES_CR,
  ES_CU,
  ES_DO,
  ES_EA,
  ES_EC,
  ES_ES,
  ES_GQ,
  ES_GT,
  ES_HN,
  ES_IC,
  ES_MX,
  ES_NI,
  ES_PA,
  ES_PE,
  ES_PH,
  ES_PR,
  ES_PY,
  ES_SV,
  ES_US,
  ES_UY,
  ES_VE,
  ET,
  ET_EE,
  EU,
  EU_ES,
  EWO,
  EWO_CM,
  FA,
  FA_AF,
  FA_IR,
  FF,
  FF_ADLM,
  FF_ADLM_BF,
  FF_ADLM_CM,
  FF_ADLM_GH,
  FF_ADLM_GM,
  FF_ADLM_GN,
  FF_ADLM_GW,
  FF_ADLM_LR,
  FF_ADLM_MR,
  FF_ADLM_NE,
  FF_ADLM_NG,
  FF_ADLM_SL,
  FF_ADLM_SN,
  FF_LATN,
  FF_LATN_BF,
  FF_LATN_CM,
  FF_LATN_GH,
  FF_LATN_GM,
  FF_LATN_GN,
  FF_LATN_GW,
  FF_LATN_LR,
  FF_LATN_MR,
  FF_LATN_NE,
  FF_LATN_NG,
  FF_LATN_SL,
  FF_LATN_SN,
  FI,
  FI_FI,
  FIL,
  FIL_PH,
  FO,
  FO_DK,
  FO_FO,
  FR,
  FR_BE,
  FR_BF,
  FR_BI,
  FR_BJ,
  FR_BL,
  FR_CA,
  FR_CD,
  FR_CF,
  FR_CG,
  FR_CH,
  FR_CI,
  FR_CM,
  FR_DJ,
  FR_DZ,
  FR_FR,
  FR_GA,
  FR_GF,
  FR_GN,
  FR_GP,
  FR_GQ,
  FR_HT,
  FR_KM,
  FR_LU,
  FR_MA,
  FR_MC,
  FR_MF,
  FR_MG,
  FR_ML,
  FR_MQ,
  FR_MR,
  FR_MU,
  FR_NC,
  FR_NE,
  FR_PF,
  FR_PM,
  FR_RE,
  FR_RW,
  FR_SC,
  FR_SN,
  FR_SY,
  FR_TD,
  FR_TG,
  FR_TN,
  FR_VU,
  FR_WF,
  FR_YT,
  FUR,
  FUR_IT,
  FY,
  FY_NL,
  GA,
  GA_GB,
  GA_IE,
  GD,
  GD_GB,
  GL,
  GL_ES,
  GSW,
  GSW_CH,
  GSW_FR,
  GSW_LI,
  GU,
  GU_IN,
  GUZ,
  GUZ_KE,
  GV,
  GV_IM,
  HA,
  HA_GH,
  HA_NE,
  HA_NG,
  HAW,
  HAW_US,
  HE,
  HE_IL,
  HI,
  HI_IN,
  HR,
  HR_BA,
  HR_HR,
  HSB,
  HSB_DE,
  HU,
  HU_HU,
  HY,
  HY_AM,
  IA,
  ID,
  ID_ID,
  IG,
  IG_NG,
  II,
  II_CN,
  IS,
  IS_IS,
  IT,
  IT_CH,
  IT_IT,
  IT_SM,
  IT_VA,
  JA,
  JA_JP,
  JGO,
  JGO_CM,
  JMC,
  JMC_TZ,
  JV,
  JV_ID,
  KA,
  KA_GE,
  KAB,
  KAB_DZ,
  KAM,
  KAM_KE,
  KDE,
  KDE_TZ,
  KEA,
  KEA_CV,
  KHQ,
  KHQ_ML,
  KI,
  KI_KE,
  KK,
  KK_KZ,
  KKJ,
  KKJ_CM,
  KL,
  KL_GL,
  KLN,
  KLN_KE,
  KM,
  KM_KH,
  KN,
  KN_IN,
  KO,
  KO_KP,
  KO_KR,
  KOK,
  KOK_IN,
  KS,
  KS_ARAB,
  KS_ARAB_IN,
  KSB,
  KSB_TZ,
  KSF,
  KSF_CM,
  KSH,
  KSH_DE,
  KU,
  KU_TR,
  KW,
  KW_GB,
  KY,
  KY_KG,
  LAG,
  LAG_TZ,
  LB,
  LB_LU,
  LG,
  LG_UG,
  LKT,
  LKT_US,
  LN,
  LN_AO,
  LN_CD,
  LN_CF,
  LN_CG,
  LO,
  LO_LA,
  LRC,
  LRC_IQ,
  LRC_IR,
  LT,
  LT_LT,
  LU,
  LU_CD,
  LUO,
  LUO_KE,
  LUY,
  LUY_KE,
  LV,
  LV_LV,
  MAI,
  MAI_IN,
  MAS,
  MAS_KE,
  MAS_TZ,
  MER,
  MER_KE,
  MFE,
  MFE_MU,
  MG,
  MG_MG,
  MGH,
  MGH_MZ,
  MGO,
  MGO_CM,
  MI,
  MI_NZ,
  MK,
  MK_MK,
  ML,
  ML_IN,
  MN,
  MN_MN,
  MNI,
  MNI_BENG,
  MNI_BENG_IN,
  MR,
  MR_IN,
  MS,
  MS_BN,
  MS_ID,
  MS_MY,
  MS_SG,
  MT,
  MT_MT,
  MUA,
  MUA_CM,
  MY,
  MY_MM,
  MZN,
  MZN_IR,
  NAQ,
  NAQ_NA,
  NB,
  NB_NO,
  NB_SJ,
  ND,
  ND_ZW,
  NDS,
  NDS_DE,
  NDS_NL,
  NE,
  NE_IN,
  NE_NP,
  NL,
  NL_AW,
  NL_BE,
  NL_BQ,
  NL_CW,
  NL_NL,
  NL_SR,
  NL_SX,
  NMG,
  NMG_CM,
  NN,
  NN_NO,
  NNH,
  NNH_CM,
  NUS,
  NUS_SS,
  NYN,
  NYN_UG,
  OM,
  OM_ET,
  OM_KE,
  OR,
  OR_IN,
  OS,
  OS_GE,
  OS_RU,
  PA,
  PA_ARAB,
  PA_ARAB_PK,
  PA_GURU,
  PA_GURU_IN,
  PCM,
  PCM_NG,
  PL,
  PL_PL,
  PRG,
  PS,
  PS_AF,
  PS_PK,
  PT,
  PT_AO,
  PT_BR,
  PT_CH,
  PT_CV,
  PT_GQ,
  PT_GW,
  PT_LU,
  PT_MO,
  PT_MZ,
  PT_PT,
  PT_ST,
  PT_TL,
  QU,
  QU_BO,
  QU_EC,
  QU_PE,
  RM,
  RM_CH,
  RN,
  RN_BI,
  RO,
  RO_MD,
  RO_RO,
  ROF,
  ROF_TZ,
  RU,
  RU_BY,
  RU_KG,
  RU_KZ,
  RU_MD,
  RU_RU,
  RU_UA,
  RW,
  RW_RW,
  RWK,
  RWK_TZ,
  SAH,
  SAH_RU,
  SAQ,
  SAQ_KE,
  SAT,
  SAT_OLCK,
  SAT_OLCK_IN,
  SBP,
  SBP_TZ,
  SD,
  SD_ARAB,
  SD_ARAB_PK,
  SD_DEVA,
  SD_DEVA_IN,
  SE,
  SE_FI,
  SE_NO,
  SE_SE,
  SEH,
  SEH_MZ,
  SES,
  SES_ML,
  SG,
  SG_CF,
  SHI,
  SHI_LATN,
  SHI_LATN_MA,
  SHI_TFNG,
  SHI_TFNG_MA,
  SI,
  SI_LK,
  SK,
  SK_SK,
  SL,
  SL_SI,
  SMN,
  SMN_FI,
  SN,
  SN_ZW,
  SO,
  SO_DJ,
  SO_ET,
  SO_KE,
  SO_SO,
  SQ,
  SQ_AL,
  SQ_MK,
  SQ_XK,
  SR,
  SR_CYRL,
  SR_CYRL_BA,
  SR_CYRL_ME,
  SR_CYRL_RS,
  SR_CYRL_XK,
  SR_LATN,
  SR_LATN_BA,
  SR_LATN_ME,
  SR_LATN_RS,
  SR_LATN_XK,
  SU,
  SU_LATN,
  SU_LATN_ID,
  SV,
  SV_AX,
  SV_FI,
  SV_SE,
  SW,
  SW_CD,
  SW_KE,
  SW_TZ,
  SW_UG,
  TA,
  TA_IN,
  TA_LK,
  TA_MY,
  TA_SG,
  TE,
  TE_IN,
  TEO,
  TEO_KE,
  TEO_UG,
  TG,
  TG_TJ,
  TH,
  TH_TH,
  TI,
  TI_ER,
  TI_ET,
  TK,
  TK_TM,
  TO,
  TO_TO,
  TR,
  TR_CY,
  TR_TR,
  TT,
  TT_RU,
  TWQ,
  TWQ_NE,
  TZM,
  TZM_MA,
  UG,
  UG_CN,
  UK,
  UK_UA,
  UR,
  UR_IN,
  UR_PK,
  UZ,
  UZ_ARAB,
  UZ_ARAB_AF,
  UZ_CYRL,
  UZ_CYRL_UZ,
  UZ_LATN,
  UZ_LATN_UZ,
  VAI,
  VAI_LATN,
  VAI_LATN_LR,
  VAI_VAII,
  VAI_VAII_LR,
  VI,
  VI_VN,
  VO,
  VUN,
  VUN_TZ,
  WAE,
  WAE_CH,
  WO,
  WO_SN,
  XH,
  XH_ZA,
  XOG,
  XOG_UG,
  YAV,
  YAV_CM,
  YI,
  YO,
  YO_BJ,
  YO_NG,
  YUE,
  YUE_HANS,
  YUE_HANS_CN,
  YUE_HANT,
  YUE_HANT_HK,
  ZGH,
  ZGH_MA,
  ZH,
  ZH_HANS,
  ZH_HANS_CN,
  ZH_HANS_HK,
  ZH_HANS_MO,
  ZH_HANS_SG,
  ZH_HANT,
  ZH_HANT_HK,
  ZH_HANT_MO,
  ZH_HANT_TW,
  ZU,
  ZU_ZA,
  $unknown;

  factory Enum$LanguageCodeEnum.fromJson(String value) =>
      fromJson$Enum$LanguageCodeEnum(value);

  String toJson() => toJson$Enum$LanguageCodeEnum(this);
}

String toJson$Enum$LanguageCodeEnum(Enum$LanguageCodeEnum e) {
  switch (e) {
    case Enum$LanguageCodeEnum.AF:
      return r'AF';
    case Enum$LanguageCodeEnum.AF_NA:
      return r'AF_NA';
    case Enum$LanguageCodeEnum.AF_ZA:
      return r'AF_ZA';
    case Enum$LanguageCodeEnum.AGQ:
      return r'AGQ';
    case Enum$LanguageCodeEnum.AGQ_CM:
      return r'AGQ_CM';
    case Enum$LanguageCodeEnum.AK:
      return r'AK';
    case Enum$LanguageCodeEnum.AK_GH:
      return r'AK_GH';
    case Enum$LanguageCodeEnum.AM:
      return r'AM';
    case Enum$LanguageCodeEnum.AM_ET:
      return r'AM_ET';
    case Enum$LanguageCodeEnum.AR:
      return r'AR';
    case Enum$LanguageCodeEnum.AR_AE:
      return r'AR_AE';
    case Enum$LanguageCodeEnum.AR_BH:
      return r'AR_BH';
    case Enum$LanguageCodeEnum.AR_DJ:
      return r'AR_DJ';
    case Enum$LanguageCodeEnum.AR_DZ:
      return r'AR_DZ';
    case Enum$LanguageCodeEnum.AR_EG:
      return r'AR_EG';
    case Enum$LanguageCodeEnum.AR_EH:
      return r'AR_EH';
    case Enum$LanguageCodeEnum.AR_ER:
      return r'AR_ER';
    case Enum$LanguageCodeEnum.AR_IL:
      return r'AR_IL';
    case Enum$LanguageCodeEnum.AR_IQ:
      return r'AR_IQ';
    case Enum$LanguageCodeEnum.AR_JO:
      return r'AR_JO';
    case Enum$LanguageCodeEnum.AR_KM:
      return r'AR_KM';
    case Enum$LanguageCodeEnum.AR_KW:
      return r'AR_KW';
    case Enum$LanguageCodeEnum.AR_LB:
      return r'AR_LB';
    case Enum$LanguageCodeEnum.AR_LY:
      return r'AR_LY';
    case Enum$LanguageCodeEnum.AR_MA:
      return r'AR_MA';
    case Enum$LanguageCodeEnum.AR_MR:
      return r'AR_MR';
    case Enum$LanguageCodeEnum.AR_OM:
      return r'AR_OM';
    case Enum$LanguageCodeEnum.AR_PS:
      return r'AR_PS';
    case Enum$LanguageCodeEnum.AR_QA:
      return r'AR_QA';
    case Enum$LanguageCodeEnum.AR_SA:
      return r'AR_SA';
    case Enum$LanguageCodeEnum.AR_SD:
      return r'AR_SD';
    case Enum$LanguageCodeEnum.AR_SO:
      return r'AR_SO';
    case Enum$LanguageCodeEnum.AR_SS:
      return r'AR_SS';
    case Enum$LanguageCodeEnum.AR_SY:
      return r'AR_SY';
    case Enum$LanguageCodeEnum.AR_TD:
      return r'AR_TD';
    case Enum$LanguageCodeEnum.AR_TN:
      return r'AR_TN';
    case Enum$LanguageCodeEnum.AR_YE:
      return r'AR_YE';
    case Enum$LanguageCodeEnum.AS:
      return r'AS';
    case Enum$LanguageCodeEnum.AS_IN:
      return r'AS_IN';
    case Enum$LanguageCodeEnum.ASA:
      return r'ASA';
    case Enum$LanguageCodeEnum.ASA_TZ:
      return r'ASA_TZ';
    case Enum$LanguageCodeEnum.AST:
      return r'AST';
    case Enum$LanguageCodeEnum.AST_ES:
      return r'AST_ES';
    case Enum$LanguageCodeEnum.AZ:
      return r'AZ';
    case Enum$LanguageCodeEnum.AZ_CYRL:
      return r'AZ_CYRL';
    case Enum$LanguageCodeEnum.AZ_CYRL_AZ:
      return r'AZ_CYRL_AZ';
    case Enum$LanguageCodeEnum.AZ_LATN:
      return r'AZ_LATN';
    case Enum$LanguageCodeEnum.AZ_LATN_AZ:
      return r'AZ_LATN_AZ';
    case Enum$LanguageCodeEnum.BAS:
      return r'BAS';
    case Enum$LanguageCodeEnum.BAS_CM:
      return r'BAS_CM';
    case Enum$LanguageCodeEnum.BE:
      return r'BE';
    case Enum$LanguageCodeEnum.BE_BY:
      return r'BE_BY';
    case Enum$LanguageCodeEnum.BEM:
      return r'BEM';
    case Enum$LanguageCodeEnum.BEM_ZM:
      return r'BEM_ZM';
    case Enum$LanguageCodeEnum.BEZ:
      return r'BEZ';
    case Enum$LanguageCodeEnum.BEZ_TZ:
      return r'BEZ_TZ';
    case Enum$LanguageCodeEnum.BG:
      return r'BG';
    case Enum$LanguageCodeEnum.BG_BG:
      return r'BG_BG';
    case Enum$LanguageCodeEnum.BM:
      return r'BM';
    case Enum$LanguageCodeEnum.BM_ML:
      return r'BM_ML';
    case Enum$LanguageCodeEnum.BN:
      return r'BN';
    case Enum$LanguageCodeEnum.BN_BD:
      return r'BN_BD';
    case Enum$LanguageCodeEnum.BN_IN:
      return r'BN_IN';
    case Enum$LanguageCodeEnum.BO:
      return r'BO';
    case Enum$LanguageCodeEnum.BO_CN:
      return r'BO_CN';
    case Enum$LanguageCodeEnum.BO_IN:
      return r'BO_IN';
    case Enum$LanguageCodeEnum.BR:
      return r'BR';
    case Enum$LanguageCodeEnum.BR_FR:
      return r'BR_FR';
    case Enum$LanguageCodeEnum.BRX:
      return r'BRX';
    case Enum$LanguageCodeEnum.BRX_IN:
      return r'BRX_IN';
    case Enum$LanguageCodeEnum.BS:
      return r'BS';
    case Enum$LanguageCodeEnum.BS_CYRL:
      return r'BS_CYRL';
    case Enum$LanguageCodeEnum.BS_CYRL_BA:
      return r'BS_CYRL_BA';
    case Enum$LanguageCodeEnum.BS_LATN:
      return r'BS_LATN';
    case Enum$LanguageCodeEnum.BS_LATN_BA:
      return r'BS_LATN_BA';
    case Enum$LanguageCodeEnum.CA:
      return r'CA';
    case Enum$LanguageCodeEnum.CA_AD:
      return r'CA_AD';
    case Enum$LanguageCodeEnum.CA_ES:
      return r'CA_ES';
    case Enum$LanguageCodeEnum.CA_ES_VALENCIA:
      return r'CA_ES_VALENCIA';
    case Enum$LanguageCodeEnum.CA_FR:
      return r'CA_FR';
    case Enum$LanguageCodeEnum.CA_IT:
      return r'CA_IT';
    case Enum$LanguageCodeEnum.CCP:
      return r'CCP';
    case Enum$LanguageCodeEnum.CCP_BD:
      return r'CCP_BD';
    case Enum$LanguageCodeEnum.CCP_IN:
      return r'CCP_IN';
    case Enum$LanguageCodeEnum.CE:
      return r'CE';
    case Enum$LanguageCodeEnum.CE_RU:
      return r'CE_RU';
    case Enum$LanguageCodeEnum.CEB:
      return r'CEB';
    case Enum$LanguageCodeEnum.CEB_PH:
      return r'CEB_PH';
    case Enum$LanguageCodeEnum.CGG:
      return r'CGG';
    case Enum$LanguageCodeEnum.CGG_UG:
      return r'CGG_UG';
    case Enum$LanguageCodeEnum.CHR:
      return r'CHR';
    case Enum$LanguageCodeEnum.CHR_US:
      return r'CHR_US';
    case Enum$LanguageCodeEnum.CKB:
      return r'CKB';
    case Enum$LanguageCodeEnum.CKB_IQ:
      return r'CKB_IQ';
    case Enum$LanguageCodeEnum.CKB_IR:
      return r'CKB_IR';
    case Enum$LanguageCodeEnum.CS:
      return r'CS';
    case Enum$LanguageCodeEnum.CS_CZ:
      return r'CS_CZ';
    case Enum$LanguageCodeEnum.CU:
      return r'CU';
    case Enum$LanguageCodeEnum.CU_RU:
      return r'CU_RU';
    case Enum$LanguageCodeEnum.CY:
      return r'CY';
    case Enum$LanguageCodeEnum.CY_GB:
      return r'CY_GB';
    case Enum$LanguageCodeEnum.DA:
      return r'DA';
    case Enum$LanguageCodeEnum.DA_DK:
      return r'DA_DK';
    case Enum$LanguageCodeEnum.DA_GL:
      return r'DA_GL';
    case Enum$LanguageCodeEnum.DAV:
      return r'DAV';
    case Enum$LanguageCodeEnum.DAV_KE:
      return r'DAV_KE';
    case Enum$LanguageCodeEnum.DE:
      return r'DE';
    case Enum$LanguageCodeEnum.DE_AT:
      return r'DE_AT';
    case Enum$LanguageCodeEnum.DE_BE:
      return r'DE_BE';
    case Enum$LanguageCodeEnum.DE_CH:
      return r'DE_CH';
    case Enum$LanguageCodeEnum.DE_DE:
      return r'DE_DE';
    case Enum$LanguageCodeEnum.DE_IT:
      return r'DE_IT';
    case Enum$LanguageCodeEnum.DE_LI:
      return r'DE_LI';
    case Enum$LanguageCodeEnum.DE_LU:
      return r'DE_LU';
    case Enum$LanguageCodeEnum.DJE:
      return r'DJE';
    case Enum$LanguageCodeEnum.DJE_NE:
      return r'DJE_NE';
    case Enum$LanguageCodeEnum.DSB:
      return r'DSB';
    case Enum$LanguageCodeEnum.DSB_DE:
      return r'DSB_DE';
    case Enum$LanguageCodeEnum.DUA:
      return r'DUA';
    case Enum$LanguageCodeEnum.DUA_CM:
      return r'DUA_CM';
    case Enum$LanguageCodeEnum.DYO:
      return r'DYO';
    case Enum$LanguageCodeEnum.DYO_SN:
      return r'DYO_SN';
    case Enum$LanguageCodeEnum.DZ:
      return r'DZ';
    case Enum$LanguageCodeEnum.DZ_BT:
      return r'DZ_BT';
    case Enum$LanguageCodeEnum.EBU:
      return r'EBU';
    case Enum$LanguageCodeEnum.EBU_KE:
      return r'EBU_KE';
    case Enum$LanguageCodeEnum.EE:
      return r'EE';
    case Enum$LanguageCodeEnum.EE_GH:
      return r'EE_GH';
    case Enum$LanguageCodeEnum.EE_TG:
      return r'EE_TG';
    case Enum$LanguageCodeEnum.EL:
      return r'EL';
    case Enum$LanguageCodeEnum.EL_CY:
      return r'EL_CY';
    case Enum$LanguageCodeEnum.EL_GR:
      return r'EL_GR';
    case Enum$LanguageCodeEnum.EN:
      return r'EN';
    case Enum$LanguageCodeEnum.EN_AE:
      return r'EN_AE';
    case Enum$LanguageCodeEnum.EN_AG:
      return r'EN_AG';
    case Enum$LanguageCodeEnum.EN_AI:
      return r'EN_AI';
    case Enum$LanguageCodeEnum.EN_AS:
      return r'EN_AS';
    case Enum$LanguageCodeEnum.EN_AT:
      return r'EN_AT';
    case Enum$LanguageCodeEnum.EN_AU:
      return r'EN_AU';
    case Enum$LanguageCodeEnum.EN_BB:
      return r'EN_BB';
    case Enum$LanguageCodeEnum.EN_BE:
      return r'EN_BE';
    case Enum$LanguageCodeEnum.EN_BI:
      return r'EN_BI';
    case Enum$LanguageCodeEnum.EN_BM:
      return r'EN_BM';
    case Enum$LanguageCodeEnum.EN_BS:
      return r'EN_BS';
    case Enum$LanguageCodeEnum.EN_BW:
      return r'EN_BW';
    case Enum$LanguageCodeEnum.EN_BZ:
      return r'EN_BZ';
    case Enum$LanguageCodeEnum.EN_CA:
      return r'EN_CA';
    case Enum$LanguageCodeEnum.EN_CC:
      return r'EN_CC';
    case Enum$LanguageCodeEnum.EN_CH:
      return r'EN_CH';
    case Enum$LanguageCodeEnum.EN_CK:
      return r'EN_CK';
    case Enum$LanguageCodeEnum.EN_CM:
      return r'EN_CM';
    case Enum$LanguageCodeEnum.EN_CX:
      return r'EN_CX';
    case Enum$LanguageCodeEnum.EN_CY:
      return r'EN_CY';
    case Enum$LanguageCodeEnum.EN_DE:
      return r'EN_DE';
    case Enum$LanguageCodeEnum.EN_DG:
      return r'EN_DG';
    case Enum$LanguageCodeEnum.EN_DK:
      return r'EN_DK';
    case Enum$LanguageCodeEnum.EN_DM:
      return r'EN_DM';
    case Enum$LanguageCodeEnum.EN_ER:
      return r'EN_ER';
    case Enum$LanguageCodeEnum.EN_FI:
      return r'EN_FI';
    case Enum$LanguageCodeEnum.EN_FJ:
      return r'EN_FJ';
    case Enum$LanguageCodeEnum.EN_FK:
      return r'EN_FK';
    case Enum$LanguageCodeEnum.EN_FM:
      return r'EN_FM';
    case Enum$LanguageCodeEnum.EN_GB:
      return r'EN_GB';
    case Enum$LanguageCodeEnum.EN_GD:
      return r'EN_GD';
    case Enum$LanguageCodeEnum.EN_GG:
      return r'EN_GG';
    case Enum$LanguageCodeEnum.EN_GH:
      return r'EN_GH';
    case Enum$LanguageCodeEnum.EN_GI:
      return r'EN_GI';
    case Enum$LanguageCodeEnum.EN_GM:
      return r'EN_GM';
    case Enum$LanguageCodeEnum.EN_GU:
      return r'EN_GU';
    case Enum$LanguageCodeEnum.EN_GY:
      return r'EN_GY';
    case Enum$LanguageCodeEnum.EN_HK:
      return r'EN_HK';
    case Enum$LanguageCodeEnum.EN_IE:
      return r'EN_IE';
    case Enum$LanguageCodeEnum.EN_IL:
      return r'EN_IL';
    case Enum$LanguageCodeEnum.EN_IM:
      return r'EN_IM';
    case Enum$LanguageCodeEnum.EN_IN:
      return r'EN_IN';
    case Enum$LanguageCodeEnum.EN_IO:
      return r'EN_IO';
    case Enum$LanguageCodeEnum.EN_JE:
      return r'EN_JE';
    case Enum$LanguageCodeEnum.EN_JM:
      return r'EN_JM';
    case Enum$LanguageCodeEnum.EN_KE:
      return r'EN_KE';
    case Enum$LanguageCodeEnum.EN_KI:
      return r'EN_KI';
    case Enum$LanguageCodeEnum.EN_KN:
      return r'EN_KN';
    case Enum$LanguageCodeEnum.EN_KY:
      return r'EN_KY';
    case Enum$LanguageCodeEnum.EN_LC:
      return r'EN_LC';
    case Enum$LanguageCodeEnum.EN_LR:
      return r'EN_LR';
    case Enum$LanguageCodeEnum.EN_LS:
      return r'EN_LS';
    case Enum$LanguageCodeEnum.EN_MG:
      return r'EN_MG';
    case Enum$LanguageCodeEnum.EN_MH:
      return r'EN_MH';
    case Enum$LanguageCodeEnum.EN_MO:
      return r'EN_MO';
    case Enum$LanguageCodeEnum.EN_MP:
      return r'EN_MP';
    case Enum$LanguageCodeEnum.EN_MS:
      return r'EN_MS';
    case Enum$LanguageCodeEnum.EN_MT:
      return r'EN_MT';
    case Enum$LanguageCodeEnum.EN_MU:
      return r'EN_MU';
    case Enum$LanguageCodeEnum.EN_MW:
      return r'EN_MW';
    case Enum$LanguageCodeEnum.EN_MY:
      return r'EN_MY';
    case Enum$LanguageCodeEnum.EN_NA:
      return r'EN_NA';
    case Enum$LanguageCodeEnum.EN_NF:
      return r'EN_NF';
    case Enum$LanguageCodeEnum.EN_NG:
      return r'EN_NG';
    case Enum$LanguageCodeEnum.EN_NL:
      return r'EN_NL';
    case Enum$LanguageCodeEnum.EN_NR:
      return r'EN_NR';
    case Enum$LanguageCodeEnum.EN_NU:
      return r'EN_NU';
    case Enum$LanguageCodeEnum.EN_NZ:
      return r'EN_NZ';
    case Enum$LanguageCodeEnum.EN_PG:
      return r'EN_PG';
    case Enum$LanguageCodeEnum.EN_PH:
      return r'EN_PH';
    case Enum$LanguageCodeEnum.EN_PK:
      return r'EN_PK';
    case Enum$LanguageCodeEnum.EN_PN:
      return r'EN_PN';
    case Enum$LanguageCodeEnum.EN_PR:
      return r'EN_PR';
    case Enum$LanguageCodeEnum.EN_PW:
      return r'EN_PW';
    case Enum$LanguageCodeEnum.EN_RW:
      return r'EN_RW';
    case Enum$LanguageCodeEnum.EN_SB:
      return r'EN_SB';
    case Enum$LanguageCodeEnum.EN_SC:
      return r'EN_SC';
    case Enum$LanguageCodeEnum.EN_SD:
      return r'EN_SD';
    case Enum$LanguageCodeEnum.EN_SE:
      return r'EN_SE';
    case Enum$LanguageCodeEnum.EN_SG:
      return r'EN_SG';
    case Enum$LanguageCodeEnum.EN_SH:
      return r'EN_SH';
    case Enum$LanguageCodeEnum.EN_SI:
      return r'EN_SI';
    case Enum$LanguageCodeEnum.EN_SL:
      return r'EN_SL';
    case Enum$LanguageCodeEnum.EN_SS:
      return r'EN_SS';
    case Enum$LanguageCodeEnum.EN_SX:
      return r'EN_SX';
    case Enum$LanguageCodeEnum.EN_SZ:
      return r'EN_SZ';
    case Enum$LanguageCodeEnum.EN_TC:
      return r'EN_TC';
    case Enum$LanguageCodeEnum.EN_TK:
      return r'EN_TK';
    case Enum$LanguageCodeEnum.EN_TO:
      return r'EN_TO';
    case Enum$LanguageCodeEnum.EN_TT:
      return r'EN_TT';
    case Enum$LanguageCodeEnum.EN_TV:
      return r'EN_TV';
    case Enum$LanguageCodeEnum.EN_TZ:
      return r'EN_TZ';
    case Enum$LanguageCodeEnum.EN_UG:
      return r'EN_UG';
    case Enum$LanguageCodeEnum.EN_UM:
      return r'EN_UM';
    case Enum$LanguageCodeEnum.EN_US:
      return r'EN_US';
    case Enum$LanguageCodeEnum.EN_VC:
      return r'EN_VC';
    case Enum$LanguageCodeEnum.EN_VG:
      return r'EN_VG';
    case Enum$LanguageCodeEnum.EN_VI:
      return r'EN_VI';
    case Enum$LanguageCodeEnum.EN_VU:
      return r'EN_VU';
    case Enum$LanguageCodeEnum.EN_WS:
      return r'EN_WS';
    case Enum$LanguageCodeEnum.EN_ZA:
      return r'EN_ZA';
    case Enum$LanguageCodeEnum.EN_ZM:
      return r'EN_ZM';
    case Enum$LanguageCodeEnum.EN_ZW:
      return r'EN_ZW';
    case Enum$LanguageCodeEnum.EO:
      return r'EO';
    case Enum$LanguageCodeEnum.ES:
      return r'ES';
    case Enum$LanguageCodeEnum.ES_AR:
      return r'ES_AR';
    case Enum$LanguageCodeEnum.ES_BO:
      return r'ES_BO';
    case Enum$LanguageCodeEnum.ES_BR:
      return r'ES_BR';
    case Enum$LanguageCodeEnum.ES_BZ:
      return r'ES_BZ';
    case Enum$LanguageCodeEnum.ES_CL:
      return r'ES_CL';
    case Enum$LanguageCodeEnum.ES_CO:
      return r'ES_CO';
    case Enum$LanguageCodeEnum.ES_CR:
      return r'ES_CR';
    case Enum$LanguageCodeEnum.ES_CU:
      return r'ES_CU';
    case Enum$LanguageCodeEnum.ES_DO:
      return r'ES_DO';
    case Enum$LanguageCodeEnum.ES_EA:
      return r'ES_EA';
    case Enum$LanguageCodeEnum.ES_EC:
      return r'ES_EC';
    case Enum$LanguageCodeEnum.ES_ES:
      return r'ES_ES';
    case Enum$LanguageCodeEnum.ES_GQ:
      return r'ES_GQ';
    case Enum$LanguageCodeEnum.ES_GT:
      return r'ES_GT';
    case Enum$LanguageCodeEnum.ES_HN:
      return r'ES_HN';
    case Enum$LanguageCodeEnum.ES_IC:
      return r'ES_IC';
    case Enum$LanguageCodeEnum.ES_MX:
      return r'ES_MX';
    case Enum$LanguageCodeEnum.ES_NI:
      return r'ES_NI';
    case Enum$LanguageCodeEnum.ES_PA:
      return r'ES_PA';
    case Enum$LanguageCodeEnum.ES_PE:
      return r'ES_PE';
    case Enum$LanguageCodeEnum.ES_PH:
      return r'ES_PH';
    case Enum$LanguageCodeEnum.ES_PR:
      return r'ES_PR';
    case Enum$LanguageCodeEnum.ES_PY:
      return r'ES_PY';
    case Enum$LanguageCodeEnum.ES_SV:
      return r'ES_SV';
    case Enum$LanguageCodeEnum.ES_US:
      return r'ES_US';
    case Enum$LanguageCodeEnum.ES_UY:
      return r'ES_UY';
    case Enum$LanguageCodeEnum.ES_VE:
      return r'ES_VE';
    case Enum$LanguageCodeEnum.ET:
      return r'ET';
    case Enum$LanguageCodeEnum.ET_EE:
      return r'ET_EE';
    case Enum$LanguageCodeEnum.EU:
      return r'EU';
    case Enum$LanguageCodeEnum.EU_ES:
      return r'EU_ES';
    case Enum$LanguageCodeEnum.EWO:
      return r'EWO';
    case Enum$LanguageCodeEnum.EWO_CM:
      return r'EWO_CM';
    case Enum$LanguageCodeEnum.FA:
      return r'FA';
    case Enum$LanguageCodeEnum.FA_AF:
      return r'FA_AF';
    case Enum$LanguageCodeEnum.FA_IR:
      return r'FA_IR';
    case Enum$LanguageCodeEnum.FF:
      return r'FF';
    case Enum$LanguageCodeEnum.FF_ADLM:
      return r'FF_ADLM';
    case Enum$LanguageCodeEnum.FF_ADLM_BF:
      return r'FF_ADLM_BF';
    case Enum$LanguageCodeEnum.FF_ADLM_CM:
      return r'FF_ADLM_CM';
    case Enum$LanguageCodeEnum.FF_ADLM_GH:
      return r'FF_ADLM_GH';
    case Enum$LanguageCodeEnum.FF_ADLM_GM:
      return r'FF_ADLM_GM';
    case Enum$LanguageCodeEnum.FF_ADLM_GN:
      return r'FF_ADLM_GN';
    case Enum$LanguageCodeEnum.FF_ADLM_GW:
      return r'FF_ADLM_GW';
    case Enum$LanguageCodeEnum.FF_ADLM_LR:
      return r'FF_ADLM_LR';
    case Enum$LanguageCodeEnum.FF_ADLM_MR:
      return r'FF_ADLM_MR';
    case Enum$LanguageCodeEnum.FF_ADLM_NE:
      return r'FF_ADLM_NE';
    case Enum$LanguageCodeEnum.FF_ADLM_NG:
      return r'FF_ADLM_NG';
    case Enum$LanguageCodeEnum.FF_ADLM_SL:
      return r'FF_ADLM_SL';
    case Enum$LanguageCodeEnum.FF_ADLM_SN:
      return r'FF_ADLM_SN';
    case Enum$LanguageCodeEnum.FF_LATN:
      return r'FF_LATN';
    case Enum$LanguageCodeEnum.FF_LATN_BF:
      return r'FF_LATN_BF';
    case Enum$LanguageCodeEnum.FF_LATN_CM:
      return r'FF_LATN_CM';
    case Enum$LanguageCodeEnum.FF_LATN_GH:
      return r'FF_LATN_GH';
    case Enum$LanguageCodeEnum.FF_LATN_GM:
      return r'FF_LATN_GM';
    case Enum$LanguageCodeEnum.FF_LATN_GN:
      return r'FF_LATN_GN';
    case Enum$LanguageCodeEnum.FF_LATN_GW:
      return r'FF_LATN_GW';
    case Enum$LanguageCodeEnum.FF_LATN_LR:
      return r'FF_LATN_LR';
    case Enum$LanguageCodeEnum.FF_LATN_MR:
      return r'FF_LATN_MR';
    case Enum$LanguageCodeEnum.FF_LATN_NE:
      return r'FF_LATN_NE';
    case Enum$LanguageCodeEnum.FF_LATN_NG:
      return r'FF_LATN_NG';
    case Enum$LanguageCodeEnum.FF_LATN_SL:
      return r'FF_LATN_SL';
    case Enum$LanguageCodeEnum.FF_LATN_SN:
      return r'FF_LATN_SN';
    case Enum$LanguageCodeEnum.FI:
      return r'FI';
    case Enum$LanguageCodeEnum.FI_FI:
      return r'FI_FI';
    case Enum$LanguageCodeEnum.FIL:
      return r'FIL';
    case Enum$LanguageCodeEnum.FIL_PH:
      return r'FIL_PH';
    case Enum$LanguageCodeEnum.FO:
      return r'FO';
    case Enum$LanguageCodeEnum.FO_DK:
      return r'FO_DK';
    case Enum$LanguageCodeEnum.FO_FO:
      return r'FO_FO';
    case Enum$LanguageCodeEnum.FR:
      return r'FR';
    case Enum$LanguageCodeEnum.FR_BE:
      return r'FR_BE';
    case Enum$LanguageCodeEnum.FR_BF:
      return r'FR_BF';
    case Enum$LanguageCodeEnum.FR_BI:
      return r'FR_BI';
    case Enum$LanguageCodeEnum.FR_BJ:
      return r'FR_BJ';
    case Enum$LanguageCodeEnum.FR_BL:
      return r'FR_BL';
    case Enum$LanguageCodeEnum.FR_CA:
      return r'FR_CA';
    case Enum$LanguageCodeEnum.FR_CD:
      return r'FR_CD';
    case Enum$LanguageCodeEnum.FR_CF:
      return r'FR_CF';
    case Enum$LanguageCodeEnum.FR_CG:
      return r'FR_CG';
    case Enum$LanguageCodeEnum.FR_CH:
      return r'FR_CH';
    case Enum$LanguageCodeEnum.FR_CI:
      return r'FR_CI';
    case Enum$LanguageCodeEnum.FR_CM:
      return r'FR_CM';
    case Enum$LanguageCodeEnum.FR_DJ:
      return r'FR_DJ';
    case Enum$LanguageCodeEnum.FR_DZ:
      return r'FR_DZ';
    case Enum$LanguageCodeEnum.FR_FR:
      return r'FR_FR';
    case Enum$LanguageCodeEnum.FR_GA:
      return r'FR_GA';
    case Enum$LanguageCodeEnum.FR_GF:
      return r'FR_GF';
    case Enum$LanguageCodeEnum.FR_GN:
      return r'FR_GN';
    case Enum$LanguageCodeEnum.FR_GP:
      return r'FR_GP';
    case Enum$LanguageCodeEnum.FR_GQ:
      return r'FR_GQ';
    case Enum$LanguageCodeEnum.FR_HT:
      return r'FR_HT';
    case Enum$LanguageCodeEnum.FR_KM:
      return r'FR_KM';
    case Enum$LanguageCodeEnum.FR_LU:
      return r'FR_LU';
    case Enum$LanguageCodeEnum.FR_MA:
      return r'FR_MA';
    case Enum$LanguageCodeEnum.FR_MC:
      return r'FR_MC';
    case Enum$LanguageCodeEnum.FR_MF:
      return r'FR_MF';
    case Enum$LanguageCodeEnum.FR_MG:
      return r'FR_MG';
    case Enum$LanguageCodeEnum.FR_ML:
      return r'FR_ML';
    case Enum$LanguageCodeEnum.FR_MQ:
      return r'FR_MQ';
    case Enum$LanguageCodeEnum.FR_MR:
      return r'FR_MR';
    case Enum$LanguageCodeEnum.FR_MU:
      return r'FR_MU';
    case Enum$LanguageCodeEnum.FR_NC:
      return r'FR_NC';
    case Enum$LanguageCodeEnum.FR_NE:
      return r'FR_NE';
    case Enum$LanguageCodeEnum.FR_PF:
      return r'FR_PF';
    case Enum$LanguageCodeEnum.FR_PM:
      return r'FR_PM';
    case Enum$LanguageCodeEnum.FR_RE:
      return r'FR_RE';
    case Enum$LanguageCodeEnum.FR_RW:
      return r'FR_RW';
    case Enum$LanguageCodeEnum.FR_SC:
      return r'FR_SC';
    case Enum$LanguageCodeEnum.FR_SN:
      return r'FR_SN';
    case Enum$LanguageCodeEnum.FR_SY:
      return r'FR_SY';
    case Enum$LanguageCodeEnum.FR_TD:
      return r'FR_TD';
    case Enum$LanguageCodeEnum.FR_TG:
      return r'FR_TG';
    case Enum$LanguageCodeEnum.FR_TN:
      return r'FR_TN';
    case Enum$LanguageCodeEnum.FR_VU:
      return r'FR_VU';
    case Enum$LanguageCodeEnum.FR_WF:
      return r'FR_WF';
    case Enum$LanguageCodeEnum.FR_YT:
      return r'FR_YT';
    case Enum$LanguageCodeEnum.FUR:
      return r'FUR';
    case Enum$LanguageCodeEnum.FUR_IT:
      return r'FUR_IT';
    case Enum$LanguageCodeEnum.FY:
      return r'FY';
    case Enum$LanguageCodeEnum.FY_NL:
      return r'FY_NL';
    case Enum$LanguageCodeEnum.GA:
      return r'GA';
    case Enum$LanguageCodeEnum.GA_GB:
      return r'GA_GB';
    case Enum$LanguageCodeEnum.GA_IE:
      return r'GA_IE';
    case Enum$LanguageCodeEnum.GD:
      return r'GD';
    case Enum$LanguageCodeEnum.GD_GB:
      return r'GD_GB';
    case Enum$LanguageCodeEnum.GL:
      return r'GL';
    case Enum$LanguageCodeEnum.GL_ES:
      return r'GL_ES';
    case Enum$LanguageCodeEnum.GSW:
      return r'GSW';
    case Enum$LanguageCodeEnum.GSW_CH:
      return r'GSW_CH';
    case Enum$LanguageCodeEnum.GSW_FR:
      return r'GSW_FR';
    case Enum$LanguageCodeEnum.GSW_LI:
      return r'GSW_LI';
    case Enum$LanguageCodeEnum.GU:
      return r'GU';
    case Enum$LanguageCodeEnum.GU_IN:
      return r'GU_IN';
    case Enum$LanguageCodeEnum.GUZ:
      return r'GUZ';
    case Enum$LanguageCodeEnum.GUZ_KE:
      return r'GUZ_KE';
    case Enum$LanguageCodeEnum.GV:
      return r'GV';
    case Enum$LanguageCodeEnum.GV_IM:
      return r'GV_IM';
    case Enum$LanguageCodeEnum.HA:
      return r'HA';
    case Enum$LanguageCodeEnum.HA_GH:
      return r'HA_GH';
    case Enum$LanguageCodeEnum.HA_NE:
      return r'HA_NE';
    case Enum$LanguageCodeEnum.HA_NG:
      return r'HA_NG';
    case Enum$LanguageCodeEnum.HAW:
      return r'HAW';
    case Enum$LanguageCodeEnum.HAW_US:
      return r'HAW_US';
    case Enum$LanguageCodeEnum.HE:
      return r'HE';
    case Enum$LanguageCodeEnum.HE_IL:
      return r'HE_IL';
    case Enum$LanguageCodeEnum.HI:
      return r'HI';
    case Enum$LanguageCodeEnum.HI_IN:
      return r'HI_IN';
    case Enum$LanguageCodeEnum.HR:
      return r'HR';
    case Enum$LanguageCodeEnum.HR_BA:
      return r'HR_BA';
    case Enum$LanguageCodeEnum.HR_HR:
      return r'HR_HR';
    case Enum$LanguageCodeEnum.HSB:
      return r'HSB';
    case Enum$LanguageCodeEnum.HSB_DE:
      return r'HSB_DE';
    case Enum$LanguageCodeEnum.HU:
      return r'HU';
    case Enum$LanguageCodeEnum.HU_HU:
      return r'HU_HU';
    case Enum$LanguageCodeEnum.HY:
      return r'HY';
    case Enum$LanguageCodeEnum.HY_AM:
      return r'HY_AM';
    case Enum$LanguageCodeEnum.IA:
      return r'IA';
    case Enum$LanguageCodeEnum.ID:
      return r'ID';
    case Enum$LanguageCodeEnum.ID_ID:
      return r'ID_ID';
    case Enum$LanguageCodeEnum.IG:
      return r'IG';
    case Enum$LanguageCodeEnum.IG_NG:
      return r'IG_NG';
    case Enum$LanguageCodeEnum.II:
      return r'II';
    case Enum$LanguageCodeEnum.II_CN:
      return r'II_CN';
    case Enum$LanguageCodeEnum.IS:
      return r'IS';
    case Enum$LanguageCodeEnum.IS_IS:
      return r'IS_IS';
    case Enum$LanguageCodeEnum.IT:
      return r'IT';
    case Enum$LanguageCodeEnum.IT_CH:
      return r'IT_CH';
    case Enum$LanguageCodeEnum.IT_IT:
      return r'IT_IT';
    case Enum$LanguageCodeEnum.IT_SM:
      return r'IT_SM';
    case Enum$LanguageCodeEnum.IT_VA:
      return r'IT_VA';
    case Enum$LanguageCodeEnum.JA:
      return r'JA';
    case Enum$LanguageCodeEnum.JA_JP:
      return r'JA_JP';
    case Enum$LanguageCodeEnum.JGO:
      return r'JGO';
    case Enum$LanguageCodeEnum.JGO_CM:
      return r'JGO_CM';
    case Enum$LanguageCodeEnum.JMC:
      return r'JMC';
    case Enum$LanguageCodeEnum.JMC_TZ:
      return r'JMC_TZ';
    case Enum$LanguageCodeEnum.JV:
      return r'JV';
    case Enum$LanguageCodeEnum.JV_ID:
      return r'JV_ID';
    case Enum$LanguageCodeEnum.KA:
      return r'KA';
    case Enum$LanguageCodeEnum.KA_GE:
      return r'KA_GE';
    case Enum$LanguageCodeEnum.KAB:
      return r'KAB';
    case Enum$LanguageCodeEnum.KAB_DZ:
      return r'KAB_DZ';
    case Enum$LanguageCodeEnum.KAM:
      return r'KAM';
    case Enum$LanguageCodeEnum.KAM_KE:
      return r'KAM_KE';
    case Enum$LanguageCodeEnum.KDE:
      return r'KDE';
    case Enum$LanguageCodeEnum.KDE_TZ:
      return r'KDE_TZ';
    case Enum$LanguageCodeEnum.KEA:
      return r'KEA';
    case Enum$LanguageCodeEnum.KEA_CV:
      return r'KEA_CV';
    case Enum$LanguageCodeEnum.KHQ:
      return r'KHQ';
    case Enum$LanguageCodeEnum.KHQ_ML:
      return r'KHQ_ML';
    case Enum$LanguageCodeEnum.KI:
      return r'KI';
    case Enum$LanguageCodeEnum.KI_KE:
      return r'KI_KE';
    case Enum$LanguageCodeEnum.KK:
      return r'KK';
    case Enum$LanguageCodeEnum.KK_KZ:
      return r'KK_KZ';
    case Enum$LanguageCodeEnum.KKJ:
      return r'KKJ';
    case Enum$LanguageCodeEnum.KKJ_CM:
      return r'KKJ_CM';
    case Enum$LanguageCodeEnum.KL:
      return r'KL';
    case Enum$LanguageCodeEnum.KL_GL:
      return r'KL_GL';
    case Enum$LanguageCodeEnum.KLN:
      return r'KLN';
    case Enum$LanguageCodeEnum.KLN_KE:
      return r'KLN_KE';
    case Enum$LanguageCodeEnum.KM:
      return r'KM';
    case Enum$LanguageCodeEnum.KM_KH:
      return r'KM_KH';
    case Enum$LanguageCodeEnum.KN:
      return r'KN';
    case Enum$LanguageCodeEnum.KN_IN:
      return r'KN_IN';
    case Enum$LanguageCodeEnum.KO:
      return r'KO';
    case Enum$LanguageCodeEnum.KO_KP:
      return r'KO_KP';
    case Enum$LanguageCodeEnum.KO_KR:
      return r'KO_KR';
    case Enum$LanguageCodeEnum.KOK:
      return r'KOK';
    case Enum$LanguageCodeEnum.KOK_IN:
      return r'KOK_IN';
    case Enum$LanguageCodeEnum.KS:
      return r'KS';
    case Enum$LanguageCodeEnum.KS_ARAB:
      return r'KS_ARAB';
    case Enum$LanguageCodeEnum.KS_ARAB_IN:
      return r'KS_ARAB_IN';
    case Enum$LanguageCodeEnum.KSB:
      return r'KSB';
    case Enum$LanguageCodeEnum.KSB_TZ:
      return r'KSB_TZ';
    case Enum$LanguageCodeEnum.KSF:
      return r'KSF';
    case Enum$LanguageCodeEnum.KSF_CM:
      return r'KSF_CM';
    case Enum$LanguageCodeEnum.KSH:
      return r'KSH';
    case Enum$LanguageCodeEnum.KSH_DE:
      return r'KSH_DE';
    case Enum$LanguageCodeEnum.KU:
      return r'KU';
    case Enum$LanguageCodeEnum.KU_TR:
      return r'KU_TR';
    case Enum$LanguageCodeEnum.KW:
      return r'KW';
    case Enum$LanguageCodeEnum.KW_GB:
      return r'KW_GB';
    case Enum$LanguageCodeEnum.KY:
      return r'KY';
    case Enum$LanguageCodeEnum.KY_KG:
      return r'KY_KG';
    case Enum$LanguageCodeEnum.LAG:
      return r'LAG';
    case Enum$LanguageCodeEnum.LAG_TZ:
      return r'LAG_TZ';
    case Enum$LanguageCodeEnum.LB:
      return r'LB';
    case Enum$LanguageCodeEnum.LB_LU:
      return r'LB_LU';
    case Enum$LanguageCodeEnum.LG:
      return r'LG';
    case Enum$LanguageCodeEnum.LG_UG:
      return r'LG_UG';
    case Enum$LanguageCodeEnum.LKT:
      return r'LKT';
    case Enum$LanguageCodeEnum.LKT_US:
      return r'LKT_US';
    case Enum$LanguageCodeEnum.LN:
      return r'LN';
    case Enum$LanguageCodeEnum.LN_AO:
      return r'LN_AO';
    case Enum$LanguageCodeEnum.LN_CD:
      return r'LN_CD';
    case Enum$LanguageCodeEnum.LN_CF:
      return r'LN_CF';
    case Enum$LanguageCodeEnum.LN_CG:
      return r'LN_CG';
    case Enum$LanguageCodeEnum.LO:
      return r'LO';
    case Enum$LanguageCodeEnum.LO_LA:
      return r'LO_LA';
    case Enum$LanguageCodeEnum.LRC:
      return r'LRC';
    case Enum$LanguageCodeEnum.LRC_IQ:
      return r'LRC_IQ';
    case Enum$LanguageCodeEnum.LRC_IR:
      return r'LRC_IR';
    case Enum$LanguageCodeEnum.LT:
      return r'LT';
    case Enum$LanguageCodeEnum.LT_LT:
      return r'LT_LT';
    case Enum$LanguageCodeEnum.LU:
      return r'LU';
    case Enum$LanguageCodeEnum.LU_CD:
      return r'LU_CD';
    case Enum$LanguageCodeEnum.LUO:
      return r'LUO';
    case Enum$LanguageCodeEnum.LUO_KE:
      return r'LUO_KE';
    case Enum$LanguageCodeEnum.LUY:
      return r'LUY';
    case Enum$LanguageCodeEnum.LUY_KE:
      return r'LUY_KE';
    case Enum$LanguageCodeEnum.LV:
      return r'LV';
    case Enum$LanguageCodeEnum.LV_LV:
      return r'LV_LV';
    case Enum$LanguageCodeEnum.MAI:
      return r'MAI';
    case Enum$LanguageCodeEnum.MAI_IN:
      return r'MAI_IN';
    case Enum$LanguageCodeEnum.MAS:
      return r'MAS';
    case Enum$LanguageCodeEnum.MAS_KE:
      return r'MAS_KE';
    case Enum$LanguageCodeEnum.MAS_TZ:
      return r'MAS_TZ';
    case Enum$LanguageCodeEnum.MER:
      return r'MER';
    case Enum$LanguageCodeEnum.MER_KE:
      return r'MER_KE';
    case Enum$LanguageCodeEnum.MFE:
      return r'MFE';
    case Enum$LanguageCodeEnum.MFE_MU:
      return r'MFE_MU';
    case Enum$LanguageCodeEnum.MG:
      return r'MG';
    case Enum$LanguageCodeEnum.MG_MG:
      return r'MG_MG';
    case Enum$LanguageCodeEnum.MGH:
      return r'MGH';
    case Enum$LanguageCodeEnum.MGH_MZ:
      return r'MGH_MZ';
    case Enum$LanguageCodeEnum.MGO:
      return r'MGO';
    case Enum$LanguageCodeEnum.MGO_CM:
      return r'MGO_CM';
    case Enum$LanguageCodeEnum.MI:
      return r'MI';
    case Enum$LanguageCodeEnum.MI_NZ:
      return r'MI_NZ';
    case Enum$LanguageCodeEnum.MK:
      return r'MK';
    case Enum$LanguageCodeEnum.MK_MK:
      return r'MK_MK';
    case Enum$LanguageCodeEnum.ML:
      return r'ML';
    case Enum$LanguageCodeEnum.ML_IN:
      return r'ML_IN';
    case Enum$LanguageCodeEnum.MN:
      return r'MN';
    case Enum$LanguageCodeEnum.MN_MN:
      return r'MN_MN';
    case Enum$LanguageCodeEnum.MNI:
      return r'MNI';
    case Enum$LanguageCodeEnum.MNI_BENG:
      return r'MNI_BENG';
    case Enum$LanguageCodeEnum.MNI_BENG_IN:
      return r'MNI_BENG_IN';
    case Enum$LanguageCodeEnum.MR:
      return r'MR';
    case Enum$LanguageCodeEnum.MR_IN:
      return r'MR_IN';
    case Enum$LanguageCodeEnum.MS:
      return r'MS';
    case Enum$LanguageCodeEnum.MS_BN:
      return r'MS_BN';
    case Enum$LanguageCodeEnum.MS_ID:
      return r'MS_ID';
    case Enum$LanguageCodeEnum.MS_MY:
      return r'MS_MY';
    case Enum$LanguageCodeEnum.MS_SG:
      return r'MS_SG';
    case Enum$LanguageCodeEnum.MT:
      return r'MT';
    case Enum$LanguageCodeEnum.MT_MT:
      return r'MT_MT';
    case Enum$LanguageCodeEnum.MUA:
      return r'MUA';
    case Enum$LanguageCodeEnum.MUA_CM:
      return r'MUA_CM';
    case Enum$LanguageCodeEnum.MY:
      return r'MY';
    case Enum$LanguageCodeEnum.MY_MM:
      return r'MY_MM';
    case Enum$LanguageCodeEnum.MZN:
      return r'MZN';
    case Enum$LanguageCodeEnum.MZN_IR:
      return r'MZN_IR';
    case Enum$LanguageCodeEnum.NAQ:
      return r'NAQ';
    case Enum$LanguageCodeEnum.NAQ_NA:
      return r'NAQ_NA';
    case Enum$LanguageCodeEnum.NB:
      return r'NB';
    case Enum$LanguageCodeEnum.NB_NO:
      return r'NB_NO';
    case Enum$LanguageCodeEnum.NB_SJ:
      return r'NB_SJ';
    case Enum$LanguageCodeEnum.ND:
      return r'ND';
    case Enum$LanguageCodeEnum.ND_ZW:
      return r'ND_ZW';
    case Enum$LanguageCodeEnum.NDS:
      return r'NDS';
    case Enum$LanguageCodeEnum.NDS_DE:
      return r'NDS_DE';
    case Enum$LanguageCodeEnum.NDS_NL:
      return r'NDS_NL';
    case Enum$LanguageCodeEnum.NE:
      return r'NE';
    case Enum$LanguageCodeEnum.NE_IN:
      return r'NE_IN';
    case Enum$LanguageCodeEnum.NE_NP:
      return r'NE_NP';
    case Enum$LanguageCodeEnum.NL:
      return r'NL';
    case Enum$LanguageCodeEnum.NL_AW:
      return r'NL_AW';
    case Enum$LanguageCodeEnum.NL_BE:
      return r'NL_BE';
    case Enum$LanguageCodeEnum.NL_BQ:
      return r'NL_BQ';
    case Enum$LanguageCodeEnum.NL_CW:
      return r'NL_CW';
    case Enum$LanguageCodeEnum.NL_NL:
      return r'NL_NL';
    case Enum$LanguageCodeEnum.NL_SR:
      return r'NL_SR';
    case Enum$LanguageCodeEnum.NL_SX:
      return r'NL_SX';
    case Enum$LanguageCodeEnum.NMG:
      return r'NMG';
    case Enum$LanguageCodeEnum.NMG_CM:
      return r'NMG_CM';
    case Enum$LanguageCodeEnum.NN:
      return r'NN';
    case Enum$LanguageCodeEnum.NN_NO:
      return r'NN_NO';
    case Enum$LanguageCodeEnum.NNH:
      return r'NNH';
    case Enum$LanguageCodeEnum.NNH_CM:
      return r'NNH_CM';
    case Enum$LanguageCodeEnum.NUS:
      return r'NUS';
    case Enum$LanguageCodeEnum.NUS_SS:
      return r'NUS_SS';
    case Enum$LanguageCodeEnum.NYN:
      return r'NYN';
    case Enum$LanguageCodeEnum.NYN_UG:
      return r'NYN_UG';
    case Enum$LanguageCodeEnum.OM:
      return r'OM';
    case Enum$LanguageCodeEnum.OM_ET:
      return r'OM_ET';
    case Enum$LanguageCodeEnum.OM_KE:
      return r'OM_KE';
    case Enum$LanguageCodeEnum.OR:
      return r'OR';
    case Enum$LanguageCodeEnum.OR_IN:
      return r'OR_IN';
    case Enum$LanguageCodeEnum.OS:
      return r'OS';
    case Enum$LanguageCodeEnum.OS_GE:
      return r'OS_GE';
    case Enum$LanguageCodeEnum.OS_RU:
      return r'OS_RU';
    case Enum$LanguageCodeEnum.PA:
      return r'PA';
    case Enum$LanguageCodeEnum.PA_ARAB:
      return r'PA_ARAB';
    case Enum$LanguageCodeEnum.PA_ARAB_PK:
      return r'PA_ARAB_PK';
    case Enum$LanguageCodeEnum.PA_GURU:
      return r'PA_GURU';
    case Enum$LanguageCodeEnum.PA_GURU_IN:
      return r'PA_GURU_IN';
    case Enum$LanguageCodeEnum.PCM:
      return r'PCM';
    case Enum$LanguageCodeEnum.PCM_NG:
      return r'PCM_NG';
    case Enum$LanguageCodeEnum.PL:
      return r'PL';
    case Enum$LanguageCodeEnum.PL_PL:
      return r'PL_PL';
    case Enum$LanguageCodeEnum.PRG:
      return r'PRG';
    case Enum$LanguageCodeEnum.PS:
      return r'PS';
    case Enum$LanguageCodeEnum.PS_AF:
      return r'PS_AF';
    case Enum$LanguageCodeEnum.PS_PK:
      return r'PS_PK';
    case Enum$LanguageCodeEnum.PT:
      return r'PT';
    case Enum$LanguageCodeEnum.PT_AO:
      return r'PT_AO';
    case Enum$LanguageCodeEnum.PT_BR:
      return r'PT_BR';
    case Enum$LanguageCodeEnum.PT_CH:
      return r'PT_CH';
    case Enum$LanguageCodeEnum.PT_CV:
      return r'PT_CV';
    case Enum$LanguageCodeEnum.PT_GQ:
      return r'PT_GQ';
    case Enum$LanguageCodeEnum.PT_GW:
      return r'PT_GW';
    case Enum$LanguageCodeEnum.PT_LU:
      return r'PT_LU';
    case Enum$LanguageCodeEnum.PT_MO:
      return r'PT_MO';
    case Enum$LanguageCodeEnum.PT_MZ:
      return r'PT_MZ';
    case Enum$LanguageCodeEnum.PT_PT:
      return r'PT_PT';
    case Enum$LanguageCodeEnum.PT_ST:
      return r'PT_ST';
    case Enum$LanguageCodeEnum.PT_TL:
      return r'PT_TL';
    case Enum$LanguageCodeEnum.QU:
      return r'QU';
    case Enum$LanguageCodeEnum.QU_BO:
      return r'QU_BO';
    case Enum$LanguageCodeEnum.QU_EC:
      return r'QU_EC';
    case Enum$LanguageCodeEnum.QU_PE:
      return r'QU_PE';
    case Enum$LanguageCodeEnum.RM:
      return r'RM';
    case Enum$LanguageCodeEnum.RM_CH:
      return r'RM_CH';
    case Enum$LanguageCodeEnum.RN:
      return r'RN';
    case Enum$LanguageCodeEnum.RN_BI:
      return r'RN_BI';
    case Enum$LanguageCodeEnum.RO:
      return r'RO';
    case Enum$LanguageCodeEnum.RO_MD:
      return r'RO_MD';
    case Enum$LanguageCodeEnum.RO_RO:
      return r'RO_RO';
    case Enum$LanguageCodeEnum.ROF:
      return r'ROF';
    case Enum$LanguageCodeEnum.ROF_TZ:
      return r'ROF_TZ';
    case Enum$LanguageCodeEnum.RU:
      return r'RU';
    case Enum$LanguageCodeEnum.RU_BY:
      return r'RU_BY';
    case Enum$LanguageCodeEnum.RU_KG:
      return r'RU_KG';
    case Enum$LanguageCodeEnum.RU_KZ:
      return r'RU_KZ';
    case Enum$LanguageCodeEnum.RU_MD:
      return r'RU_MD';
    case Enum$LanguageCodeEnum.RU_RU:
      return r'RU_RU';
    case Enum$LanguageCodeEnum.RU_UA:
      return r'RU_UA';
    case Enum$LanguageCodeEnum.RW:
      return r'RW';
    case Enum$LanguageCodeEnum.RW_RW:
      return r'RW_RW';
    case Enum$LanguageCodeEnum.RWK:
      return r'RWK';
    case Enum$LanguageCodeEnum.RWK_TZ:
      return r'RWK_TZ';
    case Enum$LanguageCodeEnum.SAH:
      return r'SAH';
    case Enum$LanguageCodeEnum.SAH_RU:
      return r'SAH_RU';
    case Enum$LanguageCodeEnum.SAQ:
      return r'SAQ';
    case Enum$LanguageCodeEnum.SAQ_KE:
      return r'SAQ_KE';
    case Enum$LanguageCodeEnum.SAT:
      return r'SAT';
    case Enum$LanguageCodeEnum.SAT_OLCK:
      return r'SAT_OLCK';
    case Enum$LanguageCodeEnum.SAT_OLCK_IN:
      return r'SAT_OLCK_IN';
    case Enum$LanguageCodeEnum.SBP:
      return r'SBP';
    case Enum$LanguageCodeEnum.SBP_TZ:
      return r'SBP_TZ';
    case Enum$LanguageCodeEnum.SD:
      return r'SD';
    case Enum$LanguageCodeEnum.SD_ARAB:
      return r'SD_ARAB';
    case Enum$LanguageCodeEnum.SD_ARAB_PK:
      return r'SD_ARAB_PK';
    case Enum$LanguageCodeEnum.SD_DEVA:
      return r'SD_DEVA';
    case Enum$LanguageCodeEnum.SD_DEVA_IN:
      return r'SD_DEVA_IN';
    case Enum$LanguageCodeEnum.SE:
      return r'SE';
    case Enum$LanguageCodeEnum.SE_FI:
      return r'SE_FI';
    case Enum$LanguageCodeEnum.SE_NO:
      return r'SE_NO';
    case Enum$LanguageCodeEnum.SE_SE:
      return r'SE_SE';
    case Enum$LanguageCodeEnum.SEH:
      return r'SEH';
    case Enum$LanguageCodeEnum.SEH_MZ:
      return r'SEH_MZ';
    case Enum$LanguageCodeEnum.SES:
      return r'SES';
    case Enum$LanguageCodeEnum.SES_ML:
      return r'SES_ML';
    case Enum$LanguageCodeEnum.SG:
      return r'SG';
    case Enum$LanguageCodeEnum.SG_CF:
      return r'SG_CF';
    case Enum$LanguageCodeEnum.SHI:
      return r'SHI';
    case Enum$LanguageCodeEnum.SHI_LATN:
      return r'SHI_LATN';
    case Enum$LanguageCodeEnum.SHI_LATN_MA:
      return r'SHI_LATN_MA';
    case Enum$LanguageCodeEnum.SHI_TFNG:
      return r'SHI_TFNG';
    case Enum$LanguageCodeEnum.SHI_TFNG_MA:
      return r'SHI_TFNG_MA';
    case Enum$LanguageCodeEnum.SI:
      return r'SI';
    case Enum$LanguageCodeEnum.SI_LK:
      return r'SI_LK';
    case Enum$LanguageCodeEnum.SK:
      return r'SK';
    case Enum$LanguageCodeEnum.SK_SK:
      return r'SK_SK';
    case Enum$LanguageCodeEnum.SL:
      return r'SL';
    case Enum$LanguageCodeEnum.SL_SI:
      return r'SL_SI';
    case Enum$LanguageCodeEnum.SMN:
      return r'SMN';
    case Enum$LanguageCodeEnum.SMN_FI:
      return r'SMN_FI';
    case Enum$LanguageCodeEnum.SN:
      return r'SN';
    case Enum$LanguageCodeEnum.SN_ZW:
      return r'SN_ZW';
    case Enum$LanguageCodeEnum.SO:
      return r'SO';
    case Enum$LanguageCodeEnum.SO_DJ:
      return r'SO_DJ';
    case Enum$LanguageCodeEnum.SO_ET:
      return r'SO_ET';
    case Enum$LanguageCodeEnum.SO_KE:
      return r'SO_KE';
    case Enum$LanguageCodeEnum.SO_SO:
      return r'SO_SO';
    case Enum$LanguageCodeEnum.SQ:
      return r'SQ';
    case Enum$LanguageCodeEnum.SQ_AL:
      return r'SQ_AL';
    case Enum$LanguageCodeEnum.SQ_MK:
      return r'SQ_MK';
    case Enum$LanguageCodeEnum.SQ_XK:
      return r'SQ_XK';
    case Enum$LanguageCodeEnum.SR:
      return r'SR';
    case Enum$LanguageCodeEnum.SR_CYRL:
      return r'SR_CYRL';
    case Enum$LanguageCodeEnum.SR_CYRL_BA:
      return r'SR_CYRL_BA';
    case Enum$LanguageCodeEnum.SR_CYRL_ME:
      return r'SR_CYRL_ME';
    case Enum$LanguageCodeEnum.SR_CYRL_RS:
      return r'SR_CYRL_RS';
    case Enum$LanguageCodeEnum.SR_CYRL_XK:
      return r'SR_CYRL_XK';
    case Enum$LanguageCodeEnum.SR_LATN:
      return r'SR_LATN';
    case Enum$LanguageCodeEnum.SR_LATN_BA:
      return r'SR_LATN_BA';
    case Enum$LanguageCodeEnum.SR_LATN_ME:
      return r'SR_LATN_ME';
    case Enum$LanguageCodeEnum.SR_LATN_RS:
      return r'SR_LATN_RS';
    case Enum$LanguageCodeEnum.SR_LATN_XK:
      return r'SR_LATN_XK';
    case Enum$LanguageCodeEnum.SU:
      return r'SU';
    case Enum$LanguageCodeEnum.SU_LATN:
      return r'SU_LATN';
    case Enum$LanguageCodeEnum.SU_LATN_ID:
      return r'SU_LATN_ID';
    case Enum$LanguageCodeEnum.SV:
      return r'SV';
    case Enum$LanguageCodeEnum.SV_AX:
      return r'SV_AX';
    case Enum$LanguageCodeEnum.SV_FI:
      return r'SV_FI';
    case Enum$LanguageCodeEnum.SV_SE:
      return r'SV_SE';
    case Enum$LanguageCodeEnum.SW:
      return r'SW';
    case Enum$LanguageCodeEnum.SW_CD:
      return r'SW_CD';
    case Enum$LanguageCodeEnum.SW_KE:
      return r'SW_KE';
    case Enum$LanguageCodeEnum.SW_TZ:
      return r'SW_TZ';
    case Enum$LanguageCodeEnum.SW_UG:
      return r'SW_UG';
    case Enum$LanguageCodeEnum.TA:
      return r'TA';
    case Enum$LanguageCodeEnum.TA_IN:
      return r'TA_IN';
    case Enum$LanguageCodeEnum.TA_LK:
      return r'TA_LK';
    case Enum$LanguageCodeEnum.TA_MY:
      return r'TA_MY';
    case Enum$LanguageCodeEnum.TA_SG:
      return r'TA_SG';
    case Enum$LanguageCodeEnum.TE:
      return r'TE';
    case Enum$LanguageCodeEnum.TE_IN:
      return r'TE_IN';
    case Enum$LanguageCodeEnum.TEO:
      return r'TEO';
    case Enum$LanguageCodeEnum.TEO_KE:
      return r'TEO_KE';
    case Enum$LanguageCodeEnum.TEO_UG:
      return r'TEO_UG';
    case Enum$LanguageCodeEnum.TG:
      return r'TG';
    case Enum$LanguageCodeEnum.TG_TJ:
      return r'TG_TJ';
    case Enum$LanguageCodeEnum.TH:
      return r'TH';
    case Enum$LanguageCodeEnum.TH_TH:
      return r'TH_TH';
    case Enum$LanguageCodeEnum.TI:
      return r'TI';
    case Enum$LanguageCodeEnum.TI_ER:
      return r'TI_ER';
    case Enum$LanguageCodeEnum.TI_ET:
      return r'TI_ET';
    case Enum$LanguageCodeEnum.TK:
      return r'TK';
    case Enum$LanguageCodeEnum.TK_TM:
      return r'TK_TM';
    case Enum$LanguageCodeEnum.TO:
      return r'TO';
    case Enum$LanguageCodeEnum.TO_TO:
      return r'TO_TO';
    case Enum$LanguageCodeEnum.TR:
      return r'TR';
    case Enum$LanguageCodeEnum.TR_CY:
      return r'TR_CY';
    case Enum$LanguageCodeEnum.TR_TR:
      return r'TR_TR';
    case Enum$LanguageCodeEnum.TT:
      return r'TT';
    case Enum$LanguageCodeEnum.TT_RU:
      return r'TT_RU';
    case Enum$LanguageCodeEnum.TWQ:
      return r'TWQ';
    case Enum$LanguageCodeEnum.TWQ_NE:
      return r'TWQ_NE';
    case Enum$LanguageCodeEnum.TZM:
      return r'TZM';
    case Enum$LanguageCodeEnum.TZM_MA:
      return r'TZM_MA';
    case Enum$LanguageCodeEnum.UG:
      return r'UG';
    case Enum$LanguageCodeEnum.UG_CN:
      return r'UG_CN';
    case Enum$LanguageCodeEnum.UK:
      return r'UK';
    case Enum$LanguageCodeEnum.UK_UA:
      return r'UK_UA';
    case Enum$LanguageCodeEnum.UR:
      return r'UR';
    case Enum$LanguageCodeEnum.UR_IN:
      return r'UR_IN';
    case Enum$LanguageCodeEnum.UR_PK:
      return r'UR_PK';
    case Enum$LanguageCodeEnum.UZ:
      return r'UZ';
    case Enum$LanguageCodeEnum.UZ_ARAB:
      return r'UZ_ARAB';
    case Enum$LanguageCodeEnum.UZ_ARAB_AF:
      return r'UZ_ARAB_AF';
    case Enum$LanguageCodeEnum.UZ_CYRL:
      return r'UZ_CYRL';
    case Enum$LanguageCodeEnum.UZ_CYRL_UZ:
      return r'UZ_CYRL_UZ';
    case Enum$LanguageCodeEnum.UZ_LATN:
      return r'UZ_LATN';
    case Enum$LanguageCodeEnum.UZ_LATN_UZ:
      return r'UZ_LATN_UZ';
    case Enum$LanguageCodeEnum.VAI:
      return r'VAI';
    case Enum$LanguageCodeEnum.VAI_LATN:
      return r'VAI_LATN';
    case Enum$LanguageCodeEnum.VAI_LATN_LR:
      return r'VAI_LATN_LR';
    case Enum$LanguageCodeEnum.VAI_VAII:
      return r'VAI_VAII';
    case Enum$LanguageCodeEnum.VAI_VAII_LR:
      return r'VAI_VAII_LR';
    case Enum$LanguageCodeEnum.VI:
      return r'VI';
    case Enum$LanguageCodeEnum.VI_VN:
      return r'VI_VN';
    case Enum$LanguageCodeEnum.VO:
      return r'VO';
    case Enum$LanguageCodeEnum.VUN:
      return r'VUN';
    case Enum$LanguageCodeEnum.VUN_TZ:
      return r'VUN_TZ';
    case Enum$LanguageCodeEnum.WAE:
      return r'WAE';
    case Enum$LanguageCodeEnum.WAE_CH:
      return r'WAE_CH';
    case Enum$LanguageCodeEnum.WO:
      return r'WO';
    case Enum$LanguageCodeEnum.WO_SN:
      return r'WO_SN';
    case Enum$LanguageCodeEnum.XH:
      return r'XH';
    case Enum$LanguageCodeEnum.XH_ZA:
      return r'XH_ZA';
    case Enum$LanguageCodeEnum.XOG:
      return r'XOG';
    case Enum$LanguageCodeEnum.XOG_UG:
      return r'XOG_UG';
    case Enum$LanguageCodeEnum.YAV:
      return r'YAV';
    case Enum$LanguageCodeEnum.YAV_CM:
      return r'YAV_CM';
    case Enum$LanguageCodeEnum.YI:
      return r'YI';
    case Enum$LanguageCodeEnum.YO:
      return r'YO';
    case Enum$LanguageCodeEnum.YO_BJ:
      return r'YO_BJ';
    case Enum$LanguageCodeEnum.YO_NG:
      return r'YO_NG';
    case Enum$LanguageCodeEnum.YUE:
      return r'YUE';
    case Enum$LanguageCodeEnum.YUE_HANS:
      return r'YUE_HANS';
    case Enum$LanguageCodeEnum.YUE_HANS_CN:
      return r'YUE_HANS_CN';
    case Enum$LanguageCodeEnum.YUE_HANT:
      return r'YUE_HANT';
    case Enum$LanguageCodeEnum.YUE_HANT_HK:
      return r'YUE_HANT_HK';
    case Enum$LanguageCodeEnum.ZGH:
      return r'ZGH';
    case Enum$LanguageCodeEnum.ZGH_MA:
      return r'ZGH_MA';
    case Enum$LanguageCodeEnum.ZH:
      return r'ZH';
    case Enum$LanguageCodeEnum.ZH_HANS:
      return r'ZH_HANS';
    case Enum$LanguageCodeEnum.ZH_HANS_CN:
      return r'ZH_HANS_CN';
    case Enum$LanguageCodeEnum.ZH_HANS_HK:
      return r'ZH_HANS_HK';
    case Enum$LanguageCodeEnum.ZH_HANS_MO:
      return r'ZH_HANS_MO';
    case Enum$LanguageCodeEnum.ZH_HANS_SG:
      return r'ZH_HANS_SG';
    case Enum$LanguageCodeEnum.ZH_HANT:
      return r'ZH_HANT';
    case Enum$LanguageCodeEnum.ZH_HANT_HK:
      return r'ZH_HANT_HK';
    case Enum$LanguageCodeEnum.ZH_HANT_MO:
      return r'ZH_HANT_MO';
    case Enum$LanguageCodeEnum.ZH_HANT_TW:
      return r'ZH_HANT_TW';
    case Enum$LanguageCodeEnum.ZU:
      return r'ZU';
    case Enum$LanguageCodeEnum.ZU_ZA:
      return r'ZU_ZA';
    case Enum$LanguageCodeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$LanguageCodeEnum fromJson$Enum$LanguageCodeEnum(String value) {
  switch (value) {
    case r'AF':
      return Enum$LanguageCodeEnum.AF;
    case r'AF_NA':
      return Enum$LanguageCodeEnum.AF_NA;
    case r'AF_ZA':
      return Enum$LanguageCodeEnum.AF_ZA;
    case r'AGQ':
      return Enum$LanguageCodeEnum.AGQ;
    case r'AGQ_CM':
      return Enum$LanguageCodeEnum.AGQ_CM;
    case r'AK':
      return Enum$LanguageCodeEnum.AK;
    case r'AK_GH':
      return Enum$LanguageCodeEnum.AK_GH;
    case r'AM':
      return Enum$LanguageCodeEnum.AM;
    case r'AM_ET':
      return Enum$LanguageCodeEnum.AM_ET;
    case r'AR':
      return Enum$LanguageCodeEnum.AR;
    case r'AR_AE':
      return Enum$LanguageCodeEnum.AR_AE;
    case r'AR_BH':
      return Enum$LanguageCodeEnum.AR_BH;
    case r'AR_DJ':
      return Enum$LanguageCodeEnum.AR_DJ;
    case r'AR_DZ':
      return Enum$LanguageCodeEnum.AR_DZ;
    case r'AR_EG':
      return Enum$LanguageCodeEnum.AR_EG;
    case r'AR_EH':
      return Enum$LanguageCodeEnum.AR_EH;
    case r'AR_ER':
      return Enum$LanguageCodeEnum.AR_ER;
    case r'AR_IL':
      return Enum$LanguageCodeEnum.AR_IL;
    case r'AR_IQ':
      return Enum$LanguageCodeEnum.AR_IQ;
    case r'AR_JO':
      return Enum$LanguageCodeEnum.AR_JO;
    case r'AR_KM':
      return Enum$LanguageCodeEnum.AR_KM;
    case r'AR_KW':
      return Enum$LanguageCodeEnum.AR_KW;
    case r'AR_LB':
      return Enum$LanguageCodeEnum.AR_LB;
    case r'AR_LY':
      return Enum$LanguageCodeEnum.AR_LY;
    case r'AR_MA':
      return Enum$LanguageCodeEnum.AR_MA;
    case r'AR_MR':
      return Enum$LanguageCodeEnum.AR_MR;
    case r'AR_OM':
      return Enum$LanguageCodeEnum.AR_OM;
    case r'AR_PS':
      return Enum$LanguageCodeEnum.AR_PS;
    case r'AR_QA':
      return Enum$LanguageCodeEnum.AR_QA;
    case r'AR_SA':
      return Enum$LanguageCodeEnum.AR_SA;
    case r'AR_SD':
      return Enum$LanguageCodeEnum.AR_SD;
    case r'AR_SO':
      return Enum$LanguageCodeEnum.AR_SO;
    case r'AR_SS':
      return Enum$LanguageCodeEnum.AR_SS;
    case r'AR_SY':
      return Enum$LanguageCodeEnum.AR_SY;
    case r'AR_TD':
      return Enum$LanguageCodeEnum.AR_TD;
    case r'AR_TN':
      return Enum$LanguageCodeEnum.AR_TN;
    case r'AR_YE':
      return Enum$LanguageCodeEnum.AR_YE;
    case r'AS':
      return Enum$LanguageCodeEnum.AS;
    case r'AS_IN':
      return Enum$LanguageCodeEnum.AS_IN;
    case r'ASA':
      return Enum$LanguageCodeEnum.ASA;
    case r'ASA_TZ':
      return Enum$LanguageCodeEnum.ASA_TZ;
    case r'AST':
      return Enum$LanguageCodeEnum.AST;
    case r'AST_ES':
      return Enum$LanguageCodeEnum.AST_ES;
    case r'AZ':
      return Enum$LanguageCodeEnum.AZ;
    case r'AZ_CYRL':
      return Enum$LanguageCodeEnum.AZ_CYRL;
    case r'AZ_CYRL_AZ':
      return Enum$LanguageCodeEnum.AZ_CYRL_AZ;
    case r'AZ_LATN':
      return Enum$LanguageCodeEnum.AZ_LATN;
    case r'AZ_LATN_AZ':
      return Enum$LanguageCodeEnum.AZ_LATN_AZ;
    case r'BAS':
      return Enum$LanguageCodeEnum.BAS;
    case r'BAS_CM':
      return Enum$LanguageCodeEnum.BAS_CM;
    case r'BE':
      return Enum$LanguageCodeEnum.BE;
    case r'BE_BY':
      return Enum$LanguageCodeEnum.BE_BY;
    case r'BEM':
      return Enum$LanguageCodeEnum.BEM;
    case r'BEM_ZM':
      return Enum$LanguageCodeEnum.BEM_ZM;
    case r'BEZ':
      return Enum$LanguageCodeEnum.BEZ;
    case r'BEZ_TZ':
      return Enum$LanguageCodeEnum.BEZ_TZ;
    case r'BG':
      return Enum$LanguageCodeEnum.BG;
    case r'BG_BG':
      return Enum$LanguageCodeEnum.BG_BG;
    case r'BM':
      return Enum$LanguageCodeEnum.BM;
    case r'BM_ML':
      return Enum$LanguageCodeEnum.BM_ML;
    case r'BN':
      return Enum$LanguageCodeEnum.BN;
    case r'BN_BD':
      return Enum$LanguageCodeEnum.BN_BD;
    case r'BN_IN':
      return Enum$LanguageCodeEnum.BN_IN;
    case r'BO':
      return Enum$LanguageCodeEnum.BO;
    case r'BO_CN':
      return Enum$LanguageCodeEnum.BO_CN;
    case r'BO_IN':
      return Enum$LanguageCodeEnum.BO_IN;
    case r'BR':
      return Enum$LanguageCodeEnum.BR;
    case r'BR_FR':
      return Enum$LanguageCodeEnum.BR_FR;
    case r'BRX':
      return Enum$LanguageCodeEnum.BRX;
    case r'BRX_IN':
      return Enum$LanguageCodeEnum.BRX_IN;
    case r'BS':
      return Enum$LanguageCodeEnum.BS;
    case r'BS_CYRL':
      return Enum$LanguageCodeEnum.BS_CYRL;
    case r'BS_CYRL_BA':
      return Enum$LanguageCodeEnum.BS_CYRL_BA;
    case r'BS_LATN':
      return Enum$LanguageCodeEnum.BS_LATN;
    case r'BS_LATN_BA':
      return Enum$LanguageCodeEnum.BS_LATN_BA;
    case r'CA':
      return Enum$LanguageCodeEnum.CA;
    case r'CA_AD':
      return Enum$LanguageCodeEnum.CA_AD;
    case r'CA_ES':
      return Enum$LanguageCodeEnum.CA_ES;
    case r'CA_ES_VALENCIA':
      return Enum$LanguageCodeEnum.CA_ES_VALENCIA;
    case r'CA_FR':
      return Enum$LanguageCodeEnum.CA_FR;
    case r'CA_IT':
      return Enum$LanguageCodeEnum.CA_IT;
    case r'CCP':
      return Enum$LanguageCodeEnum.CCP;
    case r'CCP_BD':
      return Enum$LanguageCodeEnum.CCP_BD;
    case r'CCP_IN':
      return Enum$LanguageCodeEnum.CCP_IN;
    case r'CE':
      return Enum$LanguageCodeEnum.CE;
    case r'CE_RU':
      return Enum$LanguageCodeEnum.CE_RU;
    case r'CEB':
      return Enum$LanguageCodeEnum.CEB;
    case r'CEB_PH':
      return Enum$LanguageCodeEnum.CEB_PH;
    case r'CGG':
      return Enum$LanguageCodeEnum.CGG;
    case r'CGG_UG':
      return Enum$LanguageCodeEnum.CGG_UG;
    case r'CHR':
      return Enum$LanguageCodeEnum.CHR;
    case r'CHR_US':
      return Enum$LanguageCodeEnum.CHR_US;
    case r'CKB':
      return Enum$LanguageCodeEnum.CKB;
    case r'CKB_IQ':
      return Enum$LanguageCodeEnum.CKB_IQ;
    case r'CKB_IR':
      return Enum$LanguageCodeEnum.CKB_IR;
    case r'CS':
      return Enum$LanguageCodeEnum.CS;
    case r'CS_CZ':
      return Enum$LanguageCodeEnum.CS_CZ;
    case r'CU':
      return Enum$LanguageCodeEnum.CU;
    case r'CU_RU':
      return Enum$LanguageCodeEnum.CU_RU;
    case r'CY':
      return Enum$LanguageCodeEnum.CY;
    case r'CY_GB':
      return Enum$LanguageCodeEnum.CY_GB;
    case r'DA':
      return Enum$LanguageCodeEnum.DA;
    case r'DA_DK':
      return Enum$LanguageCodeEnum.DA_DK;
    case r'DA_GL':
      return Enum$LanguageCodeEnum.DA_GL;
    case r'DAV':
      return Enum$LanguageCodeEnum.DAV;
    case r'DAV_KE':
      return Enum$LanguageCodeEnum.DAV_KE;
    case r'DE':
      return Enum$LanguageCodeEnum.DE;
    case r'DE_AT':
      return Enum$LanguageCodeEnum.DE_AT;
    case r'DE_BE':
      return Enum$LanguageCodeEnum.DE_BE;
    case r'DE_CH':
      return Enum$LanguageCodeEnum.DE_CH;
    case r'DE_DE':
      return Enum$LanguageCodeEnum.DE_DE;
    case r'DE_IT':
      return Enum$LanguageCodeEnum.DE_IT;
    case r'DE_LI':
      return Enum$LanguageCodeEnum.DE_LI;
    case r'DE_LU':
      return Enum$LanguageCodeEnum.DE_LU;
    case r'DJE':
      return Enum$LanguageCodeEnum.DJE;
    case r'DJE_NE':
      return Enum$LanguageCodeEnum.DJE_NE;
    case r'DSB':
      return Enum$LanguageCodeEnum.DSB;
    case r'DSB_DE':
      return Enum$LanguageCodeEnum.DSB_DE;
    case r'DUA':
      return Enum$LanguageCodeEnum.DUA;
    case r'DUA_CM':
      return Enum$LanguageCodeEnum.DUA_CM;
    case r'DYO':
      return Enum$LanguageCodeEnum.DYO;
    case r'DYO_SN':
      return Enum$LanguageCodeEnum.DYO_SN;
    case r'DZ':
      return Enum$LanguageCodeEnum.DZ;
    case r'DZ_BT':
      return Enum$LanguageCodeEnum.DZ_BT;
    case r'EBU':
      return Enum$LanguageCodeEnum.EBU;
    case r'EBU_KE':
      return Enum$LanguageCodeEnum.EBU_KE;
    case r'EE':
      return Enum$LanguageCodeEnum.EE;
    case r'EE_GH':
      return Enum$LanguageCodeEnum.EE_GH;
    case r'EE_TG':
      return Enum$LanguageCodeEnum.EE_TG;
    case r'EL':
      return Enum$LanguageCodeEnum.EL;
    case r'EL_CY':
      return Enum$LanguageCodeEnum.EL_CY;
    case r'EL_GR':
      return Enum$LanguageCodeEnum.EL_GR;
    case r'EN':
      return Enum$LanguageCodeEnum.EN;
    case r'EN_AE':
      return Enum$LanguageCodeEnum.EN_AE;
    case r'EN_AG':
      return Enum$LanguageCodeEnum.EN_AG;
    case r'EN_AI':
      return Enum$LanguageCodeEnum.EN_AI;
    case r'EN_AS':
      return Enum$LanguageCodeEnum.EN_AS;
    case r'EN_AT':
      return Enum$LanguageCodeEnum.EN_AT;
    case r'EN_AU':
      return Enum$LanguageCodeEnum.EN_AU;
    case r'EN_BB':
      return Enum$LanguageCodeEnum.EN_BB;
    case r'EN_BE':
      return Enum$LanguageCodeEnum.EN_BE;
    case r'EN_BI':
      return Enum$LanguageCodeEnum.EN_BI;
    case r'EN_BM':
      return Enum$LanguageCodeEnum.EN_BM;
    case r'EN_BS':
      return Enum$LanguageCodeEnum.EN_BS;
    case r'EN_BW':
      return Enum$LanguageCodeEnum.EN_BW;
    case r'EN_BZ':
      return Enum$LanguageCodeEnum.EN_BZ;
    case r'EN_CA':
      return Enum$LanguageCodeEnum.EN_CA;
    case r'EN_CC':
      return Enum$LanguageCodeEnum.EN_CC;
    case r'EN_CH':
      return Enum$LanguageCodeEnum.EN_CH;
    case r'EN_CK':
      return Enum$LanguageCodeEnum.EN_CK;
    case r'EN_CM':
      return Enum$LanguageCodeEnum.EN_CM;
    case r'EN_CX':
      return Enum$LanguageCodeEnum.EN_CX;
    case r'EN_CY':
      return Enum$LanguageCodeEnum.EN_CY;
    case r'EN_DE':
      return Enum$LanguageCodeEnum.EN_DE;
    case r'EN_DG':
      return Enum$LanguageCodeEnum.EN_DG;
    case r'EN_DK':
      return Enum$LanguageCodeEnum.EN_DK;
    case r'EN_DM':
      return Enum$LanguageCodeEnum.EN_DM;
    case r'EN_ER':
      return Enum$LanguageCodeEnum.EN_ER;
    case r'EN_FI':
      return Enum$LanguageCodeEnum.EN_FI;
    case r'EN_FJ':
      return Enum$LanguageCodeEnum.EN_FJ;
    case r'EN_FK':
      return Enum$LanguageCodeEnum.EN_FK;
    case r'EN_FM':
      return Enum$LanguageCodeEnum.EN_FM;
    case r'EN_GB':
      return Enum$LanguageCodeEnum.EN_GB;
    case r'EN_GD':
      return Enum$LanguageCodeEnum.EN_GD;
    case r'EN_GG':
      return Enum$LanguageCodeEnum.EN_GG;
    case r'EN_GH':
      return Enum$LanguageCodeEnum.EN_GH;
    case r'EN_GI':
      return Enum$LanguageCodeEnum.EN_GI;
    case r'EN_GM':
      return Enum$LanguageCodeEnum.EN_GM;
    case r'EN_GU':
      return Enum$LanguageCodeEnum.EN_GU;
    case r'EN_GY':
      return Enum$LanguageCodeEnum.EN_GY;
    case r'EN_HK':
      return Enum$LanguageCodeEnum.EN_HK;
    case r'EN_IE':
      return Enum$LanguageCodeEnum.EN_IE;
    case r'EN_IL':
      return Enum$LanguageCodeEnum.EN_IL;
    case r'EN_IM':
      return Enum$LanguageCodeEnum.EN_IM;
    case r'EN_IN':
      return Enum$LanguageCodeEnum.EN_IN;
    case r'EN_IO':
      return Enum$LanguageCodeEnum.EN_IO;
    case r'EN_JE':
      return Enum$LanguageCodeEnum.EN_JE;
    case r'EN_JM':
      return Enum$LanguageCodeEnum.EN_JM;
    case r'EN_KE':
      return Enum$LanguageCodeEnum.EN_KE;
    case r'EN_KI':
      return Enum$LanguageCodeEnum.EN_KI;
    case r'EN_KN':
      return Enum$LanguageCodeEnum.EN_KN;
    case r'EN_KY':
      return Enum$LanguageCodeEnum.EN_KY;
    case r'EN_LC':
      return Enum$LanguageCodeEnum.EN_LC;
    case r'EN_LR':
      return Enum$LanguageCodeEnum.EN_LR;
    case r'EN_LS':
      return Enum$LanguageCodeEnum.EN_LS;
    case r'EN_MG':
      return Enum$LanguageCodeEnum.EN_MG;
    case r'EN_MH':
      return Enum$LanguageCodeEnum.EN_MH;
    case r'EN_MO':
      return Enum$LanguageCodeEnum.EN_MO;
    case r'EN_MP':
      return Enum$LanguageCodeEnum.EN_MP;
    case r'EN_MS':
      return Enum$LanguageCodeEnum.EN_MS;
    case r'EN_MT':
      return Enum$LanguageCodeEnum.EN_MT;
    case r'EN_MU':
      return Enum$LanguageCodeEnum.EN_MU;
    case r'EN_MW':
      return Enum$LanguageCodeEnum.EN_MW;
    case r'EN_MY':
      return Enum$LanguageCodeEnum.EN_MY;
    case r'EN_NA':
      return Enum$LanguageCodeEnum.EN_NA;
    case r'EN_NF':
      return Enum$LanguageCodeEnum.EN_NF;
    case r'EN_NG':
      return Enum$LanguageCodeEnum.EN_NG;
    case r'EN_NL':
      return Enum$LanguageCodeEnum.EN_NL;
    case r'EN_NR':
      return Enum$LanguageCodeEnum.EN_NR;
    case r'EN_NU':
      return Enum$LanguageCodeEnum.EN_NU;
    case r'EN_NZ':
      return Enum$LanguageCodeEnum.EN_NZ;
    case r'EN_PG':
      return Enum$LanguageCodeEnum.EN_PG;
    case r'EN_PH':
      return Enum$LanguageCodeEnum.EN_PH;
    case r'EN_PK':
      return Enum$LanguageCodeEnum.EN_PK;
    case r'EN_PN':
      return Enum$LanguageCodeEnum.EN_PN;
    case r'EN_PR':
      return Enum$LanguageCodeEnum.EN_PR;
    case r'EN_PW':
      return Enum$LanguageCodeEnum.EN_PW;
    case r'EN_RW':
      return Enum$LanguageCodeEnum.EN_RW;
    case r'EN_SB':
      return Enum$LanguageCodeEnum.EN_SB;
    case r'EN_SC':
      return Enum$LanguageCodeEnum.EN_SC;
    case r'EN_SD':
      return Enum$LanguageCodeEnum.EN_SD;
    case r'EN_SE':
      return Enum$LanguageCodeEnum.EN_SE;
    case r'EN_SG':
      return Enum$LanguageCodeEnum.EN_SG;
    case r'EN_SH':
      return Enum$LanguageCodeEnum.EN_SH;
    case r'EN_SI':
      return Enum$LanguageCodeEnum.EN_SI;
    case r'EN_SL':
      return Enum$LanguageCodeEnum.EN_SL;
    case r'EN_SS':
      return Enum$LanguageCodeEnum.EN_SS;
    case r'EN_SX':
      return Enum$LanguageCodeEnum.EN_SX;
    case r'EN_SZ':
      return Enum$LanguageCodeEnum.EN_SZ;
    case r'EN_TC':
      return Enum$LanguageCodeEnum.EN_TC;
    case r'EN_TK':
      return Enum$LanguageCodeEnum.EN_TK;
    case r'EN_TO':
      return Enum$LanguageCodeEnum.EN_TO;
    case r'EN_TT':
      return Enum$LanguageCodeEnum.EN_TT;
    case r'EN_TV':
      return Enum$LanguageCodeEnum.EN_TV;
    case r'EN_TZ':
      return Enum$LanguageCodeEnum.EN_TZ;
    case r'EN_UG':
      return Enum$LanguageCodeEnum.EN_UG;
    case r'EN_UM':
      return Enum$LanguageCodeEnum.EN_UM;
    case r'EN_US':
      return Enum$LanguageCodeEnum.EN_US;
    case r'EN_VC':
      return Enum$LanguageCodeEnum.EN_VC;
    case r'EN_VG':
      return Enum$LanguageCodeEnum.EN_VG;
    case r'EN_VI':
      return Enum$LanguageCodeEnum.EN_VI;
    case r'EN_VU':
      return Enum$LanguageCodeEnum.EN_VU;
    case r'EN_WS':
      return Enum$LanguageCodeEnum.EN_WS;
    case r'EN_ZA':
      return Enum$LanguageCodeEnum.EN_ZA;
    case r'EN_ZM':
      return Enum$LanguageCodeEnum.EN_ZM;
    case r'EN_ZW':
      return Enum$LanguageCodeEnum.EN_ZW;
    case r'EO':
      return Enum$LanguageCodeEnum.EO;
    case r'ES':
      return Enum$LanguageCodeEnum.ES;
    case r'ES_AR':
      return Enum$LanguageCodeEnum.ES_AR;
    case r'ES_BO':
      return Enum$LanguageCodeEnum.ES_BO;
    case r'ES_BR':
      return Enum$LanguageCodeEnum.ES_BR;
    case r'ES_BZ':
      return Enum$LanguageCodeEnum.ES_BZ;
    case r'ES_CL':
      return Enum$LanguageCodeEnum.ES_CL;
    case r'ES_CO':
      return Enum$LanguageCodeEnum.ES_CO;
    case r'ES_CR':
      return Enum$LanguageCodeEnum.ES_CR;
    case r'ES_CU':
      return Enum$LanguageCodeEnum.ES_CU;
    case r'ES_DO':
      return Enum$LanguageCodeEnum.ES_DO;
    case r'ES_EA':
      return Enum$LanguageCodeEnum.ES_EA;
    case r'ES_EC':
      return Enum$LanguageCodeEnum.ES_EC;
    case r'ES_ES':
      return Enum$LanguageCodeEnum.ES_ES;
    case r'ES_GQ':
      return Enum$LanguageCodeEnum.ES_GQ;
    case r'ES_GT':
      return Enum$LanguageCodeEnum.ES_GT;
    case r'ES_HN':
      return Enum$LanguageCodeEnum.ES_HN;
    case r'ES_IC':
      return Enum$LanguageCodeEnum.ES_IC;
    case r'ES_MX':
      return Enum$LanguageCodeEnum.ES_MX;
    case r'ES_NI':
      return Enum$LanguageCodeEnum.ES_NI;
    case r'ES_PA':
      return Enum$LanguageCodeEnum.ES_PA;
    case r'ES_PE':
      return Enum$LanguageCodeEnum.ES_PE;
    case r'ES_PH':
      return Enum$LanguageCodeEnum.ES_PH;
    case r'ES_PR':
      return Enum$LanguageCodeEnum.ES_PR;
    case r'ES_PY':
      return Enum$LanguageCodeEnum.ES_PY;
    case r'ES_SV':
      return Enum$LanguageCodeEnum.ES_SV;
    case r'ES_US':
      return Enum$LanguageCodeEnum.ES_US;
    case r'ES_UY':
      return Enum$LanguageCodeEnum.ES_UY;
    case r'ES_VE':
      return Enum$LanguageCodeEnum.ES_VE;
    case r'ET':
      return Enum$LanguageCodeEnum.ET;
    case r'ET_EE':
      return Enum$LanguageCodeEnum.ET_EE;
    case r'EU':
      return Enum$LanguageCodeEnum.EU;
    case r'EU_ES':
      return Enum$LanguageCodeEnum.EU_ES;
    case r'EWO':
      return Enum$LanguageCodeEnum.EWO;
    case r'EWO_CM':
      return Enum$LanguageCodeEnum.EWO_CM;
    case r'FA':
      return Enum$LanguageCodeEnum.FA;
    case r'FA_AF':
      return Enum$LanguageCodeEnum.FA_AF;
    case r'FA_IR':
      return Enum$LanguageCodeEnum.FA_IR;
    case r'FF':
      return Enum$LanguageCodeEnum.FF;
    case r'FF_ADLM':
      return Enum$LanguageCodeEnum.FF_ADLM;
    case r'FF_ADLM_BF':
      return Enum$LanguageCodeEnum.FF_ADLM_BF;
    case r'FF_ADLM_CM':
      return Enum$LanguageCodeEnum.FF_ADLM_CM;
    case r'FF_ADLM_GH':
      return Enum$LanguageCodeEnum.FF_ADLM_GH;
    case r'FF_ADLM_GM':
      return Enum$LanguageCodeEnum.FF_ADLM_GM;
    case r'FF_ADLM_GN':
      return Enum$LanguageCodeEnum.FF_ADLM_GN;
    case r'FF_ADLM_GW':
      return Enum$LanguageCodeEnum.FF_ADLM_GW;
    case r'FF_ADLM_LR':
      return Enum$LanguageCodeEnum.FF_ADLM_LR;
    case r'FF_ADLM_MR':
      return Enum$LanguageCodeEnum.FF_ADLM_MR;
    case r'FF_ADLM_NE':
      return Enum$LanguageCodeEnum.FF_ADLM_NE;
    case r'FF_ADLM_NG':
      return Enum$LanguageCodeEnum.FF_ADLM_NG;
    case r'FF_ADLM_SL':
      return Enum$LanguageCodeEnum.FF_ADLM_SL;
    case r'FF_ADLM_SN':
      return Enum$LanguageCodeEnum.FF_ADLM_SN;
    case r'FF_LATN':
      return Enum$LanguageCodeEnum.FF_LATN;
    case r'FF_LATN_BF':
      return Enum$LanguageCodeEnum.FF_LATN_BF;
    case r'FF_LATN_CM':
      return Enum$LanguageCodeEnum.FF_LATN_CM;
    case r'FF_LATN_GH':
      return Enum$LanguageCodeEnum.FF_LATN_GH;
    case r'FF_LATN_GM':
      return Enum$LanguageCodeEnum.FF_LATN_GM;
    case r'FF_LATN_GN':
      return Enum$LanguageCodeEnum.FF_LATN_GN;
    case r'FF_LATN_GW':
      return Enum$LanguageCodeEnum.FF_LATN_GW;
    case r'FF_LATN_LR':
      return Enum$LanguageCodeEnum.FF_LATN_LR;
    case r'FF_LATN_MR':
      return Enum$LanguageCodeEnum.FF_LATN_MR;
    case r'FF_LATN_NE':
      return Enum$LanguageCodeEnum.FF_LATN_NE;
    case r'FF_LATN_NG':
      return Enum$LanguageCodeEnum.FF_LATN_NG;
    case r'FF_LATN_SL':
      return Enum$LanguageCodeEnum.FF_LATN_SL;
    case r'FF_LATN_SN':
      return Enum$LanguageCodeEnum.FF_LATN_SN;
    case r'FI':
      return Enum$LanguageCodeEnum.FI;
    case r'FI_FI':
      return Enum$LanguageCodeEnum.FI_FI;
    case r'FIL':
      return Enum$LanguageCodeEnum.FIL;
    case r'FIL_PH':
      return Enum$LanguageCodeEnum.FIL_PH;
    case r'FO':
      return Enum$LanguageCodeEnum.FO;
    case r'FO_DK':
      return Enum$LanguageCodeEnum.FO_DK;
    case r'FO_FO':
      return Enum$LanguageCodeEnum.FO_FO;
    case r'FR':
      return Enum$LanguageCodeEnum.FR;
    case r'FR_BE':
      return Enum$LanguageCodeEnum.FR_BE;
    case r'FR_BF':
      return Enum$LanguageCodeEnum.FR_BF;
    case r'FR_BI':
      return Enum$LanguageCodeEnum.FR_BI;
    case r'FR_BJ':
      return Enum$LanguageCodeEnum.FR_BJ;
    case r'FR_BL':
      return Enum$LanguageCodeEnum.FR_BL;
    case r'FR_CA':
      return Enum$LanguageCodeEnum.FR_CA;
    case r'FR_CD':
      return Enum$LanguageCodeEnum.FR_CD;
    case r'FR_CF':
      return Enum$LanguageCodeEnum.FR_CF;
    case r'FR_CG':
      return Enum$LanguageCodeEnum.FR_CG;
    case r'FR_CH':
      return Enum$LanguageCodeEnum.FR_CH;
    case r'FR_CI':
      return Enum$LanguageCodeEnum.FR_CI;
    case r'FR_CM':
      return Enum$LanguageCodeEnum.FR_CM;
    case r'FR_DJ':
      return Enum$LanguageCodeEnum.FR_DJ;
    case r'FR_DZ':
      return Enum$LanguageCodeEnum.FR_DZ;
    case r'FR_FR':
      return Enum$LanguageCodeEnum.FR_FR;
    case r'FR_GA':
      return Enum$LanguageCodeEnum.FR_GA;
    case r'FR_GF':
      return Enum$LanguageCodeEnum.FR_GF;
    case r'FR_GN':
      return Enum$LanguageCodeEnum.FR_GN;
    case r'FR_GP':
      return Enum$LanguageCodeEnum.FR_GP;
    case r'FR_GQ':
      return Enum$LanguageCodeEnum.FR_GQ;
    case r'FR_HT':
      return Enum$LanguageCodeEnum.FR_HT;
    case r'FR_KM':
      return Enum$LanguageCodeEnum.FR_KM;
    case r'FR_LU':
      return Enum$LanguageCodeEnum.FR_LU;
    case r'FR_MA':
      return Enum$LanguageCodeEnum.FR_MA;
    case r'FR_MC':
      return Enum$LanguageCodeEnum.FR_MC;
    case r'FR_MF':
      return Enum$LanguageCodeEnum.FR_MF;
    case r'FR_MG':
      return Enum$LanguageCodeEnum.FR_MG;
    case r'FR_ML':
      return Enum$LanguageCodeEnum.FR_ML;
    case r'FR_MQ':
      return Enum$LanguageCodeEnum.FR_MQ;
    case r'FR_MR':
      return Enum$LanguageCodeEnum.FR_MR;
    case r'FR_MU':
      return Enum$LanguageCodeEnum.FR_MU;
    case r'FR_NC':
      return Enum$LanguageCodeEnum.FR_NC;
    case r'FR_NE':
      return Enum$LanguageCodeEnum.FR_NE;
    case r'FR_PF':
      return Enum$LanguageCodeEnum.FR_PF;
    case r'FR_PM':
      return Enum$LanguageCodeEnum.FR_PM;
    case r'FR_RE':
      return Enum$LanguageCodeEnum.FR_RE;
    case r'FR_RW':
      return Enum$LanguageCodeEnum.FR_RW;
    case r'FR_SC':
      return Enum$LanguageCodeEnum.FR_SC;
    case r'FR_SN':
      return Enum$LanguageCodeEnum.FR_SN;
    case r'FR_SY':
      return Enum$LanguageCodeEnum.FR_SY;
    case r'FR_TD':
      return Enum$LanguageCodeEnum.FR_TD;
    case r'FR_TG':
      return Enum$LanguageCodeEnum.FR_TG;
    case r'FR_TN':
      return Enum$LanguageCodeEnum.FR_TN;
    case r'FR_VU':
      return Enum$LanguageCodeEnum.FR_VU;
    case r'FR_WF':
      return Enum$LanguageCodeEnum.FR_WF;
    case r'FR_YT':
      return Enum$LanguageCodeEnum.FR_YT;
    case r'FUR':
      return Enum$LanguageCodeEnum.FUR;
    case r'FUR_IT':
      return Enum$LanguageCodeEnum.FUR_IT;
    case r'FY':
      return Enum$LanguageCodeEnum.FY;
    case r'FY_NL':
      return Enum$LanguageCodeEnum.FY_NL;
    case r'GA':
      return Enum$LanguageCodeEnum.GA;
    case r'GA_GB':
      return Enum$LanguageCodeEnum.GA_GB;
    case r'GA_IE':
      return Enum$LanguageCodeEnum.GA_IE;
    case r'GD':
      return Enum$LanguageCodeEnum.GD;
    case r'GD_GB':
      return Enum$LanguageCodeEnum.GD_GB;
    case r'GL':
      return Enum$LanguageCodeEnum.GL;
    case r'GL_ES':
      return Enum$LanguageCodeEnum.GL_ES;
    case r'GSW':
      return Enum$LanguageCodeEnum.GSW;
    case r'GSW_CH':
      return Enum$LanguageCodeEnum.GSW_CH;
    case r'GSW_FR':
      return Enum$LanguageCodeEnum.GSW_FR;
    case r'GSW_LI':
      return Enum$LanguageCodeEnum.GSW_LI;
    case r'GU':
      return Enum$LanguageCodeEnum.GU;
    case r'GU_IN':
      return Enum$LanguageCodeEnum.GU_IN;
    case r'GUZ':
      return Enum$LanguageCodeEnum.GUZ;
    case r'GUZ_KE':
      return Enum$LanguageCodeEnum.GUZ_KE;
    case r'GV':
      return Enum$LanguageCodeEnum.GV;
    case r'GV_IM':
      return Enum$LanguageCodeEnum.GV_IM;
    case r'HA':
      return Enum$LanguageCodeEnum.HA;
    case r'HA_GH':
      return Enum$LanguageCodeEnum.HA_GH;
    case r'HA_NE':
      return Enum$LanguageCodeEnum.HA_NE;
    case r'HA_NG':
      return Enum$LanguageCodeEnum.HA_NG;
    case r'HAW':
      return Enum$LanguageCodeEnum.HAW;
    case r'HAW_US':
      return Enum$LanguageCodeEnum.HAW_US;
    case r'HE':
      return Enum$LanguageCodeEnum.HE;
    case r'HE_IL':
      return Enum$LanguageCodeEnum.HE_IL;
    case r'HI':
      return Enum$LanguageCodeEnum.HI;
    case r'HI_IN':
      return Enum$LanguageCodeEnum.HI_IN;
    case r'HR':
      return Enum$LanguageCodeEnum.HR;
    case r'HR_BA':
      return Enum$LanguageCodeEnum.HR_BA;
    case r'HR_HR':
      return Enum$LanguageCodeEnum.HR_HR;
    case r'HSB':
      return Enum$LanguageCodeEnum.HSB;
    case r'HSB_DE':
      return Enum$LanguageCodeEnum.HSB_DE;
    case r'HU':
      return Enum$LanguageCodeEnum.HU;
    case r'HU_HU':
      return Enum$LanguageCodeEnum.HU_HU;
    case r'HY':
      return Enum$LanguageCodeEnum.HY;
    case r'HY_AM':
      return Enum$LanguageCodeEnum.HY_AM;
    case r'IA':
      return Enum$LanguageCodeEnum.IA;
    case r'ID':
      return Enum$LanguageCodeEnum.ID;
    case r'ID_ID':
      return Enum$LanguageCodeEnum.ID_ID;
    case r'IG':
      return Enum$LanguageCodeEnum.IG;
    case r'IG_NG':
      return Enum$LanguageCodeEnum.IG_NG;
    case r'II':
      return Enum$LanguageCodeEnum.II;
    case r'II_CN':
      return Enum$LanguageCodeEnum.II_CN;
    case r'IS':
      return Enum$LanguageCodeEnum.IS;
    case r'IS_IS':
      return Enum$LanguageCodeEnum.IS_IS;
    case r'IT':
      return Enum$LanguageCodeEnum.IT;
    case r'IT_CH':
      return Enum$LanguageCodeEnum.IT_CH;
    case r'IT_IT':
      return Enum$LanguageCodeEnum.IT_IT;
    case r'IT_SM':
      return Enum$LanguageCodeEnum.IT_SM;
    case r'IT_VA':
      return Enum$LanguageCodeEnum.IT_VA;
    case r'JA':
      return Enum$LanguageCodeEnum.JA;
    case r'JA_JP':
      return Enum$LanguageCodeEnum.JA_JP;
    case r'JGO':
      return Enum$LanguageCodeEnum.JGO;
    case r'JGO_CM':
      return Enum$LanguageCodeEnum.JGO_CM;
    case r'JMC':
      return Enum$LanguageCodeEnum.JMC;
    case r'JMC_TZ':
      return Enum$LanguageCodeEnum.JMC_TZ;
    case r'JV':
      return Enum$LanguageCodeEnum.JV;
    case r'JV_ID':
      return Enum$LanguageCodeEnum.JV_ID;
    case r'KA':
      return Enum$LanguageCodeEnum.KA;
    case r'KA_GE':
      return Enum$LanguageCodeEnum.KA_GE;
    case r'KAB':
      return Enum$LanguageCodeEnum.KAB;
    case r'KAB_DZ':
      return Enum$LanguageCodeEnum.KAB_DZ;
    case r'KAM':
      return Enum$LanguageCodeEnum.KAM;
    case r'KAM_KE':
      return Enum$LanguageCodeEnum.KAM_KE;
    case r'KDE':
      return Enum$LanguageCodeEnum.KDE;
    case r'KDE_TZ':
      return Enum$LanguageCodeEnum.KDE_TZ;
    case r'KEA':
      return Enum$LanguageCodeEnum.KEA;
    case r'KEA_CV':
      return Enum$LanguageCodeEnum.KEA_CV;
    case r'KHQ':
      return Enum$LanguageCodeEnum.KHQ;
    case r'KHQ_ML':
      return Enum$LanguageCodeEnum.KHQ_ML;
    case r'KI':
      return Enum$LanguageCodeEnum.KI;
    case r'KI_KE':
      return Enum$LanguageCodeEnum.KI_KE;
    case r'KK':
      return Enum$LanguageCodeEnum.KK;
    case r'KK_KZ':
      return Enum$LanguageCodeEnum.KK_KZ;
    case r'KKJ':
      return Enum$LanguageCodeEnum.KKJ;
    case r'KKJ_CM':
      return Enum$LanguageCodeEnum.KKJ_CM;
    case r'KL':
      return Enum$LanguageCodeEnum.KL;
    case r'KL_GL':
      return Enum$LanguageCodeEnum.KL_GL;
    case r'KLN':
      return Enum$LanguageCodeEnum.KLN;
    case r'KLN_KE':
      return Enum$LanguageCodeEnum.KLN_KE;
    case r'KM':
      return Enum$LanguageCodeEnum.KM;
    case r'KM_KH':
      return Enum$LanguageCodeEnum.KM_KH;
    case r'KN':
      return Enum$LanguageCodeEnum.KN;
    case r'KN_IN':
      return Enum$LanguageCodeEnum.KN_IN;
    case r'KO':
      return Enum$LanguageCodeEnum.KO;
    case r'KO_KP':
      return Enum$LanguageCodeEnum.KO_KP;
    case r'KO_KR':
      return Enum$LanguageCodeEnum.KO_KR;
    case r'KOK':
      return Enum$LanguageCodeEnum.KOK;
    case r'KOK_IN':
      return Enum$LanguageCodeEnum.KOK_IN;
    case r'KS':
      return Enum$LanguageCodeEnum.KS;
    case r'KS_ARAB':
      return Enum$LanguageCodeEnum.KS_ARAB;
    case r'KS_ARAB_IN':
      return Enum$LanguageCodeEnum.KS_ARAB_IN;
    case r'KSB':
      return Enum$LanguageCodeEnum.KSB;
    case r'KSB_TZ':
      return Enum$LanguageCodeEnum.KSB_TZ;
    case r'KSF':
      return Enum$LanguageCodeEnum.KSF;
    case r'KSF_CM':
      return Enum$LanguageCodeEnum.KSF_CM;
    case r'KSH':
      return Enum$LanguageCodeEnum.KSH;
    case r'KSH_DE':
      return Enum$LanguageCodeEnum.KSH_DE;
    case r'KU':
      return Enum$LanguageCodeEnum.KU;
    case r'KU_TR':
      return Enum$LanguageCodeEnum.KU_TR;
    case r'KW':
      return Enum$LanguageCodeEnum.KW;
    case r'KW_GB':
      return Enum$LanguageCodeEnum.KW_GB;
    case r'KY':
      return Enum$LanguageCodeEnum.KY;
    case r'KY_KG':
      return Enum$LanguageCodeEnum.KY_KG;
    case r'LAG':
      return Enum$LanguageCodeEnum.LAG;
    case r'LAG_TZ':
      return Enum$LanguageCodeEnum.LAG_TZ;
    case r'LB':
      return Enum$LanguageCodeEnum.LB;
    case r'LB_LU':
      return Enum$LanguageCodeEnum.LB_LU;
    case r'LG':
      return Enum$LanguageCodeEnum.LG;
    case r'LG_UG':
      return Enum$LanguageCodeEnum.LG_UG;
    case r'LKT':
      return Enum$LanguageCodeEnum.LKT;
    case r'LKT_US':
      return Enum$LanguageCodeEnum.LKT_US;
    case r'LN':
      return Enum$LanguageCodeEnum.LN;
    case r'LN_AO':
      return Enum$LanguageCodeEnum.LN_AO;
    case r'LN_CD':
      return Enum$LanguageCodeEnum.LN_CD;
    case r'LN_CF':
      return Enum$LanguageCodeEnum.LN_CF;
    case r'LN_CG':
      return Enum$LanguageCodeEnum.LN_CG;
    case r'LO':
      return Enum$LanguageCodeEnum.LO;
    case r'LO_LA':
      return Enum$LanguageCodeEnum.LO_LA;
    case r'LRC':
      return Enum$LanguageCodeEnum.LRC;
    case r'LRC_IQ':
      return Enum$LanguageCodeEnum.LRC_IQ;
    case r'LRC_IR':
      return Enum$LanguageCodeEnum.LRC_IR;
    case r'LT':
      return Enum$LanguageCodeEnum.LT;
    case r'LT_LT':
      return Enum$LanguageCodeEnum.LT_LT;
    case r'LU':
      return Enum$LanguageCodeEnum.LU;
    case r'LU_CD':
      return Enum$LanguageCodeEnum.LU_CD;
    case r'LUO':
      return Enum$LanguageCodeEnum.LUO;
    case r'LUO_KE':
      return Enum$LanguageCodeEnum.LUO_KE;
    case r'LUY':
      return Enum$LanguageCodeEnum.LUY;
    case r'LUY_KE':
      return Enum$LanguageCodeEnum.LUY_KE;
    case r'LV':
      return Enum$LanguageCodeEnum.LV;
    case r'LV_LV':
      return Enum$LanguageCodeEnum.LV_LV;
    case r'MAI':
      return Enum$LanguageCodeEnum.MAI;
    case r'MAI_IN':
      return Enum$LanguageCodeEnum.MAI_IN;
    case r'MAS':
      return Enum$LanguageCodeEnum.MAS;
    case r'MAS_KE':
      return Enum$LanguageCodeEnum.MAS_KE;
    case r'MAS_TZ':
      return Enum$LanguageCodeEnum.MAS_TZ;
    case r'MER':
      return Enum$LanguageCodeEnum.MER;
    case r'MER_KE':
      return Enum$LanguageCodeEnum.MER_KE;
    case r'MFE':
      return Enum$LanguageCodeEnum.MFE;
    case r'MFE_MU':
      return Enum$LanguageCodeEnum.MFE_MU;
    case r'MG':
      return Enum$LanguageCodeEnum.MG;
    case r'MG_MG':
      return Enum$LanguageCodeEnum.MG_MG;
    case r'MGH':
      return Enum$LanguageCodeEnum.MGH;
    case r'MGH_MZ':
      return Enum$LanguageCodeEnum.MGH_MZ;
    case r'MGO':
      return Enum$LanguageCodeEnum.MGO;
    case r'MGO_CM':
      return Enum$LanguageCodeEnum.MGO_CM;
    case r'MI':
      return Enum$LanguageCodeEnum.MI;
    case r'MI_NZ':
      return Enum$LanguageCodeEnum.MI_NZ;
    case r'MK':
      return Enum$LanguageCodeEnum.MK;
    case r'MK_MK':
      return Enum$LanguageCodeEnum.MK_MK;
    case r'ML':
      return Enum$LanguageCodeEnum.ML;
    case r'ML_IN':
      return Enum$LanguageCodeEnum.ML_IN;
    case r'MN':
      return Enum$LanguageCodeEnum.MN;
    case r'MN_MN':
      return Enum$LanguageCodeEnum.MN_MN;
    case r'MNI':
      return Enum$LanguageCodeEnum.MNI;
    case r'MNI_BENG':
      return Enum$LanguageCodeEnum.MNI_BENG;
    case r'MNI_BENG_IN':
      return Enum$LanguageCodeEnum.MNI_BENG_IN;
    case r'MR':
      return Enum$LanguageCodeEnum.MR;
    case r'MR_IN':
      return Enum$LanguageCodeEnum.MR_IN;
    case r'MS':
      return Enum$LanguageCodeEnum.MS;
    case r'MS_BN':
      return Enum$LanguageCodeEnum.MS_BN;
    case r'MS_ID':
      return Enum$LanguageCodeEnum.MS_ID;
    case r'MS_MY':
      return Enum$LanguageCodeEnum.MS_MY;
    case r'MS_SG':
      return Enum$LanguageCodeEnum.MS_SG;
    case r'MT':
      return Enum$LanguageCodeEnum.MT;
    case r'MT_MT':
      return Enum$LanguageCodeEnum.MT_MT;
    case r'MUA':
      return Enum$LanguageCodeEnum.MUA;
    case r'MUA_CM':
      return Enum$LanguageCodeEnum.MUA_CM;
    case r'MY':
      return Enum$LanguageCodeEnum.MY;
    case r'MY_MM':
      return Enum$LanguageCodeEnum.MY_MM;
    case r'MZN':
      return Enum$LanguageCodeEnum.MZN;
    case r'MZN_IR':
      return Enum$LanguageCodeEnum.MZN_IR;
    case r'NAQ':
      return Enum$LanguageCodeEnum.NAQ;
    case r'NAQ_NA':
      return Enum$LanguageCodeEnum.NAQ_NA;
    case r'NB':
      return Enum$LanguageCodeEnum.NB;
    case r'NB_NO':
      return Enum$LanguageCodeEnum.NB_NO;
    case r'NB_SJ':
      return Enum$LanguageCodeEnum.NB_SJ;
    case r'ND':
      return Enum$LanguageCodeEnum.ND;
    case r'ND_ZW':
      return Enum$LanguageCodeEnum.ND_ZW;
    case r'NDS':
      return Enum$LanguageCodeEnum.NDS;
    case r'NDS_DE':
      return Enum$LanguageCodeEnum.NDS_DE;
    case r'NDS_NL':
      return Enum$LanguageCodeEnum.NDS_NL;
    case r'NE':
      return Enum$LanguageCodeEnum.NE;
    case r'NE_IN':
      return Enum$LanguageCodeEnum.NE_IN;
    case r'NE_NP':
      return Enum$LanguageCodeEnum.NE_NP;
    case r'NL':
      return Enum$LanguageCodeEnum.NL;
    case r'NL_AW':
      return Enum$LanguageCodeEnum.NL_AW;
    case r'NL_BE':
      return Enum$LanguageCodeEnum.NL_BE;
    case r'NL_BQ':
      return Enum$LanguageCodeEnum.NL_BQ;
    case r'NL_CW':
      return Enum$LanguageCodeEnum.NL_CW;
    case r'NL_NL':
      return Enum$LanguageCodeEnum.NL_NL;
    case r'NL_SR':
      return Enum$LanguageCodeEnum.NL_SR;
    case r'NL_SX':
      return Enum$LanguageCodeEnum.NL_SX;
    case r'NMG':
      return Enum$LanguageCodeEnum.NMG;
    case r'NMG_CM':
      return Enum$LanguageCodeEnum.NMG_CM;
    case r'NN':
      return Enum$LanguageCodeEnum.NN;
    case r'NN_NO':
      return Enum$LanguageCodeEnum.NN_NO;
    case r'NNH':
      return Enum$LanguageCodeEnum.NNH;
    case r'NNH_CM':
      return Enum$LanguageCodeEnum.NNH_CM;
    case r'NUS':
      return Enum$LanguageCodeEnum.NUS;
    case r'NUS_SS':
      return Enum$LanguageCodeEnum.NUS_SS;
    case r'NYN':
      return Enum$LanguageCodeEnum.NYN;
    case r'NYN_UG':
      return Enum$LanguageCodeEnum.NYN_UG;
    case r'OM':
      return Enum$LanguageCodeEnum.OM;
    case r'OM_ET':
      return Enum$LanguageCodeEnum.OM_ET;
    case r'OM_KE':
      return Enum$LanguageCodeEnum.OM_KE;
    case r'OR':
      return Enum$LanguageCodeEnum.OR;
    case r'OR_IN':
      return Enum$LanguageCodeEnum.OR_IN;
    case r'OS':
      return Enum$LanguageCodeEnum.OS;
    case r'OS_GE':
      return Enum$LanguageCodeEnum.OS_GE;
    case r'OS_RU':
      return Enum$LanguageCodeEnum.OS_RU;
    case r'PA':
      return Enum$LanguageCodeEnum.PA;
    case r'PA_ARAB':
      return Enum$LanguageCodeEnum.PA_ARAB;
    case r'PA_ARAB_PK':
      return Enum$LanguageCodeEnum.PA_ARAB_PK;
    case r'PA_GURU':
      return Enum$LanguageCodeEnum.PA_GURU;
    case r'PA_GURU_IN':
      return Enum$LanguageCodeEnum.PA_GURU_IN;
    case r'PCM':
      return Enum$LanguageCodeEnum.PCM;
    case r'PCM_NG':
      return Enum$LanguageCodeEnum.PCM_NG;
    case r'PL':
      return Enum$LanguageCodeEnum.PL;
    case r'PL_PL':
      return Enum$LanguageCodeEnum.PL_PL;
    case r'PRG':
      return Enum$LanguageCodeEnum.PRG;
    case r'PS':
      return Enum$LanguageCodeEnum.PS;
    case r'PS_AF':
      return Enum$LanguageCodeEnum.PS_AF;
    case r'PS_PK':
      return Enum$LanguageCodeEnum.PS_PK;
    case r'PT':
      return Enum$LanguageCodeEnum.PT;
    case r'PT_AO':
      return Enum$LanguageCodeEnum.PT_AO;
    case r'PT_BR':
      return Enum$LanguageCodeEnum.PT_BR;
    case r'PT_CH':
      return Enum$LanguageCodeEnum.PT_CH;
    case r'PT_CV':
      return Enum$LanguageCodeEnum.PT_CV;
    case r'PT_GQ':
      return Enum$LanguageCodeEnum.PT_GQ;
    case r'PT_GW':
      return Enum$LanguageCodeEnum.PT_GW;
    case r'PT_LU':
      return Enum$LanguageCodeEnum.PT_LU;
    case r'PT_MO':
      return Enum$LanguageCodeEnum.PT_MO;
    case r'PT_MZ':
      return Enum$LanguageCodeEnum.PT_MZ;
    case r'PT_PT':
      return Enum$LanguageCodeEnum.PT_PT;
    case r'PT_ST':
      return Enum$LanguageCodeEnum.PT_ST;
    case r'PT_TL':
      return Enum$LanguageCodeEnum.PT_TL;
    case r'QU':
      return Enum$LanguageCodeEnum.QU;
    case r'QU_BO':
      return Enum$LanguageCodeEnum.QU_BO;
    case r'QU_EC':
      return Enum$LanguageCodeEnum.QU_EC;
    case r'QU_PE':
      return Enum$LanguageCodeEnum.QU_PE;
    case r'RM':
      return Enum$LanguageCodeEnum.RM;
    case r'RM_CH':
      return Enum$LanguageCodeEnum.RM_CH;
    case r'RN':
      return Enum$LanguageCodeEnum.RN;
    case r'RN_BI':
      return Enum$LanguageCodeEnum.RN_BI;
    case r'RO':
      return Enum$LanguageCodeEnum.RO;
    case r'RO_MD':
      return Enum$LanguageCodeEnum.RO_MD;
    case r'RO_RO':
      return Enum$LanguageCodeEnum.RO_RO;
    case r'ROF':
      return Enum$LanguageCodeEnum.ROF;
    case r'ROF_TZ':
      return Enum$LanguageCodeEnum.ROF_TZ;
    case r'RU':
      return Enum$LanguageCodeEnum.RU;
    case r'RU_BY':
      return Enum$LanguageCodeEnum.RU_BY;
    case r'RU_KG':
      return Enum$LanguageCodeEnum.RU_KG;
    case r'RU_KZ':
      return Enum$LanguageCodeEnum.RU_KZ;
    case r'RU_MD':
      return Enum$LanguageCodeEnum.RU_MD;
    case r'RU_RU':
      return Enum$LanguageCodeEnum.RU_RU;
    case r'RU_UA':
      return Enum$LanguageCodeEnum.RU_UA;
    case r'RW':
      return Enum$LanguageCodeEnum.RW;
    case r'RW_RW':
      return Enum$LanguageCodeEnum.RW_RW;
    case r'RWK':
      return Enum$LanguageCodeEnum.RWK;
    case r'RWK_TZ':
      return Enum$LanguageCodeEnum.RWK_TZ;
    case r'SAH':
      return Enum$LanguageCodeEnum.SAH;
    case r'SAH_RU':
      return Enum$LanguageCodeEnum.SAH_RU;
    case r'SAQ':
      return Enum$LanguageCodeEnum.SAQ;
    case r'SAQ_KE':
      return Enum$LanguageCodeEnum.SAQ_KE;
    case r'SAT':
      return Enum$LanguageCodeEnum.SAT;
    case r'SAT_OLCK':
      return Enum$LanguageCodeEnum.SAT_OLCK;
    case r'SAT_OLCK_IN':
      return Enum$LanguageCodeEnum.SAT_OLCK_IN;
    case r'SBP':
      return Enum$LanguageCodeEnum.SBP;
    case r'SBP_TZ':
      return Enum$LanguageCodeEnum.SBP_TZ;
    case r'SD':
      return Enum$LanguageCodeEnum.SD;
    case r'SD_ARAB':
      return Enum$LanguageCodeEnum.SD_ARAB;
    case r'SD_ARAB_PK':
      return Enum$LanguageCodeEnum.SD_ARAB_PK;
    case r'SD_DEVA':
      return Enum$LanguageCodeEnum.SD_DEVA;
    case r'SD_DEVA_IN':
      return Enum$LanguageCodeEnum.SD_DEVA_IN;
    case r'SE':
      return Enum$LanguageCodeEnum.SE;
    case r'SE_FI':
      return Enum$LanguageCodeEnum.SE_FI;
    case r'SE_NO':
      return Enum$LanguageCodeEnum.SE_NO;
    case r'SE_SE':
      return Enum$LanguageCodeEnum.SE_SE;
    case r'SEH':
      return Enum$LanguageCodeEnum.SEH;
    case r'SEH_MZ':
      return Enum$LanguageCodeEnum.SEH_MZ;
    case r'SES':
      return Enum$LanguageCodeEnum.SES;
    case r'SES_ML':
      return Enum$LanguageCodeEnum.SES_ML;
    case r'SG':
      return Enum$LanguageCodeEnum.SG;
    case r'SG_CF':
      return Enum$LanguageCodeEnum.SG_CF;
    case r'SHI':
      return Enum$LanguageCodeEnum.SHI;
    case r'SHI_LATN':
      return Enum$LanguageCodeEnum.SHI_LATN;
    case r'SHI_LATN_MA':
      return Enum$LanguageCodeEnum.SHI_LATN_MA;
    case r'SHI_TFNG':
      return Enum$LanguageCodeEnum.SHI_TFNG;
    case r'SHI_TFNG_MA':
      return Enum$LanguageCodeEnum.SHI_TFNG_MA;
    case r'SI':
      return Enum$LanguageCodeEnum.SI;
    case r'SI_LK':
      return Enum$LanguageCodeEnum.SI_LK;
    case r'SK':
      return Enum$LanguageCodeEnum.SK;
    case r'SK_SK':
      return Enum$LanguageCodeEnum.SK_SK;
    case r'SL':
      return Enum$LanguageCodeEnum.SL;
    case r'SL_SI':
      return Enum$LanguageCodeEnum.SL_SI;
    case r'SMN':
      return Enum$LanguageCodeEnum.SMN;
    case r'SMN_FI':
      return Enum$LanguageCodeEnum.SMN_FI;
    case r'SN':
      return Enum$LanguageCodeEnum.SN;
    case r'SN_ZW':
      return Enum$LanguageCodeEnum.SN_ZW;
    case r'SO':
      return Enum$LanguageCodeEnum.SO;
    case r'SO_DJ':
      return Enum$LanguageCodeEnum.SO_DJ;
    case r'SO_ET':
      return Enum$LanguageCodeEnum.SO_ET;
    case r'SO_KE':
      return Enum$LanguageCodeEnum.SO_KE;
    case r'SO_SO':
      return Enum$LanguageCodeEnum.SO_SO;
    case r'SQ':
      return Enum$LanguageCodeEnum.SQ;
    case r'SQ_AL':
      return Enum$LanguageCodeEnum.SQ_AL;
    case r'SQ_MK':
      return Enum$LanguageCodeEnum.SQ_MK;
    case r'SQ_XK':
      return Enum$LanguageCodeEnum.SQ_XK;
    case r'SR':
      return Enum$LanguageCodeEnum.SR;
    case r'SR_CYRL':
      return Enum$LanguageCodeEnum.SR_CYRL;
    case r'SR_CYRL_BA':
      return Enum$LanguageCodeEnum.SR_CYRL_BA;
    case r'SR_CYRL_ME':
      return Enum$LanguageCodeEnum.SR_CYRL_ME;
    case r'SR_CYRL_RS':
      return Enum$LanguageCodeEnum.SR_CYRL_RS;
    case r'SR_CYRL_XK':
      return Enum$LanguageCodeEnum.SR_CYRL_XK;
    case r'SR_LATN':
      return Enum$LanguageCodeEnum.SR_LATN;
    case r'SR_LATN_BA':
      return Enum$LanguageCodeEnum.SR_LATN_BA;
    case r'SR_LATN_ME':
      return Enum$LanguageCodeEnum.SR_LATN_ME;
    case r'SR_LATN_RS':
      return Enum$LanguageCodeEnum.SR_LATN_RS;
    case r'SR_LATN_XK':
      return Enum$LanguageCodeEnum.SR_LATN_XK;
    case r'SU':
      return Enum$LanguageCodeEnum.SU;
    case r'SU_LATN':
      return Enum$LanguageCodeEnum.SU_LATN;
    case r'SU_LATN_ID':
      return Enum$LanguageCodeEnum.SU_LATN_ID;
    case r'SV':
      return Enum$LanguageCodeEnum.SV;
    case r'SV_AX':
      return Enum$LanguageCodeEnum.SV_AX;
    case r'SV_FI':
      return Enum$LanguageCodeEnum.SV_FI;
    case r'SV_SE':
      return Enum$LanguageCodeEnum.SV_SE;
    case r'SW':
      return Enum$LanguageCodeEnum.SW;
    case r'SW_CD':
      return Enum$LanguageCodeEnum.SW_CD;
    case r'SW_KE':
      return Enum$LanguageCodeEnum.SW_KE;
    case r'SW_TZ':
      return Enum$LanguageCodeEnum.SW_TZ;
    case r'SW_UG':
      return Enum$LanguageCodeEnum.SW_UG;
    case r'TA':
      return Enum$LanguageCodeEnum.TA;
    case r'TA_IN':
      return Enum$LanguageCodeEnum.TA_IN;
    case r'TA_LK':
      return Enum$LanguageCodeEnum.TA_LK;
    case r'TA_MY':
      return Enum$LanguageCodeEnum.TA_MY;
    case r'TA_SG':
      return Enum$LanguageCodeEnum.TA_SG;
    case r'TE':
      return Enum$LanguageCodeEnum.TE;
    case r'TE_IN':
      return Enum$LanguageCodeEnum.TE_IN;
    case r'TEO':
      return Enum$LanguageCodeEnum.TEO;
    case r'TEO_KE':
      return Enum$LanguageCodeEnum.TEO_KE;
    case r'TEO_UG':
      return Enum$LanguageCodeEnum.TEO_UG;
    case r'TG':
      return Enum$LanguageCodeEnum.TG;
    case r'TG_TJ':
      return Enum$LanguageCodeEnum.TG_TJ;
    case r'TH':
      return Enum$LanguageCodeEnum.TH;
    case r'TH_TH':
      return Enum$LanguageCodeEnum.TH_TH;
    case r'TI':
      return Enum$LanguageCodeEnum.TI;
    case r'TI_ER':
      return Enum$LanguageCodeEnum.TI_ER;
    case r'TI_ET':
      return Enum$LanguageCodeEnum.TI_ET;
    case r'TK':
      return Enum$LanguageCodeEnum.TK;
    case r'TK_TM':
      return Enum$LanguageCodeEnum.TK_TM;
    case r'TO':
      return Enum$LanguageCodeEnum.TO;
    case r'TO_TO':
      return Enum$LanguageCodeEnum.TO_TO;
    case r'TR':
      return Enum$LanguageCodeEnum.TR;
    case r'TR_CY':
      return Enum$LanguageCodeEnum.TR_CY;
    case r'TR_TR':
      return Enum$LanguageCodeEnum.TR_TR;
    case r'TT':
      return Enum$LanguageCodeEnum.TT;
    case r'TT_RU':
      return Enum$LanguageCodeEnum.TT_RU;
    case r'TWQ':
      return Enum$LanguageCodeEnum.TWQ;
    case r'TWQ_NE':
      return Enum$LanguageCodeEnum.TWQ_NE;
    case r'TZM':
      return Enum$LanguageCodeEnum.TZM;
    case r'TZM_MA':
      return Enum$LanguageCodeEnum.TZM_MA;
    case r'UG':
      return Enum$LanguageCodeEnum.UG;
    case r'UG_CN':
      return Enum$LanguageCodeEnum.UG_CN;
    case r'UK':
      return Enum$LanguageCodeEnum.UK;
    case r'UK_UA':
      return Enum$LanguageCodeEnum.UK_UA;
    case r'UR':
      return Enum$LanguageCodeEnum.UR;
    case r'UR_IN':
      return Enum$LanguageCodeEnum.UR_IN;
    case r'UR_PK':
      return Enum$LanguageCodeEnum.UR_PK;
    case r'UZ':
      return Enum$LanguageCodeEnum.UZ;
    case r'UZ_ARAB':
      return Enum$LanguageCodeEnum.UZ_ARAB;
    case r'UZ_ARAB_AF':
      return Enum$LanguageCodeEnum.UZ_ARAB_AF;
    case r'UZ_CYRL':
      return Enum$LanguageCodeEnum.UZ_CYRL;
    case r'UZ_CYRL_UZ':
      return Enum$LanguageCodeEnum.UZ_CYRL_UZ;
    case r'UZ_LATN':
      return Enum$LanguageCodeEnum.UZ_LATN;
    case r'UZ_LATN_UZ':
      return Enum$LanguageCodeEnum.UZ_LATN_UZ;
    case r'VAI':
      return Enum$LanguageCodeEnum.VAI;
    case r'VAI_LATN':
      return Enum$LanguageCodeEnum.VAI_LATN;
    case r'VAI_LATN_LR':
      return Enum$LanguageCodeEnum.VAI_LATN_LR;
    case r'VAI_VAII':
      return Enum$LanguageCodeEnum.VAI_VAII;
    case r'VAI_VAII_LR':
      return Enum$LanguageCodeEnum.VAI_VAII_LR;
    case r'VI':
      return Enum$LanguageCodeEnum.VI;
    case r'VI_VN':
      return Enum$LanguageCodeEnum.VI_VN;
    case r'VO':
      return Enum$LanguageCodeEnum.VO;
    case r'VUN':
      return Enum$LanguageCodeEnum.VUN;
    case r'VUN_TZ':
      return Enum$LanguageCodeEnum.VUN_TZ;
    case r'WAE':
      return Enum$LanguageCodeEnum.WAE;
    case r'WAE_CH':
      return Enum$LanguageCodeEnum.WAE_CH;
    case r'WO':
      return Enum$LanguageCodeEnum.WO;
    case r'WO_SN':
      return Enum$LanguageCodeEnum.WO_SN;
    case r'XH':
      return Enum$LanguageCodeEnum.XH;
    case r'XH_ZA':
      return Enum$LanguageCodeEnum.XH_ZA;
    case r'XOG':
      return Enum$LanguageCodeEnum.XOG;
    case r'XOG_UG':
      return Enum$LanguageCodeEnum.XOG_UG;
    case r'YAV':
      return Enum$LanguageCodeEnum.YAV;
    case r'YAV_CM':
      return Enum$LanguageCodeEnum.YAV_CM;
    case r'YI':
      return Enum$LanguageCodeEnum.YI;
    case r'YO':
      return Enum$LanguageCodeEnum.YO;
    case r'YO_BJ':
      return Enum$LanguageCodeEnum.YO_BJ;
    case r'YO_NG':
      return Enum$LanguageCodeEnum.YO_NG;
    case r'YUE':
      return Enum$LanguageCodeEnum.YUE;
    case r'YUE_HANS':
      return Enum$LanguageCodeEnum.YUE_HANS;
    case r'YUE_HANS_CN':
      return Enum$LanguageCodeEnum.YUE_HANS_CN;
    case r'YUE_HANT':
      return Enum$LanguageCodeEnum.YUE_HANT;
    case r'YUE_HANT_HK':
      return Enum$LanguageCodeEnum.YUE_HANT_HK;
    case r'ZGH':
      return Enum$LanguageCodeEnum.ZGH;
    case r'ZGH_MA':
      return Enum$LanguageCodeEnum.ZGH_MA;
    case r'ZH':
      return Enum$LanguageCodeEnum.ZH;
    case r'ZH_HANS':
      return Enum$LanguageCodeEnum.ZH_HANS;
    case r'ZH_HANS_CN':
      return Enum$LanguageCodeEnum.ZH_HANS_CN;
    case r'ZH_HANS_HK':
      return Enum$LanguageCodeEnum.ZH_HANS_HK;
    case r'ZH_HANS_MO':
      return Enum$LanguageCodeEnum.ZH_HANS_MO;
    case r'ZH_HANS_SG':
      return Enum$LanguageCodeEnum.ZH_HANS_SG;
    case r'ZH_HANT':
      return Enum$LanguageCodeEnum.ZH_HANT;
    case r'ZH_HANT_HK':
      return Enum$LanguageCodeEnum.ZH_HANT_HK;
    case r'ZH_HANT_MO':
      return Enum$LanguageCodeEnum.ZH_HANT_MO;
    case r'ZH_HANT_TW':
      return Enum$LanguageCodeEnum.ZH_HANT_TW;
    case r'ZU':
      return Enum$LanguageCodeEnum.ZU;
    case r'ZU_ZA':
      return Enum$LanguageCodeEnum.ZU_ZA;
    default:
      return Enum$LanguageCodeEnum.$unknown;
  }
}

enum Enum$MarkAsPaidStrategyEnum {
  TRANSACTION_FLOW,
  PAYMENT_FLOW,
  $unknown;

  factory Enum$MarkAsPaidStrategyEnum.fromJson(String value) =>
      fromJson$Enum$MarkAsPaidStrategyEnum(value);

  String toJson() => toJson$Enum$MarkAsPaidStrategyEnum(this);
}

String toJson$Enum$MarkAsPaidStrategyEnum(Enum$MarkAsPaidStrategyEnum e) {
  switch (e) {
    case Enum$MarkAsPaidStrategyEnum.TRANSACTION_FLOW:
      return r'TRANSACTION_FLOW';
    case Enum$MarkAsPaidStrategyEnum.PAYMENT_FLOW:
      return r'PAYMENT_FLOW';
    case Enum$MarkAsPaidStrategyEnum.$unknown:
      return r'$unknown';
  }
}

Enum$MarkAsPaidStrategyEnum fromJson$Enum$MarkAsPaidStrategyEnum(String value) {
  switch (value) {
    case r'TRANSACTION_FLOW':
      return Enum$MarkAsPaidStrategyEnum.TRANSACTION_FLOW;
    case r'PAYMENT_FLOW':
      return Enum$MarkAsPaidStrategyEnum.PAYMENT_FLOW;
    default:
      return Enum$MarkAsPaidStrategyEnum.$unknown;
  }
}

enum Enum$MeasurementUnitsEnum {
  MM,
  CM,
  DM,
  M,
  KM,
  FT,
  YD,
  INCH,
  SQ_MM,
  SQ_CM,
  SQ_DM,
  SQ_M,
  SQ_KM,
  SQ_FT,
  SQ_YD,
  SQ_INCH,
  CUBIC_MILLIMETER,
  CUBIC_CENTIMETER,
  CUBIC_DECIMETER,
  CUBIC_METER,
  LITER,
  CUBIC_FOOT,
  CUBIC_INCH,
  CUBIC_YARD,
  QT,
  PINT,
  FL_OZ,
  ACRE_IN,
  ACRE_FT,
  G,
  LB,
  OZ,
  KG,
  TONNE,
  $unknown;

  factory Enum$MeasurementUnitsEnum.fromJson(String value) =>
      fromJson$Enum$MeasurementUnitsEnum(value);

  String toJson() => toJson$Enum$MeasurementUnitsEnum(this);
}

String toJson$Enum$MeasurementUnitsEnum(Enum$MeasurementUnitsEnum e) {
  switch (e) {
    case Enum$MeasurementUnitsEnum.MM:
      return r'MM';
    case Enum$MeasurementUnitsEnum.CM:
      return r'CM';
    case Enum$MeasurementUnitsEnum.DM:
      return r'DM';
    case Enum$MeasurementUnitsEnum.M:
      return r'M';
    case Enum$MeasurementUnitsEnum.KM:
      return r'KM';
    case Enum$MeasurementUnitsEnum.FT:
      return r'FT';
    case Enum$MeasurementUnitsEnum.YD:
      return r'YD';
    case Enum$MeasurementUnitsEnum.INCH:
      return r'INCH';
    case Enum$MeasurementUnitsEnum.SQ_MM:
      return r'SQ_MM';
    case Enum$MeasurementUnitsEnum.SQ_CM:
      return r'SQ_CM';
    case Enum$MeasurementUnitsEnum.SQ_DM:
      return r'SQ_DM';
    case Enum$MeasurementUnitsEnum.SQ_M:
      return r'SQ_M';
    case Enum$MeasurementUnitsEnum.SQ_KM:
      return r'SQ_KM';
    case Enum$MeasurementUnitsEnum.SQ_FT:
      return r'SQ_FT';
    case Enum$MeasurementUnitsEnum.SQ_YD:
      return r'SQ_YD';
    case Enum$MeasurementUnitsEnum.SQ_INCH:
      return r'SQ_INCH';
    case Enum$MeasurementUnitsEnum.CUBIC_MILLIMETER:
      return r'CUBIC_MILLIMETER';
    case Enum$MeasurementUnitsEnum.CUBIC_CENTIMETER:
      return r'CUBIC_CENTIMETER';
    case Enum$MeasurementUnitsEnum.CUBIC_DECIMETER:
      return r'CUBIC_DECIMETER';
    case Enum$MeasurementUnitsEnum.CUBIC_METER:
      return r'CUBIC_METER';
    case Enum$MeasurementUnitsEnum.LITER:
      return r'LITER';
    case Enum$MeasurementUnitsEnum.CUBIC_FOOT:
      return r'CUBIC_FOOT';
    case Enum$MeasurementUnitsEnum.CUBIC_INCH:
      return r'CUBIC_INCH';
    case Enum$MeasurementUnitsEnum.CUBIC_YARD:
      return r'CUBIC_YARD';
    case Enum$MeasurementUnitsEnum.QT:
      return r'QT';
    case Enum$MeasurementUnitsEnum.PINT:
      return r'PINT';
    case Enum$MeasurementUnitsEnum.FL_OZ:
      return r'FL_OZ';
    case Enum$MeasurementUnitsEnum.ACRE_IN:
      return r'ACRE_IN';
    case Enum$MeasurementUnitsEnum.ACRE_FT:
      return r'ACRE_FT';
    case Enum$MeasurementUnitsEnum.G:
      return r'G';
    case Enum$MeasurementUnitsEnum.LB:
      return r'LB';
    case Enum$MeasurementUnitsEnum.OZ:
      return r'OZ';
    case Enum$MeasurementUnitsEnum.KG:
      return r'KG';
    case Enum$MeasurementUnitsEnum.TONNE:
      return r'TONNE';
    case Enum$MeasurementUnitsEnum.$unknown:
      return r'$unknown';
  }
}

Enum$MeasurementUnitsEnum fromJson$Enum$MeasurementUnitsEnum(String value) {
  switch (value) {
    case r'MM':
      return Enum$MeasurementUnitsEnum.MM;
    case r'CM':
      return Enum$MeasurementUnitsEnum.CM;
    case r'DM':
      return Enum$MeasurementUnitsEnum.DM;
    case r'M':
      return Enum$MeasurementUnitsEnum.M;
    case r'KM':
      return Enum$MeasurementUnitsEnum.KM;
    case r'FT':
      return Enum$MeasurementUnitsEnum.FT;
    case r'YD':
      return Enum$MeasurementUnitsEnum.YD;
    case r'INCH':
      return Enum$MeasurementUnitsEnum.INCH;
    case r'SQ_MM':
      return Enum$MeasurementUnitsEnum.SQ_MM;
    case r'SQ_CM':
      return Enum$MeasurementUnitsEnum.SQ_CM;
    case r'SQ_DM':
      return Enum$MeasurementUnitsEnum.SQ_DM;
    case r'SQ_M':
      return Enum$MeasurementUnitsEnum.SQ_M;
    case r'SQ_KM':
      return Enum$MeasurementUnitsEnum.SQ_KM;
    case r'SQ_FT':
      return Enum$MeasurementUnitsEnum.SQ_FT;
    case r'SQ_YD':
      return Enum$MeasurementUnitsEnum.SQ_YD;
    case r'SQ_INCH':
      return Enum$MeasurementUnitsEnum.SQ_INCH;
    case r'CUBIC_MILLIMETER':
      return Enum$MeasurementUnitsEnum.CUBIC_MILLIMETER;
    case r'CUBIC_CENTIMETER':
      return Enum$MeasurementUnitsEnum.CUBIC_CENTIMETER;
    case r'CUBIC_DECIMETER':
      return Enum$MeasurementUnitsEnum.CUBIC_DECIMETER;
    case r'CUBIC_METER':
      return Enum$MeasurementUnitsEnum.CUBIC_METER;
    case r'LITER':
      return Enum$MeasurementUnitsEnum.LITER;
    case r'CUBIC_FOOT':
      return Enum$MeasurementUnitsEnum.CUBIC_FOOT;
    case r'CUBIC_INCH':
      return Enum$MeasurementUnitsEnum.CUBIC_INCH;
    case r'CUBIC_YARD':
      return Enum$MeasurementUnitsEnum.CUBIC_YARD;
    case r'QT':
      return Enum$MeasurementUnitsEnum.QT;
    case r'PINT':
      return Enum$MeasurementUnitsEnum.PINT;
    case r'FL_OZ':
      return Enum$MeasurementUnitsEnum.FL_OZ;
    case r'ACRE_IN':
      return Enum$MeasurementUnitsEnum.ACRE_IN;
    case r'ACRE_FT':
      return Enum$MeasurementUnitsEnum.ACRE_FT;
    case r'G':
      return Enum$MeasurementUnitsEnum.G;
    case r'LB':
      return Enum$MeasurementUnitsEnum.LB;
    case r'OZ':
      return Enum$MeasurementUnitsEnum.OZ;
    case r'KG':
      return Enum$MeasurementUnitsEnum.KG;
    case r'TONNE':
      return Enum$MeasurementUnitsEnum.TONNE;
    default:
      return Enum$MeasurementUnitsEnum.$unknown;
  }
}

enum Enum$MediaChoicesSortField {
  ID,
  $unknown;

  factory Enum$MediaChoicesSortField.fromJson(String value) =>
      fromJson$Enum$MediaChoicesSortField(value);

  String toJson() => toJson$Enum$MediaChoicesSortField(this);
}

String toJson$Enum$MediaChoicesSortField(Enum$MediaChoicesSortField e) {
  switch (e) {
    case Enum$MediaChoicesSortField.ID:
      return r'ID';
    case Enum$MediaChoicesSortField.$unknown:
      return r'$unknown';
  }
}

Enum$MediaChoicesSortField fromJson$Enum$MediaChoicesSortField(String value) {
  switch (value) {
    case r'ID':
      return Enum$MediaChoicesSortField.ID;
    default:
      return Enum$MediaChoicesSortField.$unknown;
  }
}

enum Enum$MenuErrorCode {
  CANNOT_ASSIGN_NODE,
  GRAPHQL_ERROR,
  INVALID,
  INVALID_MENU_ITEM,
  NO_MENU_ITEM_PROVIDED,
  NOT_FOUND,
  REQUIRED,
  TOO_MANY_MENU_ITEMS,
  UNIQUE,
  $unknown;

  factory Enum$MenuErrorCode.fromJson(String value) =>
      fromJson$Enum$MenuErrorCode(value);

  String toJson() => toJson$Enum$MenuErrorCode(this);
}

String toJson$Enum$MenuErrorCode(Enum$MenuErrorCode e) {
  switch (e) {
    case Enum$MenuErrorCode.CANNOT_ASSIGN_NODE:
      return r'CANNOT_ASSIGN_NODE';
    case Enum$MenuErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$MenuErrorCode.INVALID:
      return r'INVALID';
    case Enum$MenuErrorCode.INVALID_MENU_ITEM:
      return r'INVALID_MENU_ITEM';
    case Enum$MenuErrorCode.NO_MENU_ITEM_PROVIDED:
      return r'NO_MENU_ITEM_PROVIDED';
    case Enum$MenuErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$MenuErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$MenuErrorCode.TOO_MANY_MENU_ITEMS:
      return r'TOO_MANY_MENU_ITEMS';
    case Enum$MenuErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$MenuErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$MenuErrorCode fromJson$Enum$MenuErrorCode(String value) {
  switch (value) {
    case r'CANNOT_ASSIGN_NODE':
      return Enum$MenuErrorCode.CANNOT_ASSIGN_NODE;
    case r'GRAPHQL_ERROR':
      return Enum$MenuErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$MenuErrorCode.INVALID;
    case r'INVALID_MENU_ITEM':
      return Enum$MenuErrorCode.INVALID_MENU_ITEM;
    case r'NO_MENU_ITEM_PROVIDED':
      return Enum$MenuErrorCode.NO_MENU_ITEM_PROVIDED;
    case r'NOT_FOUND':
      return Enum$MenuErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$MenuErrorCode.REQUIRED;
    case r'TOO_MANY_MENU_ITEMS':
      return Enum$MenuErrorCode.TOO_MANY_MENU_ITEMS;
    case r'UNIQUE':
      return Enum$MenuErrorCode.UNIQUE;
    default:
      return Enum$MenuErrorCode.$unknown;
  }
}

enum Enum$MenuItemsSortField {
  NAME,
  $unknown;

  factory Enum$MenuItemsSortField.fromJson(String value) =>
      fromJson$Enum$MenuItemsSortField(value);

  String toJson() => toJson$Enum$MenuItemsSortField(this);
}

String toJson$Enum$MenuItemsSortField(Enum$MenuItemsSortField e) {
  switch (e) {
    case Enum$MenuItemsSortField.NAME:
      return r'NAME';
    case Enum$MenuItemsSortField.$unknown:
      return r'$unknown';
  }
}

Enum$MenuItemsSortField fromJson$Enum$MenuItemsSortField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$MenuItemsSortField.NAME;
    default:
      return Enum$MenuItemsSortField.$unknown;
  }
}

enum Enum$MenuSortField {
  NAME,
  ITEMS_COUNT,
  $unknown;

  factory Enum$MenuSortField.fromJson(String value) =>
      fromJson$Enum$MenuSortField(value);

  String toJson() => toJson$Enum$MenuSortField(this);
}

String toJson$Enum$MenuSortField(Enum$MenuSortField e) {
  switch (e) {
    case Enum$MenuSortField.NAME:
      return r'NAME';
    case Enum$MenuSortField.ITEMS_COUNT:
      return r'ITEMS_COUNT';
    case Enum$MenuSortField.$unknown:
      return r'$unknown';
  }
}

Enum$MenuSortField fromJson$Enum$MenuSortField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$MenuSortField.NAME;
    case r'ITEMS_COUNT':
      return Enum$MenuSortField.ITEMS_COUNT;
    default:
      return Enum$MenuSortField.$unknown;
  }
}

enum Enum$MetadataErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  NOT_UPDATED,
  $unknown;

  factory Enum$MetadataErrorCode.fromJson(String value) =>
      fromJson$Enum$MetadataErrorCode(value);

  String toJson() => toJson$Enum$MetadataErrorCode(this);
}

String toJson$Enum$MetadataErrorCode(Enum$MetadataErrorCode e) {
  switch (e) {
    case Enum$MetadataErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$MetadataErrorCode.INVALID:
      return r'INVALID';
    case Enum$MetadataErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$MetadataErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$MetadataErrorCode.NOT_UPDATED:
      return r'NOT_UPDATED';
    case Enum$MetadataErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$MetadataErrorCode fromJson$Enum$MetadataErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$MetadataErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$MetadataErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$MetadataErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$MetadataErrorCode.REQUIRED;
    case r'NOT_UPDATED':
      return Enum$MetadataErrorCode.NOT_UPDATED;
    default:
      return Enum$MetadataErrorCode.$unknown;
  }
}

enum Enum$NavigationType {
  MAIN,
  SECONDARY,
  $unknown;

  factory Enum$NavigationType.fromJson(String value) =>
      fromJson$Enum$NavigationType(value);

  String toJson() => toJson$Enum$NavigationType(this);
}

String toJson$Enum$NavigationType(Enum$NavigationType e) {
  switch (e) {
    case Enum$NavigationType.MAIN:
      return r'MAIN';
    case Enum$NavigationType.SECONDARY:
      return r'SECONDARY';
    case Enum$NavigationType.$unknown:
      return r'$unknown';
  }
}

Enum$NavigationType fromJson$Enum$NavigationType(String value) {
  switch (value) {
    case r'MAIN':
      return Enum$NavigationType.MAIN;
    case r'SECONDARY':
      return Enum$NavigationType.SECONDARY;
    default:
      return Enum$NavigationType.$unknown;
  }
}

enum Enum$OrderAction {
  CAPTURE,
  MARK_AS_PAID,
  REFUND,
  VOID,
  $unknown;

  factory Enum$OrderAction.fromJson(String value) =>
      fromJson$Enum$OrderAction(value);

  String toJson() => toJson$Enum$OrderAction(this);
}

String toJson$Enum$OrderAction(Enum$OrderAction e) {
  switch (e) {
    case Enum$OrderAction.CAPTURE:
      return r'CAPTURE';
    case Enum$OrderAction.MARK_AS_PAID:
      return r'MARK_AS_PAID';
    case Enum$OrderAction.REFUND:
      return r'REFUND';
    case Enum$OrderAction.VOID:
      return r'VOID';
    case Enum$OrderAction.$unknown:
      return r'$unknown';
  }
}

Enum$OrderAction fromJson$Enum$OrderAction(String value) {
  switch (value) {
    case r'CAPTURE':
      return Enum$OrderAction.CAPTURE;
    case r'MARK_AS_PAID':
      return Enum$OrderAction.MARK_AS_PAID;
    case r'REFUND':
      return Enum$OrderAction.REFUND;
    case r'VOID':
      return Enum$OrderAction.VOID;
    default:
      return Enum$OrderAction.$unknown;
  }
}

enum Enum$OrderAuthorizeStatusEnum {
  NONE,
  PARTIAL,
  FULL,
  $unknown;

  factory Enum$OrderAuthorizeStatusEnum.fromJson(String value) =>
      fromJson$Enum$OrderAuthorizeStatusEnum(value);

  String toJson() => toJson$Enum$OrderAuthorizeStatusEnum(this);
}

String toJson$Enum$OrderAuthorizeStatusEnum(Enum$OrderAuthorizeStatusEnum e) {
  switch (e) {
    case Enum$OrderAuthorizeStatusEnum.NONE:
      return r'NONE';
    case Enum$OrderAuthorizeStatusEnum.PARTIAL:
      return r'PARTIAL';
    case Enum$OrderAuthorizeStatusEnum.FULL:
      return r'FULL';
    case Enum$OrderAuthorizeStatusEnum.$unknown:
      return r'$unknown';
  }
}

Enum$OrderAuthorizeStatusEnum fromJson$Enum$OrderAuthorizeStatusEnum(
    String value) {
  switch (value) {
    case r'NONE':
      return Enum$OrderAuthorizeStatusEnum.NONE;
    case r'PARTIAL':
      return Enum$OrderAuthorizeStatusEnum.PARTIAL;
    case r'FULL':
      return Enum$OrderAuthorizeStatusEnum.FULL;
    default:
      return Enum$OrderAuthorizeStatusEnum.$unknown;
  }
}

enum Enum$OrderBulkCreateErrorCode {
  GRAPHQL_ERROR,
  REQUIRED,
  INVALID,
  NOT_FOUND,
  UNIQUE,
  BULK_LIMIT,
  TOO_MANY_IDENTIFIERS,
  FUTURE_DATE,
  INVALID_QUANTITY,
  PRICE_ERROR,
  NOTE_LENGTH,
  INSUFFICIENT_STOCK,
  NON_EXISTING_STOCK,
  NO_RELATED_ORDER_LINE,
  NEGATIVE_INDEX,
  ORDER_LINE_FULFILLMENT_LINE_MISMATCH,
  METADATA_KEY_REQUIRED,
  INCORRECT_CURRENCY,
  $unknown;

  factory Enum$OrderBulkCreateErrorCode.fromJson(String value) =>
      fromJson$Enum$OrderBulkCreateErrorCode(value);

  String toJson() => toJson$Enum$OrderBulkCreateErrorCode(this);
}

String toJson$Enum$OrderBulkCreateErrorCode(Enum$OrderBulkCreateErrorCode e) {
  switch (e) {
    case Enum$OrderBulkCreateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$OrderBulkCreateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$OrderBulkCreateErrorCode.INVALID:
      return r'INVALID';
    case Enum$OrderBulkCreateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$OrderBulkCreateErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$OrderBulkCreateErrorCode.BULK_LIMIT:
      return r'BULK_LIMIT';
    case Enum$OrderBulkCreateErrorCode.TOO_MANY_IDENTIFIERS:
      return r'TOO_MANY_IDENTIFIERS';
    case Enum$OrderBulkCreateErrorCode.FUTURE_DATE:
      return r'FUTURE_DATE';
    case Enum$OrderBulkCreateErrorCode.INVALID_QUANTITY:
      return r'INVALID_QUANTITY';
    case Enum$OrderBulkCreateErrorCode.PRICE_ERROR:
      return r'PRICE_ERROR';
    case Enum$OrderBulkCreateErrorCode.NOTE_LENGTH:
      return r'NOTE_LENGTH';
    case Enum$OrderBulkCreateErrorCode.INSUFFICIENT_STOCK:
      return r'INSUFFICIENT_STOCK';
    case Enum$OrderBulkCreateErrorCode.NON_EXISTING_STOCK:
      return r'NON_EXISTING_STOCK';
    case Enum$OrderBulkCreateErrorCode.NO_RELATED_ORDER_LINE:
      return r'NO_RELATED_ORDER_LINE';
    case Enum$OrderBulkCreateErrorCode.NEGATIVE_INDEX:
      return r'NEGATIVE_INDEX';
    case Enum$OrderBulkCreateErrorCode.ORDER_LINE_FULFILLMENT_LINE_MISMATCH:
      return r'ORDER_LINE_FULFILLMENT_LINE_MISMATCH';
    case Enum$OrderBulkCreateErrorCode.METADATA_KEY_REQUIRED:
      return r'METADATA_KEY_REQUIRED';
    case Enum$OrderBulkCreateErrorCode.INCORRECT_CURRENCY:
      return r'INCORRECT_CURRENCY';
    case Enum$OrderBulkCreateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$OrderBulkCreateErrorCode fromJson$Enum$OrderBulkCreateErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$OrderBulkCreateErrorCode.GRAPHQL_ERROR;
    case r'REQUIRED':
      return Enum$OrderBulkCreateErrorCode.REQUIRED;
    case r'INVALID':
      return Enum$OrderBulkCreateErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$OrderBulkCreateErrorCode.NOT_FOUND;
    case r'UNIQUE':
      return Enum$OrderBulkCreateErrorCode.UNIQUE;
    case r'BULK_LIMIT':
      return Enum$OrderBulkCreateErrorCode.BULK_LIMIT;
    case r'TOO_MANY_IDENTIFIERS':
      return Enum$OrderBulkCreateErrorCode.TOO_MANY_IDENTIFIERS;
    case r'FUTURE_DATE':
      return Enum$OrderBulkCreateErrorCode.FUTURE_DATE;
    case r'INVALID_QUANTITY':
      return Enum$OrderBulkCreateErrorCode.INVALID_QUANTITY;
    case r'PRICE_ERROR':
      return Enum$OrderBulkCreateErrorCode.PRICE_ERROR;
    case r'NOTE_LENGTH':
      return Enum$OrderBulkCreateErrorCode.NOTE_LENGTH;
    case r'INSUFFICIENT_STOCK':
      return Enum$OrderBulkCreateErrorCode.INSUFFICIENT_STOCK;
    case r'NON_EXISTING_STOCK':
      return Enum$OrderBulkCreateErrorCode.NON_EXISTING_STOCK;
    case r'NO_RELATED_ORDER_LINE':
      return Enum$OrderBulkCreateErrorCode.NO_RELATED_ORDER_LINE;
    case r'NEGATIVE_INDEX':
      return Enum$OrderBulkCreateErrorCode.NEGATIVE_INDEX;
    case r'ORDER_LINE_FULFILLMENT_LINE_MISMATCH':
      return Enum$OrderBulkCreateErrorCode.ORDER_LINE_FULFILLMENT_LINE_MISMATCH;
    case r'METADATA_KEY_REQUIRED':
      return Enum$OrderBulkCreateErrorCode.METADATA_KEY_REQUIRED;
    case r'INCORRECT_CURRENCY':
      return Enum$OrderBulkCreateErrorCode.INCORRECT_CURRENCY;
    default:
      return Enum$OrderBulkCreateErrorCode.$unknown;
  }
}

enum Enum$OrderChargeStatusEnum {
  NONE,
  PARTIAL,
  FULL,
  OVERCHARGED,
  $unknown;

  factory Enum$OrderChargeStatusEnum.fromJson(String value) =>
      fromJson$Enum$OrderChargeStatusEnum(value);

  String toJson() => toJson$Enum$OrderChargeStatusEnum(this);
}

String toJson$Enum$OrderChargeStatusEnum(Enum$OrderChargeStatusEnum e) {
  switch (e) {
    case Enum$OrderChargeStatusEnum.NONE:
      return r'NONE';
    case Enum$OrderChargeStatusEnum.PARTIAL:
      return r'PARTIAL';
    case Enum$OrderChargeStatusEnum.FULL:
      return r'FULL';
    case Enum$OrderChargeStatusEnum.OVERCHARGED:
      return r'OVERCHARGED';
    case Enum$OrderChargeStatusEnum.$unknown:
      return r'$unknown';
  }
}

Enum$OrderChargeStatusEnum fromJson$Enum$OrderChargeStatusEnum(String value) {
  switch (value) {
    case r'NONE':
      return Enum$OrderChargeStatusEnum.NONE;
    case r'PARTIAL':
      return Enum$OrderChargeStatusEnum.PARTIAL;
    case r'FULL':
      return Enum$OrderChargeStatusEnum.FULL;
    case r'OVERCHARGED':
      return Enum$OrderChargeStatusEnum.OVERCHARGED;
    default:
      return Enum$OrderChargeStatusEnum.$unknown;
  }
}

enum Enum$OrderCreateFromCheckoutErrorCode {
  GRAPHQL_ERROR,
  CHECKOUT_NOT_FOUND,
  CHANNEL_INACTIVE,
  INSUFFICIENT_STOCK,
  VOUCHER_NOT_APPLICABLE,
  GIFT_CARD_NOT_APPLICABLE,
  TAX_ERROR,
  SHIPPING_METHOD_NOT_SET,
  BILLING_ADDRESS_NOT_SET,
  SHIPPING_ADDRESS_NOT_SET,
  INVALID_SHIPPING_METHOD,
  NO_LINES,
  EMAIL_NOT_SET,
  UNAVAILABLE_VARIANT_IN_CHANNEL,
  $unknown;

  factory Enum$OrderCreateFromCheckoutErrorCode.fromJson(String value) =>
      fromJson$Enum$OrderCreateFromCheckoutErrorCode(value);

  String toJson() => toJson$Enum$OrderCreateFromCheckoutErrorCode(this);
}

String toJson$Enum$OrderCreateFromCheckoutErrorCode(
    Enum$OrderCreateFromCheckoutErrorCode e) {
  switch (e) {
    case Enum$OrderCreateFromCheckoutErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$OrderCreateFromCheckoutErrorCode.CHECKOUT_NOT_FOUND:
      return r'CHECKOUT_NOT_FOUND';
    case Enum$OrderCreateFromCheckoutErrorCode.CHANNEL_INACTIVE:
      return r'CHANNEL_INACTIVE';
    case Enum$OrderCreateFromCheckoutErrorCode.INSUFFICIENT_STOCK:
      return r'INSUFFICIENT_STOCK';
    case Enum$OrderCreateFromCheckoutErrorCode.VOUCHER_NOT_APPLICABLE:
      return r'VOUCHER_NOT_APPLICABLE';
    case Enum$OrderCreateFromCheckoutErrorCode.GIFT_CARD_NOT_APPLICABLE:
      return r'GIFT_CARD_NOT_APPLICABLE';
    case Enum$OrderCreateFromCheckoutErrorCode.TAX_ERROR:
      return r'TAX_ERROR';
    case Enum$OrderCreateFromCheckoutErrorCode.SHIPPING_METHOD_NOT_SET:
      return r'SHIPPING_METHOD_NOT_SET';
    case Enum$OrderCreateFromCheckoutErrorCode.BILLING_ADDRESS_NOT_SET:
      return r'BILLING_ADDRESS_NOT_SET';
    case Enum$OrderCreateFromCheckoutErrorCode.SHIPPING_ADDRESS_NOT_SET:
      return r'SHIPPING_ADDRESS_NOT_SET';
    case Enum$OrderCreateFromCheckoutErrorCode.INVALID_SHIPPING_METHOD:
      return r'INVALID_SHIPPING_METHOD';
    case Enum$OrderCreateFromCheckoutErrorCode.NO_LINES:
      return r'NO_LINES';
    case Enum$OrderCreateFromCheckoutErrorCode.EMAIL_NOT_SET:
      return r'EMAIL_NOT_SET';
    case Enum$OrderCreateFromCheckoutErrorCode.UNAVAILABLE_VARIANT_IN_CHANNEL:
      return r'UNAVAILABLE_VARIANT_IN_CHANNEL';
    case Enum$OrderCreateFromCheckoutErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$OrderCreateFromCheckoutErrorCode
    fromJson$Enum$OrderCreateFromCheckoutErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$OrderCreateFromCheckoutErrorCode.GRAPHQL_ERROR;
    case r'CHECKOUT_NOT_FOUND':
      return Enum$OrderCreateFromCheckoutErrorCode.CHECKOUT_NOT_FOUND;
    case r'CHANNEL_INACTIVE':
      return Enum$OrderCreateFromCheckoutErrorCode.CHANNEL_INACTIVE;
    case r'INSUFFICIENT_STOCK':
      return Enum$OrderCreateFromCheckoutErrorCode.INSUFFICIENT_STOCK;
    case r'VOUCHER_NOT_APPLICABLE':
      return Enum$OrderCreateFromCheckoutErrorCode.VOUCHER_NOT_APPLICABLE;
    case r'GIFT_CARD_NOT_APPLICABLE':
      return Enum$OrderCreateFromCheckoutErrorCode.GIFT_CARD_NOT_APPLICABLE;
    case r'TAX_ERROR':
      return Enum$OrderCreateFromCheckoutErrorCode.TAX_ERROR;
    case r'SHIPPING_METHOD_NOT_SET':
      return Enum$OrderCreateFromCheckoutErrorCode.SHIPPING_METHOD_NOT_SET;
    case r'BILLING_ADDRESS_NOT_SET':
      return Enum$OrderCreateFromCheckoutErrorCode.BILLING_ADDRESS_NOT_SET;
    case r'SHIPPING_ADDRESS_NOT_SET':
      return Enum$OrderCreateFromCheckoutErrorCode.SHIPPING_ADDRESS_NOT_SET;
    case r'INVALID_SHIPPING_METHOD':
      return Enum$OrderCreateFromCheckoutErrorCode.INVALID_SHIPPING_METHOD;
    case r'NO_LINES':
      return Enum$OrderCreateFromCheckoutErrorCode.NO_LINES;
    case r'EMAIL_NOT_SET':
      return Enum$OrderCreateFromCheckoutErrorCode.EMAIL_NOT_SET;
    case r'UNAVAILABLE_VARIANT_IN_CHANNEL':
      return Enum$OrderCreateFromCheckoutErrorCode
          .UNAVAILABLE_VARIANT_IN_CHANNEL;
    default:
      return Enum$OrderCreateFromCheckoutErrorCode.$unknown;
  }
}

enum Enum$OrderDirection {
  ASC,
  DESC,
  $unknown;

  factory Enum$OrderDirection.fromJson(String value) =>
      fromJson$Enum$OrderDirection(value);

  String toJson() => toJson$Enum$OrderDirection(this);
}

String toJson$Enum$OrderDirection(Enum$OrderDirection e) {
  switch (e) {
    case Enum$OrderDirection.ASC:
      return r'ASC';
    case Enum$OrderDirection.DESC:
      return r'DESC';
    case Enum$OrderDirection.$unknown:
      return r'$unknown';
  }
}

Enum$OrderDirection fromJson$Enum$OrderDirection(String value) {
  switch (value) {
    case r'ASC':
      return Enum$OrderDirection.ASC;
    case r'DESC':
      return Enum$OrderDirection.DESC;
    default:
      return Enum$OrderDirection.$unknown;
  }
}

enum Enum$OrderDiscountType {
  SALE,
  VOUCHER,
  MANUAL,
  PROMOTION,
  ORDER_PROMOTION,
  $unknown;

  factory Enum$OrderDiscountType.fromJson(String value) =>
      fromJson$Enum$OrderDiscountType(value);

  String toJson() => toJson$Enum$OrderDiscountType(this);
}

String toJson$Enum$OrderDiscountType(Enum$OrderDiscountType e) {
  switch (e) {
    case Enum$OrderDiscountType.SALE:
      return r'SALE';
    case Enum$OrderDiscountType.VOUCHER:
      return r'VOUCHER';
    case Enum$OrderDiscountType.MANUAL:
      return r'MANUAL';
    case Enum$OrderDiscountType.PROMOTION:
      return r'PROMOTION';
    case Enum$OrderDiscountType.ORDER_PROMOTION:
      return r'ORDER_PROMOTION';
    case Enum$OrderDiscountType.$unknown:
      return r'$unknown';
  }
}

Enum$OrderDiscountType fromJson$Enum$OrderDiscountType(String value) {
  switch (value) {
    case r'SALE':
      return Enum$OrderDiscountType.SALE;
    case r'VOUCHER':
      return Enum$OrderDiscountType.VOUCHER;
    case r'MANUAL':
      return Enum$OrderDiscountType.MANUAL;
    case r'PROMOTION':
      return Enum$OrderDiscountType.PROMOTION;
    case r'ORDER_PROMOTION':
      return Enum$OrderDiscountType.ORDER_PROMOTION;
    default:
      return Enum$OrderDiscountType.$unknown;
  }
}

enum Enum$OrderErrorCode {
  BILLING_ADDRESS_NOT_SET,
  CANNOT_CANCEL_FULFILLMENT,
  CANNOT_CANCEL_ORDER,
  CANNOT_DELETE,
  CANNOT_DISCOUNT,
  CANNOT_REFUND,
  CANNOT_FULFILL_UNPAID_ORDER,
  CAPTURE_INACTIVE_PAYMENT,
  GIFT_CARD_LINE,
  NOT_EDITABLE,
  FULFILL_ORDER_LINE,
  GRAPHQL_ERROR,
  INVALID,
  PRODUCT_NOT_PUBLISHED,
  PRODUCT_UNAVAILABLE_FOR_PURCHASE,
  NOT_FOUND,
  ORDER_NO_SHIPPING_ADDRESS,
  PAYMENT_ERROR,
  PAYMENT_MISSING,
  TRANSACTION_ERROR,
  REQUIRED,
  SHIPPING_METHOD_NOT_APPLICABLE,
  SHIPPING_METHOD_REQUIRED,
  TAX_ERROR,
  UNIQUE,
  VOID_INACTIVE_PAYMENT,
  ZERO_QUANTITY,
  INVALID_QUANTITY,
  INSUFFICIENT_STOCK,
  DUPLICATED_INPUT_ITEM,
  NOT_AVAILABLE_IN_CHANNEL,
  CHANNEL_INACTIVE,
  INVALID_VOUCHER,
  INVALID_VOUCHER_CODE,
  NON_EDITABLE_GIFT_LINE,
  NON_REMOVABLE_GIFT_LINE,
  MISSING_ADDRESS_DATA,
  $unknown;

  factory Enum$OrderErrorCode.fromJson(String value) =>
      fromJson$Enum$OrderErrorCode(value);

  String toJson() => toJson$Enum$OrderErrorCode(this);
}

String toJson$Enum$OrderErrorCode(Enum$OrderErrorCode e) {
  switch (e) {
    case Enum$OrderErrorCode.BILLING_ADDRESS_NOT_SET:
      return r'BILLING_ADDRESS_NOT_SET';
    case Enum$OrderErrorCode.CANNOT_CANCEL_FULFILLMENT:
      return r'CANNOT_CANCEL_FULFILLMENT';
    case Enum$OrderErrorCode.CANNOT_CANCEL_ORDER:
      return r'CANNOT_CANCEL_ORDER';
    case Enum$OrderErrorCode.CANNOT_DELETE:
      return r'CANNOT_DELETE';
    case Enum$OrderErrorCode.CANNOT_DISCOUNT:
      return r'CANNOT_DISCOUNT';
    case Enum$OrderErrorCode.CANNOT_REFUND:
      return r'CANNOT_REFUND';
    case Enum$OrderErrorCode.CANNOT_FULFILL_UNPAID_ORDER:
      return r'CANNOT_FULFILL_UNPAID_ORDER';
    case Enum$OrderErrorCode.CAPTURE_INACTIVE_PAYMENT:
      return r'CAPTURE_INACTIVE_PAYMENT';
    case Enum$OrderErrorCode.GIFT_CARD_LINE:
      return r'GIFT_CARD_LINE';
    case Enum$OrderErrorCode.NOT_EDITABLE:
      return r'NOT_EDITABLE';
    case Enum$OrderErrorCode.FULFILL_ORDER_LINE:
      return r'FULFILL_ORDER_LINE';
    case Enum$OrderErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$OrderErrorCode.INVALID:
      return r'INVALID';
    case Enum$OrderErrorCode.PRODUCT_NOT_PUBLISHED:
      return r'PRODUCT_NOT_PUBLISHED';
    case Enum$OrderErrorCode.PRODUCT_UNAVAILABLE_FOR_PURCHASE:
      return r'PRODUCT_UNAVAILABLE_FOR_PURCHASE';
    case Enum$OrderErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$OrderErrorCode.ORDER_NO_SHIPPING_ADDRESS:
      return r'ORDER_NO_SHIPPING_ADDRESS';
    case Enum$OrderErrorCode.PAYMENT_ERROR:
      return r'PAYMENT_ERROR';
    case Enum$OrderErrorCode.PAYMENT_MISSING:
      return r'PAYMENT_MISSING';
    case Enum$OrderErrorCode.TRANSACTION_ERROR:
      return r'TRANSACTION_ERROR';
    case Enum$OrderErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$OrderErrorCode.SHIPPING_METHOD_NOT_APPLICABLE:
      return r'SHIPPING_METHOD_NOT_APPLICABLE';
    case Enum$OrderErrorCode.SHIPPING_METHOD_REQUIRED:
      return r'SHIPPING_METHOD_REQUIRED';
    case Enum$OrderErrorCode.TAX_ERROR:
      return r'TAX_ERROR';
    case Enum$OrderErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$OrderErrorCode.VOID_INACTIVE_PAYMENT:
      return r'VOID_INACTIVE_PAYMENT';
    case Enum$OrderErrorCode.ZERO_QUANTITY:
      return r'ZERO_QUANTITY';
    case Enum$OrderErrorCode.INVALID_QUANTITY:
      return r'INVALID_QUANTITY';
    case Enum$OrderErrorCode.INSUFFICIENT_STOCK:
      return r'INSUFFICIENT_STOCK';
    case Enum$OrderErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$OrderErrorCode.NOT_AVAILABLE_IN_CHANNEL:
      return r'NOT_AVAILABLE_IN_CHANNEL';
    case Enum$OrderErrorCode.CHANNEL_INACTIVE:
      return r'CHANNEL_INACTIVE';
    case Enum$OrderErrorCode.INVALID_VOUCHER:
      return r'INVALID_VOUCHER';
    case Enum$OrderErrorCode.INVALID_VOUCHER_CODE:
      return r'INVALID_VOUCHER_CODE';
    case Enum$OrderErrorCode.NON_EDITABLE_GIFT_LINE:
      return r'NON_EDITABLE_GIFT_LINE';
    case Enum$OrderErrorCode.NON_REMOVABLE_GIFT_LINE:
      return r'NON_REMOVABLE_GIFT_LINE';
    case Enum$OrderErrorCode.MISSING_ADDRESS_DATA:
      return r'MISSING_ADDRESS_DATA';
    case Enum$OrderErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$OrderErrorCode fromJson$Enum$OrderErrorCode(String value) {
  switch (value) {
    case r'BILLING_ADDRESS_NOT_SET':
      return Enum$OrderErrorCode.BILLING_ADDRESS_NOT_SET;
    case r'CANNOT_CANCEL_FULFILLMENT':
      return Enum$OrderErrorCode.CANNOT_CANCEL_FULFILLMENT;
    case r'CANNOT_CANCEL_ORDER':
      return Enum$OrderErrorCode.CANNOT_CANCEL_ORDER;
    case r'CANNOT_DELETE':
      return Enum$OrderErrorCode.CANNOT_DELETE;
    case r'CANNOT_DISCOUNT':
      return Enum$OrderErrorCode.CANNOT_DISCOUNT;
    case r'CANNOT_REFUND':
      return Enum$OrderErrorCode.CANNOT_REFUND;
    case r'CANNOT_FULFILL_UNPAID_ORDER':
      return Enum$OrderErrorCode.CANNOT_FULFILL_UNPAID_ORDER;
    case r'CAPTURE_INACTIVE_PAYMENT':
      return Enum$OrderErrorCode.CAPTURE_INACTIVE_PAYMENT;
    case r'GIFT_CARD_LINE':
      return Enum$OrderErrorCode.GIFT_CARD_LINE;
    case r'NOT_EDITABLE':
      return Enum$OrderErrorCode.NOT_EDITABLE;
    case r'FULFILL_ORDER_LINE':
      return Enum$OrderErrorCode.FULFILL_ORDER_LINE;
    case r'GRAPHQL_ERROR':
      return Enum$OrderErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$OrderErrorCode.INVALID;
    case r'PRODUCT_NOT_PUBLISHED':
      return Enum$OrderErrorCode.PRODUCT_NOT_PUBLISHED;
    case r'PRODUCT_UNAVAILABLE_FOR_PURCHASE':
      return Enum$OrderErrorCode.PRODUCT_UNAVAILABLE_FOR_PURCHASE;
    case r'NOT_FOUND':
      return Enum$OrderErrorCode.NOT_FOUND;
    case r'ORDER_NO_SHIPPING_ADDRESS':
      return Enum$OrderErrorCode.ORDER_NO_SHIPPING_ADDRESS;
    case r'PAYMENT_ERROR':
      return Enum$OrderErrorCode.PAYMENT_ERROR;
    case r'PAYMENT_MISSING':
      return Enum$OrderErrorCode.PAYMENT_MISSING;
    case r'TRANSACTION_ERROR':
      return Enum$OrderErrorCode.TRANSACTION_ERROR;
    case r'REQUIRED':
      return Enum$OrderErrorCode.REQUIRED;
    case r'SHIPPING_METHOD_NOT_APPLICABLE':
      return Enum$OrderErrorCode.SHIPPING_METHOD_NOT_APPLICABLE;
    case r'SHIPPING_METHOD_REQUIRED':
      return Enum$OrderErrorCode.SHIPPING_METHOD_REQUIRED;
    case r'TAX_ERROR':
      return Enum$OrderErrorCode.TAX_ERROR;
    case r'UNIQUE':
      return Enum$OrderErrorCode.UNIQUE;
    case r'VOID_INACTIVE_PAYMENT':
      return Enum$OrderErrorCode.VOID_INACTIVE_PAYMENT;
    case r'ZERO_QUANTITY':
      return Enum$OrderErrorCode.ZERO_QUANTITY;
    case r'INVALID_QUANTITY':
      return Enum$OrderErrorCode.INVALID_QUANTITY;
    case r'INSUFFICIENT_STOCK':
      return Enum$OrderErrorCode.INSUFFICIENT_STOCK;
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$OrderErrorCode.DUPLICATED_INPUT_ITEM;
    case r'NOT_AVAILABLE_IN_CHANNEL':
      return Enum$OrderErrorCode.NOT_AVAILABLE_IN_CHANNEL;
    case r'CHANNEL_INACTIVE':
      return Enum$OrderErrorCode.CHANNEL_INACTIVE;
    case r'INVALID_VOUCHER':
      return Enum$OrderErrorCode.INVALID_VOUCHER;
    case r'INVALID_VOUCHER_CODE':
      return Enum$OrderErrorCode.INVALID_VOUCHER_CODE;
    case r'NON_EDITABLE_GIFT_LINE':
      return Enum$OrderErrorCode.NON_EDITABLE_GIFT_LINE;
    case r'NON_REMOVABLE_GIFT_LINE':
      return Enum$OrderErrorCode.NON_REMOVABLE_GIFT_LINE;
    case r'MISSING_ADDRESS_DATA':
      return Enum$OrderErrorCode.MISSING_ADDRESS_DATA;
    default:
      return Enum$OrderErrorCode.$unknown;
  }
}

enum Enum$OrderEventsEmailsEnum {
  PAYMENT_CONFIRMATION,
  CONFIRMED,
  SHIPPING_CONFIRMATION,
  TRACKING_UPDATED,
  ORDER_CONFIRMATION,
  ORDER_CANCEL,
  ORDER_REFUND,
  FULFILLMENT_CONFIRMATION,
  DIGITAL_LINKS,
  $unknown;

  factory Enum$OrderEventsEmailsEnum.fromJson(String value) =>
      fromJson$Enum$OrderEventsEmailsEnum(value);

  String toJson() => toJson$Enum$OrderEventsEmailsEnum(this);
}

String toJson$Enum$OrderEventsEmailsEnum(Enum$OrderEventsEmailsEnum e) {
  switch (e) {
    case Enum$OrderEventsEmailsEnum.PAYMENT_CONFIRMATION:
      return r'PAYMENT_CONFIRMATION';
    case Enum$OrderEventsEmailsEnum.CONFIRMED:
      return r'CONFIRMED';
    case Enum$OrderEventsEmailsEnum.SHIPPING_CONFIRMATION:
      return r'SHIPPING_CONFIRMATION';
    case Enum$OrderEventsEmailsEnum.TRACKING_UPDATED:
      return r'TRACKING_UPDATED';
    case Enum$OrderEventsEmailsEnum.ORDER_CONFIRMATION:
      return r'ORDER_CONFIRMATION';
    case Enum$OrderEventsEmailsEnum.ORDER_CANCEL:
      return r'ORDER_CANCEL';
    case Enum$OrderEventsEmailsEnum.ORDER_REFUND:
      return r'ORDER_REFUND';
    case Enum$OrderEventsEmailsEnum.FULFILLMENT_CONFIRMATION:
      return r'FULFILLMENT_CONFIRMATION';
    case Enum$OrderEventsEmailsEnum.DIGITAL_LINKS:
      return r'DIGITAL_LINKS';
    case Enum$OrderEventsEmailsEnum.$unknown:
      return r'$unknown';
  }
}

Enum$OrderEventsEmailsEnum fromJson$Enum$OrderEventsEmailsEnum(String value) {
  switch (value) {
    case r'PAYMENT_CONFIRMATION':
      return Enum$OrderEventsEmailsEnum.PAYMENT_CONFIRMATION;
    case r'CONFIRMED':
      return Enum$OrderEventsEmailsEnum.CONFIRMED;
    case r'SHIPPING_CONFIRMATION':
      return Enum$OrderEventsEmailsEnum.SHIPPING_CONFIRMATION;
    case r'TRACKING_UPDATED':
      return Enum$OrderEventsEmailsEnum.TRACKING_UPDATED;
    case r'ORDER_CONFIRMATION':
      return Enum$OrderEventsEmailsEnum.ORDER_CONFIRMATION;
    case r'ORDER_CANCEL':
      return Enum$OrderEventsEmailsEnum.ORDER_CANCEL;
    case r'ORDER_REFUND':
      return Enum$OrderEventsEmailsEnum.ORDER_REFUND;
    case r'FULFILLMENT_CONFIRMATION':
      return Enum$OrderEventsEmailsEnum.FULFILLMENT_CONFIRMATION;
    case r'DIGITAL_LINKS':
      return Enum$OrderEventsEmailsEnum.DIGITAL_LINKS;
    default:
      return Enum$OrderEventsEmailsEnum.$unknown;
  }
}

enum Enum$OrderEventsEnum {
  DRAFT_CREATED,
  DRAFT_CREATED_FROM_REPLACE,
  ADDED_PRODUCTS,
  REMOVED_PRODUCTS,
  PLACED,
  PLACED_FROM_DRAFT,
  PLACED_AUTOMATICALLY_FROM_PAID_CHECKOUT,
  OVERSOLD_ITEMS,
  CANCELED,
  EXPIRED,
  ORDER_MARKED_AS_PAID,
  ORDER_FULLY_PAID,
  ORDER_REPLACEMENT_CREATED,
  ORDER_DISCOUNT_ADDED,
  ORDER_DISCOUNT_AUTOMATICALLY_UPDATED,
  ORDER_DISCOUNT_UPDATED,
  ORDER_DISCOUNT_DELETED,
  ORDER_LINE_DISCOUNT_UPDATED,
  ORDER_LINE_DISCOUNT_REMOVED,
  ORDER_LINE_PRODUCT_DELETED,
  ORDER_LINE_VARIANT_DELETED,
  UPDATED_ADDRESS,
  EMAIL_SENT,
  CONFIRMED,
  PAYMENT_AUTHORIZED,
  PAYMENT_CAPTURED,
  EXTERNAL_SERVICE_NOTIFICATION,
  PAYMENT_REFUNDED,
  PAYMENT_VOIDED,
  PAYMENT_FAILED,
  TRANSACTION_EVENT,
  TRANSACTION_CHARGE_REQUESTED,
  TRANSACTION_REFUND_REQUESTED,
  TRANSACTION_CANCEL_REQUESTED,
  TRANSACTION_MARK_AS_PAID_FAILED,
  INVOICE_REQUESTED,
  INVOICE_GENERATED,
  INVOICE_UPDATED,
  INVOICE_SENT,
  FULFILLMENT_CANCELED,
  FULFILLMENT_RESTOCKED_ITEMS,
  FULFILLMENT_FULFILLED_ITEMS,
  FULFILLMENT_REFUNDED,
  FULFILLMENT_RETURNED,
  FULFILLMENT_REPLACED,
  FULFILLMENT_AWAITS_APPROVAL,
  TRACKING_UPDATED,
  NOTE_ADDED,
  NOTE_UPDATED,
  OTHER,
  $unknown;

  factory Enum$OrderEventsEnum.fromJson(String value) =>
      fromJson$Enum$OrderEventsEnum(value);

  String toJson() => toJson$Enum$OrderEventsEnum(this);
}

String toJson$Enum$OrderEventsEnum(Enum$OrderEventsEnum e) {
  switch (e) {
    case Enum$OrderEventsEnum.DRAFT_CREATED:
      return r'DRAFT_CREATED';
    case Enum$OrderEventsEnum.DRAFT_CREATED_FROM_REPLACE:
      return r'DRAFT_CREATED_FROM_REPLACE';
    case Enum$OrderEventsEnum.ADDED_PRODUCTS:
      return r'ADDED_PRODUCTS';
    case Enum$OrderEventsEnum.REMOVED_PRODUCTS:
      return r'REMOVED_PRODUCTS';
    case Enum$OrderEventsEnum.PLACED:
      return r'PLACED';
    case Enum$OrderEventsEnum.PLACED_FROM_DRAFT:
      return r'PLACED_FROM_DRAFT';
    case Enum$OrderEventsEnum.PLACED_AUTOMATICALLY_FROM_PAID_CHECKOUT:
      return r'PLACED_AUTOMATICALLY_FROM_PAID_CHECKOUT';
    case Enum$OrderEventsEnum.OVERSOLD_ITEMS:
      return r'OVERSOLD_ITEMS';
    case Enum$OrderEventsEnum.CANCELED:
      return r'CANCELED';
    case Enum$OrderEventsEnum.EXPIRED:
      return r'EXPIRED';
    case Enum$OrderEventsEnum.ORDER_MARKED_AS_PAID:
      return r'ORDER_MARKED_AS_PAID';
    case Enum$OrderEventsEnum.ORDER_FULLY_PAID:
      return r'ORDER_FULLY_PAID';
    case Enum$OrderEventsEnum.ORDER_REPLACEMENT_CREATED:
      return r'ORDER_REPLACEMENT_CREATED';
    case Enum$OrderEventsEnum.ORDER_DISCOUNT_ADDED:
      return r'ORDER_DISCOUNT_ADDED';
    case Enum$OrderEventsEnum.ORDER_DISCOUNT_AUTOMATICALLY_UPDATED:
      return r'ORDER_DISCOUNT_AUTOMATICALLY_UPDATED';
    case Enum$OrderEventsEnum.ORDER_DISCOUNT_UPDATED:
      return r'ORDER_DISCOUNT_UPDATED';
    case Enum$OrderEventsEnum.ORDER_DISCOUNT_DELETED:
      return r'ORDER_DISCOUNT_DELETED';
    case Enum$OrderEventsEnum.ORDER_LINE_DISCOUNT_UPDATED:
      return r'ORDER_LINE_DISCOUNT_UPDATED';
    case Enum$OrderEventsEnum.ORDER_LINE_DISCOUNT_REMOVED:
      return r'ORDER_LINE_DISCOUNT_REMOVED';
    case Enum$OrderEventsEnum.ORDER_LINE_PRODUCT_DELETED:
      return r'ORDER_LINE_PRODUCT_DELETED';
    case Enum$OrderEventsEnum.ORDER_LINE_VARIANT_DELETED:
      return r'ORDER_LINE_VARIANT_DELETED';
    case Enum$OrderEventsEnum.UPDATED_ADDRESS:
      return r'UPDATED_ADDRESS';
    case Enum$OrderEventsEnum.EMAIL_SENT:
      return r'EMAIL_SENT';
    case Enum$OrderEventsEnum.CONFIRMED:
      return r'CONFIRMED';
    case Enum$OrderEventsEnum.PAYMENT_AUTHORIZED:
      return r'PAYMENT_AUTHORIZED';
    case Enum$OrderEventsEnum.PAYMENT_CAPTURED:
      return r'PAYMENT_CAPTURED';
    case Enum$OrderEventsEnum.EXTERNAL_SERVICE_NOTIFICATION:
      return r'EXTERNAL_SERVICE_NOTIFICATION';
    case Enum$OrderEventsEnum.PAYMENT_REFUNDED:
      return r'PAYMENT_REFUNDED';
    case Enum$OrderEventsEnum.PAYMENT_VOIDED:
      return r'PAYMENT_VOIDED';
    case Enum$OrderEventsEnum.PAYMENT_FAILED:
      return r'PAYMENT_FAILED';
    case Enum$OrderEventsEnum.TRANSACTION_EVENT:
      return r'TRANSACTION_EVENT';
    case Enum$OrderEventsEnum.TRANSACTION_CHARGE_REQUESTED:
      return r'TRANSACTION_CHARGE_REQUESTED';
    case Enum$OrderEventsEnum.TRANSACTION_REFUND_REQUESTED:
      return r'TRANSACTION_REFUND_REQUESTED';
    case Enum$OrderEventsEnum.TRANSACTION_CANCEL_REQUESTED:
      return r'TRANSACTION_CANCEL_REQUESTED';
    case Enum$OrderEventsEnum.TRANSACTION_MARK_AS_PAID_FAILED:
      return r'TRANSACTION_MARK_AS_PAID_FAILED';
    case Enum$OrderEventsEnum.INVOICE_REQUESTED:
      return r'INVOICE_REQUESTED';
    case Enum$OrderEventsEnum.INVOICE_GENERATED:
      return r'INVOICE_GENERATED';
    case Enum$OrderEventsEnum.INVOICE_UPDATED:
      return r'INVOICE_UPDATED';
    case Enum$OrderEventsEnum.INVOICE_SENT:
      return r'INVOICE_SENT';
    case Enum$OrderEventsEnum.FULFILLMENT_CANCELED:
      return r'FULFILLMENT_CANCELED';
    case Enum$OrderEventsEnum.FULFILLMENT_RESTOCKED_ITEMS:
      return r'FULFILLMENT_RESTOCKED_ITEMS';
    case Enum$OrderEventsEnum.FULFILLMENT_FULFILLED_ITEMS:
      return r'FULFILLMENT_FULFILLED_ITEMS';
    case Enum$OrderEventsEnum.FULFILLMENT_REFUNDED:
      return r'FULFILLMENT_REFUNDED';
    case Enum$OrderEventsEnum.FULFILLMENT_RETURNED:
      return r'FULFILLMENT_RETURNED';
    case Enum$OrderEventsEnum.FULFILLMENT_REPLACED:
      return r'FULFILLMENT_REPLACED';
    case Enum$OrderEventsEnum.FULFILLMENT_AWAITS_APPROVAL:
      return r'FULFILLMENT_AWAITS_APPROVAL';
    case Enum$OrderEventsEnum.TRACKING_UPDATED:
      return r'TRACKING_UPDATED';
    case Enum$OrderEventsEnum.NOTE_ADDED:
      return r'NOTE_ADDED';
    case Enum$OrderEventsEnum.NOTE_UPDATED:
      return r'NOTE_UPDATED';
    case Enum$OrderEventsEnum.OTHER:
      return r'OTHER';
    case Enum$OrderEventsEnum.$unknown:
      return r'$unknown';
  }
}

Enum$OrderEventsEnum fromJson$Enum$OrderEventsEnum(String value) {
  switch (value) {
    case r'DRAFT_CREATED':
      return Enum$OrderEventsEnum.DRAFT_CREATED;
    case r'DRAFT_CREATED_FROM_REPLACE':
      return Enum$OrderEventsEnum.DRAFT_CREATED_FROM_REPLACE;
    case r'ADDED_PRODUCTS':
      return Enum$OrderEventsEnum.ADDED_PRODUCTS;
    case r'REMOVED_PRODUCTS':
      return Enum$OrderEventsEnum.REMOVED_PRODUCTS;
    case r'PLACED':
      return Enum$OrderEventsEnum.PLACED;
    case r'PLACED_FROM_DRAFT':
      return Enum$OrderEventsEnum.PLACED_FROM_DRAFT;
    case r'PLACED_AUTOMATICALLY_FROM_PAID_CHECKOUT':
      return Enum$OrderEventsEnum.PLACED_AUTOMATICALLY_FROM_PAID_CHECKOUT;
    case r'OVERSOLD_ITEMS':
      return Enum$OrderEventsEnum.OVERSOLD_ITEMS;
    case r'CANCELED':
      return Enum$OrderEventsEnum.CANCELED;
    case r'EXPIRED':
      return Enum$OrderEventsEnum.EXPIRED;
    case r'ORDER_MARKED_AS_PAID':
      return Enum$OrderEventsEnum.ORDER_MARKED_AS_PAID;
    case r'ORDER_FULLY_PAID':
      return Enum$OrderEventsEnum.ORDER_FULLY_PAID;
    case r'ORDER_REPLACEMENT_CREATED':
      return Enum$OrderEventsEnum.ORDER_REPLACEMENT_CREATED;
    case r'ORDER_DISCOUNT_ADDED':
      return Enum$OrderEventsEnum.ORDER_DISCOUNT_ADDED;
    case r'ORDER_DISCOUNT_AUTOMATICALLY_UPDATED':
      return Enum$OrderEventsEnum.ORDER_DISCOUNT_AUTOMATICALLY_UPDATED;
    case r'ORDER_DISCOUNT_UPDATED':
      return Enum$OrderEventsEnum.ORDER_DISCOUNT_UPDATED;
    case r'ORDER_DISCOUNT_DELETED':
      return Enum$OrderEventsEnum.ORDER_DISCOUNT_DELETED;
    case r'ORDER_LINE_DISCOUNT_UPDATED':
      return Enum$OrderEventsEnum.ORDER_LINE_DISCOUNT_UPDATED;
    case r'ORDER_LINE_DISCOUNT_REMOVED':
      return Enum$OrderEventsEnum.ORDER_LINE_DISCOUNT_REMOVED;
    case r'ORDER_LINE_PRODUCT_DELETED':
      return Enum$OrderEventsEnum.ORDER_LINE_PRODUCT_DELETED;
    case r'ORDER_LINE_VARIANT_DELETED':
      return Enum$OrderEventsEnum.ORDER_LINE_VARIANT_DELETED;
    case r'UPDATED_ADDRESS':
      return Enum$OrderEventsEnum.UPDATED_ADDRESS;
    case r'EMAIL_SENT':
      return Enum$OrderEventsEnum.EMAIL_SENT;
    case r'CONFIRMED':
      return Enum$OrderEventsEnum.CONFIRMED;
    case r'PAYMENT_AUTHORIZED':
      return Enum$OrderEventsEnum.PAYMENT_AUTHORIZED;
    case r'PAYMENT_CAPTURED':
      return Enum$OrderEventsEnum.PAYMENT_CAPTURED;
    case r'EXTERNAL_SERVICE_NOTIFICATION':
      return Enum$OrderEventsEnum.EXTERNAL_SERVICE_NOTIFICATION;
    case r'PAYMENT_REFUNDED':
      return Enum$OrderEventsEnum.PAYMENT_REFUNDED;
    case r'PAYMENT_VOIDED':
      return Enum$OrderEventsEnum.PAYMENT_VOIDED;
    case r'PAYMENT_FAILED':
      return Enum$OrderEventsEnum.PAYMENT_FAILED;
    case r'TRANSACTION_EVENT':
      return Enum$OrderEventsEnum.TRANSACTION_EVENT;
    case r'TRANSACTION_CHARGE_REQUESTED':
      return Enum$OrderEventsEnum.TRANSACTION_CHARGE_REQUESTED;
    case r'TRANSACTION_REFUND_REQUESTED':
      return Enum$OrderEventsEnum.TRANSACTION_REFUND_REQUESTED;
    case r'TRANSACTION_CANCEL_REQUESTED':
      return Enum$OrderEventsEnum.TRANSACTION_CANCEL_REQUESTED;
    case r'TRANSACTION_MARK_AS_PAID_FAILED':
      return Enum$OrderEventsEnum.TRANSACTION_MARK_AS_PAID_FAILED;
    case r'INVOICE_REQUESTED':
      return Enum$OrderEventsEnum.INVOICE_REQUESTED;
    case r'INVOICE_GENERATED':
      return Enum$OrderEventsEnum.INVOICE_GENERATED;
    case r'INVOICE_UPDATED':
      return Enum$OrderEventsEnum.INVOICE_UPDATED;
    case r'INVOICE_SENT':
      return Enum$OrderEventsEnum.INVOICE_SENT;
    case r'FULFILLMENT_CANCELED':
      return Enum$OrderEventsEnum.FULFILLMENT_CANCELED;
    case r'FULFILLMENT_RESTOCKED_ITEMS':
      return Enum$OrderEventsEnum.FULFILLMENT_RESTOCKED_ITEMS;
    case r'FULFILLMENT_FULFILLED_ITEMS':
      return Enum$OrderEventsEnum.FULFILLMENT_FULFILLED_ITEMS;
    case r'FULFILLMENT_REFUNDED':
      return Enum$OrderEventsEnum.FULFILLMENT_REFUNDED;
    case r'FULFILLMENT_RETURNED':
      return Enum$OrderEventsEnum.FULFILLMENT_RETURNED;
    case r'FULFILLMENT_REPLACED':
      return Enum$OrderEventsEnum.FULFILLMENT_REPLACED;
    case r'FULFILLMENT_AWAITS_APPROVAL':
      return Enum$OrderEventsEnum.FULFILLMENT_AWAITS_APPROVAL;
    case r'TRACKING_UPDATED':
      return Enum$OrderEventsEnum.TRACKING_UPDATED;
    case r'NOTE_ADDED':
      return Enum$OrderEventsEnum.NOTE_ADDED;
    case r'NOTE_UPDATED':
      return Enum$OrderEventsEnum.NOTE_UPDATED;
    case r'OTHER':
      return Enum$OrderEventsEnum.OTHER;
    default:
      return Enum$OrderEventsEnum.$unknown;
  }
}

enum Enum$OrderGrantedRefundStatusEnum {
  NONE,
  PENDING,
  SUCCESS,
  FAILURE,
  $unknown;

  factory Enum$OrderGrantedRefundStatusEnum.fromJson(String value) =>
      fromJson$Enum$OrderGrantedRefundStatusEnum(value);

  String toJson() => toJson$Enum$OrderGrantedRefundStatusEnum(this);
}

String toJson$Enum$OrderGrantedRefundStatusEnum(
    Enum$OrderGrantedRefundStatusEnum e) {
  switch (e) {
    case Enum$OrderGrantedRefundStatusEnum.NONE:
      return r'NONE';
    case Enum$OrderGrantedRefundStatusEnum.PENDING:
      return r'PENDING';
    case Enum$OrderGrantedRefundStatusEnum.SUCCESS:
      return r'SUCCESS';
    case Enum$OrderGrantedRefundStatusEnum.FAILURE:
      return r'FAILURE';
    case Enum$OrderGrantedRefundStatusEnum.$unknown:
      return r'$unknown';
  }
}

Enum$OrderGrantedRefundStatusEnum fromJson$Enum$OrderGrantedRefundStatusEnum(
    String value) {
  switch (value) {
    case r'NONE':
      return Enum$OrderGrantedRefundStatusEnum.NONE;
    case r'PENDING':
      return Enum$OrderGrantedRefundStatusEnum.PENDING;
    case r'SUCCESS':
      return Enum$OrderGrantedRefundStatusEnum.SUCCESS;
    case r'FAILURE':
      return Enum$OrderGrantedRefundStatusEnum.FAILURE;
    default:
      return Enum$OrderGrantedRefundStatusEnum.$unknown;
  }
}

enum Enum$OrderGrantRefundCreateErrorCode {
  GRAPHQL_ERROR,
  NOT_FOUND,
  SHIPPING_COSTS_ALREADY_GRANTED,
  AMOUNT_GREATER_THAN_AVAILABLE,
  REQUIRED,
  INVALID,
  $unknown;

  factory Enum$OrderGrantRefundCreateErrorCode.fromJson(String value) =>
      fromJson$Enum$OrderGrantRefundCreateErrorCode(value);

  String toJson() => toJson$Enum$OrderGrantRefundCreateErrorCode(this);
}

String toJson$Enum$OrderGrantRefundCreateErrorCode(
    Enum$OrderGrantRefundCreateErrorCode e) {
  switch (e) {
    case Enum$OrderGrantRefundCreateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$OrderGrantRefundCreateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$OrderGrantRefundCreateErrorCode.SHIPPING_COSTS_ALREADY_GRANTED:
      return r'SHIPPING_COSTS_ALREADY_GRANTED';
    case Enum$OrderGrantRefundCreateErrorCode.AMOUNT_GREATER_THAN_AVAILABLE:
      return r'AMOUNT_GREATER_THAN_AVAILABLE';
    case Enum$OrderGrantRefundCreateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$OrderGrantRefundCreateErrorCode.INVALID:
      return r'INVALID';
    case Enum$OrderGrantRefundCreateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$OrderGrantRefundCreateErrorCode
    fromJson$Enum$OrderGrantRefundCreateErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$OrderGrantRefundCreateErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$OrderGrantRefundCreateErrorCode.NOT_FOUND;
    case r'SHIPPING_COSTS_ALREADY_GRANTED':
      return Enum$OrderGrantRefundCreateErrorCode
          .SHIPPING_COSTS_ALREADY_GRANTED;
    case r'AMOUNT_GREATER_THAN_AVAILABLE':
      return Enum$OrderGrantRefundCreateErrorCode.AMOUNT_GREATER_THAN_AVAILABLE;
    case r'REQUIRED':
      return Enum$OrderGrantRefundCreateErrorCode.REQUIRED;
    case r'INVALID':
      return Enum$OrderGrantRefundCreateErrorCode.INVALID;
    default:
      return Enum$OrderGrantRefundCreateErrorCode.$unknown;
  }
}

enum Enum$OrderGrantRefundCreateLineErrorCode {
  GRAPHQL_ERROR,
  NOT_FOUND,
  QUANTITY_GREATER_THAN_AVAILABLE,
  $unknown;

  factory Enum$OrderGrantRefundCreateLineErrorCode.fromJson(String value) =>
      fromJson$Enum$OrderGrantRefundCreateLineErrorCode(value);

  String toJson() => toJson$Enum$OrderGrantRefundCreateLineErrorCode(this);
}

String toJson$Enum$OrderGrantRefundCreateLineErrorCode(
    Enum$OrderGrantRefundCreateLineErrorCode e) {
  switch (e) {
    case Enum$OrderGrantRefundCreateLineErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$OrderGrantRefundCreateLineErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$OrderGrantRefundCreateLineErrorCode
          .QUANTITY_GREATER_THAN_AVAILABLE:
      return r'QUANTITY_GREATER_THAN_AVAILABLE';
    case Enum$OrderGrantRefundCreateLineErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$OrderGrantRefundCreateLineErrorCode
    fromJson$Enum$OrderGrantRefundCreateLineErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$OrderGrantRefundCreateLineErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$OrderGrantRefundCreateLineErrorCode.NOT_FOUND;
    case r'QUANTITY_GREATER_THAN_AVAILABLE':
      return Enum$OrderGrantRefundCreateLineErrorCode
          .QUANTITY_GREATER_THAN_AVAILABLE;
    default:
      return Enum$OrderGrantRefundCreateLineErrorCode.$unknown;
  }
}

enum Enum$OrderGrantRefundUpdateErrorCode {
  GRAPHQL_ERROR,
  NOT_FOUND,
  REQUIRED,
  INVALID,
  AMOUNT_GREATER_THAN_AVAILABLE,
  SHIPPING_COSTS_ALREADY_GRANTED,
  $unknown;

  factory Enum$OrderGrantRefundUpdateErrorCode.fromJson(String value) =>
      fromJson$Enum$OrderGrantRefundUpdateErrorCode(value);

  String toJson() => toJson$Enum$OrderGrantRefundUpdateErrorCode(this);
}

String toJson$Enum$OrderGrantRefundUpdateErrorCode(
    Enum$OrderGrantRefundUpdateErrorCode e) {
  switch (e) {
    case Enum$OrderGrantRefundUpdateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$OrderGrantRefundUpdateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$OrderGrantRefundUpdateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$OrderGrantRefundUpdateErrorCode.INVALID:
      return r'INVALID';
    case Enum$OrderGrantRefundUpdateErrorCode.AMOUNT_GREATER_THAN_AVAILABLE:
      return r'AMOUNT_GREATER_THAN_AVAILABLE';
    case Enum$OrderGrantRefundUpdateErrorCode.SHIPPING_COSTS_ALREADY_GRANTED:
      return r'SHIPPING_COSTS_ALREADY_GRANTED';
    case Enum$OrderGrantRefundUpdateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$OrderGrantRefundUpdateErrorCode
    fromJson$Enum$OrderGrantRefundUpdateErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$OrderGrantRefundUpdateErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$OrderGrantRefundUpdateErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$OrderGrantRefundUpdateErrorCode.REQUIRED;
    case r'INVALID':
      return Enum$OrderGrantRefundUpdateErrorCode.INVALID;
    case r'AMOUNT_GREATER_THAN_AVAILABLE':
      return Enum$OrderGrantRefundUpdateErrorCode.AMOUNT_GREATER_THAN_AVAILABLE;
    case r'SHIPPING_COSTS_ALREADY_GRANTED':
      return Enum$OrderGrantRefundUpdateErrorCode
          .SHIPPING_COSTS_ALREADY_GRANTED;
    default:
      return Enum$OrderGrantRefundUpdateErrorCode.$unknown;
  }
}

enum Enum$OrderGrantRefundUpdateLineErrorCode {
  GRAPHQL_ERROR,
  NOT_FOUND,
  QUANTITY_GREATER_THAN_AVAILABLE,
  $unknown;

  factory Enum$OrderGrantRefundUpdateLineErrorCode.fromJson(String value) =>
      fromJson$Enum$OrderGrantRefundUpdateLineErrorCode(value);

  String toJson() => toJson$Enum$OrderGrantRefundUpdateLineErrorCode(this);
}

String toJson$Enum$OrderGrantRefundUpdateLineErrorCode(
    Enum$OrderGrantRefundUpdateLineErrorCode e) {
  switch (e) {
    case Enum$OrderGrantRefundUpdateLineErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$OrderGrantRefundUpdateLineErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$OrderGrantRefundUpdateLineErrorCode
          .QUANTITY_GREATER_THAN_AVAILABLE:
      return r'QUANTITY_GREATER_THAN_AVAILABLE';
    case Enum$OrderGrantRefundUpdateLineErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$OrderGrantRefundUpdateLineErrorCode
    fromJson$Enum$OrderGrantRefundUpdateLineErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$OrderGrantRefundUpdateLineErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$OrderGrantRefundUpdateLineErrorCode.NOT_FOUND;
    case r'QUANTITY_GREATER_THAN_AVAILABLE':
      return Enum$OrderGrantRefundUpdateLineErrorCode
          .QUANTITY_GREATER_THAN_AVAILABLE;
    default:
      return Enum$OrderGrantRefundUpdateLineErrorCode.$unknown;
  }
}

enum Enum$OrderNoteAddErrorCode {
  GRAPHQL_ERROR,
  REQUIRED,
  $unknown;

  factory Enum$OrderNoteAddErrorCode.fromJson(String value) =>
      fromJson$Enum$OrderNoteAddErrorCode(value);

  String toJson() => toJson$Enum$OrderNoteAddErrorCode(this);
}

String toJson$Enum$OrderNoteAddErrorCode(Enum$OrderNoteAddErrorCode e) {
  switch (e) {
    case Enum$OrderNoteAddErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$OrderNoteAddErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$OrderNoteAddErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$OrderNoteAddErrorCode fromJson$Enum$OrderNoteAddErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$OrderNoteAddErrorCode.GRAPHQL_ERROR;
    case r'REQUIRED':
      return Enum$OrderNoteAddErrorCode.REQUIRED;
    default:
      return Enum$OrderNoteAddErrorCode.$unknown;
  }
}

enum Enum$OrderNoteUpdateErrorCode {
  GRAPHQL_ERROR,
  NOT_FOUND,
  REQUIRED,
  $unknown;

  factory Enum$OrderNoteUpdateErrorCode.fromJson(String value) =>
      fromJson$Enum$OrderNoteUpdateErrorCode(value);

  String toJson() => toJson$Enum$OrderNoteUpdateErrorCode(this);
}

String toJson$Enum$OrderNoteUpdateErrorCode(Enum$OrderNoteUpdateErrorCode e) {
  switch (e) {
    case Enum$OrderNoteUpdateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$OrderNoteUpdateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$OrderNoteUpdateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$OrderNoteUpdateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$OrderNoteUpdateErrorCode fromJson$Enum$OrderNoteUpdateErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$OrderNoteUpdateErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$OrderNoteUpdateErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$OrderNoteUpdateErrorCode.REQUIRED;
    default:
      return Enum$OrderNoteUpdateErrorCode.$unknown;
  }
}

enum Enum$OrderOriginEnum {
  CHECKOUT,
  DRAFT,
  REISSUE,
  BULK_CREATE,
  $unknown;

  factory Enum$OrderOriginEnum.fromJson(String value) =>
      fromJson$Enum$OrderOriginEnum(value);

  String toJson() => toJson$Enum$OrderOriginEnum(this);
}

String toJson$Enum$OrderOriginEnum(Enum$OrderOriginEnum e) {
  switch (e) {
    case Enum$OrderOriginEnum.CHECKOUT:
      return r'CHECKOUT';
    case Enum$OrderOriginEnum.DRAFT:
      return r'DRAFT';
    case Enum$OrderOriginEnum.REISSUE:
      return r'REISSUE';
    case Enum$OrderOriginEnum.BULK_CREATE:
      return r'BULK_CREATE';
    case Enum$OrderOriginEnum.$unknown:
      return r'$unknown';
  }
}

Enum$OrderOriginEnum fromJson$Enum$OrderOriginEnum(String value) {
  switch (value) {
    case r'CHECKOUT':
      return Enum$OrderOriginEnum.CHECKOUT;
    case r'DRAFT':
      return Enum$OrderOriginEnum.DRAFT;
    case r'REISSUE':
      return Enum$OrderOriginEnum.REISSUE;
    case r'BULK_CREATE':
      return Enum$OrderOriginEnum.BULK_CREATE;
    default:
      return Enum$OrderOriginEnum.$unknown;
  }
}

enum Enum$OrderSettingsErrorCode {
  INVALID,
  $unknown;

  factory Enum$OrderSettingsErrorCode.fromJson(String value) =>
      fromJson$Enum$OrderSettingsErrorCode(value);

  String toJson() => toJson$Enum$OrderSettingsErrorCode(this);
}

String toJson$Enum$OrderSettingsErrorCode(Enum$OrderSettingsErrorCode e) {
  switch (e) {
    case Enum$OrderSettingsErrorCode.INVALID:
      return r'INVALID';
    case Enum$OrderSettingsErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$OrderSettingsErrorCode fromJson$Enum$OrderSettingsErrorCode(String value) {
  switch (value) {
    case r'INVALID':
      return Enum$OrderSettingsErrorCode.INVALID;
    default:
      return Enum$OrderSettingsErrorCode.$unknown;
  }
}

enum Enum$OrderSortField {
  NUMBER,
  RANK,
  CREATION_DATE,
  CREATED_AT,
  LAST_MODIFIED_AT,
  CUSTOMER,
  PAYMENT,
  FULFILLMENT_STATUS,
  $unknown;

  factory Enum$OrderSortField.fromJson(String value) =>
      fromJson$Enum$OrderSortField(value);

  String toJson() => toJson$Enum$OrderSortField(this);
}

String toJson$Enum$OrderSortField(Enum$OrderSortField e) {
  switch (e) {
    case Enum$OrderSortField.NUMBER:
      return r'NUMBER';
    case Enum$OrderSortField.RANK:
      return r'RANK';
    case Enum$OrderSortField.CREATION_DATE:
      return r'CREATION_DATE';
    case Enum$OrderSortField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$OrderSortField.LAST_MODIFIED_AT:
      return r'LAST_MODIFIED_AT';
    case Enum$OrderSortField.CUSTOMER:
      return r'CUSTOMER';
    case Enum$OrderSortField.PAYMENT:
      return r'PAYMENT';
    case Enum$OrderSortField.FULFILLMENT_STATUS:
      return r'FULFILLMENT_STATUS';
    case Enum$OrderSortField.$unknown:
      return r'$unknown';
  }
}

Enum$OrderSortField fromJson$Enum$OrderSortField(String value) {
  switch (value) {
    case r'NUMBER':
      return Enum$OrderSortField.NUMBER;
    case r'RANK':
      return Enum$OrderSortField.RANK;
    case r'CREATION_DATE':
      return Enum$OrderSortField.CREATION_DATE;
    case r'CREATED_AT':
      return Enum$OrderSortField.CREATED_AT;
    case r'LAST_MODIFIED_AT':
      return Enum$OrderSortField.LAST_MODIFIED_AT;
    case r'CUSTOMER':
      return Enum$OrderSortField.CUSTOMER;
    case r'PAYMENT':
      return Enum$OrderSortField.PAYMENT;
    case r'FULFILLMENT_STATUS':
      return Enum$OrderSortField.FULFILLMENT_STATUS;
    default:
      return Enum$OrderSortField.$unknown;
  }
}

enum Enum$OrderStatus {
  DRAFT,
  UNCONFIRMED,
  UNFULFILLED,
  PARTIALLY_FULFILLED,
  PARTIALLY_RETURNED,
  RETURNED,
  FULFILLED,
  CANCELED,
  EXPIRED,
  $unknown;

  factory Enum$OrderStatus.fromJson(String value) =>
      fromJson$Enum$OrderStatus(value);

  String toJson() => toJson$Enum$OrderStatus(this);
}

String toJson$Enum$OrderStatus(Enum$OrderStatus e) {
  switch (e) {
    case Enum$OrderStatus.DRAFT:
      return r'DRAFT';
    case Enum$OrderStatus.UNCONFIRMED:
      return r'UNCONFIRMED';
    case Enum$OrderStatus.UNFULFILLED:
      return r'UNFULFILLED';
    case Enum$OrderStatus.PARTIALLY_FULFILLED:
      return r'PARTIALLY_FULFILLED';
    case Enum$OrderStatus.PARTIALLY_RETURNED:
      return r'PARTIALLY_RETURNED';
    case Enum$OrderStatus.RETURNED:
      return r'RETURNED';
    case Enum$OrderStatus.FULFILLED:
      return r'FULFILLED';
    case Enum$OrderStatus.CANCELED:
      return r'CANCELED';
    case Enum$OrderStatus.EXPIRED:
      return r'EXPIRED';
    case Enum$OrderStatus.$unknown:
      return r'$unknown';
  }
}

Enum$OrderStatus fromJson$Enum$OrderStatus(String value) {
  switch (value) {
    case r'DRAFT':
      return Enum$OrderStatus.DRAFT;
    case r'UNCONFIRMED':
      return Enum$OrderStatus.UNCONFIRMED;
    case r'UNFULFILLED':
      return Enum$OrderStatus.UNFULFILLED;
    case r'PARTIALLY_FULFILLED':
      return Enum$OrderStatus.PARTIALLY_FULFILLED;
    case r'PARTIALLY_RETURNED':
      return Enum$OrderStatus.PARTIALLY_RETURNED;
    case r'RETURNED':
      return Enum$OrderStatus.RETURNED;
    case r'FULFILLED':
      return Enum$OrderStatus.FULFILLED;
    case r'CANCELED':
      return Enum$OrderStatus.CANCELED;
    case r'EXPIRED':
      return Enum$OrderStatus.EXPIRED;
    default:
      return Enum$OrderStatus.$unknown;
  }
}

enum Enum$OrderStatusFilter {
  READY_TO_FULFILL,
  READY_TO_CAPTURE,
  UNFULFILLED,
  UNCONFIRMED,
  PARTIALLY_FULFILLED,
  FULFILLED,
  CANCELED,
  $unknown;

  factory Enum$OrderStatusFilter.fromJson(String value) =>
      fromJson$Enum$OrderStatusFilter(value);

  String toJson() => toJson$Enum$OrderStatusFilter(this);
}

String toJson$Enum$OrderStatusFilter(Enum$OrderStatusFilter e) {
  switch (e) {
    case Enum$OrderStatusFilter.READY_TO_FULFILL:
      return r'READY_TO_FULFILL';
    case Enum$OrderStatusFilter.READY_TO_CAPTURE:
      return r'READY_TO_CAPTURE';
    case Enum$OrderStatusFilter.UNFULFILLED:
      return r'UNFULFILLED';
    case Enum$OrderStatusFilter.UNCONFIRMED:
      return r'UNCONFIRMED';
    case Enum$OrderStatusFilter.PARTIALLY_FULFILLED:
      return r'PARTIALLY_FULFILLED';
    case Enum$OrderStatusFilter.FULFILLED:
      return r'FULFILLED';
    case Enum$OrderStatusFilter.CANCELED:
      return r'CANCELED';
    case Enum$OrderStatusFilter.$unknown:
      return r'$unknown';
  }
}

Enum$OrderStatusFilter fromJson$Enum$OrderStatusFilter(String value) {
  switch (value) {
    case r'READY_TO_FULFILL':
      return Enum$OrderStatusFilter.READY_TO_FULFILL;
    case r'READY_TO_CAPTURE':
      return Enum$OrderStatusFilter.READY_TO_CAPTURE;
    case r'UNFULFILLED':
      return Enum$OrderStatusFilter.UNFULFILLED;
    case r'UNCONFIRMED':
      return Enum$OrderStatusFilter.UNCONFIRMED;
    case r'PARTIALLY_FULFILLED':
      return Enum$OrderStatusFilter.PARTIALLY_FULFILLED;
    case r'FULFILLED':
      return Enum$OrderStatusFilter.FULFILLED;
    case r'CANCELED':
      return Enum$OrderStatusFilter.CANCELED;
    default:
      return Enum$OrderStatusFilter.$unknown;
  }
}

enum Enum$PageErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  DUPLICATED_INPUT_ITEM,
  ATTRIBUTE_ALREADY_ASSIGNED,
  $unknown;

  factory Enum$PageErrorCode.fromJson(String value) =>
      fromJson$Enum$PageErrorCode(value);

  String toJson() => toJson$Enum$PageErrorCode(this);
}

String toJson$Enum$PageErrorCode(Enum$PageErrorCode e) {
  switch (e) {
    case Enum$PageErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$PageErrorCode.INVALID:
      return r'INVALID';
    case Enum$PageErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$PageErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$PageErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$PageErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$PageErrorCode.ATTRIBUTE_ALREADY_ASSIGNED:
      return r'ATTRIBUTE_ALREADY_ASSIGNED';
    case Enum$PageErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$PageErrorCode fromJson$Enum$PageErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$PageErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$PageErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$PageErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$PageErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$PageErrorCode.UNIQUE;
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$PageErrorCode.DUPLICATED_INPUT_ITEM;
    case r'ATTRIBUTE_ALREADY_ASSIGNED':
      return Enum$PageErrorCode.ATTRIBUTE_ALREADY_ASSIGNED;
    default:
      return Enum$PageErrorCode.$unknown;
  }
}

enum Enum$PageSortField {
  TITLE,
  SLUG,
  VISIBILITY,
  CREATION_DATE,
  PUBLICATION_DATE,
  PUBLISHED_AT,
  CREATED_AT,
  $unknown;

  factory Enum$PageSortField.fromJson(String value) =>
      fromJson$Enum$PageSortField(value);

  String toJson() => toJson$Enum$PageSortField(this);
}

String toJson$Enum$PageSortField(Enum$PageSortField e) {
  switch (e) {
    case Enum$PageSortField.TITLE:
      return r'TITLE';
    case Enum$PageSortField.SLUG:
      return r'SLUG';
    case Enum$PageSortField.VISIBILITY:
      return r'VISIBILITY';
    case Enum$PageSortField.CREATION_DATE:
      return r'CREATION_DATE';
    case Enum$PageSortField.PUBLICATION_DATE:
      return r'PUBLICATION_DATE';
    case Enum$PageSortField.PUBLISHED_AT:
      return r'PUBLISHED_AT';
    case Enum$PageSortField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$PageSortField.$unknown:
      return r'$unknown';
  }
}

Enum$PageSortField fromJson$Enum$PageSortField(String value) {
  switch (value) {
    case r'TITLE':
      return Enum$PageSortField.TITLE;
    case r'SLUG':
      return Enum$PageSortField.SLUG;
    case r'VISIBILITY':
      return Enum$PageSortField.VISIBILITY;
    case r'CREATION_DATE':
      return Enum$PageSortField.CREATION_DATE;
    case r'PUBLICATION_DATE':
      return Enum$PageSortField.PUBLICATION_DATE;
    case r'PUBLISHED_AT':
      return Enum$PageSortField.PUBLISHED_AT;
    case r'CREATED_AT':
      return Enum$PageSortField.CREATED_AT;
    default:
      return Enum$PageSortField.$unknown;
  }
}

enum Enum$PageTypeSortField {
  NAME,
  SLUG,
  $unknown;

  factory Enum$PageTypeSortField.fromJson(String value) =>
      fromJson$Enum$PageTypeSortField(value);

  String toJson() => toJson$Enum$PageTypeSortField(this);
}

String toJson$Enum$PageTypeSortField(Enum$PageTypeSortField e) {
  switch (e) {
    case Enum$PageTypeSortField.NAME:
      return r'NAME';
    case Enum$PageTypeSortField.SLUG:
      return r'SLUG';
    case Enum$PageTypeSortField.$unknown:
      return r'$unknown';
  }
}

Enum$PageTypeSortField fromJson$Enum$PageTypeSortField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$PageTypeSortField.NAME;
    case r'SLUG':
      return Enum$PageTypeSortField.SLUG;
    default:
      return Enum$PageTypeSortField.$unknown;
  }
}

enum Enum$PaymentChargeStatusEnum {
  NOT_CHARGED,
  PENDING,
  PARTIALLY_CHARGED,
  FULLY_CHARGED,
  PARTIALLY_REFUNDED,
  FULLY_REFUNDED,
  REFUSED,
  CANCELLED,
  $unknown;

  factory Enum$PaymentChargeStatusEnum.fromJson(String value) =>
      fromJson$Enum$PaymentChargeStatusEnum(value);

  String toJson() => toJson$Enum$PaymentChargeStatusEnum(this);
}

String toJson$Enum$PaymentChargeStatusEnum(Enum$PaymentChargeStatusEnum e) {
  switch (e) {
    case Enum$PaymentChargeStatusEnum.NOT_CHARGED:
      return r'NOT_CHARGED';
    case Enum$PaymentChargeStatusEnum.PENDING:
      return r'PENDING';
    case Enum$PaymentChargeStatusEnum.PARTIALLY_CHARGED:
      return r'PARTIALLY_CHARGED';
    case Enum$PaymentChargeStatusEnum.FULLY_CHARGED:
      return r'FULLY_CHARGED';
    case Enum$PaymentChargeStatusEnum.PARTIALLY_REFUNDED:
      return r'PARTIALLY_REFUNDED';
    case Enum$PaymentChargeStatusEnum.FULLY_REFUNDED:
      return r'FULLY_REFUNDED';
    case Enum$PaymentChargeStatusEnum.REFUSED:
      return r'REFUSED';
    case Enum$PaymentChargeStatusEnum.CANCELLED:
      return r'CANCELLED';
    case Enum$PaymentChargeStatusEnum.$unknown:
      return r'$unknown';
  }
}

Enum$PaymentChargeStatusEnum fromJson$Enum$PaymentChargeStatusEnum(
    String value) {
  switch (value) {
    case r'NOT_CHARGED':
      return Enum$PaymentChargeStatusEnum.NOT_CHARGED;
    case r'PENDING':
      return Enum$PaymentChargeStatusEnum.PENDING;
    case r'PARTIALLY_CHARGED':
      return Enum$PaymentChargeStatusEnum.PARTIALLY_CHARGED;
    case r'FULLY_CHARGED':
      return Enum$PaymentChargeStatusEnum.FULLY_CHARGED;
    case r'PARTIALLY_REFUNDED':
      return Enum$PaymentChargeStatusEnum.PARTIALLY_REFUNDED;
    case r'FULLY_REFUNDED':
      return Enum$PaymentChargeStatusEnum.FULLY_REFUNDED;
    case r'REFUSED':
      return Enum$PaymentChargeStatusEnum.REFUSED;
    case r'CANCELLED':
      return Enum$PaymentChargeStatusEnum.CANCELLED;
    default:
      return Enum$PaymentChargeStatusEnum.$unknown;
  }
}

enum Enum$PaymentErrorCode {
  BILLING_ADDRESS_NOT_SET,
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  PARTIAL_PAYMENT_NOT_ALLOWED,
  SHIPPING_ADDRESS_NOT_SET,
  INVALID_SHIPPING_METHOD,
  SHIPPING_METHOD_NOT_SET,
  PAYMENT_ERROR,
  NOT_SUPPORTED_GATEWAY,
  CHANNEL_INACTIVE,
  BALANCE_CHECK_ERROR,
  CHECKOUT_EMAIL_NOT_SET,
  UNAVAILABLE_VARIANT_IN_CHANNEL,
  NO_CHECKOUT_LINES,
  CHECKOUT_COMPLETION_IN_PROGRESS,
  $unknown;

  factory Enum$PaymentErrorCode.fromJson(String value) =>
      fromJson$Enum$PaymentErrorCode(value);

  String toJson() => toJson$Enum$PaymentErrorCode(this);
}

String toJson$Enum$PaymentErrorCode(Enum$PaymentErrorCode e) {
  switch (e) {
    case Enum$PaymentErrorCode.BILLING_ADDRESS_NOT_SET:
      return r'BILLING_ADDRESS_NOT_SET';
    case Enum$PaymentErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$PaymentErrorCode.INVALID:
      return r'INVALID';
    case Enum$PaymentErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$PaymentErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$PaymentErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$PaymentErrorCode.PARTIAL_PAYMENT_NOT_ALLOWED:
      return r'PARTIAL_PAYMENT_NOT_ALLOWED';
    case Enum$PaymentErrorCode.SHIPPING_ADDRESS_NOT_SET:
      return r'SHIPPING_ADDRESS_NOT_SET';
    case Enum$PaymentErrorCode.INVALID_SHIPPING_METHOD:
      return r'INVALID_SHIPPING_METHOD';
    case Enum$PaymentErrorCode.SHIPPING_METHOD_NOT_SET:
      return r'SHIPPING_METHOD_NOT_SET';
    case Enum$PaymentErrorCode.PAYMENT_ERROR:
      return r'PAYMENT_ERROR';
    case Enum$PaymentErrorCode.NOT_SUPPORTED_GATEWAY:
      return r'NOT_SUPPORTED_GATEWAY';
    case Enum$PaymentErrorCode.CHANNEL_INACTIVE:
      return r'CHANNEL_INACTIVE';
    case Enum$PaymentErrorCode.BALANCE_CHECK_ERROR:
      return r'BALANCE_CHECK_ERROR';
    case Enum$PaymentErrorCode.CHECKOUT_EMAIL_NOT_SET:
      return r'CHECKOUT_EMAIL_NOT_SET';
    case Enum$PaymentErrorCode.UNAVAILABLE_VARIANT_IN_CHANNEL:
      return r'UNAVAILABLE_VARIANT_IN_CHANNEL';
    case Enum$PaymentErrorCode.NO_CHECKOUT_LINES:
      return r'NO_CHECKOUT_LINES';
    case Enum$PaymentErrorCode.CHECKOUT_COMPLETION_IN_PROGRESS:
      return r'CHECKOUT_COMPLETION_IN_PROGRESS';
    case Enum$PaymentErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$PaymentErrorCode fromJson$Enum$PaymentErrorCode(String value) {
  switch (value) {
    case r'BILLING_ADDRESS_NOT_SET':
      return Enum$PaymentErrorCode.BILLING_ADDRESS_NOT_SET;
    case r'GRAPHQL_ERROR':
      return Enum$PaymentErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$PaymentErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$PaymentErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$PaymentErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$PaymentErrorCode.UNIQUE;
    case r'PARTIAL_PAYMENT_NOT_ALLOWED':
      return Enum$PaymentErrorCode.PARTIAL_PAYMENT_NOT_ALLOWED;
    case r'SHIPPING_ADDRESS_NOT_SET':
      return Enum$PaymentErrorCode.SHIPPING_ADDRESS_NOT_SET;
    case r'INVALID_SHIPPING_METHOD':
      return Enum$PaymentErrorCode.INVALID_SHIPPING_METHOD;
    case r'SHIPPING_METHOD_NOT_SET':
      return Enum$PaymentErrorCode.SHIPPING_METHOD_NOT_SET;
    case r'PAYMENT_ERROR':
      return Enum$PaymentErrorCode.PAYMENT_ERROR;
    case r'NOT_SUPPORTED_GATEWAY':
      return Enum$PaymentErrorCode.NOT_SUPPORTED_GATEWAY;
    case r'CHANNEL_INACTIVE':
      return Enum$PaymentErrorCode.CHANNEL_INACTIVE;
    case r'BALANCE_CHECK_ERROR':
      return Enum$PaymentErrorCode.BALANCE_CHECK_ERROR;
    case r'CHECKOUT_EMAIL_NOT_SET':
      return Enum$PaymentErrorCode.CHECKOUT_EMAIL_NOT_SET;
    case r'UNAVAILABLE_VARIANT_IN_CHANNEL':
      return Enum$PaymentErrorCode.UNAVAILABLE_VARIANT_IN_CHANNEL;
    case r'NO_CHECKOUT_LINES':
      return Enum$PaymentErrorCode.NO_CHECKOUT_LINES;
    case r'CHECKOUT_COMPLETION_IN_PROGRESS':
      return Enum$PaymentErrorCode.CHECKOUT_COMPLETION_IN_PROGRESS;
    default:
      return Enum$PaymentErrorCode.$unknown;
  }
}

enum Enum$PaymentGatewayConfigErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  $unknown;

  factory Enum$PaymentGatewayConfigErrorCode.fromJson(String value) =>
      fromJson$Enum$PaymentGatewayConfigErrorCode(value);

  String toJson() => toJson$Enum$PaymentGatewayConfigErrorCode(this);
}

String toJson$Enum$PaymentGatewayConfigErrorCode(
    Enum$PaymentGatewayConfigErrorCode e) {
  switch (e) {
    case Enum$PaymentGatewayConfigErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$PaymentGatewayConfigErrorCode.INVALID:
      return r'INVALID';
    case Enum$PaymentGatewayConfigErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$PaymentGatewayConfigErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$PaymentGatewayConfigErrorCode fromJson$Enum$PaymentGatewayConfigErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$PaymentGatewayConfigErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$PaymentGatewayConfigErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$PaymentGatewayConfigErrorCode.NOT_FOUND;
    default:
      return Enum$PaymentGatewayConfigErrorCode.$unknown;
  }
}

enum Enum$PaymentGatewayInitializeErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  $unknown;

  factory Enum$PaymentGatewayInitializeErrorCode.fromJson(String value) =>
      fromJson$Enum$PaymentGatewayInitializeErrorCode(value);

  String toJson() => toJson$Enum$PaymentGatewayInitializeErrorCode(this);
}

String toJson$Enum$PaymentGatewayInitializeErrorCode(
    Enum$PaymentGatewayInitializeErrorCode e) {
  switch (e) {
    case Enum$PaymentGatewayInitializeErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$PaymentGatewayInitializeErrorCode.INVALID:
      return r'INVALID';
    case Enum$PaymentGatewayInitializeErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$PaymentGatewayInitializeErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$PaymentGatewayInitializeErrorCode
    fromJson$Enum$PaymentGatewayInitializeErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$PaymentGatewayInitializeErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$PaymentGatewayInitializeErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$PaymentGatewayInitializeErrorCode.NOT_FOUND;
    default:
      return Enum$PaymentGatewayInitializeErrorCode.$unknown;
  }
}

enum Enum$PaymentGatewayInitializeTokenizationErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  CHANNEL_INACTIVE,
  GATEWAY_ERROR,
  $unknown;

  factory Enum$PaymentGatewayInitializeTokenizationErrorCode.fromJson(
          String value) =>
      fromJson$Enum$PaymentGatewayInitializeTokenizationErrorCode(value);

  String toJson() =>
      toJson$Enum$PaymentGatewayInitializeTokenizationErrorCode(this);
}

String toJson$Enum$PaymentGatewayInitializeTokenizationErrorCode(
    Enum$PaymentGatewayInitializeTokenizationErrorCode e) {
  switch (e) {
    case Enum$PaymentGatewayInitializeTokenizationErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$PaymentGatewayInitializeTokenizationErrorCode.INVALID:
      return r'INVALID';
    case Enum$PaymentGatewayInitializeTokenizationErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$PaymentGatewayInitializeTokenizationErrorCode.CHANNEL_INACTIVE:
      return r'CHANNEL_INACTIVE';
    case Enum$PaymentGatewayInitializeTokenizationErrorCode.GATEWAY_ERROR:
      return r'GATEWAY_ERROR';
    case Enum$PaymentGatewayInitializeTokenizationErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$PaymentGatewayInitializeTokenizationErrorCode
    fromJson$Enum$PaymentGatewayInitializeTokenizationErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$PaymentGatewayInitializeTokenizationErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$PaymentGatewayInitializeTokenizationErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$PaymentGatewayInitializeTokenizationErrorCode.NOT_FOUND;
    case r'CHANNEL_INACTIVE':
      return Enum$PaymentGatewayInitializeTokenizationErrorCode
          .CHANNEL_INACTIVE;
    case r'GATEWAY_ERROR':
      return Enum$PaymentGatewayInitializeTokenizationErrorCode.GATEWAY_ERROR;
    default:
      return Enum$PaymentGatewayInitializeTokenizationErrorCode.$unknown;
  }
}

enum Enum$PaymentGatewayInitializeTokenizationResult {
  SUCCESSFULLY_INITIALIZED,
  FAILED_TO_INITIALIZE,
  FAILED_TO_DELIVER,
  $unknown;

  factory Enum$PaymentGatewayInitializeTokenizationResult.fromJson(
          String value) =>
      fromJson$Enum$PaymentGatewayInitializeTokenizationResult(value);

  String toJson() =>
      toJson$Enum$PaymentGatewayInitializeTokenizationResult(this);
}

String toJson$Enum$PaymentGatewayInitializeTokenizationResult(
    Enum$PaymentGatewayInitializeTokenizationResult e) {
  switch (e) {
    case Enum$PaymentGatewayInitializeTokenizationResult
          .SUCCESSFULLY_INITIALIZED:
      return r'SUCCESSFULLY_INITIALIZED';
    case Enum$PaymentGatewayInitializeTokenizationResult.FAILED_TO_INITIALIZE:
      return r'FAILED_TO_INITIALIZE';
    case Enum$PaymentGatewayInitializeTokenizationResult.FAILED_TO_DELIVER:
      return r'FAILED_TO_DELIVER';
    case Enum$PaymentGatewayInitializeTokenizationResult.$unknown:
      return r'$unknown';
  }
}

Enum$PaymentGatewayInitializeTokenizationResult
    fromJson$Enum$PaymentGatewayInitializeTokenizationResult(String value) {
  switch (value) {
    case r'SUCCESSFULLY_INITIALIZED':
      return Enum$PaymentGatewayInitializeTokenizationResult
          .SUCCESSFULLY_INITIALIZED;
    case r'FAILED_TO_INITIALIZE':
      return Enum$PaymentGatewayInitializeTokenizationResult
          .FAILED_TO_INITIALIZE;
    case r'FAILED_TO_DELIVER':
      return Enum$PaymentGatewayInitializeTokenizationResult.FAILED_TO_DELIVER;
    default:
      return Enum$PaymentGatewayInitializeTokenizationResult.$unknown;
  }
}

enum Enum$PaymentMethodInitializeTokenizationErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  CHANNEL_INACTIVE,
  GATEWAY_ERROR,
  $unknown;

  factory Enum$PaymentMethodInitializeTokenizationErrorCode.fromJson(
          String value) =>
      fromJson$Enum$PaymentMethodInitializeTokenizationErrorCode(value);

  String toJson() =>
      toJson$Enum$PaymentMethodInitializeTokenizationErrorCode(this);
}

String toJson$Enum$PaymentMethodInitializeTokenizationErrorCode(
    Enum$PaymentMethodInitializeTokenizationErrorCode e) {
  switch (e) {
    case Enum$PaymentMethodInitializeTokenizationErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$PaymentMethodInitializeTokenizationErrorCode.INVALID:
      return r'INVALID';
    case Enum$PaymentMethodInitializeTokenizationErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$PaymentMethodInitializeTokenizationErrorCode.CHANNEL_INACTIVE:
      return r'CHANNEL_INACTIVE';
    case Enum$PaymentMethodInitializeTokenizationErrorCode.GATEWAY_ERROR:
      return r'GATEWAY_ERROR';
    case Enum$PaymentMethodInitializeTokenizationErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$PaymentMethodInitializeTokenizationErrorCode
    fromJson$Enum$PaymentMethodInitializeTokenizationErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$PaymentMethodInitializeTokenizationErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$PaymentMethodInitializeTokenizationErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$PaymentMethodInitializeTokenizationErrorCode.NOT_FOUND;
    case r'CHANNEL_INACTIVE':
      return Enum$PaymentMethodInitializeTokenizationErrorCode.CHANNEL_INACTIVE;
    case r'GATEWAY_ERROR':
      return Enum$PaymentMethodInitializeTokenizationErrorCode.GATEWAY_ERROR;
    default:
      return Enum$PaymentMethodInitializeTokenizationErrorCode.$unknown;
  }
}

enum Enum$PaymentMethodProcessTokenizationErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  CHANNEL_INACTIVE,
  GATEWAY_ERROR,
  $unknown;

  factory Enum$PaymentMethodProcessTokenizationErrorCode.fromJson(
          String value) =>
      fromJson$Enum$PaymentMethodProcessTokenizationErrorCode(value);

  String toJson() =>
      toJson$Enum$PaymentMethodProcessTokenizationErrorCode(this);
}

String toJson$Enum$PaymentMethodProcessTokenizationErrorCode(
    Enum$PaymentMethodProcessTokenizationErrorCode e) {
  switch (e) {
    case Enum$PaymentMethodProcessTokenizationErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$PaymentMethodProcessTokenizationErrorCode.INVALID:
      return r'INVALID';
    case Enum$PaymentMethodProcessTokenizationErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$PaymentMethodProcessTokenizationErrorCode.CHANNEL_INACTIVE:
      return r'CHANNEL_INACTIVE';
    case Enum$PaymentMethodProcessTokenizationErrorCode.GATEWAY_ERROR:
      return r'GATEWAY_ERROR';
    case Enum$PaymentMethodProcessTokenizationErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$PaymentMethodProcessTokenizationErrorCode
    fromJson$Enum$PaymentMethodProcessTokenizationErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$PaymentMethodProcessTokenizationErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$PaymentMethodProcessTokenizationErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$PaymentMethodProcessTokenizationErrorCode.NOT_FOUND;
    case r'CHANNEL_INACTIVE':
      return Enum$PaymentMethodProcessTokenizationErrorCode.CHANNEL_INACTIVE;
    case r'GATEWAY_ERROR':
      return Enum$PaymentMethodProcessTokenizationErrorCode.GATEWAY_ERROR;
    default:
      return Enum$PaymentMethodProcessTokenizationErrorCode.$unknown;
  }
}

enum Enum$PaymentMethodTokenizationResult {
  SUCCESSFULLY_TOKENIZED,
  PENDING,
  ADDITIONAL_ACTION_REQUIRED,
  FAILED_TO_TOKENIZE,
  FAILED_TO_DELIVER,
  $unknown;

  factory Enum$PaymentMethodTokenizationResult.fromJson(String value) =>
      fromJson$Enum$PaymentMethodTokenizationResult(value);

  String toJson() => toJson$Enum$PaymentMethodTokenizationResult(this);
}

String toJson$Enum$PaymentMethodTokenizationResult(
    Enum$PaymentMethodTokenizationResult e) {
  switch (e) {
    case Enum$PaymentMethodTokenizationResult.SUCCESSFULLY_TOKENIZED:
      return r'SUCCESSFULLY_TOKENIZED';
    case Enum$PaymentMethodTokenizationResult.PENDING:
      return r'PENDING';
    case Enum$PaymentMethodTokenizationResult.ADDITIONAL_ACTION_REQUIRED:
      return r'ADDITIONAL_ACTION_REQUIRED';
    case Enum$PaymentMethodTokenizationResult.FAILED_TO_TOKENIZE:
      return r'FAILED_TO_TOKENIZE';
    case Enum$PaymentMethodTokenizationResult.FAILED_TO_DELIVER:
      return r'FAILED_TO_DELIVER';
    case Enum$PaymentMethodTokenizationResult.$unknown:
      return r'$unknown';
  }
}

Enum$PaymentMethodTokenizationResult
    fromJson$Enum$PaymentMethodTokenizationResult(String value) {
  switch (value) {
    case r'SUCCESSFULLY_TOKENIZED':
      return Enum$PaymentMethodTokenizationResult.SUCCESSFULLY_TOKENIZED;
    case r'PENDING':
      return Enum$PaymentMethodTokenizationResult.PENDING;
    case r'ADDITIONAL_ACTION_REQUIRED':
      return Enum$PaymentMethodTokenizationResult.ADDITIONAL_ACTION_REQUIRED;
    case r'FAILED_TO_TOKENIZE':
      return Enum$PaymentMethodTokenizationResult.FAILED_TO_TOKENIZE;
    case r'FAILED_TO_DELIVER':
      return Enum$PaymentMethodTokenizationResult.FAILED_TO_DELIVER;
    default:
      return Enum$PaymentMethodTokenizationResult.$unknown;
  }
}

enum Enum$PermissionEnum {
  MANAGE_USERS,
  MANAGE_STAFF,
  IMPERSONATE_USER,
  MANAGE_APPS,
  MANAGE_OBSERVABILITY,
  MANAGE_CHECKOUTS,
  HANDLE_CHECKOUTS,
  HANDLE_TAXES,
  MANAGE_TAXES,
  MANAGE_CHANNELS,
  MANAGE_DISCOUNTS,
  MANAGE_GIFT_CARD,
  MANAGE_MENUS,
  MANAGE_ORDERS,
  MANAGE_ORDERS_IMPORT,
  MANAGE_PAGES,
  MANAGE_PAGE_TYPES_AND_ATTRIBUTES,
  HANDLE_PAYMENTS,
  MANAGE_PLUGINS,
  MANAGE_PRODUCTS,
  MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES,
  MANAGE_SHIPPING,
  MANAGE_SETTINGS,
  MANAGE_TRANSLATIONS,
  $unknown;

  factory Enum$PermissionEnum.fromJson(String value) =>
      fromJson$Enum$PermissionEnum(value);

  String toJson() => toJson$Enum$PermissionEnum(this);
}

String toJson$Enum$PermissionEnum(Enum$PermissionEnum e) {
  switch (e) {
    case Enum$PermissionEnum.MANAGE_USERS:
      return r'MANAGE_USERS';
    case Enum$PermissionEnum.MANAGE_STAFF:
      return r'MANAGE_STAFF';
    case Enum$PermissionEnum.IMPERSONATE_USER:
      return r'IMPERSONATE_USER';
    case Enum$PermissionEnum.MANAGE_APPS:
      return r'MANAGE_APPS';
    case Enum$PermissionEnum.MANAGE_OBSERVABILITY:
      return r'MANAGE_OBSERVABILITY';
    case Enum$PermissionEnum.MANAGE_CHECKOUTS:
      return r'MANAGE_CHECKOUTS';
    case Enum$PermissionEnum.HANDLE_CHECKOUTS:
      return r'HANDLE_CHECKOUTS';
    case Enum$PermissionEnum.HANDLE_TAXES:
      return r'HANDLE_TAXES';
    case Enum$PermissionEnum.MANAGE_TAXES:
      return r'MANAGE_TAXES';
    case Enum$PermissionEnum.MANAGE_CHANNELS:
      return r'MANAGE_CHANNELS';
    case Enum$PermissionEnum.MANAGE_DISCOUNTS:
      return r'MANAGE_DISCOUNTS';
    case Enum$PermissionEnum.MANAGE_GIFT_CARD:
      return r'MANAGE_GIFT_CARD';
    case Enum$PermissionEnum.MANAGE_MENUS:
      return r'MANAGE_MENUS';
    case Enum$PermissionEnum.MANAGE_ORDERS:
      return r'MANAGE_ORDERS';
    case Enum$PermissionEnum.MANAGE_ORDERS_IMPORT:
      return r'MANAGE_ORDERS_IMPORT';
    case Enum$PermissionEnum.MANAGE_PAGES:
      return r'MANAGE_PAGES';
    case Enum$PermissionEnum.MANAGE_PAGE_TYPES_AND_ATTRIBUTES:
      return r'MANAGE_PAGE_TYPES_AND_ATTRIBUTES';
    case Enum$PermissionEnum.HANDLE_PAYMENTS:
      return r'HANDLE_PAYMENTS';
    case Enum$PermissionEnum.MANAGE_PLUGINS:
      return r'MANAGE_PLUGINS';
    case Enum$PermissionEnum.MANAGE_PRODUCTS:
      return r'MANAGE_PRODUCTS';
    case Enum$PermissionEnum.MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES:
      return r'MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES';
    case Enum$PermissionEnum.MANAGE_SHIPPING:
      return r'MANAGE_SHIPPING';
    case Enum$PermissionEnum.MANAGE_SETTINGS:
      return r'MANAGE_SETTINGS';
    case Enum$PermissionEnum.MANAGE_TRANSLATIONS:
      return r'MANAGE_TRANSLATIONS';
    case Enum$PermissionEnum.$unknown:
      return r'$unknown';
  }
}

Enum$PermissionEnum fromJson$Enum$PermissionEnum(String value) {
  switch (value) {
    case r'MANAGE_USERS':
      return Enum$PermissionEnum.MANAGE_USERS;
    case r'MANAGE_STAFF':
      return Enum$PermissionEnum.MANAGE_STAFF;
    case r'IMPERSONATE_USER':
      return Enum$PermissionEnum.IMPERSONATE_USER;
    case r'MANAGE_APPS':
      return Enum$PermissionEnum.MANAGE_APPS;
    case r'MANAGE_OBSERVABILITY':
      return Enum$PermissionEnum.MANAGE_OBSERVABILITY;
    case r'MANAGE_CHECKOUTS':
      return Enum$PermissionEnum.MANAGE_CHECKOUTS;
    case r'HANDLE_CHECKOUTS':
      return Enum$PermissionEnum.HANDLE_CHECKOUTS;
    case r'HANDLE_TAXES':
      return Enum$PermissionEnum.HANDLE_TAXES;
    case r'MANAGE_TAXES':
      return Enum$PermissionEnum.MANAGE_TAXES;
    case r'MANAGE_CHANNELS':
      return Enum$PermissionEnum.MANAGE_CHANNELS;
    case r'MANAGE_DISCOUNTS':
      return Enum$PermissionEnum.MANAGE_DISCOUNTS;
    case r'MANAGE_GIFT_CARD':
      return Enum$PermissionEnum.MANAGE_GIFT_CARD;
    case r'MANAGE_MENUS':
      return Enum$PermissionEnum.MANAGE_MENUS;
    case r'MANAGE_ORDERS':
      return Enum$PermissionEnum.MANAGE_ORDERS;
    case r'MANAGE_ORDERS_IMPORT':
      return Enum$PermissionEnum.MANAGE_ORDERS_IMPORT;
    case r'MANAGE_PAGES':
      return Enum$PermissionEnum.MANAGE_PAGES;
    case r'MANAGE_PAGE_TYPES_AND_ATTRIBUTES':
      return Enum$PermissionEnum.MANAGE_PAGE_TYPES_AND_ATTRIBUTES;
    case r'HANDLE_PAYMENTS':
      return Enum$PermissionEnum.HANDLE_PAYMENTS;
    case r'MANAGE_PLUGINS':
      return Enum$PermissionEnum.MANAGE_PLUGINS;
    case r'MANAGE_PRODUCTS':
      return Enum$PermissionEnum.MANAGE_PRODUCTS;
    case r'MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES':
      return Enum$PermissionEnum.MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES;
    case r'MANAGE_SHIPPING':
      return Enum$PermissionEnum.MANAGE_SHIPPING;
    case r'MANAGE_SETTINGS':
      return Enum$PermissionEnum.MANAGE_SETTINGS;
    case r'MANAGE_TRANSLATIONS':
      return Enum$PermissionEnum.MANAGE_TRANSLATIONS;
    default:
      return Enum$PermissionEnum.$unknown;
  }
}

enum Enum$PermissionGroupErrorCode {
  REQUIRED,
  UNIQUE,
  ASSIGN_NON_STAFF_MEMBER,
  DUPLICATED_INPUT_ITEM,
  CANNOT_REMOVE_FROM_LAST_GROUP,
  LEFT_NOT_MANAGEABLE_PERMISSION,
  OUT_OF_SCOPE_PERMISSION,
  OUT_OF_SCOPE_USER,
  OUT_OF_SCOPE_CHANNEL,
  $unknown;

  factory Enum$PermissionGroupErrorCode.fromJson(String value) =>
      fromJson$Enum$PermissionGroupErrorCode(value);

  String toJson() => toJson$Enum$PermissionGroupErrorCode(this);
}

String toJson$Enum$PermissionGroupErrorCode(Enum$PermissionGroupErrorCode e) {
  switch (e) {
    case Enum$PermissionGroupErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$PermissionGroupErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$PermissionGroupErrorCode.ASSIGN_NON_STAFF_MEMBER:
      return r'ASSIGN_NON_STAFF_MEMBER';
    case Enum$PermissionGroupErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$PermissionGroupErrorCode.CANNOT_REMOVE_FROM_LAST_GROUP:
      return r'CANNOT_REMOVE_FROM_LAST_GROUP';
    case Enum$PermissionGroupErrorCode.LEFT_NOT_MANAGEABLE_PERMISSION:
      return r'LEFT_NOT_MANAGEABLE_PERMISSION';
    case Enum$PermissionGroupErrorCode.OUT_OF_SCOPE_PERMISSION:
      return r'OUT_OF_SCOPE_PERMISSION';
    case Enum$PermissionGroupErrorCode.OUT_OF_SCOPE_USER:
      return r'OUT_OF_SCOPE_USER';
    case Enum$PermissionGroupErrorCode.OUT_OF_SCOPE_CHANNEL:
      return r'OUT_OF_SCOPE_CHANNEL';
    case Enum$PermissionGroupErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$PermissionGroupErrorCode fromJson$Enum$PermissionGroupErrorCode(
    String value) {
  switch (value) {
    case r'REQUIRED':
      return Enum$PermissionGroupErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$PermissionGroupErrorCode.UNIQUE;
    case r'ASSIGN_NON_STAFF_MEMBER':
      return Enum$PermissionGroupErrorCode.ASSIGN_NON_STAFF_MEMBER;
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$PermissionGroupErrorCode.DUPLICATED_INPUT_ITEM;
    case r'CANNOT_REMOVE_FROM_LAST_GROUP':
      return Enum$PermissionGroupErrorCode.CANNOT_REMOVE_FROM_LAST_GROUP;
    case r'LEFT_NOT_MANAGEABLE_PERMISSION':
      return Enum$PermissionGroupErrorCode.LEFT_NOT_MANAGEABLE_PERMISSION;
    case r'OUT_OF_SCOPE_PERMISSION':
      return Enum$PermissionGroupErrorCode.OUT_OF_SCOPE_PERMISSION;
    case r'OUT_OF_SCOPE_USER':
      return Enum$PermissionGroupErrorCode.OUT_OF_SCOPE_USER;
    case r'OUT_OF_SCOPE_CHANNEL':
      return Enum$PermissionGroupErrorCode.OUT_OF_SCOPE_CHANNEL;
    default:
      return Enum$PermissionGroupErrorCode.$unknown;
  }
}

enum Enum$PermissionGroupSortField {
  NAME,
  $unknown;

  factory Enum$PermissionGroupSortField.fromJson(String value) =>
      fromJson$Enum$PermissionGroupSortField(value);

  String toJson() => toJson$Enum$PermissionGroupSortField(this);
}

String toJson$Enum$PermissionGroupSortField(Enum$PermissionGroupSortField e) {
  switch (e) {
    case Enum$PermissionGroupSortField.NAME:
      return r'NAME';
    case Enum$PermissionGroupSortField.$unknown:
      return r'$unknown';
  }
}

Enum$PermissionGroupSortField fromJson$Enum$PermissionGroupSortField(
    String value) {
  switch (value) {
    case r'NAME':
      return Enum$PermissionGroupSortField.NAME;
    default:
      return Enum$PermissionGroupSortField.$unknown;
  }
}

enum Enum$PluginConfigurationType {
  PER_CHANNEL,
  GLOBAL,
  $unknown;

  factory Enum$PluginConfigurationType.fromJson(String value) =>
      fromJson$Enum$PluginConfigurationType(value);

  String toJson() => toJson$Enum$PluginConfigurationType(this);
}

String toJson$Enum$PluginConfigurationType(Enum$PluginConfigurationType e) {
  switch (e) {
    case Enum$PluginConfigurationType.PER_CHANNEL:
      return r'PER_CHANNEL';
    case Enum$PluginConfigurationType.GLOBAL:
      return r'GLOBAL';
    case Enum$PluginConfigurationType.$unknown:
      return r'$unknown';
  }
}

Enum$PluginConfigurationType fromJson$Enum$PluginConfigurationType(
    String value) {
  switch (value) {
    case r'PER_CHANNEL':
      return Enum$PluginConfigurationType.PER_CHANNEL;
    case r'GLOBAL':
      return Enum$PluginConfigurationType.GLOBAL;
    default:
      return Enum$PluginConfigurationType.$unknown;
  }
}

enum Enum$PluginErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  PLUGIN_MISCONFIGURED,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  $unknown;

  factory Enum$PluginErrorCode.fromJson(String value) =>
      fromJson$Enum$PluginErrorCode(value);

  String toJson() => toJson$Enum$PluginErrorCode(this);
}

String toJson$Enum$PluginErrorCode(Enum$PluginErrorCode e) {
  switch (e) {
    case Enum$PluginErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$PluginErrorCode.INVALID:
      return r'INVALID';
    case Enum$PluginErrorCode.PLUGIN_MISCONFIGURED:
      return r'PLUGIN_MISCONFIGURED';
    case Enum$PluginErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$PluginErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$PluginErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$PluginErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$PluginErrorCode fromJson$Enum$PluginErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$PluginErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$PluginErrorCode.INVALID;
    case r'PLUGIN_MISCONFIGURED':
      return Enum$PluginErrorCode.PLUGIN_MISCONFIGURED;
    case r'NOT_FOUND':
      return Enum$PluginErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$PluginErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$PluginErrorCode.UNIQUE;
    default:
      return Enum$PluginErrorCode.$unknown;
  }
}

enum Enum$PluginSortField {
  NAME,
  IS_ACTIVE,
  $unknown;

  factory Enum$PluginSortField.fromJson(String value) =>
      fromJson$Enum$PluginSortField(value);

  String toJson() => toJson$Enum$PluginSortField(this);
}

String toJson$Enum$PluginSortField(Enum$PluginSortField e) {
  switch (e) {
    case Enum$PluginSortField.NAME:
      return r'NAME';
    case Enum$PluginSortField.IS_ACTIVE:
      return r'IS_ACTIVE';
    case Enum$PluginSortField.$unknown:
      return r'$unknown';
  }
}

Enum$PluginSortField fromJson$Enum$PluginSortField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$PluginSortField.NAME;
    case r'IS_ACTIVE':
      return Enum$PluginSortField.IS_ACTIVE;
    default:
      return Enum$PluginSortField.$unknown;
  }
}

enum Enum$PostalCodeRuleInclusionTypeEnum {
  INCLUDE,
  EXCLUDE,
  $unknown;

  factory Enum$PostalCodeRuleInclusionTypeEnum.fromJson(String value) =>
      fromJson$Enum$PostalCodeRuleInclusionTypeEnum(value);

  String toJson() => toJson$Enum$PostalCodeRuleInclusionTypeEnum(this);
}

String toJson$Enum$PostalCodeRuleInclusionTypeEnum(
    Enum$PostalCodeRuleInclusionTypeEnum e) {
  switch (e) {
    case Enum$PostalCodeRuleInclusionTypeEnum.INCLUDE:
      return r'INCLUDE';
    case Enum$PostalCodeRuleInclusionTypeEnum.EXCLUDE:
      return r'EXCLUDE';
    case Enum$PostalCodeRuleInclusionTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$PostalCodeRuleInclusionTypeEnum
    fromJson$Enum$PostalCodeRuleInclusionTypeEnum(String value) {
  switch (value) {
    case r'INCLUDE':
      return Enum$PostalCodeRuleInclusionTypeEnum.INCLUDE;
    case r'EXCLUDE':
      return Enum$PostalCodeRuleInclusionTypeEnum.EXCLUDE;
    default:
      return Enum$PostalCodeRuleInclusionTypeEnum.$unknown;
  }
}

enum Enum$ProductAttributeType {
  PRODUCT,
  VARIANT,
  $unknown;

  factory Enum$ProductAttributeType.fromJson(String value) =>
      fromJson$Enum$ProductAttributeType(value);

  String toJson() => toJson$Enum$ProductAttributeType(this);
}

String toJson$Enum$ProductAttributeType(Enum$ProductAttributeType e) {
  switch (e) {
    case Enum$ProductAttributeType.PRODUCT:
      return r'PRODUCT';
    case Enum$ProductAttributeType.VARIANT:
      return r'VARIANT';
    case Enum$ProductAttributeType.$unknown:
      return r'$unknown';
  }
}

Enum$ProductAttributeType fromJson$Enum$ProductAttributeType(String value) {
  switch (value) {
    case r'PRODUCT':
      return Enum$ProductAttributeType.PRODUCT;
    case r'VARIANT':
      return Enum$ProductAttributeType.VARIANT;
    default:
      return Enum$ProductAttributeType.$unknown;
  }
}

enum Enum$ProductBulkCreateErrorCode {
  ATTRIBUTE_ALREADY_ASSIGNED,
  ATTRIBUTE_CANNOT_BE_ASSIGNED,
  ATTRIBUTE_VARIANTS_DISABLED,
  BLANK,
  MAX_LENGTH,
  DUPLICATED_INPUT_ITEM,
  GRAPHQL_ERROR,
  INVALID,
  INVALID_PRICE,
  PRODUCT_WITHOUT_CATEGORY,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  PRODUCT_NOT_ASSIGNED_TO_CHANNEL,
  UNSUPPORTED_MEDIA_PROVIDER,
  $unknown;

  factory Enum$ProductBulkCreateErrorCode.fromJson(String value) =>
      fromJson$Enum$ProductBulkCreateErrorCode(value);

  String toJson() => toJson$Enum$ProductBulkCreateErrorCode(this);
}

String toJson$Enum$ProductBulkCreateErrorCode(
    Enum$ProductBulkCreateErrorCode e) {
  switch (e) {
    case Enum$ProductBulkCreateErrorCode.ATTRIBUTE_ALREADY_ASSIGNED:
      return r'ATTRIBUTE_ALREADY_ASSIGNED';
    case Enum$ProductBulkCreateErrorCode.ATTRIBUTE_CANNOT_BE_ASSIGNED:
      return r'ATTRIBUTE_CANNOT_BE_ASSIGNED';
    case Enum$ProductBulkCreateErrorCode.ATTRIBUTE_VARIANTS_DISABLED:
      return r'ATTRIBUTE_VARIANTS_DISABLED';
    case Enum$ProductBulkCreateErrorCode.BLANK:
      return r'BLANK';
    case Enum$ProductBulkCreateErrorCode.MAX_LENGTH:
      return r'MAX_LENGTH';
    case Enum$ProductBulkCreateErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$ProductBulkCreateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$ProductBulkCreateErrorCode.INVALID:
      return r'INVALID';
    case Enum$ProductBulkCreateErrorCode.INVALID_PRICE:
      return r'INVALID_PRICE';
    case Enum$ProductBulkCreateErrorCode.PRODUCT_WITHOUT_CATEGORY:
      return r'PRODUCT_WITHOUT_CATEGORY';
    case Enum$ProductBulkCreateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$ProductBulkCreateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$ProductBulkCreateErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$ProductBulkCreateErrorCode.PRODUCT_NOT_ASSIGNED_TO_CHANNEL:
      return r'PRODUCT_NOT_ASSIGNED_TO_CHANNEL';
    case Enum$ProductBulkCreateErrorCode.UNSUPPORTED_MEDIA_PROVIDER:
      return r'UNSUPPORTED_MEDIA_PROVIDER';
    case Enum$ProductBulkCreateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$ProductBulkCreateErrorCode fromJson$Enum$ProductBulkCreateErrorCode(
    String value) {
  switch (value) {
    case r'ATTRIBUTE_ALREADY_ASSIGNED':
      return Enum$ProductBulkCreateErrorCode.ATTRIBUTE_ALREADY_ASSIGNED;
    case r'ATTRIBUTE_CANNOT_BE_ASSIGNED':
      return Enum$ProductBulkCreateErrorCode.ATTRIBUTE_CANNOT_BE_ASSIGNED;
    case r'ATTRIBUTE_VARIANTS_DISABLED':
      return Enum$ProductBulkCreateErrorCode.ATTRIBUTE_VARIANTS_DISABLED;
    case r'BLANK':
      return Enum$ProductBulkCreateErrorCode.BLANK;
    case r'MAX_LENGTH':
      return Enum$ProductBulkCreateErrorCode.MAX_LENGTH;
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$ProductBulkCreateErrorCode.DUPLICATED_INPUT_ITEM;
    case r'GRAPHQL_ERROR':
      return Enum$ProductBulkCreateErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$ProductBulkCreateErrorCode.INVALID;
    case r'INVALID_PRICE':
      return Enum$ProductBulkCreateErrorCode.INVALID_PRICE;
    case r'PRODUCT_WITHOUT_CATEGORY':
      return Enum$ProductBulkCreateErrorCode.PRODUCT_WITHOUT_CATEGORY;
    case r'NOT_FOUND':
      return Enum$ProductBulkCreateErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$ProductBulkCreateErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$ProductBulkCreateErrorCode.UNIQUE;
    case r'PRODUCT_NOT_ASSIGNED_TO_CHANNEL':
      return Enum$ProductBulkCreateErrorCode.PRODUCT_NOT_ASSIGNED_TO_CHANNEL;
    case r'UNSUPPORTED_MEDIA_PROVIDER':
      return Enum$ProductBulkCreateErrorCode.UNSUPPORTED_MEDIA_PROVIDER;
    default:
      return Enum$ProductBulkCreateErrorCode.$unknown;
  }
}

enum Enum$ProductErrorCode {
  ALREADY_EXISTS,
  ATTRIBUTE_ALREADY_ASSIGNED,
  ATTRIBUTE_CANNOT_BE_ASSIGNED,
  ATTRIBUTE_VARIANTS_DISABLED,
  MEDIA_ALREADY_ASSIGNED,
  DUPLICATED_INPUT_ITEM,
  GRAPHQL_ERROR,
  INVALID,
  INVALID_PRICE,
  PRODUCT_WITHOUT_CATEGORY,
  NOT_PRODUCTS_IMAGE,
  NOT_PRODUCTS_VARIANT,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  VARIANT_NO_DIGITAL_CONTENT,
  CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT,
  PRODUCT_NOT_ASSIGNED_TO_CHANNEL,
  UNSUPPORTED_MEDIA_PROVIDER,
  PREORDER_VARIANT_CANNOT_BE_DEACTIVATED,
  $unknown;

  factory Enum$ProductErrorCode.fromJson(String value) =>
      fromJson$Enum$ProductErrorCode(value);

  String toJson() => toJson$Enum$ProductErrorCode(this);
}

String toJson$Enum$ProductErrorCode(Enum$ProductErrorCode e) {
  switch (e) {
    case Enum$ProductErrorCode.ALREADY_EXISTS:
      return r'ALREADY_EXISTS';
    case Enum$ProductErrorCode.ATTRIBUTE_ALREADY_ASSIGNED:
      return r'ATTRIBUTE_ALREADY_ASSIGNED';
    case Enum$ProductErrorCode.ATTRIBUTE_CANNOT_BE_ASSIGNED:
      return r'ATTRIBUTE_CANNOT_BE_ASSIGNED';
    case Enum$ProductErrorCode.ATTRIBUTE_VARIANTS_DISABLED:
      return r'ATTRIBUTE_VARIANTS_DISABLED';
    case Enum$ProductErrorCode.MEDIA_ALREADY_ASSIGNED:
      return r'MEDIA_ALREADY_ASSIGNED';
    case Enum$ProductErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$ProductErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$ProductErrorCode.INVALID:
      return r'INVALID';
    case Enum$ProductErrorCode.INVALID_PRICE:
      return r'INVALID_PRICE';
    case Enum$ProductErrorCode.PRODUCT_WITHOUT_CATEGORY:
      return r'PRODUCT_WITHOUT_CATEGORY';
    case Enum$ProductErrorCode.NOT_PRODUCTS_IMAGE:
      return r'NOT_PRODUCTS_IMAGE';
    case Enum$ProductErrorCode.NOT_PRODUCTS_VARIANT:
      return r'NOT_PRODUCTS_VARIANT';
    case Enum$ProductErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$ProductErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$ProductErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$ProductErrorCode.VARIANT_NO_DIGITAL_CONTENT:
      return r'VARIANT_NO_DIGITAL_CONTENT';
    case Enum$ProductErrorCode.CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT:
      return r'CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT';
    case Enum$ProductErrorCode.PRODUCT_NOT_ASSIGNED_TO_CHANNEL:
      return r'PRODUCT_NOT_ASSIGNED_TO_CHANNEL';
    case Enum$ProductErrorCode.UNSUPPORTED_MEDIA_PROVIDER:
      return r'UNSUPPORTED_MEDIA_PROVIDER';
    case Enum$ProductErrorCode.PREORDER_VARIANT_CANNOT_BE_DEACTIVATED:
      return r'PREORDER_VARIANT_CANNOT_BE_DEACTIVATED';
    case Enum$ProductErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$ProductErrorCode fromJson$Enum$ProductErrorCode(String value) {
  switch (value) {
    case r'ALREADY_EXISTS':
      return Enum$ProductErrorCode.ALREADY_EXISTS;
    case r'ATTRIBUTE_ALREADY_ASSIGNED':
      return Enum$ProductErrorCode.ATTRIBUTE_ALREADY_ASSIGNED;
    case r'ATTRIBUTE_CANNOT_BE_ASSIGNED':
      return Enum$ProductErrorCode.ATTRIBUTE_CANNOT_BE_ASSIGNED;
    case r'ATTRIBUTE_VARIANTS_DISABLED':
      return Enum$ProductErrorCode.ATTRIBUTE_VARIANTS_DISABLED;
    case r'MEDIA_ALREADY_ASSIGNED':
      return Enum$ProductErrorCode.MEDIA_ALREADY_ASSIGNED;
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$ProductErrorCode.DUPLICATED_INPUT_ITEM;
    case r'GRAPHQL_ERROR':
      return Enum$ProductErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$ProductErrorCode.INVALID;
    case r'INVALID_PRICE':
      return Enum$ProductErrorCode.INVALID_PRICE;
    case r'PRODUCT_WITHOUT_CATEGORY':
      return Enum$ProductErrorCode.PRODUCT_WITHOUT_CATEGORY;
    case r'NOT_PRODUCTS_IMAGE':
      return Enum$ProductErrorCode.NOT_PRODUCTS_IMAGE;
    case r'NOT_PRODUCTS_VARIANT':
      return Enum$ProductErrorCode.NOT_PRODUCTS_VARIANT;
    case r'NOT_FOUND':
      return Enum$ProductErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$ProductErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$ProductErrorCode.UNIQUE;
    case r'VARIANT_NO_DIGITAL_CONTENT':
      return Enum$ProductErrorCode.VARIANT_NO_DIGITAL_CONTENT;
    case r'CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT':
      return Enum$ProductErrorCode.CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT;
    case r'PRODUCT_NOT_ASSIGNED_TO_CHANNEL':
      return Enum$ProductErrorCode.PRODUCT_NOT_ASSIGNED_TO_CHANNEL;
    case r'UNSUPPORTED_MEDIA_PROVIDER':
      return Enum$ProductErrorCode.UNSUPPORTED_MEDIA_PROVIDER;
    case r'PREORDER_VARIANT_CANNOT_BE_DEACTIVATED':
      return Enum$ProductErrorCode.PREORDER_VARIANT_CANNOT_BE_DEACTIVATED;
    default:
      return Enum$ProductErrorCode.$unknown;
  }
}

enum Enum$ProductFieldEnum {
  NAME,
  DESCRIPTION,
  PRODUCT_TYPE,
  CATEGORY,
  PRODUCT_WEIGHT,
  COLLECTIONS,
  CHARGE_TAXES,
  PRODUCT_MEDIA,
  VARIANT_ID,
  VARIANT_SKU,
  VARIANT_WEIGHT,
  VARIANT_MEDIA,
  $unknown;

  factory Enum$ProductFieldEnum.fromJson(String value) =>
      fromJson$Enum$ProductFieldEnum(value);

  String toJson() => toJson$Enum$ProductFieldEnum(this);
}

String toJson$Enum$ProductFieldEnum(Enum$ProductFieldEnum e) {
  switch (e) {
    case Enum$ProductFieldEnum.NAME:
      return r'NAME';
    case Enum$ProductFieldEnum.DESCRIPTION:
      return r'DESCRIPTION';
    case Enum$ProductFieldEnum.PRODUCT_TYPE:
      return r'PRODUCT_TYPE';
    case Enum$ProductFieldEnum.CATEGORY:
      return r'CATEGORY';
    case Enum$ProductFieldEnum.PRODUCT_WEIGHT:
      return r'PRODUCT_WEIGHT';
    case Enum$ProductFieldEnum.COLLECTIONS:
      return r'COLLECTIONS';
    case Enum$ProductFieldEnum.CHARGE_TAXES:
      return r'CHARGE_TAXES';
    case Enum$ProductFieldEnum.PRODUCT_MEDIA:
      return r'PRODUCT_MEDIA';
    case Enum$ProductFieldEnum.VARIANT_ID:
      return r'VARIANT_ID';
    case Enum$ProductFieldEnum.VARIANT_SKU:
      return r'VARIANT_SKU';
    case Enum$ProductFieldEnum.VARIANT_WEIGHT:
      return r'VARIANT_WEIGHT';
    case Enum$ProductFieldEnum.VARIANT_MEDIA:
      return r'VARIANT_MEDIA';
    case Enum$ProductFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ProductFieldEnum fromJson$Enum$ProductFieldEnum(String value) {
  switch (value) {
    case r'NAME':
      return Enum$ProductFieldEnum.NAME;
    case r'DESCRIPTION':
      return Enum$ProductFieldEnum.DESCRIPTION;
    case r'PRODUCT_TYPE':
      return Enum$ProductFieldEnum.PRODUCT_TYPE;
    case r'CATEGORY':
      return Enum$ProductFieldEnum.CATEGORY;
    case r'PRODUCT_WEIGHT':
      return Enum$ProductFieldEnum.PRODUCT_WEIGHT;
    case r'COLLECTIONS':
      return Enum$ProductFieldEnum.COLLECTIONS;
    case r'CHARGE_TAXES':
      return Enum$ProductFieldEnum.CHARGE_TAXES;
    case r'PRODUCT_MEDIA':
      return Enum$ProductFieldEnum.PRODUCT_MEDIA;
    case r'VARIANT_ID':
      return Enum$ProductFieldEnum.VARIANT_ID;
    case r'VARIANT_SKU':
      return Enum$ProductFieldEnum.VARIANT_SKU;
    case r'VARIANT_WEIGHT':
      return Enum$ProductFieldEnum.VARIANT_WEIGHT;
    case r'VARIANT_MEDIA':
      return Enum$ProductFieldEnum.VARIANT_MEDIA;
    default:
      return Enum$ProductFieldEnum.$unknown;
  }
}

enum Enum$ProductMediaType {
  IMAGE,
  VIDEO,
  $unknown;

  factory Enum$ProductMediaType.fromJson(String value) =>
      fromJson$Enum$ProductMediaType(value);

  String toJson() => toJson$Enum$ProductMediaType(this);
}

String toJson$Enum$ProductMediaType(Enum$ProductMediaType e) {
  switch (e) {
    case Enum$ProductMediaType.IMAGE:
      return r'IMAGE';
    case Enum$ProductMediaType.VIDEO:
      return r'VIDEO';
    case Enum$ProductMediaType.$unknown:
      return r'$unknown';
  }
}

Enum$ProductMediaType fromJson$Enum$ProductMediaType(String value) {
  switch (value) {
    case r'IMAGE':
      return Enum$ProductMediaType.IMAGE;
    case r'VIDEO':
      return Enum$ProductMediaType.VIDEO;
    default:
      return Enum$ProductMediaType.$unknown;
  }
}

enum Enum$ProductOrderField {
  NAME,
  RANK,
  PRICE,
  MINIMAL_PRICE,
  LAST_MODIFIED,
  DATE,
  TYPE,
  PUBLISHED,
  PUBLICATION_DATE,
  PUBLISHED_AT,
  LAST_MODIFIED_AT,
  COLLECTION,
  RATING,
  CREATED_AT,
  $unknown;

  factory Enum$ProductOrderField.fromJson(String value) =>
      fromJson$Enum$ProductOrderField(value);

  String toJson() => toJson$Enum$ProductOrderField(this);
}

String toJson$Enum$ProductOrderField(Enum$ProductOrderField e) {
  switch (e) {
    case Enum$ProductOrderField.NAME:
      return r'NAME';
    case Enum$ProductOrderField.RANK:
      return r'RANK';
    case Enum$ProductOrderField.PRICE:
      return r'PRICE';
    case Enum$ProductOrderField.MINIMAL_PRICE:
      return r'MINIMAL_PRICE';
    case Enum$ProductOrderField.LAST_MODIFIED:
      return r'LAST_MODIFIED';
    case Enum$ProductOrderField.DATE:
      return r'DATE';
    case Enum$ProductOrderField.TYPE:
      return r'TYPE';
    case Enum$ProductOrderField.PUBLISHED:
      return r'PUBLISHED';
    case Enum$ProductOrderField.PUBLICATION_DATE:
      return r'PUBLICATION_DATE';
    case Enum$ProductOrderField.PUBLISHED_AT:
      return r'PUBLISHED_AT';
    case Enum$ProductOrderField.LAST_MODIFIED_AT:
      return r'LAST_MODIFIED_AT';
    case Enum$ProductOrderField.COLLECTION:
      return r'COLLECTION';
    case Enum$ProductOrderField.RATING:
      return r'RATING';
    case Enum$ProductOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProductOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProductOrderField fromJson$Enum$ProductOrderField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$ProductOrderField.NAME;
    case r'RANK':
      return Enum$ProductOrderField.RANK;
    case r'PRICE':
      return Enum$ProductOrderField.PRICE;
    case r'MINIMAL_PRICE':
      return Enum$ProductOrderField.MINIMAL_PRICE;
    case r'LAST_MODIFIED':
      return Enum$ProductOrderField.LAST_MODIFIED;
    case r'DATE':
      return Enum$ProductOrderField.DATE;
    case r'TYPE':
      return Enum$ProductOrderField.TYPE;
    case r'PUBLISHED':
      return Enum$ProductOrderField.PUBLISHED;
    case r'PUBLICATION_DATE':
      return Enum$ProductOrderField.PUBLICATION_DATE;
    case r'PUBLISHED_AT':
      return Enum$ProductOrderField.PUBLISHED_AT;
    case r'LAST_MODIFIED_AT':
      return Enum$ProductOrderField.LAST_MODIFIED_AT;
    case r'COLLECTION':
      return Enum$ProductOrderField.COLLECTION;
    case r'RATING':
      return Enum$ProductOrderField.RATING;
    case r'CREATED_AT':
      return Enum$ProductOrderField.CREATED_AT;
    default:
      return Enum$ProductOrderField.$unknown;
  }
}

enum Enum$ProductTranslateErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  $unknown;

  factory Enum$ProductTranslateErrorCode.fromJson(String value) =>
      fromJson$Enum$ProductTranslateErrorCode(value);

  String toJson() => toJson$Enum$ProductTranslateErrorCode(this);
}

String toJson$Enum$ProductTranslateErrorCode(Enum$ProductTranslateErrorCode e) {
  switch (e) {
    case Enum$ProductTranslateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$ProductTranslateErrorCode.INVALID:
      return r'INVALID';
    case Enum$ProductTranslateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$ProductTranslateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$ProductTranslateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$ProductTranslateErrorCode fromJson$Enum$ProductTranslateErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$ProductTranslateErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$ProductTranslateErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$ProductTranslateErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$ProductTranslateErrorCode.REQUIRED;
    default:
      return Enum$ProductTranslateErrorCode.$unknown;
  }
}

enum Enum$ProductTypeConfigurable {
  CONFIGURABLE,
  SIMPLE,
  $unknown;

  factory Enum$ProductTypeConfigurable.fromJson(String value) =>
      fromJson$Enum$ProductTypeConfigurable(value);

  String toJson() => toJson$Enum$ProductTypeConfigurable(this);
}

String toJson$Enum$ProductTypeConfigurable(Enum$ProductTypeConfigurable e) {
  switch (e) {
    case Enum$ProductTypeConfigurable.CONFIGURABLE:
      return r'CONFIGURABLE';
    case Enum$ProductTypeConfigurable.SIMPLE:
      return r'SIMPLE';
    case Enum$ProductTypeConfigurable.$unknown:
      return r'$unknown';
  }
}

Enum$ProductTypeConfigurable fromJson$Enum$ProductTypeConfigurable(
    String value) {
  switch (value) {
    case r'CONFIGURABLE':
      return Enum$ProductTypeConfigurable.CONFIGURABLE;
    case r'SIMPLE':
      return Enum$ProductTypeConfigurable.SIMPLE;
    default:
      return Enum$ProductTypeConfigurable.$unknown;
  }
}

enum Enum$ProductTypeEnum {
  DIGITAL,
  SHIPPABLE,
  $unknown;

  factory Enum$ProductTypeEnum.fromJson(String value) =>
      fromJson$Enum$ProductTypeEnum(value);

  String toJson() => toJson$Enum$ProductTypeEnum(this);
}

String toJson$Enum$ProductTypeEnum(Enum$ProductTypeEnum e) {
  switch (e) {
    case Enum$ProductTypeEnum.DIGITAL:
      return r'DIGITAL';
    case Enum$ProductTypeEnum.SHIPPABLE:
      return r'SHIPPABLE';
    case Enum$ProductTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ProductTypeEnum fromJson$Enum$ProductTypeEnum(String value) {
  switch (value) {
    case r'DIGITAL':
      return Enum$ProductTypeEnum.DIGITAL;
    case r'SHIPPABLE':
      return Enum$ProductTypeEnum.SHIPPABLE;
    default:
      return Enum$ProductTypeEnum.$unknown;
  }
}

enum Enum$ProductTypeKindEnum {
  NORMAL,
  GIFT_CARD,
  $unknown;

  factory Enum$ProductTypeKindEnum.fromJson(String value) =>
      fromJson$Enum$ProductTypeKindEnum(value);

  String toJson() => toJson$Enum$ProductTypeKindEnum(this);
}

String toJson$Enum$ProductTypeKindEnum(Enum$ProductTypeKindEnum e) {
  switch (e) {
    case Enum$ProductTypeKindEnum.NORMAL:
      return r'NORMAL';
    case Enum$ProductTypeKindEnum.GIFT_CARD:
      return r'GIFT_CARD';
    case Enum$ProductTypeKindEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ProductTypeKindEnum fromJson$Enum$ProductTypeKindEnum(String value) {
  switch (value) {
    case r'NORMAL':
      return Enum$ProductTypeKindEnum.NORMAL;
    case r'GIFT_CARD':
      return Enum$ProductTypeKindEnum.GIFT_CARD;
    default:
      return Enum$ProductTypeKindEnum.$unknown;
  }
}

enum Enum$ProductTypeSortField {
  NAME,
  DIGITAL,
  SHIPPING_REQUIRED,
  $unknown;

  factory Enum$ProductTypeSortField.fromJson(String value) =>
      fromJson$Enum$ProductTypeSortField(value);

  String toJson() => toJson$Enum$ProductTypeSortField(this);
}

String toJson$Enum$ProductTypeSortField(Enum$ProductTypeSortField e) {
  switch (e) {
    case Enum$ProductTypeSortField.NAME:
      return r'NAME';
    case Enum$ProductTypeSortField.DIGITAL:
      return r'DIGITAL';
    case Enum$ProductTypeSortField.SHIPPING_REQUIRED:
      return r'SHIPPING_REQUIRED';
    case Enum$ProductTypeSortField.$unknown:
      return r'$unknown';
  }
}

Enum$ProductTypeSortField fromJson$Enum$ProductTypeSortField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$ProductTypeSortField.NAME;
    case r'DIGITAL':
      return Enum$ProductTypeSortField.DIGITAL;
    case r'SHIPPING_REQUIRED':
      return Enum$ProductTypeSortField.SHIPPING_REQUIRED;
    default:
      return Enum$ProductTypeSortField.$unknown;
  }
}

enum Enum$ProductVariantBulkErrorCode {
  ATTRIBUTE_ALREADY_ASSIGNED,
  ATTRIBUTE_CANNOT_BE_ASSIGNED,
  ATTRIBUTE_VARIANTS_DISABLED,
  DUPLICATED_INPUT_ITEM,
  GRAPHQL_ERROR,
  INVALID,
  INVALID_PRICE,
  NOT_PRODUCTS_VARIANT,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  PRODUCT_NOT_ASSIGNED_TO_CHANNEL,
  STOCK_ALREADY_EXISTS,
  $unknown;

  factory Enum$ProductVariantBulkErrorCode.fromJson(String value) =>
      fromJson$Enum$ProductVariantBulkErrorCode(value);

  String toJson() => toJson$Enum$ProductVariantBulkErrorCode(this);
}

String toJson$Enum$ProductVariantBulkErrorCode(
    Enum$ProductVariantBulkErrorCode e) {
  switch (e) {
    case Enum$ProductVariantBulkErrorCode.ATTRIBUTE_ALREADY_ASSIGNED:
      return r'ATTRIBUTE_ALREADY_ASSIGNED';
    case Enum$ProductVariantBulkErrorCode.ATTRIBUTE_CANNOT_BE_ASSIGNED:
      return r'ATTRIBUTE_CANNOT_BE_ASSIGNED';
    case Enum$ProductVariantBulkErrorCode.ATTRIBUTE_VARIANTS_DISABLED:
      return r'ATTRIBUTE_VARIANTS_DISABLED';
    case Enum$ProductVariantBulkErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$ProductVariantBulkErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$ProductVariantBulkErrorCode.INVALID:
      return r'INVALID';
    case Enum$ProductVariantBulkErrorCode.INVALID_PRICE:
      return r'INVALID_PRICE';
    case Enum$ProductVariantBulkErrorCode.NOT_PRODUCTS_VARIANT:
      return r'NOT_PRODUCTS_VARIANT';
    case Enum$ProductVariantBulkErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$ProductVariantBulkErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$ProductVariantBulkErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$ProductVariantBulkErrorCode.PRODUCT_NOT_ASSIGNED_TO_CHANNEL:
      return r'PRODUCT_NOT_ASSIGNED_TO_CHANNEL';
    case Enum$ProductVariantBulkErrorCode.STOCK_ALREADY_EXISTS:
      return r'STOCK_ALREADY_EXISTS';
    case Enum$ProductVariantBulkErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$ProductVariantBulkErrorCode fromJson$Enum$ProductVariantBulkErrorCode(
    String value) {
  switch (value) {
    case r'ATTRIBUTE_ALREADY_ASSIGNED':
      return Enum$ProductVariantBulkErrorCode.ATTRIBUTE_ALREADY_ASSIGNED;
    case r'ATTRIBUTE_CANNOT_BE_ASSIGNED':
      return Enum$ProductVariantBulkErrorCode.ATTRIBUTE_CANNOT_BE_ASSIGNED;
    case r'ATTRIBUTE_VARIANTS_DISABLED':
      return Enum$ProductVariantBulkErrorCode.ATTRIBUTE_VARIANTS_DISABLED;
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$ProductVariantBulkErrorCode.DUPLICATED_INPUT_ITEM;
    case r'GRAPHQL_ERROR':
      return Enum$ProductVariantBulkErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$ProductVariantBulkErrorCode.INVALID;
    case r'INVALID_PRICE':
      return Enum$ProductVariantBulkErrorCode.INVALID_PRICE;
    case r'NOT_PRODUCTS_VARIANT':
      return Enum$ProductVariantBulkErrorCode.NOT_PRODUCTS_VARIANT;
    case r'NOT_FOUND':
      return Enum$ProductVariantBulkErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$ProductVariantBulkErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$ProductVariantBulkErrorCode.UNIQUE;
    case r'PRODUCT_NOT_ASSIGNED_TO_CHANNEL':
      return Enum$ProductVariantBulkErrorCode.PRODUCT_NOT_ASSIGNED_TO_CHANNEL;
    case r'STOCK_ALREADY_EXISTS':
      return Enum$ProductVariantBulkErrorCode.STOCK_ALREADY_EXISTS;
    default:
      return Enum$ProductVariantBulkErrorCode.$unknown;
  }
}

enum Enum$ProductVariantSortField {
  LAST_MODIFIED_AT,
  $unknown;

  factory Enum$ProductVariantSortField.fromJson(String value) =>
      fromJson$Enum$ProductVariantSortField(value);

  String toJson() => toJson$Enum$ProductVariantSortField(this);
}

String toJson$Enum$ProductVariantSortField(Enum$ProductVariantSortField e) {
  switch (e) {
    case Enum$ProductVariantSortField.LAST_MODIFIED_AT:
      return r'LAST_MODIFIED_AT';
    case Enum$ProductVariantSortField.$unknown:
      return r'$unknown';
  }
}

Enum$ProductVariantSortField fromJson$Enum$ProductVariantSortField(
    String value) {
  switch (value) {
    case r'LAST_MODIFIED_AT':
      return Enum$ProductVariantSortField.LAST_MODIFIED_AT;
    default:
      return Enum$ProductVariantSortField.$unknown;
  }
}

enum Enum$ProductVariantTranslateErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  $unknown;

  factory Enum$ProductVariantTranslateErrorCode.fromJson(String value) =>
      fromJson$Enum$ProductVariantTranslateErrorCode(value);

  String toJson() => toJson$Enum$ProductVariantTranslateErrorCode(this);
}

String toJson$Enum$ProductVariantTranslateErrorCode(
    Enum$ProductVariantTranslateErrorCode e) {
  switch (e) {
    case Enum$ProductVariantTranslateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$ProductVariantTranslateErrorCode.INVALID:
      return r'INVALID';
    case Enum$ProductVariantTranslateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$ProductVariantTranslateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$ProductVariantTranslateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$ProductVariantTranslateErrorCode
    fromJson$Enum$ProductVariantTranslateErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$ProductVariantTranslateErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$ProductVariantTranslateErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$ProductVariantTranslateErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$ProductVariantTranslateErrorCode.REQUIRED;
    default:
      return Enum$ProductVariantTranslateErrorCode.$unknown;
  }
}

enum Enum$PromotionCreateErrorCode {
  GRAPHQL_ERROR,
  NOT_FOUND,
  REQUIRED,
  INVALID,
  MULTIPLE_CURRENCIES_NOT_ALLOWED,
  INVALID_PRECISION,
  MISSING_CHANNELS,
  RULES_NUMBER_LIMIT,
  GIFTS_NUMBER_LIMIT,
  INVALID_GIFT_TYPE,
  $unknown;

  factory Enum$PromotionCreateErrorCode.fromJson(String value) =>
      fromJson$Enum$PromotionCreateErrorCode(value);

  String toJson() => toJson$Enum$PromotionCreateErrorCode(this);
}

String toJson$Enum$PromotionCreateErrorCode(Enum$PromotionCreateErrorCode e) {
  switch (e) {
    case Enum$PromotionCreateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$PromotionCreateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$PromotionCreateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$PromotionCreateErrorCode.INVALID:
      return r'INVALID';
    case Enum$PromotionCreateErrorCode.MULTIPLE_CURRENCIES_NOT_ALLOWED:
      return r'MULTIPLE_CURRENCIES_NOT_ALLOWED';
    case Enum$PromotionCreateErrorCode.INVALID_PRECISION:
      return r'INVALID_PRECISION';
    case Enum$PromotionCreateErrorCode.MISSING_CHANNELS:
      return r'MISSING_CHANNELS';
    case Enum$PromotionCreateErrorCode.RULES_NUMBER_LIMIT:
      return r'RULES_NUMBER_LIMIT';
    case Enum$PromotionCreateErrorCode.GIFTS_NUMBER_LIMIT:
      return r'GIFTS_NUMBER_LIMIT';
    case Enum$PromotionCreateErrorCode.INVALID_GIFT_TYPE:
      return r'INVALID_GIFT_TYPE';
    case Enum$PromotionCreateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$PromotionCreateErrorCode fromJson$Enum$PromotionCreateErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$PromotionCreateErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$PromotionCreateErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$PromotionCreateErrorCode.REQUIRED;
    case r'INVALID':
      return Enum$PromotionCreateErrorCode.INVALID;
    case r'MULTIPLE_CURRENCIES_NOT_ALLOWED':
      return Enum$PromotionCreateErrorCode.MULTIPLE_CURRENCIES_NOT_ALLOWED;
    case r'INVALID_PRECISION':
      return Enum$PromotionCreateErrorCode.INVALID_PRECISION;
    case r'MISSING_CHANNELS':
      return Enum$PromotionCreateErrorCode.MISSING_CHANNELS;
    case r'RULES_NUMBER_LIMIT':
      return Enum$PromotionCreateErrorCode.RULES_NUMBER_LIMIT;
    case r'GIFTS_NUMBER_LIMIT':
      return Enum$PromotionCreateErrorCode.GIFTS_NUMBER_LIMIT;
    case r'INVALID_GIFT_TYPE':
      return Enum$PromotionCreateErrorCode.INVALID_GIFT_TYPE;
    default:
      return Enum$PromotionCreateErrorCode.$unknown;
  }
}

enum Enum$PromotionDeleteErrorCode {
  GRAPHQL_ERROR,
  NOT_FOUND,
  $unknown;

  factory Enum$PromotionDeleteErrorCode.fromJson(String value) =>
      fromJson$Enum$PromotionDeleteErrorCode(value);

  String toJson() => toJson$Enum$PromotionDeleteErrorCode(this);
}

String toJson$Enum$PromotionDeleteErrorCode(Enum$PromotionDeleteErrorCode e) {
  switch (e) {
    case Enum$PromotionDeleteErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$PromotionDeleteErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$PromotionDeleteErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$PromotionDeleteErrorCode fromJson$Enum$PromotionDeleteErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$PromotionDeleteErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$PromotionDeleteErrorCode.NOT_FOUND;
    default:
      return Enum$PromotionDeleteErrorCode.$unknown;
  }
}

enum Enum$PromotionEventsEnum {
  PROMOTION_CREATED,
  PROMOTION_UPDATED,
  PROMOTION_STARTED,
  PROMOTION_ENDED,
  RULE_CREATED,
  RULE_UPDATED,
  RULE_DELETED,
  $unknown;

  factory Enum$PromotionEventsEnum.fromJson(String value) =>
      fromJson$Enum$PromotionEventsEnum(value);

  String toJson() => toJson$Enum$PromotionEventsEnum(this);
}

String toJson$Enum$PromotionEventsEnum(Enum$PromotionEventsEnum e) {
  switch (e) {
    case Enum$PromotionEventsEnum.PROMOTION_CREATED:
      return r'PROMOTION_CREATED';
    case Enum$PromotionEventsEnum.PROMOTION_UPDATED:
      return r'PROMOTION_UPDATED';
    case Enum$PromotionEventsEnum.PROMOTION_STARTED:
      return r'PROMOTION_STARTED';
    case Enum$PromotionEventsEnum.PROMOTION_ENDED:
      return r'PROMOTION_ENDED';
    case Enum$PromotionEventsEnum.RULE_CREATED:
      return r'RULE_CREATED';
    case Enum$PromotionEventsEnum.RULE_UPDATED:
      return r'RULE_UPDATED';
    case Enum$PromotionEventsEnum.RULE_DELETED:
      return r'RULE_DELETED';
    case Enum$PromotionEventsEnum.$unknown:
      return r'$unknown';
  }
}

Enum$PromotionEventsEnum fromJson$Enum$PromotionEventsEnum(String value) {
  switch (value) {
    case r'PROMOTION_CREATED':
      return Enum$PromotionEventsEnum.PROMOTION_CREATED;
    case r'PROMOTION_UPDATED':
      return Enum$PromotionEventsEnum.PROMOTION_UPDATED;
    case r'PROMOTION_STARTED':
      return Enum$PromotionEventsEnum.PROMOTION_STARTED;
    case r'PROMOTION_ENDED':
      return Enum$PromotionEventsEnum.PROMOTION_ENDED;
    case r'RULE_CREATED':
      return Enum$PromotionEventsEnum.RULE_CREATED;
    case r'RULE_UPDATED':
      return Enum$PromotionEventsEnum.RULE_UPDATED;
    case r'RULE_DELETED':
      return Enum$PromotionEventsEnum.RULE_DELETED;
    default:
      return Enum$PromotionEventsEnum.$unknown;
  }
}

enum Enum$PromotionRuleCreateErrorCode {
  GRAPHQL_ERROR,
  NOT_FOUND,
  REQUIRED,
  INVALID,
  MULTIPLE_CURRENCIES_NOT_ALLOWED,
  INVALID_PRECISION,
  MISSING_CHANNELS,
  RULES_NUMBER_LIMIT,
  GIFTS_NUMBER_LIMIT,
  INVALID_GIFT_TYPE,
  $unknown;

  factory Enum$PromotionRuleCreateErrorCode.fromJson(String value) =>
      fromJson$Enum$PromotionRuleCreateErrorCode(value);

  String toJson() => toJson$Enum$PromotionRuleCreateErrorCode(this);
}

String toJson$Enum$PromotionRuleCreateErrorCode(
    Enum$PromotionRuleCreateErrorCode e) {
  switch (e) {
    case Enum$PromotionRuleCreateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$PromotionRuleCreateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$PromotionRuleCreateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$PromotionRuleCreateErrorCode.INVALID:
      return r'INVALID';
    case Enum$PromotionRuleCreateErrorCode.MULTIPLE_CURRENCIES_NOT_ALLOWED:
      return r'MULTIPLE_CURRENCIES_NOT_ALLOWED';
    case Enum$PromotionRuleCreateErrorCode.INVALID_PRECISION:
      return r'INVALID_PRECISION';
    case Enum$PromotionRuleCreateErrorCode.MISSING_CHANNELS:
      return r'MISSING_CHANNELS';
    case Enum$PromotionRuleCreateErrorCode.RULES_NUMBER_LIMIT:
      return r'RULES_NUMBER_LIMIT';
    case Enum$PromotionRuleCreateErrorCode.GIFTS_NUMBER_LIMIT:
      return r'GIFTS_NUMBER_LIMIT';
    case Enum$PromotionRuleCreateErrorCode.INVALID_GIFT_TYPE:
      return r'INVALID_GIFT_TYPE';
    case Enum$PromotionRuleCreateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$PromotionRuleCreateErrorCode fromJson$Enum$PromotionRuleCreateErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$PromotionRuleCreateErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$PromotionRuleCreateErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$PromotionRuleCreateErrorCode.REQUIRED;
    case r'INVALID':
      return Enum$PromotionRuleCreateErrorCode.INVALID;
    case r'MULTIPLE_CURRENCIES_NOT_ALLOWED':
      return Enum$PromotionRuleCreateErrorCode.MULTIPLE_CURRENCIES_NOT_ALLOWED;
    case r'INVALID_PRECISION':
      return Enum$PromotionRuleCreateErrorCode.INVALID_PRECISION;
    case r'MISSING_CHANNELS':
      return Enum$PromotionRuleCreateErrorCode.MISSING_CHANNELS;
    case r'RULES_NUMBER_LIMIT':
      return Enum$PromotionRuleCreateErrorCode.RULES_NUMBER_LIMIT;
    case r'GIFTS_NUMBER_LIMIT':
      return Enum$PromotionRuleCreateErrorCode.GIFTS_NUMBER_LIMIT;
    case r'INVALID_GIFT_TYPE':
      return Enum$PromotionRuleCreateErrorCode.INVALID_GIFT_TYPE;
    default:
      return Enum$PromotionRuleCreateErrorCode.$unknown;
  }
}

enum Enum$PromotionRuleDeleteErrorCode {
  GRAPHQL_ERROR,
  NOT_FOUND,
  $unknown;

  factory Enum$PromotionRuleDeleteErrorCode.fromJson(String value) =>
      fromJson$Enum$PromotionRuleDeleteErrorCode(value);

  String toJson() => toJson$Enum$PromotionRuleDeleteErrorCode(this);
}

String toJson$Enum$PromotionRuleDeleteErrorCode(
    Enum$PromotionRuleDeleteErrorCode e) {
  switch (e) {
    case Enum$PromotionRuleDeleteErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$PromotionRuleDeleteErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$PromotionRuleDeleteErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$PromotionRuleDeleteErrorCode fromJson$Enum$PromotionRuleDeleteErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$PromotionRuleDeleteErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$PromotionRuleDeleteErrorCode.NOT_FOUND;
    default:
      return Enum$PromotionRuleDeleteErrorCode.$unknown;
  }
}

enum Enum$PromotionRuleUpdateErrorCode {
  GRAPHQL_ERROR,
  NOT_FOUND,
  INVALID,
  REQUIRED,
  DUPLICATED_INPUT_ITEM,
  MISSING_CHANNELS,
  MULTIPLE_CURRENCIES_NOT_ALLOWED,
  INVALID_PRECISION,
  INVALID_GIFT_TYPE,
  GIFTS_NUMBER_LIMIT,
  $unknown;

  factory Enum$PromotionRuleUpdateErrorCode.fromJson(String value) =>
      fromJson$Enum$PromotionRuleUpdateErrorCode(value);

  String toJson() => toJson$Enum$PromotionRuleUpdateErrorCode(this);
}

String toJson$Enum$PromotionRuleUpdateErrorCode(
    Enum$PromotionRuleUpdateErrorCode e) {
  switch (e) {
    case Enum$PromotionRuleUpdateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$PromotionRuleUpdateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$PromotionRuleUpdateErrorCode.INVALID:
      return r'INVALID';
    case Enum$PromotionRuleUpdateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$PromotionRuleUpdateErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$PromotionRuleUpdateErrorCode.MISSING_CHANNELS:
      return r'MISSING_CHANNELS';
    case Enum$PromotionRuleUpdateErrorCode.MULTIPLE_CURRENCIES_NOT_ALLOWED:
      return r'MULTIPLE_CURRENCIES_NOT_ALLOWED';
    case Enum$PromotionRuleUpdateErrorCode.INVALID_PRECISION:
      return r'INVALID_PRECISION';
    case Enum$PromotionRuleUpdateErrorCode.INVALID_GIFT_TYPE:
      return r'INVALID_GIFT_TYPE';
    case Enum$PromotionRuleUpdateErrorCode.GIFTS_NUMBER_LIMIT:
      return r'GIFTS_NUMBER_LIMIT';
    case Enum$PromotionRuleUpdateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$PromotionRuleUpdateErrorCode fromJson$Enum$PromotionRuleUpdateErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$PromotionRuleUpdateErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$PromotionRuleUpdateErrorCode.NOT_FOUND;
    case r'INVALID':
      return Enum$PromotionRuleUpdateErrorCode.INVALID;
    case r'REQUIRED':
      return Enum$PromotionRuleUpdateErrorCode.REQUIRED;
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$PromotionRuleUpdateErrorCode.DUPLICATED_INPUT_ITEM;
    case r'MISSING_CHANNELS':
      return Enum$PromotionRuleUpdateErrorCode.MISSING_CHANNELS;
    case r'MULTIPLE_CURRENCIES_NOT_ALLOWED':
      return Enum$PromotionRuleUpdateErrorCode.MULTIPLE_CURRENCIES_NOT_ALLOWED;
    case r'INVALID_PRECISION':
      return Enum$PromotionRuleUpdateErrorCode.INVALID_PRECISION;
    case r'INVALID_GIFT_TYPE':
      return Enum$PromotionRuleUpdateErrorCode.INVALID_GIFT_TYPE;
    case r'GIFTS_NUMBER_LIMIT':
      return Enum$PromotionRuleUpdateErrorCode.GIFTS_NUMBER_LIMIT;
    default:
      return Enum$PromotionRuleUpdateErrorCode.$unknown;
  }
}

enum Enum$PromotionSortField {
  NAME,
  START_DATE,
  END_DATE,
  CREATED_AT,
  $unknown;

  factory Enum$PromotionSortField.fromJson(String value) =>
      fromJson$Enum$PromotionSortField(value);

  String toJson() => toJson$Enum$PromotionSortField(this);
}

String toJson$Enum$PromotionSortField(Enum$PromotionSortField e) {
  switch (e) {
    case Enum$PromotionSortField.NAME:
      return r'NAME';
    case Enum$PromotionSortField.START_DATE:
      return r'START_DATE';
    case Enum$PromotionSortField.END_DATE:
      return r'END_DATE';
    case Enum$PromotionSortField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$PromotionSortField.$unknown:
      return r'$unknown';
  }
}

Enum$PromotionSortField fromJson$Enum$PromotionSortField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$PromotionSortField.NAME;
    case r'START_DATE':
      return Enum$PromotionSortField.START_DATE;
    case r'END_DATE':
      return Enum$PromotionSortField.END_DATE;
    case r'CREATED_AT':
      return Enum$PromotionSortField.CREATED_AT;
    default:
      return Enum$PromotionSortField.$unknown;
  }
}

enum Enum$PromotionTypeEnum {
  CATALOGUE,
  ORDER,
  $unknown;

  factory Enum$PromotionTypeEnum.fromJson(String value) =>
      fromJson$Enum$PromotionTypeEnum(value);

  String toJson() => toJson$Enum$PromotionTypeEnum(this);
}

String toJson$Enum$PromotionTypeEnum(Enum$PromotionTypeEnum e) {
  switch (e) {
    case Enum$PromotionTypeEnum.CATALOGUE:
      return r'CATALOGUE';
    case Enum$PromotionTypeEnum.ORDER:
      return r'ORDER';
    case Enum$PromotionTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$PromotionTypeEnum fromJson$Enum$PromotionTypeEnum(String value) {
  switch (value) {
    case r'CATALOGUE':
      return Enum$PromotionTypeEnum.CATALOGUE;
    case r'ORDER':
      return Enum$PromotionTypeEnum.ORDER;
    default:
      return Enum$PromotionTypeEnum.$unknown;
  }
}

enum Enum$PromotionUpdateErrorCode {
  GRAPHQL_ERROR,
  NOT_FOUND,
  REQUIRED,
  INVALID,
  $unknown;

  factory Enum$PromotionUpdateErrorCode.fromJson(String value) =>
      fromJson$Enum$PromotionUpdateErrorCode(value);

  String toJson() => toJson$Enum$PromotionUpdateErrorCode(this);
}

String toJson$Enum$PromotionUpdateErrorCode(Enum$PromotionUpdateErrorCode e) {
  switch (e) {
    case Enum$PromotionUpdateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$PromotionUpdateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$PromotionUpdateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$PromotionUpdateErrorCode.INVALID:
      return r'INVALID';
    case Enum$PromotionUpdateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$PromotionUpdateErrorCode fromJson$Enum$PromotionUpdateErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$PromotionUpdateErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$PromotionUpdateErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$PromotionUpdateErrorCode.REQUIRED;
    case r'INVALID':
      return Enum$PromotionUpdateErrorCode.INVALID;
    default:
      return Enum$PromotionUpdateErrorCode.$unknown;
  }
}

enum Enum$ReportingPeriod {
  TODAY,
  THIS_MONTH,
  $unknown;

  factory Enum$ReportingPeriod.fromJson(String value) =>
      fromJson$Enum$ReportingPeriod(value);

  String toJson() => toJson$Enum$ReportingPeriod(this);
}

String toJson$Enum$ReportingPeriod(Enum$ReportingPeriod e) {
  switch (e) {
    case Enum$ReportingPeriod.TODAY:
      return r'TODAY';
    case Enum$ReportingPeriod.THIS_MONTH:
      return r'THIS_MONTH';
    case Enum$ReportingPeriod.$unknown:
      return r'$unknown';
  }
}

Enum$ReportingPeriod fromJson$Enum$ReportingPeriod(String value) {
  switch (value) {
    case r'TODAY':
      return Enum$ReportingPeriod.TODAY;
    case r'THIS_MONTH':
      return Enum$ReportingPeriod.THIS_MONTH;
    default:
      return Enum$ReportingPeriod.$unknown;
  }
}

enum Enum$RewardTypeEnum {
  SUBTOTAL_DISCOUNT,
  GIFT,
  $unknown;

  factory Enum$RewardTypeEnum.fromJson(String value) =>
      fromJson$Enum$RewardTypeEnum(value);

  String toJson() => toJson$Enum$RewardTypeEnum(this);
}

String toJson$Enum$RewardTypeEnum(Enum$RewardTypeEnum e) {
  switch (e) {
    case Enum$RewardTypeEnum.SUBTOTAL_DISCOUNT:
      return r'SUBTOTAL_DISCOUNT';
    case Enum$RewardTypeEnum.GIFT:
      return r'GIFT';
    case Enum$RewardTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$RewardTypeEnum fromJson$Enum$RewardTypeEnum(String value) {
  switch (value) {
    case r'SUBTOTAL_DISCOUNT':
      return Enum$RewardTypeEnum.SUBTOTAL_DISCOUNT;
    case r'GIFT':
      return Enum$RewardTypeEnum.GIFT;
    default:
      return Enum$RewardTypeEnum.$unknown;
  }
}

enum Enum$RewardValueTypeEnum {
  FIXED,
  PERCENTAGE,
  $unknown;

  factory Enum$RewardValueTypeEnum.fromJson(String value) =>
      fromJson$Enum$RewardValueTypeEnum(value);

  String toJson() => toJson$Enum$RewardValueTypeEnum(this);
}

String toJson$Enum$RewardValueTypeEnum(Enum$RewardValueTypeEnum e) {
  switch (e) {
    case Enum$RewardValueTypeEnum.FIXED:
      return r'FIXED';
    case Enum$RewardValueTypeEnum.PERCENTAGE:
      return r'PERCENTAGE';
    case Enum$RewardValueTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$RewardValueTypeEnum fromJson$Enum$RewardValueTypeEnum(String value) {
  switch (value) {
    case r'FIXED':
      return Enum$RewardValueTypeEnum.FIXED;
    case r'PERCENTAGE':
      return Enum$RewardValueTypeEnum.PERCENTAGE;
    default:
      return Enum$RewardValueTypeEnum.$unknown;
  }
}

enum Enum$SaleSortField {
  NAME,
  START_DATE,
  END_DATE,
  VALUE,
  TYPE,
  CREATED_AT,
  LAST_MODIFIED_AT,
  $unknown;

  factory Enum$SaleSortField.fromJson(String value) =>
      fromJson$Enum$SaleSortField(value);

  String toJson() => toJson$Enum$SaleSortField(this);
}

String toJson$Enum$SaleSortField(Enum$SaleSortField e) {
  switch (e) {
    case Enum$SaleSortField.NAME:
      return r'NAME';
    case Enum$SaleSortField.START_DATE:
      return r'START_DATE';
    case Enum$SaleSortField.END_DATE:
      return r'END_DATE';
    case Enum$SaleSortField.VALUE:
      return r'VALUE';
    case Enum$SaleSortField.TYPE:
      return r'TYPE';
    case Enum$SaleSortField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$SaleSortField.LAST_MODIFIED_AT:
      return r'LAST_MODIFIED_AT';
    case Enum$SaleSortField.$unknown:
      return r'$unknown';
  }
}

Enum$SaleSortField fromJson$Enum$SaleSortField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$SaleSortField.NAME;
    case r'START_DATE':
      return Enum$SaleSortField.START_DATE;
    case r'END_DATE':
      return Enum$SaleSortField.END_DATE;
    case r'VALUE':
      return Enum$SaleSortField.VALUE;
    case r'TYPE':
      return Enum$SaleSortField.TYPE;
    case r'CREATED_AT':
      return Enum$SaleSortField.CREATED_AT;
    case r'LAST_MODIFIED_AT':
      return Enum$SaleSortField.LAST_MODIFIED_AT;
    default:
      return Enum$SaleSortField.$unknown;
  }
}

enum Enum$SaleType {
  FIXED,
  PERCENTAGE,
  $unknown;

  factory Enum$SaleType.fromJson(String value) => fromJson$Enum$SaleType(value);

  String toJson() => toJson$Enum$SaleType(this);
}

String toJson$Enum$SaleType(Enum$SaleType e) {
  switch (e) {
    case Enum$SaleType.FIXED:
      return r'FIXED';
    case Enum$SaleType.PERCENTAGE:
      return r'PERCENTAGE';
    case Enum$SaleType.$unknown:
      return r'$unknown';
  }
}

Enum$SaleType fromJson$Enum$SaleType(String value) {
  switch (value) {
    case r'FIXED':
      return Enum$SaleType.FIXED;
    case r'PERCENTAGE':
      return Enum$SaleType.PERCENTAGE;
    default:
      return Enum$SaleType.$unknown;
  }
}

enum Enum$SendConfirmationEmailErrorCode {
  INVALID,
  ACCOUNT_CONFIRMED,
  CONFIRMATION_ALREADY_REQUESTED,
  MISSING_CHANNEL_SLUG,
  $unknown;

  factory Enum$SendConfirmationEmailErrorCode.fromJson(String value) =>
      fromJson$Enum$SendConfirmationEmailErrorCode(value);

  String toJson() => toJson$Enum$SendConfirmationEmailErrorCode(this);
}

String toJson$Enum$SendConfirmationEmailErrorCode(
    Enum$SendConfirmationEmailErrorCode e) {
  switch (e) {
    case Enum$SendConfirmationEmailErrorCode.INVALID:
      return r'INVALID';
    case Enum$SendConfirmationEmailErrorCode.ACCOUNT_CONFIRMED:
      return r'ACCOUNT_CONFIRMED';
    case Enum$SendConfirmationEmailErrorCode.CONFIRMATION_ALREADY_REQUESTED:
      return r'CONFIRMATION_ALREADY_REQUESTED';
    case Enum$SendConfirmationEmailErrorCode.MISSING_CHANNEL_SLUG:
      return r'MISSING_CHANNEL_SLUG';
    case Enum$SendConfirmationEmailErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$SendConfirmationEmailErrorCode
    fromJson$Enum$SendConfirmationEmailErrorCode(String value) {
  switch (value) {
    case r'INVALID':
      return Enum$SendConfirmationEmailErrorCode.INVALID;
    case r'ACCOUNT_CONFIRMED':
      return Enum$SendConfirmationEmailErrorCode.ACCOUNT_CONFIRMED;
    case r'CONFIRMATION_ALREADY_REQUESTED':
      return Enum$SendConfirmationEmailErrorCode.CONFIRMATION_ALREADY_REQUESTED;
    case r'MISSING_CHANNEL_SLUG':
      return Enum$SendConfirmationEmailErrorCode.MISSING_CHANNEL_SLUG;
    default:
      return Enum$SendConfirmationEmailErrorCode.$unknown;
  }
}

enum Enum$ShippingErrorCode {
  ALREADY_EXISTS,
  GRAPHQL_ERROR,
  INVALID,
  MAX_LESS_THAN_MIN,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  DUPLICATED_INPUT_ITEM,
  $unknown;

  factory Enum$ShippingErrorCode.fromJson(String value) =>
      fromJson$Enum$ShippingErrorCode(value);

  String toJson() => toJson$Enum$ShippingErrorCode(this);
}

String toJson$Enum$ShippingErrorCode(Enum$ShippingErrorCode e) {
  switch (e) {
    case Enum$ShippingErrorCode.ALREADY_EXISTS:
      return r'ALREADY_EXISTS';
    case Enum$ShippingErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$ShippingErrorCode.INVALID:
      return r'INVALID';
    case Enum$ShippingErrorCode.MAX_LESS_THAN_MIN:
      return r'MAX_LESS_THAN_MIN';
    case Enum$ShippingErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$ShippingErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$ShippingErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$ShippingErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$ShippingErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$ShippingErrorCode fromJson$Enum$ShippingErrorCode(String value) {
  switch (value) {
    case r'ALREADY_EXISTS':
      return Enum$ShippingErrorCode.ALREADY_EXISTS;
    case r'GRAPHQL_ERROR':
      return Enum$ShippingErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$ShippingErrorCode.INVALID;
    case r'MAX_LESS_THAN_MIN':
      return Enum$ShippingErrorCode.MAX_LESS_THAN_MIN;
    case r'NOT_FOUND':
      return Enum$ShippingErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$ShippingErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$ShippingErrorCode.UNIQUE;
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$ShippingErrorCode.DUPLICATED_INPUT_ITEM;
    default:
      return Enum$ShippingErrorCode.$unknown;
  }
}

enum Enum$ShippingMethodTypeEnum {
  PRICE,
  WEIGHT,
  $unknown;

  factory Enum$ShippingMethodTypeEnum.fromJson(String value) =>
      fromJson$Enum$ShippingMethodTypeEnum(value);

  String toJson() => toJson$Enum$ShippingMethodTypeEnum(this);
}

String toJson$Enum$ShippingMethodTypeEnum(Enum$ShippingMethodTypeEnum e) {
  switch (e) {
    case Enum$ShippingMethodTypeEnum.PRICE:
      return r'PRICE';
    case Enum$ShippingMethodTypeEnum.WEIGHT:
      return r'WEIGHT';
    case Enum$ShippingMethodTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ShippingMethodTypeEnum fromJson$Enum$ShippingMethodTypeEnum(String value) {
  switch (value) {
    case r'PRICE':
      return Enum$ShippingMethodTypeEnum.PRICE;
    case r'WEIGHT':
      return Enum$ShippingMethodTypeEnum.WEIGHT;
    default:
      return Enum$ShippingMethodTypeEnum.$unknown;
  }
}

enum Enum$ShopErrorCode {
  ALREADY_EXISTS,
  CANNOT_FETCH_TAX_RATES,
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  $unknown;

  factory Enum$ShopErrorCode.fromJson(String value) =>
      fromJson$Enum$ShopErrorCode(value);

  String toJson() => toJson$Enum$ShopErrorCode(this);
}

String toJson$Enum$ShopErrorCode(Enum$ShopErrorCode e) {
  switch (e) {
    case Enum$ShopErrorCode.ALREADY_EXISTS:
      return r'ALREADY_EXISTS';
    case Enum$ShopErrorCode.CANNOT_FETCH_TAX_RATES:
      return r'CANNOT_FETCH_TAX_RATES';
    case Enum$ShopErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$ShopErrorCode.INVALID:
      return r'INVALID';
    case Enum$ShopErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$ShopErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$ShopErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$ShopErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$ShopErrorCode fromJson$Enum$ShopErrorCode(String value) {
  switch (value) {
    case r'ALREADY_EXISTS':
      return Enum$ShopErrorCode.ALREADY_EXISTS;
    case r'CANNOT_FETCH_TAX_RATES':
      return Enum$ShopErrorCode.CANNOT_FETCH_TAX_RATES;
    case r'GRAPHQL_ERROR':
      return Enum$ShopErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$ShopErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$ShopErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$ShopErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$ShopErrorCode.UNIQUE;
    default:
      return Enum$ShopErrorCode.$unknown;
  }
}

enum Enum$StaffMemberStatus {
  ACTIVE,
  DEACTIVATED,
  $unknown;

  factory Enum$StaffMemberStatus.fromJson(String value) =>
      fromJson$Enum$StaffMemberStatus(value);

  String toJson() => toJson$Enum$StaffMemberStatus(this);
}

String toJson$Enum$StaffMemberStatus(Enum$StaffMemberStatus e) {
  switch (e) {
    case Enum$StaffMemberStatus.ACTIVE:
      return r'ACTIVE';
    case Enum$StaffMemberStatus.DEACTIVATED:
      return r'DEACTIVATED';
    case Enum$StaffMemberStatus.$unknown:
      return r'$unknown';
  }
}

Enum$StaffMemberStatus fromJson$Enum$StaffMemberStatus(String value) {
  switch (value) {
    case r'ACTIVE':
      return Enum$StaffMemberStatus.ACTIVE;
    case r'DEACTIVATED':
      return Enum$StaffMemberStatus.DEACTIVATED;
    default:
      return Enum$StaffMemberStatus.$unknown;
  }
}

enum Enum$StockAvailability {
  IN_STOCK,
  OUT_OF_STOCK,
  $unknown;

  factory Enum$StockAvailability.fromJson(String value) =>
      fromJson$Enum$StockAvailability(value);

  String toJson() => toJson$Enum$StockAvailability(this);
}

String toJson$Enum$StockAvailability(Enum$StockAvailability e) {
  switch (e) {
    case Enum$StockAvailability.IN_STOCK:
      return r'IN_STOCK';
    case Enum$StockAvailability.OUT_OF_STOCK:
      return r'OUT_OF_STOCK';
    case Enum$StockAvailability.$unknown:
      return r'$unknown';
  }
}

Enum$StockAvailability fromJson$Enum$StockAvailability(String value) {
  switch (value) {
    case r'IN_STOCK':
      return Enum$StockAvailability.IN_STOCK;
    case r'OUT_OF_STOCK':
      return Enum$StockAvailability.OUT_OF_STOCK;
    default:
      return Enum$StockAvailability.$unknown;
  }
}

enum Enum$StockBulkUpdateErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  $unknown;

  factory Enum$StockBulkUpdateErrorCode.fromJson(String value) =>
      fromJson$Enum$StockBulkUpdateErrorCode(value);

  String toJson() => toJson$Enum$StockBulkUpdateErrorCode(this);
}

String toJson$Enum$StockBulkUpdateErrorCode(Enum$StockBulkUpdateErrorCode e) {
  switch (e) {
    case Enum$StockBulkUpdateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$StockBulkUpdateErrorCode.INVALID:
      return r'INVALID';
    case Enum$StockBulkUpdateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$StockBulkUpdateErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$StockBulkUpdateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$StockBulkUpdateErrorCode fromJson$Enum$StockBulkUpdateErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$StockBulkUpdateErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$StockBulkUpdateErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$StockBulkUpdateErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$StockBulkUpdateErrorCode.REQUIRED;
    default:
      return Enum$StockBulkUpdateErrorCode.$unknown;
  }
}

enum Enum$StockErrorCode {
  ALREADY_EXISTS,
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  $unknown;

  factory Enum$StockErrorCode.fromJson(String value) =>
      fromJson$Enum$StockErrorCode(value);

  String toJson() => toJson$Enum$StockErrorCode(this);
}

String toJson$Enum$StockErrorCode(Enum$StockErrorCode e) {
  switch (e) {
    case Enum$StockErrorCode.ALREADY_EXISTS:
      return r'ALREADY_EXISTS';
    case Enum$StockErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$StockErrorCode.INVALID:
      return r'INVALID';
    case Enum$StockErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$StockErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$StockErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$StockErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$StockErrorCode fromJson$Enum$StockErrorCode(String value) {
  switch (value) {
    case r'ALREADY_EXISTS':
      return Enum$StockErrorCode.ALREADY_EXISTS;
    case r'GRAPHQL_ERROR':
      return Enum$StockErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$StockErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$StockErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$StockErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$StockErrorCode.UNIQUE;
    default:
      return Enum$StockErrorCode.$unknown;
  }
}

enum Enum$StockUpdatePolicyEnum {
  SKIP,
  UPDATE,
  FORCE,
  $unknown;

  factory Enum$StockUpdatePolicyEnum.fromJson(String value) =>
      fromJson$Enum$StockUpdatePolicyEnum(value);

  String toJson() => toJson$Enum$StockUpdatePolicyEnum(this);
}

String toJson$Enum$StockUpdatePolicyEnum(Enum$StockUpdatePolicyEnum e) {
  switch (e) {
    case Enum$StockUpdatePolicyEnum.SKIP:
      return r'SKIP';
    case Enum$StockUpdatePolicyEnum.UPDATE:
      return r'UPDATE';
    case Enum$StockUpdatePolicyEnum.FORCE:
      return r'FORCE';
    case Enum$StockUpdatePolicyEnum.$unknown:
      return r'$unknown';
  }
}

Enum$StockUpdatePolicyEnum fromJson$Enum$StockUpdatePolicyEnum(String value) {
  switch (value) {
    case r'SKIP':
      return Enum$StockUpdatePolicyEnum.SKIP;
    case r'UPDATE':
      return Enum$StockUpdatePolicyEnum.UPDATE;
    case r'FORCE':
      return Enum$StockUpdatePolicyEnum.FORCE;
    default:
      return Enum$StockUpdatePolicyEnum.$unknown;
  }
}

enum Enum$StoredPaymentMethodRequestDeleteErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  CHANNEL_INACTIVE,
  GATEWAY_ERROR,
  $unknown;

  factory Enum$StoredPaymentMethodRequestDeleteErrorCode.fromJson(
          String value) =>
      fromJson$Enum$StoredPaymentMethodRequestDeleteErrorCode(value);

  String toJson() =>
      toJson$Enum$StoredPaymentMethodRequestDeleteErrorCode(this);
}

String toJson$Enum$StoredPaymentMethodRequestDeleteErrorCode(
    Enum$StoredPaymentMethodRequestDeleteErrorCode e) {
  switch (e) {
    case Enum$StoredPaymentMethodRequestDeleteErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$StoredPaymentMethodRequestDeleteErrorCode.INVALID:
      return r'INVALID';
    case Enum$StoredPaymentMethodRequestDeleteErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$StoredPaymentMethodRequestDeleteErrorCode.CHANNEL_INACTIVE:
      return r'CHANNEL_INACTIVE';
    case Enum$StoredPaymentMethodRequestDeleteErrorCode.GATEWAY_ERROR:
      return r'GATEWAY_ERROR';
    case Enum$StoredPaymentMethodRequestDeleteErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$StoredPaymentMethodRequestDeleteErrorCode
    fromJson$Enum$StoredPaymentMethodRequestDeleteErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$StoredPaymentMethodRequestDeleteErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$StoredPaymentMethodRequestDeleteErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$StoredPaymentMethodRequestDeleteErrorCode.NOT_FOUND;
    case r'CHANNEL_INACTIVE':
      return Enum$StoredPaymentMethodRequestDeleteErrorCode.CHANNEL_INACTIVE;
    case r'GATEWAY_ERROR':
      return Enum$StoredPaymentMethodRequestDeleteErrorCode.GATEWAY_ERROR;
    default:
      return Enum$StoredPaymentMethodRequestDeleteErrorCode.$unknown;
  }
}

enum Enum$StoredPaymentMethodRequestDeleteResult {
  SUCCESSFULLY_DELETED,
  FAILED_TO_DELETE,
  FAILED_TO_DELIVER,
  $unknown;

  factory Enum$StoredPaymentMethodRequestDeleteResult.fromJson(String value) =>
      fromJson$Enum$StoredPaymentMethodRequestDeleteResult(value);

  String toJson() => toJson$Enum$StoredPaymentMethodRequestDeleteResult(this);
}

String toJson$Enum$StoredPaymentMethodRequestDeleteResult(
    Enum$StoredPaymentMethodRequestDeleteResult e) {
  switch (e) {
    case Enum$StoredPaymentMethodRequestDeleteResult.SUCCESSFULLY_DELETED:
      return r'SUCCESSFULLY_DELETED';
    case Enum$StoredPaymentMethodRequestDeleteResult.FAILED_TO_DELETE:
      return r'FAILED_TO_DELETE';
    case Enum$StoredPaymentMethodRequestDeleteResult.FAILED_TO_DELIVER:
      return r'FAILED_TO_DELIVER';
    case Enum$StoredPaymentMethodRequestDeleteResult.$unknown:
      return r'$unknown';
  }
}

Enum$StoredPaymentMethodRequestDeleteResult
    fromJson$Enum$StoredPaymentMethodRequestDeleteResult(String value) {
  switch (value) {
    case r'SUCCESSFULLY_DELETED':
      return Enum$StoredPaymentMethodRequestDeleteResult.SUCCESSFULLY_DELETED;
    case r'FAILED_TO_DELETE':
      return Enum$StoredPaymentMethodRequestDeleteResult.FAILED_TO_DELETE;
    case r'FAILED_TO_DELIVER':
      return Enum$StoredPaymentMethodRequestDeleteResult.FAILED_TO_DELIVER;
    default:
      return Enum$StoredPaymentMethodRequestDeleteResult.$unknown;
  }
}

enum Enum$StorePaymentMethodEnum {
  ON_SESSION,
  OFF_SESSION,
  NONE,
  $unknown;

  factory Enum$StorePaymentMethodEnum.fromJson(String value) =>
      fromJson$Enum$StorePaymentMethodEnum(value);

  String toJson() => toJson$Enum$StorePaymentMethodEnum(this);
}

String toJson$Enum$StorePaymentMethodEnum(Enum$StorePaymentMethodEnum e) {
  switch (e) {
    case Enum$StorePaymentMethodEnum.ON_SESSION:
      return r'ON_SESSION';
    case Enum$StorePaymentMethodEnum.OFF_SESSION:
      return r'OFF_SESSION';
    case Enum$StorePaymentMethodEnum.NONE:
      return r'NONE';
    case Enum$StorePaymentMethodEnum.$unknown:
      return r'$unknown';
  }
}

Enum$StorePaymentMethodEnum fromJson$Enum$StorePaymentMethodEnum(String value) {
  switch (value) {
    case r'ON_SESSION':
      return Enum$StorePaymentMethodEnum.ON_SESSION;
    case r'OFF_SESSION':
      return Enum$StorePaymentMethodEnum.OFF_SESSION;
    case r'NONE':
      return Enum$StorePaymentMethodEnum.NONE;
    default:
      return Enum$StorePaymentMethodEnum.$unknown;
  }
}

enum Enum$TaxableObjectDiscountTypeEnum {
  SUBTOTAL,
  SHIPPING,
  $unknown;

  factory Enum$TaxableObjectDiscountTypeEnum.fromJson(String value) =>
      fromJson$Enum$TaxableObjectDiscountTypeEnum(value);

  String toJson() => toJson$Enum$TaxableObjectDiscountTypeEnum(this);
}

String toJson$Enum$TaxableObjectDiscountTypeEnum(
    Enum$TaxableObjectDiscountTypeEnum e) {
  switch (e) {
    case Enum$TaxableObjectDiscountTypeEnum.SUBTOTAL:
      return r'SUBTOTAL';
    case Enum$TaxableObjectDiscountTypeEnum.SHIPPING:
      return r'SHIPPING';
    case Enum$TaxableObjectDiscountTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$TaxableObjectDiscountTypeEnum fromJson$Enum$TaxableObjectDiscountTypeEnum(
    String value) {
  switch (value) {
    case r'SUBTOTAL':
      return Enum$TaxableObjectDiscountTypeEnum.SUBTOTAL;
    case r'SHIPPING':
      return Enum$TaxableObjectDiscountTypeEnum.SHIPPING;
    default:
      return Enum$TaxableObjectDiscountTypeEnum.$unknown;
  }
}

enum Enum$TaxCalculationStrategy {
  FLAT_RATES,
  TAX_APP,
  $unknown;

  factory Enum$TaxCalculationStrategy.fromJson(String value) =>
      fromJson$Enum$TaxCalculationStrategy(value);

  String toJson() => toJson$Enum$TaxCalculationStrategy(this);
}

String toJson$Enum$TaxCalculationStrategy(Enum$TaxCalculationStrategy e) {
  switch (e) {
    case Enum$TaxCalculationStrategy.FLAT_RATES:
      return r'FLAT_RATES';
    case Enum$TaxCalculationStrategy.TAX_APP:
      return r'TAX_APP';
    case Enum$TaxCalculationStrategy.$unknown:
      return r'$unknown';
  }
}

Enum$TaxCalculationStrategy fromJson$Enum$TaxCalculationStrategy(String value) {
  switch (value) {
    case r'FLAT_RATES':
      return Enum$TaxCalculationStrategy.FLAT_RATES;
    case r'TAX_APP':
      return Enum$TaxCalculationStrategy.TAX_APP;
    default:
      return Enum$TaxCalculationStrategy.$unknown;
  }
}

enum Enum$TaxClassCreateErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  $unknown;

  factory Enum$TaxClassCreateErrorCode.fromJson(String value) =>
      fromJson$Enum$TaxClassCreateErrorCode(value);

  String toJson() => toJson$Enum$TaxClassCreateErrorCode(this);
}

String toJson$Enum$TaxClassCreateErrorCode(Enum$TaxClassCreateErrorCode e) {
  switch (e) {
    case Enum$TaxClassCreateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$TaxClassCreateErrorCode.INVALID:
      return r'INVALID';
    case Enum$TaxClassCreateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$TaxClassCreateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$TaxClassCreateErrorCode fromJson$Enum$TaxClassCreateErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$TaxClassCreateErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$TaxClassCreateErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$TaxClassCreateErrorCode.NOT_FOUND;
    default:
      return Enum$TaxClassCreateErrorCode.$unknown;
  }
}

enum Enum$TaxClassDeleteErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  $unknown;

  factory Enum$TaxClassDeleteErrorCode.fromJson(String value) =>
      fromJson$Enum$TaxClassDeleteErrorCode(value);

  String toJson() => toJson$Enum$TaxClassDeleteErrorCode(this);
}

String toJson$Enum$TaxClassDeleteErrorCode(Enum$TaxClassDeleteErrorCode e) {
  switch (e) {
    case Enum$TaxClassDeleteErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$TaxClassDeleteErrorCode.INVALID:
      return r'INVALID';
    case Enum$TaxClassDeleteErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$TaxClassDeleteErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$TaxClassDeleteErrorCode fromJson$Enum$TaxClassDeleteErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$TaxClassDeleteErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$TaxClassDeleteErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$TaxClassDeleteErrorCode.NOT_FOUND;
    default:
      return Enum$TaxClassDeleteErrorCode.$unknown;
  }
}

enum Enum$TaxClassSortField {
  NAME,
  $unknown;

  factory Enum$TaxClassSortField.fromJson(String value) =>
      fromJson$Enum$TaxClassSortField(value);

  String toJson() => toJson$Enum$TaxClassSortField(this);
}

String toJson$Enum$TaxClassSortField(Enum$TaxClassSortField e) {
  switch (e) {
    case Enum$TaxClassSortField.NAME:
      return r'NAME';
    case Enum$TaxClassSortField.$unknown:
      return r'$unknown';
  }
}

Enum$TaxClassSortField fromJson$Enum$TaxClassSortField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$TaxClassSortField.NAME;
    default:
      return Enum$TaxClassSortField.$unknown;
  }
}

enum Enum$TaxClassUpdateErrorCode {
  DUPLICATED_INPUT_ITEM,
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  $unknown;

  factory Enum$TaxClassUpdateErrorCode.fromJson(String value) =>
      fromJson$Enum$TaxClassUpdateErrorCode(value);

  String toJson() => toJson$Enum$TaxClassUpdateErrorCode(this);
}

String toJson$Enum$TaxClassUpdateErrorCode(Enum$TaxClassUpdateErrorCode e) {
  switch (e) {
    case Enum$TaxClassUpdateErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$TaxClassUpdateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$TaxClassUpdateErrorCode.INVALID:
      return r'INVALID';
    case Enum$TaxClassUpdateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$TaxClassUpdateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$TaxClassUpdateErrorCode fromJson$Enum$TaxClassUpdateErrorCode(
    String value) {
  switch (value) {
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$TaxClassUpdateErrorCode.DUPLICATED_INPUT_ITEM;
    case r'GRAPHQL_ERROR':
      return Enum$TaxClassUpdateErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$TaxClassUpdateErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$TaxClassUpdateErrorCode.NOT_FOUND;
    default:
      return Enum$TaxClassUpdateErrorCode.$unknown;
  }
}

enum Enum$TaxConfigurationUpdateErrorCode {
  DUPLICATED_INPUT_ITEM,
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  $unknown;

  factory Enum$TaxConfigurationUpdateErrorCode.fromJson(String value) =>
      fromJson$Enum$TaxConfigurationUpdateErrorCode(value);

  String toJson() => toJson$Enum$TaxConfigurationUpdateErrorCode(this);
}

String toJson$Enum$TaxConfigurationUpdateErrorCode(
    Enum$TaxConfigurationUpdateErrorCode e) {
  switch (e) {
    case Enum$TaxConfigurationUpdateErrorCode.DUPLICATED_INPUT_ITEM:
      return r'DUPLICATED_INPUT_ITEM';
    case Enum$TaxConfigurationUpdateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$TaxConfigurationUpdateErrorCode.INVALID:
      return r'INVALID';
    case Enum$TaxConfigurationUpdateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$TaxConfigurationUpdateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$TaxConfigurationUpdateErrorCode
    fromJson$Enum$TaxConfigurationUpdateErrorCode(String value) {
  switch (value) {
    case r'DUPLICATED_INPUT_ITEM':
      return Enum$TaxConfigurationUpdateErrorCode.DUPLICATED_INPUT_ITEM;
    case r'GRAPHQL_ERROR':
      return Enum$TaxConfigurationUpdateErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$TaxConfigurationUpdateErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$TaxConfigurationUpdateErrorCode.NOT_FOUND;
    default:
      return Enum$TaxConfigurationUpdateErrorCode.$unknown;
  }
}

enum Enum$TaxCountryConfigurationDeleteErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  $unknown;

  factory Enum$TaxCountryConfigurationDeleteErrorCode.fromJson(String value) =>
      fromJson$Enum$TaxCountryConfigurationDeleteErrorCode(value);

  String toJson() => toJson$Enum$TaxCountryConfigurationDeleteErrorCode(this);
}

String toJson$Enum$TaxCountryConfigurationDeleteErrorCode(
    Enum$TaxCountryConfigurationDeleteErrorCode e) {
  switch (e) {
    case Enum$TaxCountryConfigurationDeleteErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$TaxCountryConfigurationDeleteErrorCode.INVALID:
      return r'INVALID';
    case Enum$TaxCountryConfigurationDeleteErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$TaxCountryConfigurationDeleteErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$TaxCountryConfigurationDeleteErrorCode
    fromJson$Enum$TaxCountryConfigurationDeleteErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$TaxCountryConfigurationDeleteErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$TaxCountryConfigurationDeleteErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$TaxCountryConfigurationDeleteErrorCode.NOT_FOUND;
    default:
      return Enum$TaxCountryConfigurationDeleteErrorCode.$unknown;
  }
}

enum Enum$TaxCountryConfigurationUpdateErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  ONLY_ONE_DEFAULT_COUNTRY_RATE_ALLOWED,
  CANNOT_CREATE_NEGATIVE_RATE,
  $unknown;

  factory Enum$TaxCountryConfigurationUpdateErrorCode.fromJson(String value) =>
      fromJson$Enum$TaxCountryConfigurationUpdateErrorCode(value);

  String toJson() => toJson$Enum$TaxCountryConfigurationUpdateErrorCode(this);
}

String toJson$Enum$TaxCountryConfigurationUpdateErrorCode(
    Enum$TaxCountryConfigurationUpdateErrorCode e) {
  switch (e) {
    case Enum$TaxCountryConfigurationUpdateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$TaxCountryConfigurationUpdateErrorCode.INVALID:
      return r'INVALID';
    case Enum$TaxCountryConfigurationUpdateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$TaxCountryConfigurationUpdateErrorCode
          .ONLY_ONE_DEFAULT_COUNTRY_RATE_ALLOWED:
      return r'ONLY_ONE_DEFAULT_COUNTRY_RATE_ALLOWED';
    case Enum$TaxCountryConfigurationUpdateErrorCode
          .CANNOT_CREATE_NEGATIVE_RATE:
      return r'CANNOT_CREATE_NEGATIVE_RATE';
    case Enum$TaxCountryConfigurationUpdateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$TaxCountryConfigurationUpdateErrorCode
    fromJson$Enum$TaxCountryConfigurationUpdateErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$TaxCountryConfigurationUpdateErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$TaxCountryConfigurationUpdateErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$TaxCountryConfigurationUpdateErrorCode.NOT_FOUND;
    case r'ONLY_ONE_DEFAULT_COUNTRY_RATE_ALLOWED':
      return Enum$TaxCountryConfigurationUpdateErrorCode
          .ONLY_ONE_DEFAULT_COUNTRY_RATE_ALLOWED;
    case r'CANNOT_CREATE_NEGATIVE_RATE':
      return Enum$TaxCountryConfigurationUpdateErrorCode
          .CANNOT_CREATE_NEGATIVE_RATE;
    default:
      return Enum$TaxCountryConfigurationUpdateErrorCode.$unknown;
  }
}

enum Enum$TaxExemptionManageErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  NOT_EDITABLE_ORDER,
  $unknown;

  factory Enum$TaxExemptionManageErrorCode.fromJson(String value) =>
      fromJson$Enum$TaxExemptionManageErrorCode(value);

  String toJson() => toJson$Enum$TaxExemptionManageErrorCode(this);
}

String toJson$Enum$TaxExemptionManageErrorCode(
    Enum$TaxExemptionManageErrorCode e) {
  switch (e) {
    case Enum$TaxExemptionManageErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$TaxExemptionManageErrorCode.INVALID:
      return r'INVALID';
    case Enum$TaxExemptionManageErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$TaxExemptionManageErrorCode.NOT_EDITABLE_ORDER:
      return r'NOT_EDITABLE_ORDER';
    case Enum$TaxExemptionManageErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$TaxExemptionManageErrorCode fromJson$Enum$TaxExemptionManageErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$TaxExemptionManageErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$TaxExemptionManageErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$TaxExemptionManageErrorCode.NOT_FOUND;
    case r'NOT_EDITABLE_ORDER':
      return Enum$TaxExemptionManageErrorCode.NOT_EDITABLE_ORDER;
    default:
      return Enum$TaxExemptionManageErrorCode.$unknown;
  }
}

enum Enum$ThumbnailFormatEnum {
  ORIGINAL,
  AVIF,
  WEBP,
  $unknown;

  factory Enum$ThumbnailFormatEnum.fromJson(String value) =>
      fromJson$Enum$ThumbnailFormatEnum(value);

  String toJson() => toJson$Enum$ThumbnailFormatEnum(this);
}

String toJson$Enum$ThumbnailFormatEnum(Enum$ThumbnailFormatEnum e) {
  switch (e) {
    case Enum$ThumbnailFormatEnum.ORIGINAL:
      return r'ORIGINAL';
    case Enum$ThumbnailFormatEnum.AVIF:
      return r'AVIF';
    case Enum$ThumbnailFormatEnum.WEBP:
      return r'WEBP';
    case Enum$ThumbnailFormatEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ThumbnailFormatEnum fromJson$Enum$ThumbnailFormatEnum(String value) {
  switch (value) {
    case r'ORIGINAL':
      return Enum$ThumbnailFormatEnum.ORIGINAL;
    case r'AVIF':
      return Enum$ThumbnailFormatEnum.AVIF;
    case r'WEBP':
      return Enum$ThumbnailFormatEnum.WEBP;
    default:
      return Enum$ThumbnailFormatEnum.$unknown;
  }
}

enum Enum$TimePeriodTypeEnum {
  DAY,
  WEEK,
  MONTH,
  YEAR,
  $unknown;

  factory Enum$TimePeriodTypeEnum.fromJson(String value) =>
      fromJson$Enum$TimePeriodTypeEnum(value);

  String toJson() => toJson$Enum$TimePeriodTypeEnum(this);
}

String toJson$Enum$TimePeriodTypeEnum(Enum$TimePeriodTypeEnum e) {
  switch (e) {
    case Enum$TimePeriodTypeEnum.DAY:
      return r'DAY';
    case Enum$TimePeriodTypeEnum.WEEK:
      return r'WEEK';
    case Enum$TimePeriodTypeEnum.MONTH:
      return r'MONTH';
    case Enum$TimePeriodTypeEnum.YEAR:
      return r'YEAR';
    case Enum$TimePeriodTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$TimePeriodTypeEnum fromJson$Enum$TimePeriodTypeEnum(String value) {
  switch (value) {
    case r'DAY':
      return Enum$TimePeriodTypeEnum.DAY;
    case r'WEEK':
      return Enum$TimePeriodTypeEnum.WEEK;
    case r'MONTH':
      return Enum$TimePeriodTypeEnum.MONTH;
    case r'YEAR':
      return Enum$TimePeriodTypeEnum.YEAR;
    default:
      return Enum$TimePeriodTypeEnum.$unknown;
  }
}

enum Enum$TokenizedPaymentFlowEnum {
  INTERACTIVE,
  $unknown;

  factory Enum$TokenizedPaymentFlowEnum.fromJson(String value) =>
      fromJson$Enum$TokenizedPaymentFlowEnum(value);

  String toJson() => toJson$Enum$TokenizedPaymentFlowEnum(this);
}

String toJson$Enum$TokenizedPaymentFlowEnum(Enum$TokenizedPaymentFlowEnum e) {
  switch (e) {
    case Enum$TokenizedPaymentFlowEnum.INTERACTIVE:
      return r'INTERACTIVE';
    case Enum$TokenizedPaymentFlowEnum.$unknown:
      return r'$unknown';
  }
}

Enum$TokenizedPaymentFlowEnum fromJson$Enum$TokenizedPaymentFlowEnum(
    String value) {
  switch (value) {
    case r'INTERACTIVE':
      return Enum$TokenizedPaymentFlowEnum.INTERACTIVE;
    default:
      return Enum$TokenizedPaymentFlowEnum.$unknown;
  }
}

enum Enum$TransactionActionEnum {
  CHARGE,
  REFUND,
  CANCEL,
  $unknown;

  factory Enum$TransactionActionEnum.fromJson(String value) =>
      fromJson$Enum$TransactionActionEnum(value);

  String toJson() => toJson$Enum$TransactionActionEnum(this);
}

String toJson$Enum$TransactionActionEnum(Enum$TransactionActionEnum e) {
  switch (e) {
    case Enum$TransactionActionEnum.CHARGE:
      return r'CHARGE';
    case Enum$TransactionActionEnum.REFUND:
      return r'REFUND';
    case Enum$TransactionActionEnum.CANCEL:
      return r'CANCEL';
    case Enum$TransactionActionEnum.$unknown:
      return r'$unknown';
  }
}

Enum$TransactionActionEnum fromJson$Enum$TransactionActionEnum(String value) {
  switch (value) {
    case r'CHARGE':
      return Enum$TransactionActionEnum.CHARGE;
    case r'REFUND':
      return Enum$TransactionActionEnum.REFUND;
    case r'CANCEL':
      return Enum$TransactionActionEnum.CANCEL;
    default:
      return Enum$TransactionActionEnum.$unknown;
  }
}

enum Enum$TransactionCreateErrorCode {
  INVALID,
  GRAPHQL_ERROR,
  NOT_FOUND,
  INCORRECT_CURRENCY,
  METADATA_KEY_REQUIRED,
  UNIQUE,
  $unknown;

  factory Enum$TransactionCreateErrorCode.fromJson(String value) =>
      fromJson$Enum$TransactionCreateErrorCode(value);

  String toJson() => toJson$Enum$TransactionCreateErrorCode(this);
}

String toJson$Enum$TransactionCreateErrorCode(
    Enum$TransactionCreateErrorCode e) {
  switch (e) {
    case Enum$TransactionCreateErrorCode.INVALID:
      return r'INVALID';
    case Enum$TransactionCreateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$TransactionCreateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$TransactionCreateErrorCode.INCORRECT_CURRENCY:
      return r'INCORRECT_CURRENCY';
    case Enum$TransactionCreateErrorCode.METADATA_KEY_REQUIRED:
      return r'METADATA_KEY_REQUIRED';
    case Enum$TransactionCreateErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$TransactionCreateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$TransactionCreateErrorCode fromJson$Enum$TransactionCreateErrorCode(
    String value) {
  switch (value) {
    case r'INVALID':
      return Enum$TransactionCreateErrorCode.INVALID;
    case r'GRAPHQL_ERROR':
      return Enum$TransactionCreateErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$TransactionCreateErrorCode.NOT_FOUND;
    case r'INCORRECT_CURRENCY':
      return Enum$TransactionCreateErrorCode.INCORRECT_CURRENCY;
    case r'METADATA_KEY_REQUIRED':
      return Enum$TransactionCreateErrorCode.METADATA_KEY_REQUIRED;
    case r'UNIQUE':
      return Enum$TransactionCreateErrorCode.UNIQUE;
    default:
      return Enum$TransactionCreateErrorCode.$unknown;
  }
}

enum Enum$TransactionEventReportErrorCode {
  INVALID,
  GRAPHQL_ERROR,
  NOT_FOUND,
  INCORRECT_DETAILS,
  ALREADY_EXISTS,
  REQUIRED,
  $unknown;

  factory Enum$TransactionEventReportErrorCode.fromJson(String value) =>
      fromJson$Enum$TransactionEventReportErrorCode(value);

  String toJson() => toJson$Enum$TransactionEventReportErrorCode(this);
}

String toJson$Enum$TransactionEventReportErrorCode(
    Enum$TransactionEventReportErrorCode e) {
  switch (e) {
    case Enum$TransactionEventReportErrorCode.INVALID:
      return r'INVALID';
    case Enum$TransactionEventReportErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$TransactionEventReportErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$TransactionEventReportErrorCode.INCORRECT_DETAILS:
      return r'INCORRECT_DETAILS';
    case Enum$TransactionEventReportErrorCode.ALREADY_EXISTS:
      return r'ALREADY_EXISTS';
    case Enum$TransactionEventReportErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$TransactionEventReportErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$TransactionEventReportErrorCode
    fromJson$Enum$TransactionEventReportErrorCode(String value) {
  switch (value) {
    case r'INVALID':
      return Enum$TransactionEventReportErrorCode.INVALID;
    case r'GRAPHQL_ERROR':
      return Enum$TransactionEventReportErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$TransactionEventReportErrorCode.NOT_FOUND;
    case r'INCORRECT_DETAILS':
      return Enum$TransactionEventReportErrorCode.INCORRECT_DETAILS;
    case r'ALREADY_EXISTS':
      return Enum$TransactionEventReportErrorCode.ALREADY_EXISTS;
    case r'REQUIRED':
      return Enum$TransactionEventReportErrorCode.REQUIRED;
    default:
      return Enum$TransactionEventReportErrorCode.$unknown;
  }
}

enum Enum$TransactionEventTypeEnum {
  AUTHORIZATION_SUCCESS,
  AUTHORIZATION_FAILURE,
  AUTHORIZATION_ADJUSTMENT,
  AUTHORIZATION_REQUEST,
  AUTHORIZATION_ACTION_REQUIRED,
  CHARGE_ACTION_REQUIRED,
  CHARGE_SUCCESS,
  CHARGE_FAILURE,
  CHARGE_BACK,
  CHARGE_REQUEST,
  REFUND_SUCCESS,
  REFUND_FAILURE,
  REFUND_REVERSE,
  REFUND_REQUEST,
  CANCEL_SUCCESS,
  CANCEL_FAILURE,
  CANCEL_REQUEST,
  INFO,
  $unknown;

  factory Enum$TransactionEventTypeEnum.fromJson(String value) =>
      fromJson$Enum$TransactionEventTypeEnum(value);

  String toJson() => toJson$Enum$TransactionEventTypeEnum(this);
}

String toJson$Enum$TransactionEventTypeEnum(Enum$TransactionEventTypeEnum e) {
  switch (e) {
    case Enum$TransactionEventTypeEnum.AUTHORIZATION_SUCCESS:
      return r'AUTHORIZATION_SUCCESS';
    case Enum$TransactionEventTypeEnum.AUTHORIZATION_FAILURE:
      return r'AUTHORIZATION_FAILURE';
    case Enum$TransactionEventTypeEnum.AUTHORIZATION_ADJUSTMENT:
      return r'AUTHORIZATION_ADJUSTMENT';
    case Enum$TransactionEventTypeEnum.AUTHORIZATION_REQUEST:
      return r'AUTHORIZATION_REQUEST';
    case Enum$TransactionEventTypeEnum.AUTHORIZATION_ACTION_REQUIRED:
      return r'AUTHORIZATION_ACTION_REQUIRED';
    case Enum$TransactionEventTypeEnum.CHARGE_ACTION_REQUIRED:
      return r'CHARGE_ACTION_REQUIRED';
    case Enum$TransactionEventTypeEnum.CHARGE_SUCCESS:
      return r'CHARGE_SUCCESS';
    case Enum$TransactionEventTypeEnum.CHARGE_FAILURE:
      return r'CHARGE_FAILURE';
    case Enum$TransactionEventTypeEnum.CHARGE_BACK:
      return r'CHARGE_BACK';
    case Enum$TransactionEventTypeEnum.CHARGE_REQUEST:
      return r'CHARGE_REQUEST';
    case Enum$TransactionEventTypeEnum.REFUND_SUCCESS:
      return r'REFUND_SUCCESS';
    case Enum$TransactionEventTypeEnum.REFUND_FAILURE:
      return r'REFUND_FAILURE';
    case Enum$TransactionEventTypeEnum.REFUND_REVERSE:
      return r'REFUND_REVERSE';
    case Enum$TransactionEventTypeEnum.REFUND_REQUEST:
      return r'REFUND_REQUEST';
    case Enum$TransactionEventTypeEnum.CANCEL_SUCCESS:
      return r'CANCEL_SUCCESS';
    case Enum$TransactionEventTypeEnum.CANCEL_FAILURE:
      return r'CANCEL_FAILURE';
    case Enum$TransactionEventTypeEnum.CANCEL_REQUEST:
      return r'CANCEL_REQUEST';
    case Enum$TransactionEventTypeEnum.INFO:
      return r'INFO';
    case Enum$TransactionEventTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$TransactionEventTypeEnum fromJson$Enum$TransactionEventTypeEnum(
    String value) {
  switch (value) {
    case r'AUTHORIZATION_SUCCESS':
      return Enum$TransactionEventTypeEnum.AUTHORIZATION_SUCCESS;
    case r'AUTHORIZATION_FAILURE':
      return Enum$TransactionEventTypeEnum.AUTHORIZATION_FAILURE;
    case r'AUTHORIZATION_ADJUSTMENT':
      return Enum$TransactionEventTypeEnum.AUTHORIZATION_ADJUSTMENT;
    case r'AUTHORIZATION_REQUEST':
      return Enum$TransactionEventTypeEnum.AUTHORIZATION_REQUEST;
    case r'AUTHORIZATION_ACTION_REQUIRED':
      return Enum$TransactionEventTypeEnum.AUTHORIZATION_ACTION_REQUIRED;
    case r'CHARGE_ACTION_REQUIRED':
      return Enum$TransactionEventTypeEnum.CHARGE_ACTION_REQUIRED;
    case r'CHARGE_SUCCESS':
      return Enum$TransactionEventTypeEnum.CHARGE_SUCCESS;
    case r'CHARGE_FAILURE':
      return Enum$TransactionEventTypeEnum.CHARGE_FAILURE;
    case r'CHARGE_BACK':
      return Enum$TransactionEventTypeEnum.CHARGE_BACK;
    case r'CHARGE_REQUEST':
      return Enum$TransactionEventTypeEnum.CHARGE_REQUEST;
    case r'REFUND_SUCCESS':
      return Enum$TransactionEventTypeEnum.REFUND_SUCCESS;
    case r'REFUND_FAILURE':
      return Enum$TransactionEventTypeEnum.REFUND_FAILURE;
    case r'REFUND_REVERSE':
      return Enum$TransactionEventTypeEnum.REFUND_REVERSE;
    case r'REFUND_REQUEST':
      return Enum$TransactionEventTypeEnum.REFUND_REQUEST;
    case r'CANCEL_SUCCESS':
      return Enum$TransactionEventTypeEnum.CANCEL_SUCCESS;
    case r'CANCEL_FAILURE':
      return Enum$TransactionEventTypeEnum.CANCEL_FAILURE;
    case r'CANCEL_REQUEST':
      return Enum$TransactionEventTypeEnum.CANCEL_REQUEST;
    case r'INFO':
      return Enum$TransactionEventTypeEnum.INFO;
    default:
      return Enum$TransactionEventTypeEnum.$unknown;
  }
}

enum Enum$TransactionFlowStrategyEnum {
  AUTHORIZATION,
  CHARGE,
  $unknown;

  factory Enum$TransactionFlowStrategyEnum.fromJson(String value) =>
      fromJson$Enum$TransactionFlowStrategyEnum(value);

  String toJson() => toJson$Enum$TransactionFlowStrategyEnum(this);
}

String toJson$Enum$TransactionFlowStrategyEnum(
    Enum$TransactionFlowStrategyEnum e) {
  switch (e) {
    case Enum$TransactionFlowStrategyEnum.AUTHORIZATION:
      return r'AUTHORIZATION';
    case Enum$TransactionFlowStrategyEnum.CHARGE:
      return r'CHARGE';
    case Enum$TransactionFlowStrategyEnum.$unknown:
      return r'$unknown';
  }
}

Enum$TransactionFlowStrategyEnum fromJson$Enum$TransactionFlowStrategyEnum(
    String value) {
  switch (value) {
    case r'AUTHORIZATION':
      return Enum$TransactionFlowStrategyEnum.AUTHORIZATION;
    case r'CHARGE':
      return Enum$TransactionFlowStrategyEnum.CHARGE;
    default:
      return Enum$TransactionFlowStrategyEnum.$unknown;
  }
}

enum Enum$TransactionInitializeErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  UNIQUE,
  CHECKOUT_COMPLETION_IN_PROGRESS,
  $unknown;

  factory Enum$TransactionInitializeErrorCode.fromJson(String value) =>
      fromJson$Enum$TransactionInitializeErrorCode(value);

  String toJson() => toJson$Enum$TransactionInitializeErrorCode(this);
}

String toJson$Enum$TransactionInitializeErrorCode(
    Enum$TransactionInitializeErrorCode e) {
  switch (e) {
    case Enum$TransactionInitializeErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$TransactionInitializeErrorCode.INVALID:
      return r'INVALID';
    case Enum$TransactionInitializeErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$TransactionInitializeErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$TransactionInitializeErrorCode.CHECKOUT_COMPLETION_IN_PROGRESS:
      return r'CHECKOUT_COMPLETION_IN_PROGRESS';
    case Enum$TransactionInitializeErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$TransactionInitializeErrorCode
    fromJson$Enum$TransactionInitializeErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$TransactionInitializeErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$TransactionInitializeErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$TransactionInitializeErrorCode.NOT_FOUND;
    case r'UNIQUE':
      return Enum$TransactionInitializeErrorCode.UNIQUE;
    case r'CHECKOUT_COMPLETION_IN_PROGRESS':
      return Enum$TransactionInitializeErrorCode
          .CHECKOUT_COMPLETION_IN_PROGRESS;
    default:
      return Enum$TransactionInitializeErrorCode.$unknown;
  }
}

enum Enum$TransactionKind {
  EXTERNAL,
  AUTH,
  PENDING,
  ACTION_TO_CONFIRM,
  REFUND,
  REFUND_ONGOING,
  CAPTURE,
  VOID,
  CONFIRM,
  CANCEL,
  $unknown;

  factory Enum$TransactionKind.fromJson(String value) =>
      fromJson$Enum$TransactionKind(value);

  String toJson() => toJson$Enum$TransactionKind(this);
}

String toJson$Enum$TransactionKind(Enum$TransactionKind e) {
  switch (e) {
    case Enum$TransactionKind.EXTERNAL:
      return r'EXTERNAL';
    case Enum$TransactionKind.AUTH:
      return r'AUTH';
    case Enum$TransactionKind.PENDING:
      return r'PENDING';
    case Enum$TransactionKind.ACTION_TO_CONFIRM:
      return r'ACTION_TO_CONFIRM';
    case Enum$TransactionKind.REFUND:
      return r'REFUND';
    case Enum$TransactionKind.REFUND_ONGOING:
      return r'REFUND_ONGOING';
    case Enum$TransactionKind.CAPTURE:
      return r'CAPTURE';
    case Enum$TransactionKind.VOID:
      return r'VOID';
    case Enum$TransactionKind.CONFIRM:
      return r'CONFIRM';
    case Enum$TransactionKind.CANCEL:
      return r'CANCEL';
    case Enum$TransactionKind.$unknown:
      return r'$unknown';
  }
}

Enum$TransactionKind fromJson$Enum$TransactionKind(String value) {
  switch (value) {
    case r'EXTERNAL':
      return Enum$TransactionKind.EXTERNAL;
    case r'AUTH':
      return Enum$TransactionKind.AUTH;
    case r'PENDING':
      return Enum$TransactionKind.PENDING;
    case r'ACTION_TO_CONFIRM':
      return Enum$TransactionKind.ACTION_TO_CONFIRM;
    case r'REFUND':
      return Enum$TransactionKind.REFUND;
    case r'REFUND_ONGOING':
      return Enum$TransactionKind.REFUND_ONGOING;
    case r'CAPTURE':
      return Enum$TransactionKind.CAPTURE;
    case r'VOID':
      return Enum$TransactionKind.VOID;
    case r'CONFIRM':
      return Enum$TransactionKind.CONFIRM;
    case r'CANCEL':
      return Enum$TransactionKind.CANCEL;
    default:
      return Enum$TransactionKind.$unknown;
  }
}

enum Enum$TransactionProcessErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  TRANSACTION_ALREADY_PROCESSED,
  MISSING_PAYMENT_APP_RELATION,
  MISSING_PAYMENT_APP,
  CHECKOUT_COMPLETION_IN_PROGRESS,
  $unknown;

  factory Enum$TransactionProcessErrorCode.fromJson(String value) =>
      fromJson$Enum$TransactionProcessErrorCode(value);

  String toJson() => toJson$Enum$TransactionProcessErrorCode(this);
}

String toJson$Enum$TransactionProcessErrorCode(
    Enum$TransactionProcessErrorCode e) {
  switch (e) {
    case Enum$TransactionProcessErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$TransactionProcessErrorCode.INVALID:
      return r'INVALID';
    case Enum$TransactionProcessErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$TransactionProcessErrorCode.TRANSACTION_ALREADY_PROCESSED:
      return r'TRANSACTION_ALREADY_PROCESSED';
    case Enum$TransactionProcessErrorCode.MISSING_PAYMENT_APP_RELATION:
      return r'MISSING_PAYMENT_APP_RELATION';
    case Enum$TransactionProcessErrorCode.MISSING_PAYMENT_APP:
      return r'MISSING_PAYMENT_APP';
    case Enum$TransactionProcessErrorCode.CHECKOUT_COMPLETION_IN_PROGRESS:
      return r'CHECKOUT_COMPLETION_IN_PROGRESS';
    case Enum$TransactionProcessErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$TransactionProcessErrorCode fromJson$Enum$TransactionProcessErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$TransactionProcessErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$TransactionProcessErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$TransactionProcessErrorCode.NOT_FOUND;
    case r'TRANSACTION_ALREADY_PROCESSED':
      return Enum$TransactionProcessErrorCode.TRANSACTION_ALREADY_PROCESSED;
    case r'MISSING_PAYMENT_APP_RELATION':
      return Enum$TransactionProcessErrorCode.MISSING_PAYMENT_APP_RELATION;
    case r'MISSING_PAYMENT_APP':
      return Enum$TransactionProcessErrorCode.MISSING_PAYMENT_APP;
    case r'CHECKOUT_COMPLETION_IN_PROGRESS':
      return Enum$TransactionProcessErrorCode.CHECKOUT_COMPLETION_IN_PROGRESS;
    default:
      return Enum$TransactionProcessErrorCode.$unknown;
  }
}

enum Enum$TransactionRequestActionErrorCode {
  INVALID,
  GRAPHQL_ERROR,
  NOT_FOUND,
  MISSING_TRANSACTION_ACTION_REQUEST_WEBHOOK,
  $unknown;

  factory Enum$TransactionRequestActionErrorCode.fromJson(String value) =>
      fromJson$Enum$TransactionRequestActionErrorCode(value);

  String toJson() => toJson$Enum$TransactionRequestActionErrorCode(this);
}

String toJson$Enum$TransactionRequestActionErrorCode(
    Enum$TransactionRequestActionErrorCode e) {
  switch (e) {
    case Enum$TransactionRequestActionErrorCode.INVALID:
      return r'INVALID';
    case Enum$TransactionRequestActionErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$TransactionRequestActionErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$TransactionRequestActionErrorCode
          .MISSING_TRANSACTION_ACTION_REQUEST_WEBHOOK:
      return r'MISSING_TRANSACTION_ACTION_REQUEST_WEBHOOK';
    case Enum$TransactionRequestActionErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$TransactionRequestActionErrorCode
    fromJson$Enum$TransactionRequestActionErrorCode(String value) {
  switch (value) {
    case r'INVALID':
      return Enum$TransactionRequestActionErrorCode.INVALID;
    case r'GRAPHQL_ERROR':
      return Enum$TransactionRequestActionErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$TransactionRequestActionErrorCode.NOT_FOUND;
    case r'MISSING_TRANSACTION_ACTION_REQUEST_WEBHOOK':
      return Enum$TransactionRequestActionErrorCode
          .MISSING_TRANSACTION_ACTION_REQUEST_WEBHOOK;
    default:
      return Enum$TransactionRequestActionErrorCode.$unknown;
  }
}

enum Enum$TransactionRequestRefundForGrantedRefundErrorCode {
  INVALID,
  GRAPHQL_ERROR,
  NOT_FOUND,
  AMOUNT_GREATER_THAN_AVAILABLE,
  MISSING_TRANSACTION_ACTION_REQUEST_WEBHOOK,
  REFUND_ALREADY_PROCESSED,
  REFUND_IS_PENDING,
  $unknown;

  factory Enum$TransactionRequestRefundForGrantedRefundErrorCode.fromJson(
          String value) =>
      fromJson$Enum$TransactionRequestRefundForGrantedRefundErrorCode(value);

  String toJson() =>
      toJson$Enum$TransactionRequestRefundForGrantedRefundErrorCode(this);
}

String toJson$Enum$TransactionRequestRefundForGrantedRefundErrorCode(
    Enum$TransactionRequestRefundForGrantedRefundErrorCode e) {
  switch (e) {
    case Enum$TransactionRequestRefundForGrantedRefundErrorCode.INVALID:
      return r'INVALID';
    case Enum$TransactionRequestRefundForGrantedRefundErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$TransactionRequestRefundForGrantedRefundErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$TransactionRequestRefundForGrantedRefundErrorCode
          .AMOUNT_GREATER_THAN_AVAILABLE:
      return r'AMOUNT_GREATER_THAN_AVAILABLE';
    case Enum$TransactionRequestRefundForGrantedRefundErrorCode
          .MISSING_TRANSACTION_ACTION_REQUEST_WEBHOOK:
      return r'MISSING_TRANSACTION_ACTION_REQUEST_WEBHOOK';
    case Enum$TransactionRequestRefundForGrantedRefundErrorCode
          .REFUND_ALREADY_PROCESSED:
      return r'REFUND_ALREADY_PROCESSED';
    case Enum$TransactionRequestRefundForGrantedRefundErrorCode
          .REFUND_IS_PENDING:
      return r'REFUND_IS_PENDING';
    case Enum$TransactionRequestRefundForGrantedRefundErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$TransactionRequestRefundForGrantedRefundErrorCode
    fromJson$Enum$TransactionRequestRefundForGrantedRefundErrorCode(
        String value) {
  switch (value) {
    case r'INVALID':
      return Enum$TransactionRequestRefundForGrantedRefundErrorCode.INVALID;
    case r'GRAPHQL_ERROR':
      return Enum$TransactionRequestRefundForGrantedRefundErrorCode
          .GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$TransactionRequestRefundForGrantedRefundErrorCode.NOT_FOUND;
    case r'AMOUNT_GREATER_THAN_AVAILABLE':
      return Enum$TransactionRequestRefundForGrantedRefundErrorCode
          .AMOUNT_GREATER_THAN_AVAILABLE;
    case r'MISSING_TRANSACTION_ACTION_REQUEST_WEBHOOK':
      return Enum$TransactionRequestRefundForGrantedRefundErrorCode
          .MISSING_TRANSACTION_ACTION_REQUEST_WEBHOOK;
    case r'REFUND_ALREADY_PROCESSED':
      return Enum$TransactionRequestRefundForGrantedRefundErrorCode
          .REFUND_ALREADY_PROCESSED;
    case r'REFUND_IS_PENDING':
      return Enum$TransactionRequestRefundForGrantedRefundErrorCode
          .REFUND_IS_PENDING;
    default:
      return Enum$TransactionRequestRefundForGrantedRefundErrorCode.$unknown;
  }
}

enum Enum$TransactionUpdateErrorCode {
  INVALID,
  GRAPHQL_ERROR,
  NOT_FOUND,
  INCORRECT_CURRENCY,
  METADATA_KEY_REQUIRED,
  UNIQUE,
  $unknown;

  factory Enum$TransactionUpdateErrorCode.fromJson(String value) =>
      fromJson$Enum$TransactionUpdateErrorCode(value);

  String toJson() => toJson$Enum$TransactionUpdateErrorCode(this);
}

String toJson$Enum$TransactionUpdateErrorCode(
    Enum$TransactionUpdateErrorCode e) {
  switch (e) {
    case Enum$TransactionUpdateErrorCode.INVALID:
      return r'INVALID';
    case Enum$TransactionUpdateErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$TransactionUpdateErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$TransactionUpdateErrorCode.INCORRECT_CURRENCY:
      return r'INCORRECT_CURRENCY';
    case Enum$TransactionUpdateErrorCode.METADATA_KEY_REQUIRED:
      return r'METADATA_KEY_REQUIRED';
    case Enum$TransactionUpdateErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$TransactionUpdateErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$TransactionUpdateErrorCode fromJson$Enum$TransactionUpdateErrorCode(
    String value) {
  switch (value) {
    case r'INVALID':
      return Enum$TransactionUpdateErrorCode.INVALID;
    case r'GRAPHQL_ERROR':
      return Enum$TransactionUpdateErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$TransactionUpdateErrorCode.NOT_FOUND;
    case r'INCORRECT_CURRENCY':
      return Enum$TransactionUpdateErrorCode.INCORRECT_CURRENCY;
    case r'METADATA_KEY_REQUIRED':
      return Enum$TransactionUpdateErrorCode.METADATA_KEY_REQUIRED;
    case r'UNIQUE':
      return Enum$TransactionUpdateErrorCode.UNIQUE;
    default:
      return Enum$TransactionUpdateErrorCode.$unknown;
  }
}

enum Enum$TranslatableKinds {
  ATTRIBUTE,
  ATTRIBUTE_VALUE,
  CATEGORY,
  COLLECTION,
  MENU_ITEM,
  PAGE,
  PRODUCT,
  PROMOTION,
  PROMOTION_RULE,
  SALE,
  SHIPPING_METHOD,
  VARIANT,
  VOUCHER,
  $unknown;

  factory Enum$TranslatableKinds.fromJson(String value) =>
      fromJson$Enum$TranslatableKinds(value);

  String toJson() => toJson$Enum$TranslatableKinds(this);
}

String toJson$Enum$TranslatableKinds(Enum$TranslatableKinds e) {
  switch (e) {
    case Enum$TranslatableKinds.ATTRIBUTE:
      return r'ATTRIBUTE';
    case Enum$TranslatableKinds.ATTRIBUTE_VALUE:
      return r'ATTRIBUTE_VALUE';
    case Enum$TranslatableKinds.CATEGORY:
      return r'CATEGORY';
    case Enum$TranslatableKinds.COLLECTION:
      return r'COLLECTION';
    case Enum$TranslatableKinds.MENU_ITEM:
      return r'MENU_ITEM';
    case Enum$TranslatableKinds.PAGE:
      return r'PAGE';
    case Enum$TranslatableKinds.PRODUCT:
      return r'PRODUCT';
    case Enum$TranslatableKinds.PROMOTION:
      return r'PROMOTION';
    case Enum$TranslatableKinds.PROMOTION_RULE:
      return r'PROMOTION_RULE';
    case Enum$TranslatableKinds.SALE:
      return r'SALE';
    case Enum$TranslatableKinds.SHIPPING_METHOD:
      return r'SHIPPING_METHOD';
    case Enum$TranslatableKinds.VARIANT:
      return r'VARIANT';
    case Enum$TranslatableKinds.VOUCHER:
      return r'VOUCHER';
    case Enum$TranslatableKinds.$unknown:
      return r'$unknown';
  }
}

Enum$TranslatableKinds fromJson$Enum$TranslatableKinds(String value) {
  switch (value) {
    case r'ATTRIBUTE':
      return Enum$TranslatableKinds.ATTRIBUTE;
    case r'ATTRIBUTE_VALUE':
      return Enum$TranslatableKinds.ATTRIBUTE_VALUE;
    case r'CATEGORY':
      return Enum$TranslatableKinds.CATEGORY;
    case r'COLLECTION':
      return Enum$TranslatableKinds.COLLECTION;
    case r'MENU_ITEM':
      return Enum$TranslatableKinds.MENU_ITEM;
    case r'PAGE':
      return Enum$TranslatableKinds.PAGE;
    case r'PRODUCT':
      return Enum$TranslatableKinds.PRODUCT;
    case r'PROMOTION':
      return Enum$TranslatableKinds.PROMOTION;
    case r'PROMOTION_RULE':
      return Enum$TranslatableKinds.PROMOTION_RULE;
    case r'SALE':
      return Enum$TranslatableKinds.SALE;
    case r'SHIPPING_METHOD':
      return Enum$TranslatableKinds.SHIPPING_METHOD;
    case r'VARIANT':
      return Enum$TranslatableKinds.VARIANT;
    case r'VOUCHER':
      return Enum$TranslatableKinds.VOUCHER;
    default:
      return Enum$TranslatableKinds.$unknown;
  }
}

enum Enum$TranslationErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  $unknown;

  factory Enum$TranslationErrorCode.fromJson(String value) =>
      fromJson$Enum$TranslationErrorCode(value);

  String toJson() => toJson$Enum$TranslationErrorCode(this);
}

String toJson$Enum$TranslationErrorCode(Enum$TranslationErrorCode e) {
  switch (e) {
    case Enum$TranslationErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$TranslationErrorCode.INVALID:
      return r'INVALID';
    case Enum$TranslationErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$TranslationErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$TranslationErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$TranslationErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$TranslationErrorCode fromJson$Enum$TranslationErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$TranslationErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$TranslationErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$TranslationErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$TranslationErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$TranslationErrorCode.UNIQUE;
    default:
      return Enum$TranslationErrorCode.$unknown;
  }
}

enum Enum$UploadErrorCode {
  GRAPHQL_ERROR,
  $unknown;

  factory Enum$UploadErrorCode.fromJson(String value) =>
      fromJson$Enum$UploadErrorCode(value);

  String toJson() => toJson$Enum$UploadErrorCode(this);
}

String toJson$Enum$UploadErrorCode(Enum$UploadErrorCode e) {
  switch (e) {
    case Enum$UploadErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$UploadErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$UploadErrorCode fromJson$Enum$UploadErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$UploadErrorCode.GRAPHQL_ERROR;
    default:
      return Enum$UploadErrorCode.$unknown;
  }
}

enum Enum$UserSortField {
  FIRST_NAME,
  LAST_NAME,
  EMAIL,
  ORDER_COUNT,
  CREATED_AT,
  LAST_MODIFIED_AT,
  $unknown;

  factory Enum$UserSortField.fromJson(String value) =>
      fromJson$Enum$UserSortField(value);

  String toJson() => toJson$Enum$UserSortField(this);
}

String toJson$Enum$UserSortField(Enum$UserSortField e) {
  switch (e) {
    case Enum$UserSortField.FIRST_NAME:
      return r'FIRST_NAME';
    case Enum$UserSortField.LAST_NAME:
      return r'LAST_NAME';
    case Enum$UserSortField.EMAIL:
      return r'EMAIL';
    case Enum$UserSortField.ORDER_COUNT:
      return r'ORDER_COUNT';
    case Enum$UserSortField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$UserSortField.LAST_MODIFIED_AT:
      return r'LAST_MODIFIED_AT';
    case Enum$UserSortField.$unknown:
      return r'$unknown';
  }
}

Enum$UserSortField fromJson$Enum$UserSortField(String value) {
  switch (value) {
    case r'FIRST_NAME':
      return Enum$UserSortField.FIRST_NAME;
    case r'LAST_NAME':
      return Enum$UserSortField.LAST_NAME;
    case r'EMAIL':
      return Enum$UserSortField.EMAIL;
    case r'ORDER_COUNT':
      return Enum$UserSortField.ORDER_COUNT;
    case r'CREATED_AT':
      return Enum$UserSortField.CREATED_AT;
    case r'LAST_MODIFIED_AT':
      return Enum$UserSortField.LAST_MODIFIED_AT;
    default:
      return Enum$UserSortField.$unknown;
  }
}

enum Enum$VariantAttributeScope {
  ALL,
  VARIANT_SELECTION,
  NOT_VARIANT_SELECTION,
  $unknown;

  factory Enum$VariantAttributeScope.fromJson(String value) =>
      fromJson$Enum$VariantAttributeScope(value);

  String toJson() => toJson$Enum$VariantAttributeScope(this);
}

String toJson$Enum$VariantAttributeScope(Enum$VariantAttributeScope e) {
  switch (e) {
    case Enum$VariantAttributeScope.ALL:
      return r'ALL';
    case Enum$VariantAttributeScope.VARIANT_SELECTION:
      return r'VARIANT_SELECTION';
    case Enum$VariantAttributeScope.NOT_VARIANT_SELECTION:
      return r'NOT_VARIANT_SELECTION';
    case Enum$VariantAttributeScope.$unknown:
      return r'$unknown';
  }
}

Enum$VariantAttributeScope fromJson$Enum$VariantAttributeScope(String value) {
  switch (value) {
    case r'ALL':
      return Enum$VariantAttributeScope.ALL;
    case r'VARIANT_SELECTION':
      return Enum$VariantAttributeScope.VARIANT_SELECTION;
    case r'NOT_VARIANT_SELECTION':
      return Enum$VariantAttributeScope.NOT_VARIANT_SELECTION;
    default:
      return Enum$VariantAttributeScope.$unknown;
  }
}

enum Enum$VolumeUnitsEnum {
  CUBIC_MILLIMETER,
  CUBIC_CENTIMETER,
  CUBIC_DECIMETER,
  CUBIC_METER,
  LITER,
  CUBIC_FOOT,
  CUBIC_INCH,
  CUBIC_YARD,
  QT,
  PINT,
  FL_OZ,
  ACRE_IN,
  ACRE_FT,
  $unknown;

  factory Enum$VolumeUnitsEnum.fromJson(String value) =>
      fromJson$Enum$VolumeUnitsEnum(value);

  String toJson() => toJson$Enum$VolumeUnitsEnum(this);
}

String toJson$Enum$VolumeUnitsEnum(Enum$VolumeUnitsEnum e) {
  switch (e) {
    case Enum$VolumeUnitsEnum.CUBIC_MILLIMETER:
      return r'CUBIC_MILLIMETER';
    case Enum$VolumeUnitsEnum.CUBIC_CENTIMETER:
      return r'CUBIC_CENTIMETER';
    case Enum$VolumeUnitsEnum.CUBIC_DECIMETER:
      return r'CUBIC_DECIMETER';
    case Enum$VolumeUnitsEnum.CUBIC_METER:
      return r'CUBIC_METER';
    case Enum$VolumeUnitsEnum.LITER:
      return r'LITER';
    case Enum$VolumeUnitsEnum.CUBIC_FOOT:
      return r'CUBIC_FOOT';
    case Enum$VolumeUnitsEnum.CUBIC_INCH:
      return r'CUBIC_INCH';
    case Enum$VolumeUnitsEnum.CUBIC_YARD:
      return r'CUBIC_YARD';
    case Enum$VolumeUnitsEnum.QT:
      return r'QT';
    case Enum$VolumeUnitsEnum.PINT:
      return r'PINT';
    case Enum$VolumeUnitsEnum.FL_OZ:
      return r'FL_OZ';
    case Enum$VolumeUnitsEnum.ACRE_IN:
      return r'ACRE_IN';
    case Enum$VolumeUnitsEnum.ACRE_FT:
      return r'ACRE_FT';
    case Enum$VolumeUnitsEnum.$unknown:
      return r'$unknown';
  }
}

Enum$VolumeUnitsEnum fromJson$Enum$VolumeUnitsEnum(String value) {
  switch (value) {
    case r'CUBIC_MILLIMETER':
      return Enum$VolumeUnitsEnum.CUBIC_MILLIMETER;
    case r'CUBIC_CENTIMETER':
      return Enum$VolumeUnitsEnum.CUBIC_CENTIMETER;
    case r'CUBIC_DECIMETER':
      return Enum$VolumeUnitsEnum.CUBIC_DECIMETER;
    case r'CUBIC_METER':
      return Enum$VolumeUnitsEnum.CUBIC_METER;
    case r'LITER':
      return Enum$VolumeUnitsEnum.LITER;
    case r'CUBIC_FOOT':
      return Enum$VolumeUnitsEnum.CUBIC_FOOT;
    case r'CUBIC_INCH':
      return Enum$VolumeUnitsEnum.CUBIC_INCH;
    case r'CUBIC_YARD':
      return Enum$VolumeUnitsEnum.CUBIC_YARD;
    case r'QT':
      return Enum$VolumeUnitsEnum.QT;
    case r'PINT':
      return Enum$VolumeUnitsEnum.PINT;
    case r'FL_OZ':
      return Enum$VolumeUnitsEnum.FL_OZ;
    case r'ACRE_IN':
      return Enum$VolumeUnitsEnum.ACRE_IN;
    case r'ACRE_FT':
      return Enum$VolumeUnitsEnum.ACRE_FT;
    default:
      return Enum$VolumeUnitsEnum.$unknown;
  }
}

enum Enum$VoucherCodeBulkDeleteErrorCode {
  GRAPHQL_ERROR,
  NOT_FOUND,
  INVALID,
  $unknown;

  factory Enum$VoucherCodeBulkDeleteErrorCode.fromJson(String value) =>
      fromJson$Enum$VoucherCodeBulkDeleteErrorCode(value);

  String toJson() => toJson$Enum$VoucherCodeBulkDeleteErrorCode(this);
}

String toJson$Enum$VoucherCodeBulkDeleteErrorCode(
    Enum$VoucherCodeBulkDeleteErrorCode e) {
  switch (e) {
    case Enum$VoucherCodeBulkDeleteErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$VoucherCodeBulkDeleteErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$VoucherCodeBulkDeleteErrorCode.INVALID:
      return r'INVALID';
    case Enum$VoucherCodeBulkDeleteErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$VoucherCodeBulkDeleteErrorCode
    fromJson$Enum$VoucherCodeBulkDeleteErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$VoucherCodeBulkDeleteErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$VoucherCodeBulkDeleteErrorCode.NOT_FOUND;
    case r'INVALID':
      return Enum$VoucherCodeBulkDeleteErrorCode.INVALID;
    default:
      return Enum$VoucherCodeBulkDeleteErrorCode.$unknown;
  }
}

enum Enum$VoucherDiscountType {
  FIXED,
  PERCENTAGE,
  SHIPPING,
  $unknown;

  factory Enum$VoucherDiscountType.fromJson(String value) =>
      fromJson$Enum$VoucherDiscountType(value);

  String toJson() => toJson$Enum$VoucherDiscountType(this);
}

String toJson$Enum$VoucherDiscountType(Enum$VoucherDiscountType e) {
  switch (e) {
    case Enum$VoucherDiscountType.FIXED:
      return r'FIXED';
    case Enum$VoucherDiscountType.PERCENTAGE:
      return r'PERCENTAGE';
    case Enum$VoucherDiscountType.SHIPPING:
      return r'SHIPPING';
    case Enum$VoucherDiscountType.$unknown:
      return r'$unknown';
  }
}

Enum$VoucherDiscountType fromJson$Enum$VoucherDiscountType(String value) {
  switch (value) {
    case r'FIXED':
      return Enum$VoucherDiscountType.FIXED;
    case r'PERCENTAGE':
      return Enum$VoucherDiscountType.PERCENTAGE;
    case r'SHIPPING':
      return Enum$VoucherDiscountType.SHIPPING;
    default:
      return Enum$VoucherDiscountType.$unknown;
  }
}

enum Enum$VoucherSortField {
  CODE,
  NAME,
  START_DATE,
  END_DATE,
  VALUE,
  TYPE,
  USAGE_LIMIT,
  MINIMUM_SPENT_AMOUNT,
  $unknown;

  factory Enum$VoucherSortField.fromJson(String value) =>
      fromJson$Enum$VoucherSortField(value);

  String toJson() => toJson$Enum$VoucherSortField(this);
}

String toJson$Enum$VoucherSortField(Enum$VoucherSortField e) {
  switch (e) {
    case Enum$VoucherSortField.CODE:
      return r'CODE';
    case Enum$VoucherSortField.NAME:
      return r'NAME';
    case Enum$VoucherSortField.START_DATE:
      return r'START_DATE';
    case Enum$VoucherSortField.END_DATE:
      return r'END_DATE';
    case Enum$VoucherSortField.VALUE:
      return r'VALUE';
    case Enum$VoucherSortField.TYPE:
      return r'TYPE';
    case Enum$VoucherSortField.USAGE_LIMIT:
      return r'USAGE_LIMIT';
    case Enum$VoucherSortField.MINIMUM_SPENT_AMOUNT:
      return r'MINIMUM_SPENT_AMOUNT';
    case Enum$VoucherSortField.$unknown:
      return r'$unknown';
  }
}

Enum$VoucherSortField fromJson$Enum$VoucherSortField(String value) {
  switch (value) {
    case r'CODE':
      return Enum$VoucherSortField.CODE;
    case r'NAME':
      return Enum$VoucherSortField.NAME;
    case r'START_DATE':
      return Enum$VoucherSortField.START_DATE;
    case r'END_DATE':
      return Enum$VoucherSortField.END_DATE;
    case r'VALUE':
      return Enum$VoucherSortField.VALUE;
    case r'TYPE':
      return Enum$VoucherSortField.TYPE;
    case r'USAGE_LIMIT':
      return Enum$VoucherSortField.USAGE_LIMIT;
    case r'MINIMUM_SPENT_AMOUNT':
      return Enum$VoucherSortField.MINIMUM_SPENT_AMOUNT;
    default:
      return Enum$VoucherSortField.$unknown;
  }
}

enum Enum$VoucherTypeEnum {
  SHIPPING,
  ENTIRE_ORDER,
  SPECIFIC_PRODUCT,
  $unknown;

  factory Enum$VoucherTypeEnum.fromJson(String value) =>
      fromJson$Enum$VoucherTypeEnum(value);

  String toJson() => toJson$Enum$VoucherTypeEnum(this);
}

String toJson$Enum$VoucherTypeEnum(Enum$VoucherTypeEnum e) {
  switch (e) {
    case Enum$VoucherTypeEnum.SHIPPING:
      return r'SHIPPING';
    case Enum$VoucherTypeEnum.ENTIRE_ORDER:
      return r'ENTIRE_ORDER';
    case Enum$VoucherTypeEnum.SPECIFIC_PRODUCT:
      return r'SPECIFIC_PRODUCT';
    case Enum$VoucherTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$VoucherTypeEnum fromJson$Enum$VoucherTypeEnum(String value) {
  switch (value) {
    case r'SHIPPING':
      return Enum$VoucherTypeEnum.SHIPPING;
    case r'ENTIRE_ORDER':
      return Enum$VoucherTypeEnum.ENTIRE_ORDER;
    case r'SPECIFIC_PRODUCT':
      return Enum$VoucherTypeEnum.SPECIFIC_PRODUCT;
    default:
      return Enum$VoucherTypeEnum.$unknown;
  }
}

enum Enum$WarehouseClickAndCollectOptionEnum {
  DISABLED,
  LOCAL,
  ALL,
  $unknown;

  factory Enum$WarehouseClickAndCollectOptionEnum.fromJson(String value) =>
      fromJson$Enum$WarehouseClickAndCollectOptionEnum(value);

  String toJson() => toJson$Enum$WarehouseClickAndCollectOptionEnum(this);
}

String toJson$Enum$WarehouseClickAndCollectOptionEnum(
    Enum$WarehouseClickAndCollectOptionEnum e) {
  switch (e) {
    case Enum$WarehouseClickAndCollectOptionEnum.DISABLED:
      return r'DISABLED';
    case Enum$WarehouseClickAndCollectOptionEnum.LOCAL:
      return r'LOCAL';
    case Enum$WarehouseClickAndCollectOptionEnum.ALL:
      return r'ALL';
    case Enum$WarehouseClickAndCollectOptionEnum.$unknown:
      return r'$unknown';
  }
}

Enum$WarehouseClickAndCollectOptionEnum
    fromJson$Enum$WarehouseClickAndCollectOptionEnum(String value) {
  switch (value) {
    case r'DISABLED':
      return Enum$WarehouseClickAndCollectOptionEnum.DISABLED;
    case r'LOCAL':
      return Enum$WarehouseClickAndCollectOptionEnum.LOCAL;
    case r'ALL':
      return Enum$WarehouseClickAndCollectOptionEnum.ALL;
    default:
      return Enum$WarehouseClickAndCollectOptionEnum.$unknown;
  }
}

enum Enum$WarehouseErrorCode {
  ALREADY_EXISTS,
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  $unknown;

  factory Enum$WarehouseErrorCode.fromJson(String value) =>
      fromJson$Enum$WarehouseErrorCode(value);

  String toJson() => toJson$Enum$WarehouseErrorCode(this);
}

String toJson$Enum$WarehouseErrorCode(Enum$WarehouseErrorCode e) {
  switch (e) {
    case Enum$WarehouseErrorCode.ALREADY_EXISTS:
      return r'ALREADY_EXISTS';
    case Enum$WarehouseErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$WarehouseErrorCode.INVALID:
      return r'INVALID';
    case Enum$WarehouseErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$WarehouseErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$WarehouseErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$WarehouseErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$WarehouseErrorCode fromJson$Enum$WarehouseErrorCode(String value) {
  switch (value) {
    case r'ALREADY_EXISTS':
      return Enum$WarehouseErrorCode.ALREADY_EXISTS;
    case r'GRAPHQL_ERROR':
      return Enum$WarehouseErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$WarehouseErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$WarehouseErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$WarehouseErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$WarehouseErrorCode.UNIQUE;
    default:
      return Enum$WarehouseErrorCode.$unknown;
  }
}

enum Enum$WarehouseSortField {
  NAME,
  $unknown;

  factory Enum$WarehouseSortField.fromJson(String value) =>
      fromJson$Enum$WarehouseSortField(value);

  String toJson() => toJson$Enum$WarehouseSortField(this);
}

String toJson$Enum$WarehouseSortField(Enum$WarehouseSortField e) {
  switch (e) {
    case Enum$WarehouseSortField.NAME:
      return r'NAME';
    case Enum$WarehouseSortField.$unknown:
      return r'$unknown';
  }
}

Enum$WarehouseSortField fromJson$Enum$WarehouseSortField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$WarehouseSortField.NAME;
    default:
      return Enum$WarehouseSortField.$unknown;
  }
}

enum Enum$WebhookDryRunErrorCode {
  GRAPHQL_ERROR,
  NOT_FOUND,
  INVALID_ID,
  MISSING_PERMISSION,
  TYPE_NOT_SUPPORTED,
  SYNTAX,
  MISSING_SUBSCRIPTION,
  UNABLE_TO_PARSE,
  MISSING_EVENT,
  $unknown;

  factory Enum$WebhookDryRunErrorCode.fromJson(String value) =>
      fromJson$Enum$WebhookDryRunErrorCode(value);

  String toJson() => toJson$Enum$WebhookDryRunErrorCode(this);
}

String toJson$Enum$WebhookDryRunErrorCode(Enum$WebhookDryRunErrorCode e) {
  switch (e) {
    case Enum$WebhookDryRunErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$WebhookDryRunErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$WebhookDryRunErrorCode.INVALID_ID:
      return r'INVALID_ID';
    case Enum$WebhookDryRunErrorCode.MISSING_PERMISSION:
      return r'MISSING_PERMISSION';
    case Enum$WebhookDryRunErrorCode.TYPE_NOT_SUPPORTED:
      return r'TYPE_NOT_SUPPORTED';
    case Enum$WebhookDryRunErrorCode.SYNTAX:
      return r'SYNTAX';
    case Enum$WebhookDryRunErrorCode.MISSING_SUBSCRIPTION:
      return r'MISSING_SUBSCRIPTION';
    case Enum$WebhookDryRunErrorCode.UNABLE_TO_PARSE:
      return r'UNABLE_TO_PARSE';
    case Enum$WebhookDryRunErrorCode.MISSING_EVENT:
      return r'MISSING_EVENT';
    case Enum$WebhookDryRunErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$WebhookDryRunErrorCode fromJson$Enum$WebhookDryRunErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$WebhookDryRunErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$WebhookDryRunErrorCode.NOT_FOUND;
    case r'INVALID_ID':
      return Enum$WebhookDryRunErrorCode.INVALID_ID;
    case r'MISSING_PERMISSION':
      return Enum$WebhookDryRunErrorCode.MISSING_PERMISSION;
    case r'TYPE_NOT_SUPPORTED':
      return Enum$WebhookDryRunErrorCode.TYPE_NOT_SUPPORTED;
    case r'SYNTAX':
      return Enum$WebhookDryRunErrorCode.SYNTAX;
    case r'MISSING_SUBSCRIPTION':
      return Enum$WebhookDryRunErrorCode.MISSING_SUBSCRIPTION;
    case r'UNABLE_TO_PARSE':
      return Enum$WebhookDryRunErrorCode.UNABLE_TO_PARSE;
    case r'MISSING_EVENT':
      return Enum$WebhookDryRunErrorCode.MISSING_EVENT;
    default:
      return Enum$WebhookDryRunErrorCode.$unknown;
  }
}

enum Enum$WebhookErrorCode {
  GRAPHQL_ERROR,
  INVALID,
  NOT_FOUND,
  REQUIRED,
  UNIQUE,
  DELETE_FAILED,
  SYNTAX,
  MISSING_SUBSCRIPTION,
  UNABLE_TO_PARSE,
  MISSING_EVENT,
  INVALID_CUSTOM_HEADERS,
  INVALID_NOTIFY_WITH_SUBSCRIPTION,
  $unknown;

  factory Enum$WebhookErrorCode.fromJson(String value) =>
      fromJson$Enum$WebhookErrorCode(value);

  String toJson() => toJson$Enum$WebhookErrorCode(this);
}

String toJson$Enum$WebhookErrorCode(Enum$WebhookErrorCode e) {
  switch (e) {
    case Enum$WebhookErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$WebhookErrorCode.INVALID:
      return r'INVALID';
    case Enum$WebhookErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$WebhookErrorCode.REQUIRED:
      return r'REQUIRED';
    case Enum$WebhookErrorCode.UNIQUE:
      return r'UNIQUE';
    case Enum$WebhookErrorCode.DELETE_FAILED:
      return r'DELETE_FAILED';
    case Enum$WebhookErrorCode.SYNTAX:
      return r'SYNTAX';
    case Enum$WebhookErrorCode.MISSING_SUBSCRIPTION:
      return r'MISSING_SUBSCRIPTION';
    case Enum$WebhookErrorCode.UNABLE_TO_PARSE:
      return r'UNABLE_TO_PARSE';
    case Enum$WebhookErrorCode.MISSING_EVENT:
      return r'MISSING_EVENT';
    case Enum$WebhookErrorCode.INVALID_CUSTOM_HEADERS:
      return r'INVALID_CUSTOM_HEADERS';
    case Enum$WebhookErrorCode.INVALID_NOTIFY_WITH_SUBSCRIPTION:
      return r'INVALID_NOTIFY_WITH_SUBSCRIPTION';
    case Enum$WebhookErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$WebhookErrorCode fromJson$Enum$WebhookErrorCode(String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$WebhookErrorCode.GRAPHQL_ERROR;
    case r'INVALID':
      return Enum$WebhookErrorCode.INVALID;
    case r'NOT_FOUND':
      return Enum$WebhookErrorCode.NOT_FOUND;
    case r'REQUIRED':
      return Enum$WebhookErrorCode.REQUIRED;
    case r'UNIQUE':
      return Enum$WebhookErrorCode.UNIQUE;
    case r'DELETE_FAILED':
      return Enum$WebhookErrorCode.DELETE_FAILED;
    case r'SYNTAX':
      return Enum$WebhookErrorCode.SYNTAX;
    case r'MISSING_SUBSCRIPTION':
      return Enum$WebhookErrorCode.MISSING_SUBSCRIPTION;
    case r'UNABLE_TO_PARSE':
      return Enum$WebhookErrorCode.UNABLE_TO_PARSE;
    case r'MISSING_EVENT':
      return Enum$WebhookErrorCode.MISSING_EVENT;
    case r'INVALID_CUSTOM_HEADERS':
      return Enum$WebhookErrorCode.INVALID_CUSTOM_HEADERS;
    case r'INVALID_NOTIFY_WITH_SUBSCRIPTION':
      return Enum$WebhookErrorCode.INVALID_NOTIFY_WITH_SUBSCRIPTION;
    default:
      return Enum$WebhookErrorCode.$unknown;
  }
}

enum Enum$WebhookEventTypeAsyncEnum {
  @Deprecated('No longer supported')
  ANY_EVENTS,
  ACCOUNT_CONFIRMATION_REQUESTED,
  ACCOUNT_CHANGE_EMAIL_REQUESTED,
  ACCOUNT_EMAIL_CHANGED,
  ACCOUNT_SET_PASSWORD_REQUESTED,
  ACCOUNT_CONFIRMED,
  ACCOUNT_DELETE_REQUESTED,
  ACCOUNT_DELETED,
  ADDRESS_CREATED,
  ADDRESS_UPDATED,
  ADDRESS_DELETED,
  APP_INSTALLED,
  APP_UPDATED,
  APP_DELETED,
  APP_STATUS_CHANGED,
  ATTRIBUTE_CREATED,
  ATTRIBUTE_UPDATED,
  ATTRIBUTE_DELETED,
  ATTRIBUTE_VALUE_CREATED,
  ATTRIBUTE_VALUE_UPDATED,
  ATTRIBUTE_VALUE_DELETED,
  CATEGORY_CREATED,
  CATEGORY_UPDATED,
  CATEGORY_DELETED,
  CHANNEL_CREATED,
  CHANNEL_UPDATED,
  CHANNEL_DELETED,
  CHANNEL_STATUS_CHANGED,
  CHANNEL_METADATA_UPDATED,
  GIFT_CARD_CREATED,
  GIFT_CARD_UPDATED,
  GIFT_CARD_DELETED,
  GIFT_CARD_SENT,
  GIFT_CARD_STATUS_CHANGED,
  GIFT_CARD_METADATA_UPDATED,
  GIFT_CARD_EXPORT_COMPLETED,
  MENU_CREATED,
  MENU_UPDATED,
  MENU_DELETED,
  MENU_ITEM_CREATED,
  MENU_ITEM_UPDATED,
  MENU_ITEM_DELETED,
  ORDER_CREATED,
  ORDER_CONFIRMED,
  ORDER_PAID,
  ORDER_FULLY_PAID,
  ORDER_REFUNDED,
  ORDER_FULLY_REFUNDED,
  ORDER_UPDATED,
  ORDER_CANCELLED,
  ORDER_EXPIRED,
  ORDER_FULFILLED,
  ORDER_METADATA_UPDATED,
  ORDER_BULK_CREATED,
  FULFILLMENT_CREATED,
  FULFILLMENT_CANCELED,
  FULFILLMENT_APPROVED,
  FULFILLMENT_METADATA_UPDATED,
  FULFILLMENT_TRACKING_NUMBER_UPDATED,
  DRAFT_ORDER_CREATED,
  DRAFT_ORDER_UPDATED,
  DRAFT_ORDER_DELETED,
  SALE_CREATED,
  SALE_UPDATED,
  SALE_DELETED,
  SALE_TOGGLE,
  PROMOTION_CREATED,
  PROMOTION_UPDATED,
  PROMOTION_DELETED,
  PROMOTION_STARTED,
  PROMOTION_ENDED,
  PROMOTION_RULE_CREATED,
  PROMOTION_RULE_UPDATED,
  PROMOTION_RULE_DELETED,
  INVOICE_REQUESTED,
  INVOICE_DELETED,
  INVOICE_SENT,
  CUSTOMER_CREATED,
  CUSTOMER_UPDATED,
  CUSTOMER_DELETED,
  CUSTOMER_METADATA_UPDATED,
  COLLECTION_CREATED,
  COLLECTION_UPDATED,
  COLLECTION_DELETED,
  COLLECTION_METADATA_UPDATED,
  PRODUCT_CREATED,
  PRODUCT_UPDATED,
  PRODUCT_DELETED,
  PRODUCT_METADATA_UPDATED,
  PRODUCT_EXPORT_COMPLETED,
  PRODUCT_MEDIA_CREATED,
  PRODUCT_MEDIA_UPDATED,
  PRODUCT_MEDIA_DELETED,
  PRODUCT_VARIANT_CREATED,
  PRODUCT_VARIANT_UPDATED,
  PRODUCT_VARIANT_DELETED,
  PRODUCT_VARIANT_METADATA_UPDATED,
  PRODUCT_VARIANT_OUT_OF_STOCK,
  PRODUCT_VARIANT_BACK_IN_STOCK,
  PRODUCT_VARIANT_STOCK_UPDATED,
  CHECKOUT_CREATED,
  CHECKOUT_UPDATED,
  CHECKOUT_FULLY_PAID,
  CHECKOUT_METADATA_UPDATED,
  @Deprecated(
      'See the docs for more details about migrating from NOTIFY_USER to other events: https://docs.saleor.io/upgrade-guides/core/3-16-to-3-17#migrating-from-notify_user')
  NOTIFY_USER,
  PAGE_CREATED,
  PAGE_UPDATED,
  PAGE_DELETED,
  PAGE_TYPE_CREATED,
  PAGE_TYPE_UPDATED,
  PAGE_TYPE_DELETED,
  PERMISSION_GROUP_CREATED,
  PERMISSION_GROUP_UPDATED,
  PERMISSION_GROUP_DELETED,
  SHIPPING_PRICE_CREATED,
  SHIPPING_PRICE_UPDATED,
  SHIPPING_PRICE_DELETED,
  SHIPPING_ZONE_CREATED,
  SHIPPING_ZONE_UPDATED,
  SHIPPING_ZONE_DELETED,
  SHIPPING_ZONE_METADATA_UPDATED,
  STAFF_CREATED,
  STAFF_UPDATED,
  STAFF_DELETED,
  STAFF_SET_PASSWORD_REQUESTED,
  TRANSACTION_ITEM_METADATA_UPDATED,
  TRANSLATION_CREATED,
  TRANSLATION_UPDATED,
  WAREHOUSE_CREATED,
  WAREHOUSE_UPDATED,
  WAREHOUSE_DELETED,
  WAREHOUSE_METADATA_UPDATED,
  VOUCHER_CREATED,
  VOUCHER_UPDATED,
  VOUCHER_DELETED,
  VOUCHER_CODES_CREATED,
  VOUCHER_CODES_DELETED,
  VOUCHER_METADATA_UPDATED,
  VOUCHER_CODE_EXPORT_COMPLETED,
  OBSERVABILITY,
  THUMBNAIL_CREATED,
  SHOP_METADATA_UPDATED,
  $unknown;

  factory Enum$WebhookEventTypeAsyncEnum.fromJson(String value) =>
      fromJson$Enum$WebhookEventTypeAsyncEnum(value);

  String toJson() => toJson$Enum$WebhookEventTypeAsyncEnum(this);
}

String toJson$Enum$WebhookEventTypeAsyncEnum(Enum$WebhookEventTypeAsyncEnum e) {
  switch (e) {
    case Enum$WebhookEventTypeAsyncEnum.ANY_EVENTS:
      return r'ANY_EVENTS';
    case Enum$WebhookEventTypeAsyncEnum.ACCOUNT_CONFIRMATION_REQUESTED:
      return r'ACCOUNT_CONFIRMATION_REQUESTED';
    case Enum$WebhookEventTypeAsyncEnum.ACCOUNT_CHANGE_EMAIL_REQUESTED:
      return r'ACCOUNT_CHANGE_EMAIL_REQUESTED';
    case Enum$WebhookEventTypeAsyncEnum.ACCOUNT_EMAIL_CHANGED:
      return r'ACCOUNT_EMAIL_CHANGED';
    case Enum$WebhookEventTypeAsyncEnum.ACCOUNT_SET_PASSWORD_REQUESTED:
      return r'ACCOUNT_SET_PASSWORD_REQUESTED';
    case Enum$WebhookEventTypeAsyncEnum.ACCOUNT_CONFIRMED:
      return r'ACCOUNT_CONFIRMED';
    case Enum$WebhookEventTypeAsyncEnum.ACCOUNT_DELETE_REQUESTED:
      return r'ACCOUNT_DELETE_REQUESTED';
    case Enum$WebhookEventTypeAsyncEnum.ACCOUNT_DELETED:
      return r'ACCOUNT_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.ADDRESS_CREATED:
      return r'ADDRESS_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.ADDRESS_UPDATED:
      return r'ADDRESS_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.ADDRESS_DELETED:
      return r'ADDRESS_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.APP_INSTALLED:
      return r'APP_INSTALLED';
    case Enum$WebhookEventTypeAsyncEnum.APP_UPDATED:
      return r'APP_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.APP_DELETED:
      return r'APP_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.APP_STATUS_CHANGED:
      return r'APP_STATUS_CHANGED';
    case Enum$WebhookEventTypeAsyncEnum.ATTRIBUTE_CREATED:
      return r'ATTRIBUTE_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.ATTRIBUTE_UPDATED:
      return r'ATTRIBUTE_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.ATTRIBUTE_DELETED:
      return r'ATTRIBUTE_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.ATTRIBUTE_VALUE_CREATED:
      return r'ATTRIBUTE_VALUE_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.ATTRIBUTE_VALUE_UPDATED:
      return r'ATTRIBUTE_VALUE_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.ATTRIBUTE_VALUE_DELETED:
      return r'ATTRIBUTE_VALUE_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.CATEGORY_CREATED:
      return r'CATEGORY_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.CATEGORY_UPDATED:
      return r'CATEGORY_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.CATEGORY_DELETED:
      return r'CATEGORY_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.CHANNEL_CREATED:
      return r'CHANNEL_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.CHANNEL_UPDATED:
      return r'CHANNEL_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.CHANNEL_DELETED:
      return r'CHANNEL_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.CHANNEL_STATUS_CHANGED:
      return r'CHANNEL_STATUS_CHANGED';
    case Enum$WebhookEventTypeAsyncEnum.CHANNEL_METADATA_UPDATED:
      return r'CHANNEL_METADATA_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.GIFT_CARD_CREATED:
      return r'GIFT_CARD_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.GIFT_CARD_UPDATED:
      return r'GIFT_CARD_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.GIFT_CARD_DELETED:
      return r'GIFT_CARD_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.GIFT_CARD_SENT:
      return r'GIFT_CARD_SENT';
    case Enum$WebhookEventTypeAsyncEnum.GIFT_CARD_STATUS_CHANGED:
      return r'GIFT_CARD_STATUS_CHANGED';
    case Enum$WebhookEventTypeAsyncEnum.GIFT_CARD_METADATA_UPDATED:
      return r'GIFT_CARD_METADATA_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.GIFT_CARD_EXPORT_COMPLETED:
      return r'GIFT_CARD_EXPORT_COMPLETED';
    case Enum$WebhookEventTypeAsyncEnum.MENU_CREATED:
      return r'MENU_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.MENU_UPDATED:
      return r'MENU_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.MENU_DELETED:
      return r'MENU_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.MENU_ITEM_CREATED:
      return r'MENU_ITEM_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.MENU_ITEM_UPDATED:
      return r'MENU_ITEM_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.MENU_ITEM_DELETED:
      return r'MENU_ITEM_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.ORDER_CREATED:
      return r'ORDER_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.ORDER_CONFIRMED:
      return r'ORDER_CONFIRMED';
    case Enum$WebhookEventTypeAsyncEnum.ORDER_PAID:
      return r'ORDER_PAID';
    case Enum$WebhookEventTypeAsyncEnum.ORDER_FULLY_PAID:
      return r'ORDER_FULLY_PAID';
    case Enum$WebhookEventTypeAsyncEnum.ORDER_REFUNDED:
      return r'ORDER_REFUNDED';
    case Enum$WebhookEventTypeAsyncEnum.ORDER_FULLY_REFUNDED:
      return r'ORDER_FULLY_REFUNDED';
    case Enum$WebhookEventTypeAsyncEnum.ORDER_UPDATED:
      return r'ORDER_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.ORDER_CANCELLED:
      return r'ORDER_CANCELLED';
    case Enum$WebhookEventTypeAsyncEnum.ORDER_EXPIRED:
      return r'ORDER_EXPIRED';
    case Enum$WebhookEventTypeAsyncEnum.ORDER_FULFILLED:
      return r'ORDER_FULFILLED';
    case Enum$WebhookEventTypeAsyncEnum.ORDER_METADATA_UPDATED:
      return r'ORDER_METADATA_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.ORDER_BULK_CREATED:
      return r'ORDER_BULK_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.FULFILLMENT_CREATED:
      return r'FULFILLMENT_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.FULFILLMENT_CANCELED:
      return r'FULFILLMENT_CANCELED';
    case Enum$WebhookEventTypeAsyncEnum.FULFILLMENT_APPROVED:
      return r'FULFILLMENT_APPROVED';
    case Enum$WebhookEventTypeAsyncEnum.FULFILLMENT_METADATA_UPDATED:
      return r'FULFILLMENT_METADATA_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.FULFILLMENT_TRACKING_NUMBER_UPDATED:
      return r'FULFILLMENT_TRACKING_NUMBER_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.DRAFT_ORDER_CREATED:
      return r'DRAFT_ORDER_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.DRAFT_ORDER_UPDATED:
      return r'DRAFT_ORDER_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.DRAFT_ORDER_DELETED:
      return r'DRAFT_ORDER_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.SALE_CREATED:
      return r'SALE_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.SALE_UPDATED:
      return r'SALE_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.SALE_DELETED:
      return r'SALE_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.SALE_TOGGLE:
      return r'SALE_TOGGLE';
    case Enum$WebhookEventTypeAsyncEnum.PROMOTION_CREATED:
      return r'PROMOTION_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.PROMOTION_UPDATED:
      return r'PROMOTION_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.PROMOTION_DELETED:
      return r'PROMOTION_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.PROMOTION_STARTED:
      return r'PROMOTION_STARTED';
    case Enum$WebhookEventTypeAsyncEnum.PROMOTION_ENDED:
      return r'PROMOTION_ENDED';
    case Enum$WebhookEventTypeAsyncEnum.PROMOTION_RULE_CREATED:
      return r'PROMOTION_RULE_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.PROMOTION_RULE_UPDATED:
      return r'PROMOTION_RULE_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.PROMOTION_RULE_DELETED:
      return r'PROMOTION_RULE_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.INVOICE_REQUESTED:
      return r'INVOICE_REQUESTED';
    case Enum$WebhookEventTypeAsyncEnum.INVOICE_DELETED:
      return r'INVOICE_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.INVOICE_SENT:
      return r'INVOICE_SENT';
    case Enum$WebhookEventTypeAsyncEnum.CUSTOMER_CREATED:
      return r'CUSTOMER_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.CUSTOMER_UPDATED:
      return r'CUSTOMER_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.CUSTOMER_DELETED:
      return r'CUSTOMER_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.CUSTOMER_METADATA_UPDATED:
      return r'CUSTOMER_METADATA_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.COLLECTION_CREATED:
      return r'COLLECTION_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.COLLECTION_UPDATED:
      return r'COLLECTION_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.COLLECTION_DELETED:
      return r'COLLECTION_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.COLLECTION_METADATA_UPDATED:
      return r'COLLECTION_METADATA_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.PRODUCT_CREATED:
      return r'PRODUCT_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.PRODUCT_UPDATED:
      return r'PRODUCT_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.PRODUCT_DELETED:
      return r'PRODUCT_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.PRODUCT_METADATA_UPDATED:
      return r'PRODUCT_METADATA_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.PRODUCT_EXPORT_COMPLETED:
      return r'PRODUCT_EXPORT_COMPLETED';
    case Enum$WebhookEventTypeAsyncEnum.PRODUCT_MEDIA_CREATED:
      return r'PRODUCT_MEDIA_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.PRODUCT_MEDIA_UPDATED:
      return r'PRODUCT_MEDIA_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.PRODUCT_MEDIA_DELETED:
      return r'PRODUCT_MEDIA_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.PRODUCT_VARIANT_CREATED:
      return r'PRODUCT_VARIANT_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.PRODUCT_VARIANT_UPDATED:
      return r'PRODUCT_VARIANT_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.PRODUCT_VARIANT_DELETED:
      return r'PRODUCT_VARIANT_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.PRODUCT_VARIANT_METADATA_UPDATED:
      return r'PRODUCT_VARIANT_METADATA_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.PRODUCT_VARIANT_OUT_OF_STOCK:
      return r'PRODUCT_VARIANT_OUT_OF_STOCK';
    case Enum$WebhookEventTypeAsyncEnum.PRODUCT_VARIANT_BACK_IN_STOCK:
      return r'PRODUCT_VARIANT_BACK_IN_STOCK';
    case Enum$WebhookEventTypeAsyncEnum.PRODUCT_VARIANT_STOCK_UPDATED:
      return r'PRODUCT_VARIANT_STOCK_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.CHECKOUT_CREATED:
      return r'CHECKOUT_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.CHECKOUT_UPDATED:
      return r'CHECKOUT_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.CHECKOUT_FULLY_PAID:
      return r'CHECKOUT_FULLY_PAID';
    case Enum$WebhookEventTypeAsyncEnum.CHECKOUT_METADATA_UPDATED:
      return r'CHECKOUT_METADATA_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.NOTIFY_USER:
      return r'NOTIFY_USER';
    case Enum$WebhookEventTypeAsyncEnum.PAGE_CREATED:
      return r'PAGE_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.PAGE_UPDATED:
      return r'PAGE_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.PAGE_DELETED:
      return r'PAGE_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.PAGE_TYPE_CREATED:
      return r'PAGE_TYPE_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.PAGE_TYPE_UPDATED:
      return r'PAGE_TYPE_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.PAGE_TYPE_DELETED:
      return r'PAGE_TYPE_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.PERMISSION_GROUP_CREATED:
      return r'PERMISSION_GROUP_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.PERMISSION_GROUP_UPDATED:
      return r'PERMISSION_GROUP_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.PERMISSION_GROUP_DELETED:
      return r'PERMISSION_GROUP_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.SHIPPING_PRICE_CREATED:
      return r'SHIPPING_PRICE_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.SHIPPING_PRICE_UPDATED:
      return r'SHIPPING_PRICE_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.SHIPPING_PRICE_DELETED:
      return r'SHIPPING_PRICE_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.SHIPPING_ZONE_CREATED:
      return r'SHIPPING_ZONE_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.SHIPPING_ZONE_UPDATED:
      return r'SHIPPING_ZONE_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.SHIPPING_ZONE_DELETED:
      return r'SHIPPING_ZONE_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.SHIPPING_ZONE_METADATA_UPDATED:
      return r'SHIPPING_ZONE_METADATA_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.STAFF_CREATED:
      return r'STAFF_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.STAFF_UPDATED:
      return r'STAFF_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.STAFF_DELETED:
      return r'STAFF_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.STAFF_SET_PASSWORD_REQUESTED:
      return r'STAFF_SET_PASSWORD_REQUESTED';
    case Enum$WebhookEventTypeAsyncEnum.TRANSACTION_ITEM_METADATA_UPDATED:
      return r'TRANSACTION_ITEM_METADATA_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.TRANSLATION_CREATED:
      return r'TRANSLATION_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.TRANSLATION_UPDATED:
      return r'TRANSLATION_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.WAREHOUSE_CREATED:
      return r'WAREHOUSE_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.WAREHOUSE_UPDATED:
      return r'WAREHOUSE_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.WAREHOUSE_DELETED:
      return r'WAREHOUSE_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.WAREHOUSE_METADATA_UPDATED:
      return r'WAREHOUSE_METADATA_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.VOUCHER_CREATED:
      return r'VOUCHER_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.VOUCHER_UPDATED:
      return r'VOUCHER_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.VOUCHER_DELETED:
      return r'VOUCHER_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.VOUCHER_CODES_CREATED:
      return r'VOUCHER_CODES_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.VOUCHER_CODES_DELETED:
      return r'VOUCHER_CODES_DELETED';
    case Enum$WebhookEventTypeAsyncEnum.VOUCHER_METADATA_UPDATED:
      return r'VOUCHER_METADATA_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.VOUCHER_CODE_EXPORT_COMPLETED:
      return r'VOUCHER_CODE_EXPORT_COMPLETED';
    case Enum$WebhookEventTypeAsyncEnum.OBSERVABILITY:
      return r'OBSERVABILITY';
    case Enum$WebhookEventTypeAsyncEnum.THUMBNAIL_CREATED:
      return r'THUMBNAIL_CREATED';
    case Enum$WebhookEventTypeAsyncEnum.SHOP_METADATA_UPDATED:
      return r'SHOP_METADATA_UPDATED';
    case Enum$WebhookEventTypeAsyncEnum.$unknown:
      return r'$unknown';
  }
}

Enum$WebhookEventTypeAsyncEnum fromJson$Enum$WebhookEventTypeAsyncEnum(
    String value) {
  switch (value) {
    case r'ANY_EVENTS':
      return Enum$WebhookEventTypeAsyncEnum.ANY_EVENTS;
    case r'ACCOUNT_CONFIRMATION_REQUESTED':
      return Enum$WebhookEventTypeAsyncEnum.ACCOUNT_CONFIRMATION_REQUESTED;
    case r'ACCOUNT_CHANGE_EMAIL_REQUESTED':
      return Enum$WebhookEventTypeAsyncEnum.ACCOUNT_CHANGE_EMAIL_REQUESTED;
    case r'ACCOUNT_EMAIL_CHANGED':
      return Enum$WebhookEventTypeAsyncEnum.ACCOUNT_EMAIL_CHANGED;
    case r'ACCOUNT_SET_PASSWORD_REQUESTED':
      return Enum$WebhookEventTypeAsyncEnum.ACCOUNT_SET_PASSWORD_REQUESTED;
    case r'ACCOUNT_CONFIRMED':
      return Enum$WebhookEventTypeAsyncEnum.ACCOUNT_CONFIRMED;
    case r'ACCOUNT_DELETE_REQUESTED':
      return Enum$WebhookEventTypeAsyncEnum.ACCOUNT_DELETE_REQUESTED;
    case r'ACCOUNT_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.ACCOUNT_DELETED;
    case r'ADDRESS_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.ADDRESS_CREATED;
    case r'ADDRESS_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.ADDRESS_UPDATED;
    case r'ADDRESS_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.ADDRESS_DELETED;
    case r'APP_INSTALLED':
      return Enum$WebhookEventTypeAsyncEnum.APP_INSTALLED;
    case r'APP_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.APP_UPDATED;
    case r'APP_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.APP_DELETED;
    case r'APP_STATUS_CHANGED':
      return Enum$WebhookEventTypeAsyncEnum.APP_STATUS_CHANGED;
    case r'ATTRIBUTE_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.ATTRIBUTE_CREATED;
    case r'ATTRIBUTE_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.ATTRIBUTE_UPDATED;
    case r'ATTRIBUTE_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.ATTRIBUTE_DELETED;
    case r'ATTRIBUTE_VALUE_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.ATTRIBUTE_VALUE_CREATED;
    case r'ATTRIBUTE_VALUE_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.ATTRIBUTE_VALUE_UPDATED;
    case r'ATTRIBUTE_VALUE_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.ATTRIBUTE_VALUE_DELETED;
    case r'CATEGORY_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.CATEGORY_CREATED;
    case r'CATEGORY_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.CATEGORY_UPDATED;
    case r'CATEGORY_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.CATEGORY_DELETED;
    case r'CHANNEL_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.CHANNEL_CREATED;
    case r'CHANNEL_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.CHANNEL_UPDATED;
    case r'CHANNEL_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.CHANNEL_DELETED;
    case r'CHANNEL_STATUS_CHANGED':
      return Enum$WebhookEventTypeAsyncEnum.CHANNEL_STATUS_CHANGED;
    case r'CHANNEL_METADATA_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.CHANNEL_METADATA_UPDATED;
    case r'GIFT_CARD_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.GIFT_CARD_CREATED;
    case r'GIFT_CARD_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.GIFT_CARD_UPDATED;
    case r'GIFT_CARD_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.GIFT_CARD_DELETED;
    case r'GIFT_CARD_SENT':
      return Enum$WebhookEventTypeAsyncEnum.GIFT_CARD_SENT;
    case r'GIFT_CARD_STATUS_CHANGED':
      return Enum$WebhookEventTypeAsyncEnum.GIFT_CARD_STATUS_CHANGED;
    case r'GIFT_CARD_METADATA_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.GIFT_CARD_METADATA_UPDATED;
    case r'GIFT_CARD_EXPORT_COMPLETED':
      return Enum$WebhookEventTypeAsyncEnum.GIFT_CARD_EXPORT_COMPLETED;
    case r'MENU_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.MENU_CREATED;
    case r'MENU_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.MENU_UPDATED;
    case r'MENU_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.MENU_DELETED;
    case r'MENU_ITEM_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.MENU_ITEM_CREATED;
    case r'MENU_ITEM_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.MENU_ITEM_UPDATED;
    case r'MENU_ITEM_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.MENU_ITEM_DELETED;
    case r'ORDER_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.ORDER_CREATED;
    case r'ORDER_CONFIRMED':
      return Enum$WebhookEventTypeAsyncEnum.ORDER_CONFIRMED;
    case r'ORDER_PAID':
      return Enum$WebhookEventTypeAsyncEnum.ORDER_PAID;
    case r'ORDER_FULLY_PAID':
      return Enum$WebhookEventTypeAsyncEnum.ORDER_FULLY_PAID;
    case r'ORDER_REFUNDED':
      return Enum$WebhookEventTypeAsyncEnum.ORDER_REFUNDED;
    case r'ORDER_FULLY_REFUNDED':
      return Enum$WebhookEventTypeAsyncEnum.ORDER_FULLY_REFUNDED;
    case r'ORDER_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.ORDER_UPDATED;
    case r'ORDER_CANCELLED':
      return Enum$WebhookEventTypeAsyncEnum.ORDER_CANCELLED;
    case r'ORDER_EXPIRED':
      return Enum$WebhookEventTypeAsyncEnum.ORDER_EXPIRED;
    case r'ORDER_FULFILLED':
      return Enum$WebhookEventTypeAsyncEnum.ORDER_FULFILLED;
    case r'ORDER_METADATA_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.ORDER_METADATA_UPDATED;
    case r'ORDER_BULK_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.ORDER_BULK_CREATED;
    case r'FULFILLMENT_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.FULFILLMENT_CREATED;
    case r'FULFILLMENT_CANCELED':
      return Enum$WebhookEventTypeAsyncEnum.FULFILLMENT_CANCELED;
    case r'FULFILLMENT_APPROVED':
      return Enum$WebhookEventTypeAsyncEnum.FULFILLMENT_APPROVED;
    case r'FULFILLMENT_METADATA_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.FULFILLMENT_METADATA_UPDATED;
    case r'FULFILLMENT_TRACKING_NUMBER_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.FULFILLMENT_TRACKING_NUMBER_UPDATED;
    case r'DRAFT_ORDER_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.DRAFT_ORDER_CREATED;
    case r'DRAFT_ORDER_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.DRAFT_ORDER_UPDATED;
    case r'DRAFT_ORDER_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.DRAFT_ORDER_DELETED;
    case r'SALE_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.SALE_CREATED;
    case r'SALE_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.SALE_UPDATED;
    case r'SALE_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.SALE_DELETED;
    case r'SALE_TOGGLE':
      return Enum$WebhookEventTypeAsyncEnum.SALE_TOGGLE;
    case r'PROMOTION_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.PROMOTION_CREATED;
    case r'PROMOTION_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.PROMOTION_UPDATED;
    case r'PROMOTION_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.PROMOTION_DELETED;
    case r'PROMOTION_STARTED':
      return Enum$WebhookEventTypeAsyncEnum.PROMOTION_STARTED;
    case r'PROMOTION_ENDED':
      return Enum$WebhookEventTypeAsyncEnum.PROMOTION_ENDED;
    case r'PROMOTION_RULE_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.PROMOTION_RULE_CREATED;
    case r'PROMOTION_RULE_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.PROMOTION_RULE_UPDATED;
    case r'PROMOTION_RULE_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.PROMOTION_RULE_DELETED;
    case r'INVOICE_REQUESTED':
      return Enum$WebhookEventTypeAsyncEnum.INVOICE_REQUESTED;
    case r'INVOICE_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.INVOICE_DELETED;
    case r'INVOICE_SENT':
      return Enum$WebhookEventTypeAsyncEnum.INVOICE_SENT;
    case r'CUSTOMER_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.CUSTOMER_CREATED;
    case r'CUSTOMER_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.CUSTOMER_UPDATED;
    case r'CUSTOMER_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.CUSTOMER_DELETED;
    case r'CUSTOMER_METADATA_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.CUSTOMER_METADATA_UPDATED;
    case r'COLLECTION_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.COLLECTION_CREATED;
    case r'COLLECTION_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.COLLECTION_UPDATED;
    case r'COLLECTION_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.COLLECTION_DELETED;
    case r'COLLECTION_METADATA_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.COLLECTION_METADATA_UPDATED;
    case r'PRODUCT_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.PRODUCT_CREATED;
    case r'PRODUCT_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.PRODUCT_UPDATED;
    case r'PRODUCT_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.PRODUCT_DELETED;
    case r'PRODUCT_METADATA_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.PRODUCT_METADATA_UPDATED;
    case r'PRODUCT_EXPORT_COMPLETED':
      return Enum$WebhookEventTypeAsyncEnum.PRODUCT_EXPORT_COMPLETED;
    case r'PRODUCT_MEDIA_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.PRODUCT_MEDIA_CREATED;
    case r'PRODUCT_MEDIA_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.PRODUCT_MEDIA_UPDATED;
    case r'PRODUCT_MEDIA_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.PRODUCT_MEDIA_DELETED;
    case r'PRODUCT_VARIANT_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.PRODUCT_VARIANT_CREATED;
    case r'PRODUCT_VARIANT_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.PRODUCT_VARIANT_UPDATED;
    case r'PRODUCT_VARIANT_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.PRODUCT_VARIANT_DELETED;
    case r'PRODUCT_VARIANT_METADATA_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.PRODUCT_VARIANT_METADATA_UPDATED;
    case r'PRODUCT_VARIANT_OUT_OF_STOCK':
      return Enum$WebhookEventTypeAsyncEnum.PRODUCT_VARIANT_OUT_OF_STOCK;
    case r'PRODUCT_VARIANT_BACK_IN_STOCK':
      return Enum$WebhookEventTypeAsyncEnum.PRODUCT_VARIANT_BACK_IN_STOCK;
    case r'PRODUCT_VARIANT_STOCK_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.PRODUCT_VARIANT_STOCK_UPDATED;
    case r'CHECKOUT_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.CHECKOUT_CREATED;
    case r'CHECKOUT_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.CHECKOUT_UPDATED;
    case r'CHECKOUT_FULLY_PAID':
      return Enum$WebhookEventTypeAsyncEnum.CHECKOUT_FULLY_PAID;
    case r'CHECKOUT_METADATA_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.CHECKOUT_METADATA_UPDATED;
    case r'NOTIFY_USER':
      return Enum$WebhookEventTypeAsyncEnum.NOTIFY_USER;
    case r'PAGE_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.PAGE_CREATED;
    case r'PAGE_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.PAGE_UPDATED;
    case r'PAGE_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.PAGE_DELETED;
    case r'PAGE_TYPE_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.PAGE_TYPE_CREATED;
    case r'PAGE_TYPE_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.PAGE_TYPE_UPDATED;
    case r'PAGE_TYPE_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.PAGE_TYPE_DELETED;
    case r'PERMISSION_GROUP_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.PERMISSION_GROUP_CREATED;
    case r'PERMISSION_GROUP_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.PERMISSION_GROUP_UPDATED;
    case r'PERMISSION_GROUP_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.PERMISSION_GROUP_DELETED;
    case r'SHIPPING_PRICE_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.SHIPPING_PRICE_CREATED;
    case r'SHIPPING_PRICE_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.SHIPPING_PRICE_UPDATED;
    case r'SHIPPING_PRICE_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.SHIPPING_PRICE_DELETED;
    case r'SHIPPING_ZONE_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.SHIPPING_ZONE_CREATED;
    case r'SHIPPING_ZONE_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.SHIPPING_ZONE_UPDATED;
    case r'SHIPPING_ZONE_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.SHIPPING_ZONE_DELETED;
    case r'SHIPPING_ZONE_METADATA_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.SHIPPING_ZONE_METADATA_UPDATED;
    case r'STAFF_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.STAFF_CREATED;
    case r'STAFF_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.STAFF_UPDATED;
    case r'STAFF_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.STAFF_DELETED;
    case r'STAFF_SET_PASSWORD_REQUESTED':
      return Enum$WebhookEventTypeAsyncEnum.STAFF_SET_PASSWORD_REQUESTED;
    case r'TRANSACTION_ITEM_METADATA_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.TRANSACTION_ITEM_METADATA_UPDATED;
    case r'TRANSLATION_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.TRANSLATION_CREATED;
    case r'TRANSLATION_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.TRANSLATION_UPDATED;
    case r'WAREHOUSE_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.WAREHOUSE_CREATED;
    case r'WAREHOUSE_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.WAREHOUSE_UPDATED;
    case r'WAREHOUSE_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.WAREHOUSE_DELETED;
    case r'WAREHOUSE_METADATA_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.WAREHOUSE_METADATA_UPDATED;
    case r'VOUCHER_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.VOUCHER_CREATED;
    case r'VOUCHER_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.VOUCHER_UPDATED;
    case r'VOUCHER_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.VOUCHER_DELETED;
    case r'VOUCHER_CODES_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.VOUCHER_CODES_CREATED;
    case r'VOUCHER_CODES_DELETED':
      return Enum$WebhookEventTypeAsyncEnum.VOUCHER_CODES_DELETED;
    case r'VOUCHER_METADATA_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.VOUCHER_METADATA_UPDATED;
    case r'VOUCHER_CODE_EXPORT_COMPLETED':
      return Enum$WebhookEventTypeAsyncEnum.VOUCHER_CODE_EXPORT_COMPLETED;
    case r'OBSERVABILITY':
      return Enum$WebhookEventTypeAsyncEnum.OBSERVABILITY;
    case r'THUMBNAIL_CREATED':
      return Enum$WebhookEventTypeAsyncEnum.THUMBNAIL_CREATED;
    case r'SHOP_METADATA_UPDATED':
      return Enum$WebhookEventTypeAsyncEnum.SHOP_METADATA_UPDATED;
    default:
      return Enum$WebhookEventTypeAsyncEnum.$unknown;
  }
}

enum Enum$WebhookEventTypeEnum {
  @Deprecated('No longer supported')
  ANY_EVENTS,
  ACCOUNT_CONFIRMATION_REQUESTED,
  ACCOUNT_CHANGE_EMAIL_REQUESTED,
  ACCOUNT_EMAIL_CHANGED,
  ACCOUNT_SET_PASSWORD_REQUESTED,
  ACCOUNT_CONFIRMED,
  ACCOUNT_DELETE_REQUESTED,
  ACCOUNT_DELETED,
  ADDRESS_CREATED,
  ADDRESS_UPDATED,
  ADDRESS_DELETED,
  APP_INSTALLED,
  APP_UPDATED,
  APP_DELETED,
  APP_STATUS_CHANGED,
  ATTRIBUTE_CREATED,
  ATTRIBUTE_UPDATED,
  ATTRIBUTE_DELETED,
  ATTRIBUTE_VALUE_CREATED,
  ATTRIBUTE_VALUE_UPDATED,
  ATTRIBUTE_VALUE_DELETED,
  CATEGORY_CREATED,
  CATEGORY_UPDATED,
  CATEGORY_DELETED,
  CHANNEL_CREATED,
  CHANNEL_UPDATED,
  CHANNEL_DELETED,
  CHANNEL_STATUS_CHANGED,
  CHANNEL_METADATA_UPDATED,
  GIFT_CARD_CREATED,
  GIFT_CARD_UPDATED,
  GIFT_CARD_DELETED,
  GIFT_CARD_SENT,
  GIFT_CARD_STATUS_CHANGED,
  GIFT_CARD_METADATA_UPDATED,
  GIFT_CARD_EXPORT_COMPLETED,
  MENU_CREATED,
  MENU_UPDATED,
  MENU_DELETED,
  MENU_ITEM_CREATED,
  MENU_ITEM_UPDATED,
  MENU_ITEM_DELETED,
  ORDER_CREATED,
  ORDER_CONFIRMED,
  ORDER_PAID,
  ORDER_FULLY_PAID,
  ORDER_REFUNDED,
  ORDER_FULLY_REFUNDED,
  ORDER_UPDATED,
  ORDER_CANCELLED,
  ORDER_EXPIRED,
  ORDER_FULFILLED,
  ORDER_METADATA_UPDATED,
  ORDER_BULK_CREATED,
  FULFILLMENT_CREATED,
  FULFILLMENT_CANCELED,
  FULFILLMENT_APPROVED,
  FULFILLMENT_METADATA_UPDATED,
  FULFILLMENT_TRACKING_NUMBER_UPDATED,
  DRAFT_ORDER_CREATED,
  DRAFT_ORDER_UPDATED,
  DRAFT_ORDER_DELETED,
  SALE_CREATED,
  SALE_UPDATED,
  SALE_DELETED,
  SALE_TOGGLE,
  PROMOTION_CREATED,
  PROMOTION_UPDATED,
  PROMOTION_DELETED,
  PROMOTION_STARTED,
  PROMOTION_ENDED,
  PROMOTION_RULE_CREATED,
  PROMOTION_RULE_UPDATED,
  PROMOTION_RULE_DELETED,
  INVOICE_REQUESTED,
  INVOICE_DELETED,
  INVOICE_SENT,
  CUSTOMER_CREATED,
  CUSTOMER_UPDATED,
  CUSTOMER_DELETED,
  CUSTOMER_METADATA_UPDATED,
  COLLECTION_CREATED,
  COLLECTION_UPDATED,
  COLLECTION_DELETED,
  COLLECTION_METADATA_UPDATED,
  PRODUCT_CREATED,
  PRODUCT_UPDATED,
  PRODUCT_DELETED,
  PRODUCT_METADATA_UPDATED,
  PRODUCT_EXPORT_COMPLETED,
  PRODUCT_MEDIA_CREATED,
  PRODUCT_MEDIA_UPDATED,
  PRODUCT_MEDIA_DELETED,
  PRODUCT_VARIANT_CREATED,
  PRODUCT_VARIANT_UPDATED,
  PRODUCT_VARIANT_DELETED,
  PRODUCT_VARIANT_METADATA_UPDATED,
  PRODUCT_VARIANT_OUT_OF_STOCK,
  PRODUCT_VARIANT_BACK_IN_STOCK,
  PRODUCT_VARIANT_STOCK_UPDATED,
  CHECKOUT_CREATED,
  CHECKOUT_UPDATED,
  CHECKOUT_FULLY_PAID,
  CHECKOUT_METADATA_UPDATED,
  @Deprecated(
      'See the docs for more details about migrating from NOTIFY_USER to other events: https://docs.saleor.io/upgrade-guides/core/3-16-to-3-17#migrating-from-notify_user')
  NOTIFY_USER,
  PAGE_CREATED,
  PAGE_UPDATED,
  PAGE_DELETED,
  PAGE_TYPE_CREATED,
  PAGE_TYPE_UPDATED,
  PAGE_TYPE_DELETED,
  PERMISSION_GROUP_CREATED,
  PERMISSION_GROUP_UPDATED,
  PERMISSION_GROUP_DELETED,
  SHIPPING_PRICE_CREATED,
  SHIPPING_PRICE_UPDATED,
  SHIPPING_PRICE_DELETED,
  SHIPPING_ZONE_CREATED,
  SHIPPING_ZONE_UPDATED,
  SHIPPING_ZONE_DELETED,
  SHIPPING_ZONE_METADATA_UPDATED,
  STAFF_CREATED,
  STAFF_UPDATED,
  STAFF_DELETED,
  STAFF_SET_PASSWORD_REQUESTED,
  TRANSACTION_ITEM_METADATA_UPDATED,
  TRANSLATION_CREATED,
  TRANSLATION_UPDATED,
  WAREHOUSE_CREATED,
  WAREHOUSE_UPDATED,
  WAREHOUSE_DELETED,
  WAREHOUSE_METADATA_UPDATED,
  VOUCHER_CREATED,
  VOUCHER_UPDATED,
  VOUCHER_DELETED,
  VOUCHER_CODES_CREATED,
  VOUCHER_CODES_DELETED,
  VOUCHER_METADATA_UPDATED,
  VOUCHER_CODE_EXPORT_COMPLETED,
  OBSERVABILITY,
  THUMBNAIL_CREATED,
  SHOP_METADATA_UPDATED,
  PAYMENT_LIST_GATEWAYS,
  PAYMENT_AUTHORIZE,
  PAYMENT_CAPTURE,
  PAYMENT_REFUND,
  PAYMENT_VOID,
  PAYMENT_CONFIRM,
  PAYMENT_PROCESS,
  CHECKOUT_CALCULATE_TAXES,
  ORDER_CALCULATE_TAXES,
  TRANSACTION_CHARGE_REQUESTED,
  TRANSACTION_REFUND_REQUESTED,
  TRANSACTION_CANCELATION_REQUESTED,
  SHIPPING_LIST_METHODS_FOR_CHECKOUT,
  CHECKOUT_FILTER_SHIPPING_METHODS,
  ORDER_FILTER_SHIPPING_METHODS,
  PAYMENT_GATEWAY_INITIALIZE_SESSION,
  TRANSACTION_INITIALIZE_SESSION,
  TRANSACTION_PROCESS_SESSION,
  LIST_STORED_PAYMENT_METHODS,
  STORED_PAYMENT_METHOD_DELETE_REQUESTED,
  PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION,
  PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION,
  PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION,
  $unknown;

  factory Enum$WebhookEventTypeEnum.fromJson(String value) =>
      fromJson$Enum$WebhookEventTypeEnum(value);

  String toJson() => toJson$Enum$WebhookEventTypeEnum(this);
}

String toJson$Enum$WebhookEventTypeEnum(Enum$WebhookEventTypeEnum e) {
  switch (e) {
    case Enum$WebhookEventTypeEnum.ANY_EVENTS:
      return r'ANY_EVENTS';
    case Enum$WebhookEventTypeEnum.ACCOUNT_CONFIRMATION_REQUESTED:
      return r'ACCOUNT_CONFIRMATION_REQUESTED';
    case Enum$WebhookEventTypeEnum.ACCOUNT_CHANGE_EMAIL_REQUESTED:
      return r'ACCOUNT_CHANGE_EMAIL_REQUESTED';
    case Enum$WebhookEventTypeEnum.ACCOUNT_EMAIL_CHANGED:
      return r'ACCOUNT_EMAIL_CHANGED';
    case Enum$WebhookEventTypeEnum.ACCOUNT_SET_PASSWORD_REQUESTED:
      return r'ACCOUNT_SET_PASSWORD_REQUESTED';
    case Enum$WebhookEventTypeEnum.ACCOUNT_CONFIRMED:
      return r'ACCOUNT_CONFIRMED';
    case Enum$WebhookEventTypeEnum.ACCOUNT_DELETE_REQUESTED:
      return r'ACCOUNT_DELETE_REQUESTED';
    case Enum$WebhookEventTypeEnum.ACCOUNT_DELETED:
      return r'ACCOUNT_DELETED';
    case Enum$WebhookEventTypeEnum.ADDRESS_CREATED:
      return r'ADDRESS_CREATED';
    case Enum$WebhookEventTypeEnum.ADDRESS_UPDATED:
      return r'ADDRESS_UPDATED';
    case Enum$WebhookEventTypeEnum.ADDRESS_DELETED:
      return r'ADDRESS_DELETED';
    case Enum$WebhookEventTypeEnum.APP_INSTALLED:
      return r'APP_INSTALLED';
    case Enum$WebhookEventTypeEnum.APP_UPDATED:
      return r'APP_UPDATED';
    case Enum$WebhookEventTypeEnum.APP_DELETED:
      return r'APP_DELETED';
    case Enum$WebhookEventTypeEnum.APP_STATUS_CHANGED:
      return r'APP_STATUS_CHANGED';
    case Enum$WebhookEventTypeEnum.ATTRIBUTE_CREATED:
      return r'ATTRIBUTE_CREATED';
    case Enum$WebhookEventTypeEnum.ATTRIBUTE_UPDATED:
      return r'ATTRIBUTE_UPDATED';
    case Enum$WebhookEventTypeEnum.ATTRIBUTE_DELETED:
      return r'ATTRIBUTE_DELETED';
    case Enum$WebhookEventTypeEnum.ATTRIBUTE_VALUE_CREATED:
      return r'ATTRIBUTE_VALUE_CREATED';
    case Enum$WebhookEventTypeEnum.ATTRIBUTE_VALUE_UPDATED:
      return r'ATTRIBUTE_VALUE_UPDATED';
    case Enum$WebhookEventTypeEnum.ATTRIBUTE_VALUE_DELETED:
      return r'ATTRIBUTE_VALUE_DELETED';
    case Enum$WebhookEventTypeEnum.CATEGORY_CREATED:
      return r'CATEGORY_CREATED';
    case Enum$WebhookEventTypeEnum.CATEGORY_UPDATED:
      return r'CATEGORY_UPDATED';
    case Enum$WebhookEventTypeEnum.CATEGORY_DELETED:
      return r'CATEGORY_DELETED';
    case Enum$WebhookEventTypeEnum.CHANNEL_CREATED:
      return r'CHANNEL_CREATED';
    case Enum$WebhookEventTypeEnum.CHANNEL_UPDATED:
      return r'CHANNEL_UPDATED';
    case Enum$WebhookEventTypeEnum.CHANNEL_DELETED:
      return r'CHANNEL_DELETED';
    case Enum$WebhookEventTypeEnum.CHANNEL_STATUS_CHANGED:
      return r'CHANNEL_STATUS_CHANGED';
    case Enum$WebhookEventTypeEnum.CHANNEL_METADATA_UPDATED:
      return r'CHANNEL_METADATA_UPDATED';
    case Enum$WebhookEventTypeEnum.GIFT_CARD_CREATED:
      return r'GIFT_CARD_CREATED';
    case Enum$WebhookEventTypeEnum.GIFT_CARD_UPDATED:
      return r'GIFT_CARD_UPDATED';
    case Enum$WebhookEventTypeEnum.GIFT_CARD_DELETED:
      return r'GIFT_CARD_DELETED';
    case Enum$WebhookEventTypeEnum.GIFT_CARD_SENT:
      return r'GIFT_CARD_SENT';
    case Enum$WebhookEventTypeEnum.GIFT_CARD_STATUS_CHANGED:
      return r'GIFT_CARD_STATUS_CHANGED';
    case Enum$WebhookEventTypeEnum.GIFT_CARD_METADATA_UPDATED:
      return r'GIFT_CARD_METADATA_UPDATED';
    case Enum$WebhookEventTypeEnum.GIFT_CARD_EXPORT_COMPLETED:
      return r'GIFT_CARD_EXPORT_COMPLETED';
    case Enum$WebhookEventTypeEnum.MENU_CREATED:
      return r'MENU_CREATED';
    case Enum$WebhookEventTypeEnum.MENU_UPDATED:
      return r'MENU_UPDATED';
    case Enum$WebhookEventTypeEnum.MENU_DELETED:
      return r'MENU_DELETED';
    case Enum$WebhookEventTypeEnum.MENU_ITEM_CREATED:
      return r'MENU_ITEM_CREATED';
    case Enum$WebhookEventTypeEnum.MENU_ITEM_UPDATED:
      return r'MENU_ITEM_UPDATED';
    case Enum$WebhookEventTypeEnum.MENU_ITEM_DELETED:
      return r'MENU_ITEM_DELETED';
    case Enum$WebhookEventTypeEnum.ORDER_CREATED:
      return r'ORDER_CREATED';
    case Enum$WebhookEventTypeEnum.ORDER_CONFIRMED:
      return r'ORDER_CONFIRMED';
    case Enum$WebhookEventTypeEnum.ORDER_PAID:
      return r'ORDER_PAID';
    case Enum$WebhookEventTypeEnum.ORDER_FULLY_PAID:
      return r'ORDER_FULLY_PAID';
    case Enum$WebhookEventTypeEnum.ORDER_REFUNDED:
      return r'ORDER_REFUNDED';
    case Enum$WebhookEventTypeEnum.ORDER_FULLY_REFUNDED:
      return r'ORDER_FULLY_REFUNDED';
    case Enum$WebhookEventTypeEnum.ORDER_UPDATED:
      return r'ORDER_UPDATED';
    case Enum$WebhookEventTypeEnum.ORDER_CANCELLED:
      return r'ORDER_CANCELLED';
    case Enum$WebhookEventTypeEnum.ORDER_EXPIRED:
      return r'ORDER_EXPIRED';
    case Enum$WebhookEventTypeEnum.ORDER_FULFILLED:
      return r'ORDER_FULFILLED';
    case Enum$WebhookEventTypeEnum.ORDER_METADATA_UPDATED:
      return r'ORDER_METADATA_UPDATED';
    case Enum$WebhookEventTypeEnum.ORDER_BULK_CREATED:
      return r'ORDER_BULK_CREATED';
    case Enum$WebhookEventTypeEnum.FULFILLMENT_CREATED:
      return r'FULFILLMENT_CREATED';
    case Enum$WebhookEventTypeEnum.FULFILLMENT_CANCELED:
      return r'FULFILLMENT_CANCELED';
    case Enum$WebhookEventTypeEnum.FULFILLMENT_APPROVED:
      return r'FULFILLMENT_APPROVED';
    case Enum$WebhookEventTypeEnum.FULFILLMENT_METADATA_UPDATED:
      return r'FULFILLMENT_METADATA_UPDATED';
    case Enum$WebhookEventTypeEnum.FULFILLMENT_TRACKING_NUMBER_UPDATED:
      return r'FULFILLMENT_TRACKING_NUMBER_UPDATED';
    case Enum$WebhookEventTypeEnum.DRAFT_ORDER_CREATED:
      return r'DRAFT_ORDER_CREATED';
    case Enum$WebhookEventTypeEnum.DRAFT_ORDER_UPDATED:
      return r'DRAFT_ORDER_UPDATED';
    case Enum$WebhookEventTypeEnum.DRAFT_ORDER_DELETED:
      return r'DRAFT_ORDER_DELETED';
    case Enum$WebhookEventTypeEnum.SALE_CREATED:
      return r'SALE_CREATED';
    case Enum$WebhookEventTypeEnum.SALE_UPDATED:
      return r'SALE_UPDATED';
    case Enum$WebhookEventTypeEnum.SALE_DELETED:
      return r'SALE_DELETED';
    case Enum$WebhookEventTypeEnum.SALE_TOGGLE:
      return r'SALE_TOGGLE';
    case Enum$WebhookEventTypeEnum.PROMOTION_CREATED:
      return r'PROMOTION_CREATED';
    case Enum$WebhookEventTypeEnum.PROMOTION_UPDATED:
      return r'PROMOTION_UPDATED';
    case Enum$WebhookEventTypeEnum.PROMOTION_DELETED:
      return r'PROMOTION_DELETED';
    case Enum$WebhookEventTypeEnum.PROMOTION_STARTED:
      return r'PROMOTION_STARTED';
    case Enum$WebhookEventTypeEnum.PROMOTION_ENDED:
      return r'PROMOTION_ENDED';
    case Enum$WebhookEventTypeEnum.PROMOTION_RULE_CREATED:
      return r'PROMOTION_RULE_CREATED';
    case Enum$WebhookEventTypeEnum.PROMOTION_RULE_UPDATED:
      return r'PROMOTION_RULE_UPDATED';
    case Enum$WebhookEventTypeEnum.PROMOTION_RULE_DELETED:
      return r'PROMOTION_RULE_DELETED';
    case Enum$WebhookEventTypeEnum.INVOICE_REQUESTED:
      return r'INVOICE_REQUESTED';
    case Enum$WebhookEventTypeEnum.INVOICE_DELETED:
      return r'INVOICE_DELETED';
    case Enum$WebhookEventTypeEnum.INVOICE_SENT:
      return r'INVOICE_SENT';
    case Enum$WebhookEventTypeEnum.CUSTOMER_CREATED:
      return r'CUSTOMER_CREATED';
    case Enum$WebhookEventTypeEnum.CUSTOMER_UPDATED:
      return r'CUSTOMER_UPDATED';
    case Enum$WebhookEventTypeEnum.CUSTOMER_DELETED:
      return r'CUSTOMER_DELETED';
    case Enum$WebhookEventTypeEnum.CUSTOMER_METADATA_UPDATED:
      return r'CUSTOMER_METADATA_UPDATED';
    case Enum$WebhookEventTypeEnum.COLLECTION_CREATED:
      return r'COLLECTION_CREATED';
    case Enum$WebhookEventTypeEnum.COLLECTION_UPDATED:
      return r'COLLECTION_UPDATED';
    case Enum$WebhookEventTypeEnum.COLLECTION_DELETED:
      return r'COLLECTION_DELETED';
    case Enum$WebhookEventTypeEnum.COLLECTION_METADATA_UPDATED:
      return r'COLLECTION_METADATA_UPDATED';
    case Enum$WebhookEventTypeEnum.PRODUCT_CREATED:
      return r'PRODUCT_CREATED';
    case Enum$WebhookEventTypeEnum.PRODUCT_UPDATED:
      return r'PRODUCT_UPDATED';
    case Enum$WebhookEventTypeEnum.PRODUCT_DELETED:
      return r'PRODUCT_DELETED';
    case Enum$WebhookEventTypeEnum.PRODUCT_METADATA_UPDATED:
      return r'PRODUCT_METADATA_UPDATED';
    case Enum$WebhookEventTypeEnum.PRODUCT_EXPORT_COMPLETED:
      return r'PRODUCT_EXPORT_COMPLETED';
    case Enum$WebhookEventTypeEnum.PRODUCT_MEDIA_CREATED:
      return r'PRODUCT_MEDIA_CREATED';
    case Enum$WebhookEventTypeEnum.PRODUCT_MEDIA_UPDATED:
      return r'PRODUCT_MEDIA_UPDATED';
    case Enum$WebhookEventTypeEnum.PRODUCT_MEDIA_DELETED:
      return r'PRODUCT_MEDIA_DELETED';
    case Enum$WebhookEventTypeEnum.PRODUCT_VARIANT_CREATED:
      return r'PRODUCT_VARIANT_CREATED';
    case Enum$WebhookEventTypeEnum.PRODUCT_VARIANT_UPDATED:
      return r'PRODUCT_VARIANT_UPDATED';
    case Enum$WebhookEventTypeEnum.PRODUCT_VARIANT_DELETED:
      return r'PRODUCT_VARIANT_DELETED';
    case Enum$WebhookEventTypeEnum.PRODUCT_VARIANT_METADATA_UPDATED:
      return r'PRODUCT_VARIANT_METADATA_UPDATED';
    case Enum$WebhookEventTypeEnum.PRODUCT_VARIANT_OUT_OF_STOCK:
      return r'PRODUCT_VARIANT_OUT_OF_STOCK';
    case Enum$WebhookEventTypeEnum.PRODUCT_VARIANT_BACK_IN_STOCK:
      return r'PRODUCT_VARIANT_BACK_IN_STOCK';
    case Enum$WebhookEventTypeEnum.PRODUCT_VARIANT_STOCK_UPDATED:
      return r'PRODUCT_VARIANT_STOCK_UPDATED';
    case Enum$WebhookEventTypeEnum.CHECKOUT_CREATED:
      return r'CHECKOUT_CREATED';
    case Enum$WebhookEventTypeEnum.CHECKOUT_UPDATED:
      return r'CHECKOUT_UPDATED';
    case Enum$WebhookEventTypeEnum.CHECKOUT_FULLY_PAID:
      return r'CHECKOUT_FULLY_PAID';
    case Enum$WebhookEventTypeEnum.CHECKOUT_METADATA_UPDATED:
      return r'CHECKOUT_METADATA_UPDATED';
    case Enum$WebhookEventTypeEnum.NOTIFY_USER:
      return r'NOTIFY_USER';
    case Enum$WebhookEventTypeEnum.PAGE_CREATED:
      return r'PAGE_CREATED';
    case Enum$WebhookEventTypeEnum.PAGE_UPDATED:
      return r'PAGE_UPDATED';
    case Enum$WebhookEventTypeEnum.PAGE_DELETED:
      return r'PAGE_DELETED';
    case Enum$WebhookEventTypeEnum.PAGE_TYPE_CREATED:
      return r'PAGE_TYPE_CREATED';
    case Enum$WebhookEventTypeEnum.PAGE_TYPE_UPDATED:
      return r'PAGE_TYPE_UPDATED';
    case Enum$WebhookEventTypeEnum.PAGE_TYPE_DELETED:
      return r'PAGE_TYPE_DELETED';
    case Enum$WebhookEventTypeEnum.PERMISSION_GROUP_CREATED:
      return r'PERMISSION_GROUP_CREATED';
    case Enum$WebhookEventTypeEnum.PERMISSION_GROUP_UPDATED:
      return r'PERMISSION_GROUP_UPDATED';
    case Enum$WebhookEventTypeEnum.PERMISSION_GROUP_DELETED:
      return r'PERMISSION_GROUP_DELETED';
    case Enum$WebhookEventTypeEnum.SHIPPING_PRICE_CREATED:
      return r'SHIPPING_PRICE_CREATED';
    case Enum$WebhookEventTypeEnum.SHIPPING_PRICE_UPDATED:
      return r'SHIPPING_PRICE_UPDATED';
    case Enum$WebhookEventTypeEnum.SHIPPING_PRICE_DELETED:
      return r'SHIPPING_PRICE_DELETED';
    case Enum$WebhookEventTypeEnum.SHIPPING_ZONE_CREATED:
      return r'SHIPPING_ZONE_CREATED';
    case Enum$WebhookEventTypeEnum.SHIPPING_ZONE_UPDATED:
      return r'SHIPPING_ZONE_UPDATED';
    case Enum$WebhookEventTypeEnum.SHIPPING_ZONE_DELETED:
      return r'SHIPPING_ZONE_DELETED';
    case Enum$WebhookEventTypeEnum.SHIPPING_ZONE_METADATA_UPDATED:
      return r'SHIPPING_ZONE_METADATA_UPDATED';
    case Enum$WebhookEventTypeEnum.STAFF_CREATED:
      return r'STAFF_CREATED';
    case Enum$WebhookEventTypeEnum.STAFF_UPDATED:
      return r'STAFF_UPDATED';
    case Enum$WebhookEventTypeEnum.STAFF_DELETED:
      return r'STAFF_DELETED';
    case Enum$WebhookEventTypeEnum.STAFF_SET_PASSWORD_REQUESTED:
      return r'STAFF_SET_PASSWORD_REQUESTED';
    case Enum$WebhookEventTypeEnum.TRANSACTION_ITEM_METADATA_UPDATED:
      return r'TRANSACTION_ITEM_METADATA_UPDATED';
    case Enum$WebhookEventTypeEnum.TRANSLATION_CREATED:
      return r'TRANSLATION_CREATED';
    case Enum$WebhookEventTypeEnum.TRANSLATION_UPDATED:
      return r'TRANSLATION_UPDATED';
    case Enum$WebhookEventTypeEnum.WAREHOUSE_CREATED:
      return r'WAREHOUSE_CREATED';
    case Enum$WebhookEventTypeEnum.WAREHOUSE_UPDATED:
      return r'WAREHOUSE_UPDATED';
    case Enum$WebhookEventTypeEnum.WAREHOUSE_DELETED:
      return r'WAREHOUSE_DELETED';
    case Enum$WebhookEventTypeEnum.WAREHOUSE_METADATA_UPDATED:
      return r'WAREHOUSE_METADATA_UPDATED';
    case Enum$WebhookEventTypeEnum.VOUCHER_CREATED:
      return r'VOUCHER_CREATED';
    case Enum$WebhookEventTypeEnum.VOUCHER_UPDATED:
      return r'VOUCHER_UPDATED';
    case Enum$WebhookEventTypeEnum.VOUCHER_DELETED:
      return r'VOUCHER_DELETED';
    case Enum$WebhookEventTypeEnum.VOUCHER_CODES_CREATED:
      return r'VOUCHER_CODES_CREATED';
    case Enum$WebhookEventTypeEnum.VOUCHER_CODES_DELETED:
      return r'VOUCHER_CODES_DELETED';
    case Enum$WebhookEventTypeEnum.VOUCHER_METADATA_UPDATED:
      return r'VOUCHER_METADATA_UPDATED';
    case Enum$WebhookEventTypeEnum.VOUCHER_CODE_EXPORT_COMPLETED:
      return r'VOUCHER_CODE_EXPORT_COMPLETED';
    case Enum$WebhookEventTypeEnum.OBSERVABILITY:
      return r'OBSERVABILITY';
    case Enum$WebhookEventTypeEnum.THUMBNAIL_CREATED:
      return r'THUMBNAIL_CREATED';
    case Enum$WebhookEventTypeEnum.SHOP_METADATA_UPDATED:
      return r'SHOP_METADATA_UPDATED';
    case Enum$WebhookEventTypeEnum.PAYMENT_LIST_GATEWAYS:
      return r'PAYMENT_LIST_GATEWAYS';
    case Enum$WebhookEventTypeEnum.PAYMENT_AUTHORIZE:
      return r'PAYMENT_AUTHORIZE';
    case Enum$WebhookEventTypeEnum.PAYMENT_CAPTURE:
      return r'PAYMENT_CAPTURE';
    case Enum$WebhookEventTypeEnum.PAYMENT_REFUND:
      return r'PAYMENT_REFUND';
    case Enum$WebhookEventTypeEnum.PAYMENT_VOID:
      return r'PAYMENT_VOID';
    case Enum$WebhookEventTypeEnum.PAYMENT_CONFIRM:
      return r'PAYMENT_CONFIRM';
    case Enum$WebhookEventTypeEnum.PAYMENT_PROCESS:
      return r'PAYMENT_PROCESS';
    case Enum$WebhookEventTypeEnum.CHECKOUT_CALCULATE_TAXES:
      return r'CHECKOUT_CALCULATE_TAXES';
    case Enum$WebhookEventTypeEnum.ORDER_CALCULATE_TAXES:
      return r'ORDER_CALCULATE_TAXES';
    case Enum$WebhookEventTypeEnum.TRANSACTION_CHARGE_REQUESTED:
      return r'TRANSACTION_CHARGE_REQUESTED';
    case Enum$WebhookEventTypeEnum.TRANSACTION_REFUND_REQUESTED:
      return r'TRANSACTION_REFUND_REQUESTED';
    case Enum$WebhookEventTypeEnum.TRANSACTION_CANCELATION_REQUESTED:
      return r'TRANSACTION_CANCELATION_REQUESTED';
    case Enum$WebhookEventTypeEnum.SHIPPING_LIST_METHODS_FOR_CHECKOUT:
      return r'SHIPPING_LIST_METHODS_FOR_CHECKOUT';
    case Enum$WebhookEventTypeEnum.CHECKOUT_FILTER_SHIPPING_METHODS:
      return r'CHECKOUT_FILTER_SHIPPING_METHODS';
    case Enum$WebhookEventTypeEnum.ORDER_FILTER_SHIPPING_METHODS:
      return r'ORDER_FILTER_SHIPPING_METHODS';
    case Enum$WebhookEventTypeEnum.PAYMENT_GATEWAY_INITIALIZE_SESSION:
      return r'PAYMENT_GATEWAY_INITIALIZE_SESSION';
    case Enum$WebhookEventTypeEnum.TRANSACTION_INITIALIZE_SESSION:
      return r'TRANSACTION_INITIALIZE_SESSION';
    case Enum$WebhookEventTypeEnum.TRANSACTION_PROCESS_SESSION:
      return r'TRANSACTION_PROCESS_SESSION';
    case Enum$WebhookEventTypeEnum.LIST_STORED_PAYMENT_METHODS:
      return r'LIST_STORED_PAYMENT_METHODS';
    case Enum$WebhookEventTypeEnum.STORED_PAYMENT_METHOD_DELETE_REQUESTED:
      return r'STORED_PAYMENT_METHOD_DELETE_REQUESTED';
    case Enum$WebhookEventTypeEnum
          .PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION:
      return r'PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION';
    case Enum$WebhookEventTypeEnum
          .PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION:
      return r'PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION';
    case Enum$WebhookEventTypeEnum.PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION:
      return r'PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION';
    case Enum$WebhookEventTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$WebhookEventTypeEnum fromJson$Enum$WebhookEventTypeEnum(String value) {
  switch (value) {
    case r'ANY_EVENTS':
      return Enum$WebhookEventTypeEnum.ANY_EVENTS;
    case r'ACCOUNT_CONFIRMATION_REQUESTED':
      return Enum$WebhookEventTypeEnum.ACCOUNT_CONFIRMATION_REQUESTED;
    case r'ACCOUNT_CHANGE_EMAIL_REQUESTED':
      return Enum$WebhookEventTypeEnum.ACCOUNT_CHANGE_EMAIL_REQUESTED;
    case r'ACCOUNT_EMAIL_CHANGED':
      return Enum$WebhookEventTypeEnum.ACCOUNT_EMAIL_CHANGED;
    case r'ACCOUNT_SET_PASSWORD_REQUESTED':
      return Enum$WebhookEventTypeEnum.ACCOUNT_SET_PASSWORD_REQUESTED;
    case r'ACCOUNT_CONFIRMED':
      return Enum$WebhookEventTypeEnum.ACCOUNT_CONFIRMED;
    case r'ACCOUNT_DELETE_REQUESTED':
      return Enum$WebhookEventTypeEnum.ACCOUNT_DELETE_REQUESTED;
    case r'ACCOUNT_DELETED':
      return Enum$WebhookEventTypeEnum.ACCOUNT_DELETED;
    case r'ADDRESS_CREATED':
      return Enum$WebhookEventTypeEnum.ADDRESS_CREATED;
    case r'ADDRESS_UPDATED':
      return Enum$WebhookEventTypeEnum.ADDRESS_UPDATED;
    case r'ADDRESS_DELETED':
      return Enum$WebhookEventTypeEnum.ADDRESS_DELETED;
    case r'APP_INSTALLED':
      return Enum$WebhookEventTypeEnum.APP_INSTALLED;
    case r'APP_UPDATED':
      return Enum$WebhookEventTypeEnum.APP_UPDATED;
    case r'APP_DELETED':
      return Enum$WebhookEventTypeEnum.APP_DELETED;
    case r'APP_STATUS_CHANGED':
      return Enum$WebhookEventTypeEnum.APP_STATUS_CHANGED;
    case r'ATTRIBUTE_CREATED':
      return Enum$WebhookEventTypeEnum.ATTRIBUTE_CREATED;
    case r'ATTRIBUTE_UPDATED':
      return Enum$WebhookEventTypeEnum.ATTRIBUTE_UPDATED;
    case r'ATTRIBUTE_DELETED':
      return Enum$WebhookEventTypeEnum.ATTRIBUTE_DELETED;
    case r'ATTRIBUTE_VALUE_CREATED':
      return Enum$WebhookEventTypeEnum.ATTRIBUTE_VALUE_CREATED;
    case r'ATTRIBUTE_VALUE_UPDATED':
      return Enum$WebhookEventTypeEnum.ATTRIBUTE_VALUE_UPDATED;
    case r'ATTRIBUTE_VALUE_DELETED':
      return Enum$WebhookEventTypeEnum.ATTRIBUTE_VALUE_DELETED;
    case r'CATEGORY_CREATED':
      return Enum$WebhookEventTypeEnum.CATEGORY_CREATED;
    case r'CATEGORY_UPDATED':
      return Enum$WebhookEventTypeEnum.CATEGORY_UPDATED;
    case r'CATEGORY_DELETED':
      return Enum$WebhookEventTypeEnum.CATEGORY_DELETED;
    case r'CHANNEL_CREATED':
      return Enum$WebhookEventTypeEnum.CHANNEL_CREATED;
    case r'CHANNEL_UPDATED':
      return Enum$WebhookEventTypeEnum.CHANNEL_UPDATED;
    case r'CHANNEL_DELETED':
      return Enum$WebhookEventTypeEnum.CHANNEL_DELETED;
    case r'CHANNEL_STATUS_CHANGED':
      return Enum$WebhookEventTypeEnum.CHANNEL_STATUS_CHANGED;
    case r'CHANNEL_METADATA_UPDATED':
      return Enum$WebhookEventTypeEnum.CHANNEL_METADATA_UPDATED;
    case r'GIFT_CARD_CREATED':
      return Enum$WebhookEventTypeEnum.GIFT_CARD_CREATED;
    case r'GIFT_CARD_UPDATED':
      return Enum$WebhookEventTypeEnum.GIFT_CARD_UPDATED;
    case r'GIFT_CARD_DELETED':
      return Enum$WebhookEventTypeEnum.GIFT_CARD_DELETED;
    case r'GIFT_CARD_SENT':
      return Enum$WebhookEventTypeEnum.GIFT_CARD_SENT;
    case r'GIFT_CARD_STATUS_CHANGED':
      return Enum$WebhookEventTypeEnum.GIFT_CARD_STATUS_CHANGED;
    case r'GIFT_CARD_METADATA_UPDATED':
      return Enum$WebhookEventTypeEnum.GIFT_CARD_METADATA_UPDATED;
    case r'GIFT_CARD_EXPORT_COMPLETED':
      return Enum$WebhookEventTypeEnum.GIFT_CARD_EXPORT_COMPLETED;
    case r'MENU_CREATED':
      return Enum$WebhookEventTypeEnum.MENU_CREATED;
    case r'MENU_UPDATED':
      return Enum$WebhookEventTypeEnum.MENU_UPDATED;
    case r'MENU_DELETED':
      return Enum$WebhookEventTypeEnum.MENU_DELETED;
    case r'MENU_ITEM_CREATED':
      return Enum$WebhookEventTypeEnum.MENU_ITEM_CREATED;
    case r'MENU_ITEM_UPDATED':
      return Enum$WebhookEventTypeEnum.MENU_ITEM_UPDATED;
    case r'MENU_ITEM_DELETED':
      return Enum$WebhookEventTypeEnum.MENU_ITEM_DELETED;
    case r'ORDER_CREATED':
      return Enum$WebhookEventTypeEnum.ORDER_CREATED;
    case r'ORDER_CONFIRMED':
      return Enum$WebhookEventTypeEnum.ORDER_CONFIRMED;
    case r'ORDER_PAID':
      return Enum$WebhookEventTypeEnum.ORDER_PAID;
    case r'ORDER_FULLY_PAID':
      return Enum$WebhookEventTypeEnum.ORDER_FULLY_PAID;
    case r'ORDER_REFUNDED':
      return Enum$WebhookEventTypeEnum.ORDER_REFUNDED;
    case r'ORDER_FULLY_REFUNDED':
      return Enum$WebhookEventTypeEnum.ORDER_FULLY_REFUNDED;
    case r'ORDER_UPDATED':
      return Enum$WebhookEventTypeEnum.ORDER_UPDATED;
    case r'ORDER_CANCELLED':
      return Enum$WebhookEventTypeEnum.ORDER_CANCELLED;
    case r'ORDER_EXPIRED':
      return Enum$WebhookEventTypeEnum.ORDER_EXPIRED;
    case r'ORDER_FULFILLED':
      return Enum$WebhookEventTypeEnum.ORDER_FULFILLED;
    case r'ORDER_METADATA_UPDATED':
      return Enum$WebhookEventTypeEnum.ORDER_METADATA_UPDATED;
    case r'ORDER_BULK_CREATED':
      return Enum$WebhookEventTypeEnum.ORDER_BULK_CREATED;
    case r'FULFILLMENT_CREATED':
      return Enum$WebhookEventTypeEnum.FULFILLMENT_CREATED;
    case r'FULFILLMENT_CANCELED':
      return Enum$WebhookEventTypeEnum.FULFILLMENT_CANCELED;
    case r'FULFILLMENT_APPROVED':
      return Enum$WebhookEventTypeEnum.FULFILLMENT_APPROVED;
    case r'FULFILLMENT_METADATA_UPDATED':
      return Enum$WebhookEventTypeEnum.FULFILLMENT_METADATA_UPDATED;
    case r'FULFILLMENT_TRACKING_NUMBER_UPDATED':
      return Enum$WebhookEventTypeEnum.FULFILLMENT_TRACKING_NUMBER_UPDATED;
    case r'DRAFT_ORDER_CREATED':
      return Enum$WebhookEventTypeEnum.DRAFT_ORDER_CREATED;
    case r'DRAFT_ORDER_UPDATED':
      return Enum$WebhookEventTypeEnum.DRAFT_ORDER_UPDATED;
    case r'DRAFT_ORDER_DELETED':
      return Enum$WebhookEventTypeEnum.DRAFT_ORDER_DELETED;
    case r'SALE_CREATED':
      return Enum$WebhookEventTypeEnum.SALE_CREATED;
    case r'SALE_UPDATED':
      return Enum$WebhookEventTypeEnum.SALE_UPDATED;
    case r'SALE_DELETED':
      return Enum$WebhookEventTypeEnum.SALE_DELETED;
    case r'SALE_TOGGLE':
      return Enum$WebhookEventTypeEnum.SALE_TOGGLE;
    case r'PROMOTION_CREATED':
      return Enum$WebhookEventTypeEnum.PROMOTION_CREATED;
    case r'PROMOTION_UPDATED':
      return Enum$WebhookEventTypeEnum.PROMOTION_UPDATED;
    case r'PROMOTION_DELETED':
      return Enum$WebhookEventTypeEnum.PROMOTION_DELETED;
    case r'PROMOTION_STARTED':
      return Enum$WebhookEventTypeEnum.PROMOTION_STARTED;
    case r'PROMOTION_ENDED':
      return Enum$WebhookEventTypeEnum.PROMOTION_ENDED;
    case r'PROMOTION_RULE_CREATED':
      return Enum$WebhookEventTypeEnum.PROMOTION_RULE_CREATED;
    case r'PROMOTION_RULE_UPDATED':
      return Enum$WebhookEventTypeEnum.PROMOTION_RULE_UPDATED;
    case r'PROMOTION_RULE_DELETED':
      return Enum$WebhookEventTypeEnum.PROMOTION_RULE_DELETED;
    case r'INVOICE_REQUESTED':
      return Enum$WebhookEventTypeEnum.INVOICE_REQUESTED;
    case r'INVOICE_DELETED':
      return Enum$WebhookEventTypeEnum.INVOICE_DELETED;
    case r'INVOICE_SENT':
      return Enum$WebhookEventTypeEnum.INVOICE_SENT;
    case r'CUSTOMER_CREATED':
      return Enum$WebhookEventTypeEnum.CUSTOMER_CREATED;
    case r'CUSTOMER_UPDATED':
      return Enum$WebhookEventTypeEnum.CUSTOMER_UPDATED;
    case r'CUSTOMER_DELETED':
      return Enum$WebhookEventTypeEnum.CUSTOMER_DELETED;
    case r'CUSTOMER_METADATA_UPDATED':
      return Enum$WebhookEventTypeEnum.CUSTOMER_METADATA_UPDATED;
    case r'COLLECTION_CREATED':
      return Enum$WebhookEventTypeEnum.COLLECTION_CREATED;
    case r'COLLECTION_UPDATED':
      return Enum$WebhookEventTypeEnum.COLLECTION_UPDATED;
    case r'COLLECTION_DELETED':
      return Enum$WebhookEventTypeEnum.COLLECTION_DELETED;
    case r'COLLECTION_METADATA_UPDATED':
      return Enum$WebhookEventTypeEnum.COLLECTION_METADATA_UPDATED;
    case r'PRODUCT_CREATED':
      return Enum$WebhookEventTypeEnum.PRODUCT_CREATED;
    case r'PRODUCT_UPDATED':
      return Enum$WebhookEventTypeEnum.PRODUCT_UPDATED;
    case r'PRODUCT_DELETED':
      return Enum$WebhookEventTypeEnum.PRODUCT_DELETED;
    case r'PRODUCT_METADATA_UPDATED':
      return Enum$WebhookEventTypeEnum.PRODUCT_METADATA_UPDATED;
    case r'PRODUCT_EXPORT_COMPLETED':
      return Enum$WebhookEventTypeEnum.PRODUCT_EXPORT_COMPLETED;
    case r'PRODUCT_MEDIA_CREATED':
      return Enum$WebhookEventTypeEnum.PRODUCT_MEDIA_CREATED;
    case r'PRODUCT_MEDIA_UPDATED':
      return Enum$WebhookEventTypeEnum.PRODUCT_MEDIA_UPDATED;
    case r'PRODUCT_MEDIA_DELETED':
      return Enum$WebhookEventTypeEnum.PRODUCT_MEDIA_DELETED;
    case r'PRODUCT_VARIANT_CREATED':
      return Enum$WebhookEventTypeEnum.PRODUCT_VARIANT_CREATED;
    case r'PRODUCT_VARIANT_UPDATED':
      return Enum$WebhookEventTypeEnum.PRODUCT_VARIANT_UPDATED;
    case r'PRODUCT_VARIANT_DELETED':
      return Enum$WebhookEventTypeEnum.PRODUCT_VARIANT_DELETED;
    case r'PRODUCT_VARIANT_METADATA_UPDATED':
      return Enum$WebhookEventTypeEnum.PRODUCT_VARIANT_METADATA_UPDATED;
    case r'PRODUCT_VARIANT_OUT_OF_STOCK':
      return Enum$WebhookEventTypeEnum.PRODUCT_VARIANT_OUT_OF_STOCK;
    case r'PRODUCT_VARIANT_BACK_IN_STOCK':
      return Enum$WebhookEventTypeEnum.PRODUCT_VARIANT_BACK_IN_STOCK;
    case r'PRODUCT_VARIANT_STOCK_UPDATED':
      return Enum$WebhookEventTypeEnum.PRODUCT_VARIANT_STOCK_UPDATED;
    case r'CHECKOUT_CREATED':
      return Enum$WebhookEventTypeEnum.CHECKOUT_CREATED;
    case r'CHECKOUT_UPDATED':
      return Enum$WebhookEventTypeEnum.CHECKOUT_UPDATED;
    case r'CHECKOUT_FULLY_PAID':
      return Enum$WebhookEventTypeEnum.CHECKOUT_FULLY_PAID;
    case r'CHECKOUT_METADATA_UPDATED':
      return Enum$WebhookEventTypeEnum.CHECKOUT_METADATA_UPDATED;
    case r'NOTIFY_USER':
      return Enum$WebhookEventTypeEnum.NOTIFY_USER;
    case r'PAGE_CREATED':
      return Enum$WebhookEventTypeEnum.PAGE_CREATED;
    case r'PAGE_UPDATED':
      return Enum$WebhookEventTypeEnum.PAGE_UPDATED;
    case r'PAGE_DELETED':
      return Enum$WebhookEventTypeEnum.PAGE_DELETED;
    case r'PAGE_TYPE_CREATED':
      return Enum$WebhookEventTypeEnum.PAGE_TYPE_CREATED;
    case r'PAGE_TYPE_UPDATED':
      return Enum$WebhookEventTypeEnum.PAGE_TYPE_UPDATED;
    case r'PAGE_TYPE_DELETED':
      return Enum$WebhookEventTypeEnum.PAGE_TYPE_DELETED;
    case r'PERMISSION_GROUP_CREATED':
      return Enum$WebhookEventTypeEnum.PERMISSION_GROUP_CREATED;
    case r'PERMISSION_GROUP_UPDATED':
      return Enum$WebhookEventTypeEnum.PERMISSION_GROUP_UPDATED;
    case r'PERMISSION_GROUP_DELETED':
      return Enum$WebhookEventTypeEnum.PERMISSION_GROUP_DELETED;
    case r'SHIPPING_PRICE_CREATED':
      return Enum$WebhookEventTypeEnum.SHIPPING_PRICE_CREATED;
    case r'SHIPPING_PRICE_UPDATED':
      return Enum$WebhookEventTypeEnum.SHIPPING_PRICE_UPDATED;
    case r'SHIPPING_PRICE_DELETED':
      return Enum$WebhookEventTypeEnum.SHIPPING_PRICE_DELETED;
    case r'SHIPPING_ZONE_CREATED':
      return Enum$WebhookEventTypeEnum.SHIPPING_ZONE_CREATED;
    case r'SHIPPING_ZONE_UPDATED':
      return Enum$WebhookEventTypeEnum.SHIPPING_ZONE_UPDATED;
    case r'SHIPPING_ZONE_DELETED':
      return Enum$WebhookEventTypeEnum.SHIPPING_ZONE_DELETED;
    case r'SHIPPING_ZONE_METADATA_UPDATED':
      return Enum$WebhookEventTypeEnum.SHIPPING_ZONE_METADATA_UPDATED;
    case r'STAFF_CREATED':
      return Enum$WebhookEventTypeEnum.STAFF_CREATED;
    case r'STAFF_UPDATED':
      return Enum$WebhookEventTypeEnum.STAFF_UPDATED;
    case r'STAFF_DELETED':
      return Enum$WebhookEventTypeEnum.STAFF_DELETED;
    case r'STAFF_SET_PASSWORD_REQUESTED':
      return Enum$WebhookEventTypeEnum.STAFF_SET_PASSWORD_REQUESTED;
    case r'TRANSACTION_ITEM_METADATA_UPDATED':
      return Enum$WebhookEventTypeEnum.TRANSACTION_ITEM_METADATA_UPDATED;
    case r'TRANSLATION_CREATED':
      return Enum$WebhookEventTypeEnum.TRANSLATION_CREATED;
    case r'TRANSLATION_UPDATED':
      return Enum$WebhookEventTypeEnum.TRANSLATION_UPDATED;
    case r'WAREHOUSE_CREATED':
      return Enum$WebhookEventTypeEnum.WAREHOUSE_CREATED;
    case r'WAREHOUSE_UPDATED':
      return Enum$WebhookEventTypeEnum.WAREHOUSE_UPDATED;
    case r'WAREHOUSE_DELETED':
      return Enum$WebhookEventTypeEnum.WAREHOUSE_DELETED;
    case r'WAREHOUSE_METADATA_UPDATED':
      return Enum$WebhookEventTypeEnum.WAREHOUSE_METADATA_UPDATED;
    case r'VOUCHER_CREATED':
      return Enum$WebhookEventTypeEnum.VOUCHER_CREATED;
    case r'VOUCHER_UPDATED':
      return Enum$WebhookEventTypeEnum.VOUCHER_UPDATED;
    case r'VOUCHER_DELETED':
      return Enum$WebhookEventTypeEnum.VOUCHER_DELETED;
    case r'VOUCHER_CODES_CREATED':
      return Enum$WebhookEventTypeEnum.VOUCHER_CODES_CREATED;
    case r'VOUCHER_CODES_DELETED':
      return Enum$WebhookEventTypeEnum.VOUCHER_CODES_DELETED;
    case r'VOUCHER_METADATA_UPDATED':
      return Enum$WebhookEventTypeEnum.VOUCHER_METADATA_UPDATED;
    case r'VOUCHER_CODE_EXPORT_COMPLETED':
      return Enum$WebhookEventTypeEnum.VOUCHER_CODE_EXPORT_COMPLETED;
    case r'OBSERVABILITY':
      return Enum$WebhookEventTypeEnum.OBSERVABILITY;
    case r'THUMBNAIL_CREATED':
      return Enum$WebhookEventTypeEnum.THUMBNAIL_CREATED;
    case r'SHOP_METADATA_UPDATED':
      return Enum$WebhookEventTypeEnum.SHOP_METADATA_UPDATED;
    case r'PAYMENT_LIST_GATEWAYS':
      return Enum$WebhookEventTypeEnum.PAYMENT_LIST_GATEWAYS;
    case r'PAYMENT_AUTHORIZE':
      return Enum$WebhookEventTypeEnum.PAYMENT_AUTHORIZE;
    case r'PAYMENT_CAPTURE':
      return Enum$WebhookEventTypeEnum.PAYMENT_CAPTURE;
    case r'PAYMENT_REFUND':
      return Enum$WebhookEventTypeEnum.PAYMENT_REFUND;
    case r'PAYMENT_VOID':
      return Enum$WebhookEventTypeEnum.PAYMENT_VOID;
    case r'PAYMENT_CONFIRM':
      return Enum$WebhookEventTypeEnum.PAYMENT_CONFIRM;
    case r'PAYMENT_PROCESS':
      return Enum$WebhookEventTypeEnum.PAYMENT_PROCESS;
    case r'CHECKOUT_CALCULATE_TAXES':
      return Enum$WebhookEventTypeEnum.CHECKOUT_CALCULATE_TAXES;
    case r'ORDER_CALCULATE_TAXES':
      return Enum$WebhookEventTypeEnum.ORDER_CALCULATE_TAXES;
    case r'TRANSACTION_CHARGE_REQUESTED':
      return Enum$WebhookEventTypeEnum.TRANSACTION_CHARGE_REQUESTED;
    case r'TRANSACTION_REFUND_REQUESTED':
      return Enum$WebhookEventTypeEnum.TRANSACTION_REFUND_REQUESTED;
    case r'TRANSACTION_CANCELATION_REQUESTED':
      return Enum$WebhookEventTypeEnum.TRANSACTION_CANCELATION_REQUESTED;
    case r'SHIPPING_LIST_METHODS_FOR_CHECKOUT':
      return Enum$WebhookEventTypeEnum.SHIPPING_LIST_METHODS_FOR_CHECKOUT;
    case r'CHECKOUT_FILTER_SHIPPING_METHODS':
      return Enum$WebhookEventTypeEnum.CHECKOUT_FILTER_SHIPPING_METHODS;
    case r'ORDER_FILTER_SHIPPING_METHODS':
      return Enum$WebhookEventTypeEnum.ORDER_FILTER_SHIPPING_METHODS;
    case r'PAYMENT_GATEWAY_INITIALIZE_SESSION':
      return Enum$WebhookEventTypeEnum.PAYMENT_GATEWAY_INITIALIZE_SESSION;
    case r'TRANSACTION_INITIALIZE_SESSION':
      return Enum$WebhookEventTypeEnum.TRANSACTION_INITIALIZE_SESSION;
    case r'TRANSACTION_PROCESS_SESSION':
      return Enum$WebhookEventTypeEnum.TRANSACTION_PROCESS_SESSION;
    case r'LIST_STORED_PAYMENT_METHODS':
      return Enum$WebhookEventTypeEnum.LIST_STORED_PAYMENT_METHODS;
    case r'STORED_PAYMENT_METHOD_DELETE_REQUESTED':
      return Enum$WebhookEventTypeEnum.STORED_PAYMENT_METHOD_DELETE_REQUESTED;
    case r'PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION':
      return Enum$WebhookEventTypeEnum
          .PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION;
    case r'PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION':
      return Enum$WebhookEventTypeEnum
          .PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION;
    case r'PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION':
      return Enum$WebhookEventTypeEnum
          .PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION;
    default:
      return Enum$WebhookEventTypeEnum.$unknown;
  }
}

enum Enum$WebhookEventTypeSyncEnum {
  PAYMENT_LIST_GATEWAYS,
  PAYMENT_AUTHORIZE,
  PAYMENT_CAPTURE,
  PAYMENT_REFUND,
  PAYMENT_VOID,
  PAYMENT_CONFIRM,
  PAYMENT_PROCESS,
  CHECKOUT_CALCULATE_TAXES,
  ORDER_CALCULATE_TAXES,
  TRANSACTION_CHARGE_REQUESTED,
  TRANSACTION_REFUND_REQUESTED,
  TRANSACTION_CANCELATION_REQUESTED,
  SHIPPING_LIST_METHODS_FOR_CHECKOUT,
  CHECKOUT_FILTER_SHIPPING_METHODS,
  ORDER_FILTER_SHIPPING_METHODS,
  PAYMENT_GATEWAY_INITIALIZE_SESSION,
  TRANSACTION_INITIALIZE_SESSION,
  TRANSACTION_PROCESS_SESSION,
  LIST_STORED_PAYMENT_METHODS,
  STORED_PAYMENT_METHOD_DELETE_REQUESTED,
  PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION,
  PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION,
  PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION,
  $unknown;

  factory Enum$WebhookEventTypeSyncEnum.fromJson(String value) =>
      fromJson$Enum$WebhookEventTypeSyncEnum(value);

  String toJson() => toJson$Enum$WebhookEventTypeSyncEnum(this);
}

String toJson$Enum$WebhookEventTypeSyncEnum(Enum$WebhookEventTypeSyncEnum e) {
  switch (e) {
    case Enum$WebhookEventTypeSyncEnum.PAYMENT_LIST_GATEWAYS:
      return r'PAYMENT_LIST_GATEWAYS';
    case Enum$WebhookEventTypeSyncEnum.PAYMENT_AUTHORIZE:
      return r'PAYMENT_AUTHORIZE';
    case Enum$WebhookEventTypeSyncEnum.PAYMENT_CAPTURE:
      return r'PAYMENT_CAPTURE';
    case Enum$WebhookEventTypeSyncEnum.PAYMENT_REFUND:
      return r'PAYMENT_REFUND';
    case Enum$WebhookEventTypeSyncEnum.PAYMENT_VOID:
      return r'PAYMENT_VOID';
    case Enum$WebhookEventTypeSyncEnum.PAYMENT_CONFIRM:
      return r'PAYMENT_CONFIRM';
    case Enum$WebhookEventTypeSyncEnum.PAYMENT_PROCESS:
      return r'PAYMENT_PROCESS';
    case Enum$WebhookEventTypeSyncEnum.CHECKOUT_CALCULATE_TAXES:
      return r'CHECKOUT_CALCULATE_TAXES';
    case Enum$WebhookEventTypeSyncEnum.ORDER_CALCULATE_TAXES:
      return r'ORDER_CALCULATE_TAXES';
    case Enum$WebhookEventTypeSyncEnum.TRANSACTION_CHARGE_REQUESTED:
      return r'TRANSACTION_CHARGE_REQUESTED';
    case Enum$WebhookEventTypeSyncEnum.TRANSACTION_REFUND_REQUESTED:
      return r'TRANSACTION_REFUND_REQUESTED';
    case Enum$WebhookEventTypeSyncEnum.TRANSACTION_CANCELATION_REQUESTED:
      return r'TRANSACTION_CANCELATION_REQUESTED';
    case Enum$WebhookEventTypeSyncEnum.SHIPPING_LIST_METHODS_FOR_CHECKOUT:
      return r'SHIPPING_LIST_METHODS_FOR_CHECKOUT';
    case Enum$WebhookEventTypeSyncEnum.CHECKOUT_FILTER_SHIPPING_METHODS:
      return r'CHECKOUT_FILTER_SHIPPING_METHODS';
    case Enum$WebhookEventTypeSyncEnum.ORDER_FILTER_SHIPPING_METHODS:
      return r'ORDER_FILTER_SHIPPING_METHODS';
    case Enum$WebhookEventTypeSyncEnum.PAYMENT_GATEWAY_INITIALIZE_SESSION:
      return r'PAYMENT_GATEWAY_INITIALIZE_SESSION';
    case Enum$WebhookEventTypeSyncEnum.TRANSACTION_INITIALIZE_SESSION:
      return r'TRANSACTION_INITIALIZE_SESSION';
    case Enum$WebhookEventTypeSyncEnum.TRANSACTION_PROCESS_SESSION:
      return r'TRANSACTION_PROCESS_SESSION';
    case Enum$WebhookEventTypeSyncEnum.LIST_STORED_PAYMENT_METHODS:
      return r'LIST_STORED_PAYMENT_METHODS';
    case Enum$WebhookEventTypeSyncEnum.STORED_PAYMENT_METHOD_DELETE_REQUESTED:
      return r'STORED_PAYMENT_METHOD_DELETE_REQUESTED';
    case Enum$WebhookEventTypeSyncEnum
          .PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION:
      return r'PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION';
    case Enum$WebhookEventTypeSyncEnum
          .PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION:
      return r'PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION';
    case Enum$WebhookEventTypeSyncEnum
          .PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION:
      return r'PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION';
    case Enum$WebhookEventTypeSyncEnum.$unknown:
      return r'$unknown';
  }
}

Enum$WebhookEventTypeSyncEnum fromJson$Enum$WebhookEventTypeSyncEnum(
    String value) {
  switch (value) {
    case r'PAYMENT_LIST_GATEWAYS':
      return Enum$WebhookEventTypeSyncEnum.PAYMENT_LIST_GATEWAYS;
    case r'PAYMENT_AUTHORIZE':
      return Enum$WebhookEventTypeSyncEnum.PAYMENT_AUTHORIZE;
    case r'PAYMENT_CAPTURE':
      return Enum$WebhookEventTypeSyncEnum.PAYMENT_CAPTURE;
    case r'PAYMENT_REFUND':
      return Enum$WebhookEventTypeSyncEnum.PAYMENT_REFUND;
    case r'PAYMENT_VOID':
      return Enum$WebhookEventTypeSyncEnum.PAYMENT_VOID;
    case r'PAYMENT_CONFIRM':
      return Enum$WebhookEventTypeSyncEnum.PAYMENT_CONFIRM;
    case r'PAYMENT_PROCESS':
      return Enum$WebhookEventTypeSyncEnum.PAYMENT_PROCESS;
    case r'CHECKOUT_CALCULATE_TAXES':
      return Enum$WebhookEventTypeSyncEnum.CHECKOUT_CALCULATE_TAXES;
    case r'ORDER_CALCULATE_TAXES':
      return Enum$WebhookEventTypeSyncEnum.ORDER_CALCULATE_TAXES;
    case r'TRANSACTION_CHARGE_REQUESTED':
      return Enum$WebhookEventTypeSyncEnum.TRANSACTION_CHARGE_REQUESTED;
    case r'TRANSACTION_REFUND_REQUESTED':
      return Enum$WebhookEventTypeSyncEnum.TRANSACTION_REFUND_REQUESTED;
    case r'TRANSACTION_CANCELATION_REQUESTED':
      return Enum$WebhookEventTypeSyncEnum.TRANSACTION_CANCELATION_REQUESTED;
    case r'SHIPPING_LIST_METHODS_FOR_CHECKOUT':
      return Enum$WebhookEventTypeSyncEnum.SHIPPING_LIST_METHODS_FOR_CHECKOUT;
    case r'CHECKOUT_FILTER_SHIPPING_METHODS':
      return Enum$WebhookEventTypeSyncEnum.CHECKOUT_FILTER_SHIPPING_METHODS;
    case r'ORDER_FILTER_SHIPPING_METHODS':
      return Enum$WebhookEventTypeSyncEnum.ORDER_FILTER_SHIPPING_METHODS;
    case r'PAYMENT_GATEWAY_INITIALIZE_SESSION':
      return Enum$WebhookEventTypeSyncEnum.PAYMENT_GATEWAY_INITIALIZE_SESSION;
    case r'TRANSACTION_INITIALIZE_SESSION':
      return Enum$WebhookEventTypeSyncEnum.TRANSACTION_INITIALIZE_SESSION;
    case r'TRANSACTION_PROCESS_SESSION':
      return Enum$WebhookEventTypeSyncEnum.TRANSACTION_PROCESS_SESSION;
    case r'LIST_STORED_PAYMENT_METHODS':
      return Enum$WebhookEventTypeSyncEnum.LIST_STORED_PAYMENT_METHODS;
    case r'STORED_PAYMENT_METHOD_DELETE_REQUESTED':
      return Enum$WebhookEventTypeSyncEnum
          .STORED_PAYMENT_METHOD_DELETE_REQUESTED;
    case r'PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION':
      return Enum$WebhookEventTypeSyncEnum
          .PAYMENT_GATEWAY_INITIALIZE_TOKENIZATION_SESSION;
    case r'PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION':
      return Enum$WebhookEventTypeSyncEnum
          .PAYMENT_METHOD_INITIALIZE_TOKENIZATION_SESSION;
    case r'PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION':
      return Enum$WebhookEventTypeSyncEnum
          .PAYMENT_METHOD_PROCESS_TOKENIZATION_SESSION;
    default:
      return Enum$WebhookEventTypeSyncEnum.$unknown;
  }
}

enum Enum$WebhookSampleEventTypeEnum {
  ACCOUNT_CONFIRMATION_REQUESTED,
  ACCOUNT_CHANGE_EMAIL_REQUESTED,
  ACCOUNT_EMAIL_CHANGED,
  ACCOUNT_SET_PASSWORD_REQUESTED,
  ACCOUNT_CONFIRMED,
  ACCOUNT_DELETE_REQUESTED,
  ACCOUNT_DELETED,
  ADDRESS_CREATED,
  ADDRESS_UPDATED,
  ADDRESS_DELETED,
  APP_INSTALLED,
  APP_UPDATED,
  APP_DELETED,
  APP_STATUS_CHANGED,
  ATTRIBUTE_CREATED,
  ATTRIBUTE_UPDATED,
  ATTRIBUTE_DELETED,
  ATTRIBUTE_VALUE_CREATED,
  ATTRIBUTE_VALUE_UPDATED,
  ATTRIBUTE_VALUE_DELETED,
  CATEGORY_CREATED,
  CATEGORY_UPDATED,
  CATEGORY_DELETED,
  CHANNEL_CREATED,
  CHANNEL_UPDATED,
  CHANNEL_DELETED,
  CHANNEL_STATUS_CHANGED,
  CHANNEL_METADATA_UPDATED,
  GIFT_CARD_CREATED,
  GIFT_CARD_UPDATED,
  GIFT_CARD_DELETED,
  GIFT_CARD_SENT,
  GIFT_CARD_STATUS_CHANGED,
  GIFT_CARD_METADATA_UPDATED,
  GIFT_CARD_EXPORT_COMPLETED,
  MENU_CREATED,
  MENU_UPDATED,
  MENU_DELETED,
  MENU_ITEM_CREATED,
  MENU_ITEM_UPDATED,
  MENU_ITEM_DELETED,
  ORDER_CREATED,
  ORDER_CONFIRMED,
  ORDER_PAID,
  ORDER_FULLY_PAID,
  ORDER_REFUNDED,
  ORDER_FULLY_REFUNDED,
  ORDER_UPDATED,
  ORDER_CANCELLED,
  ORDER_EXPIRED,
  ORDER_FULFILLED,
  ORDER_METADATA_UPDATED,
  ORDER_BULK_CREATED,
  FULFILLMENT_CREATED,
  FULFILLMENT_CANCELED,
  FULFILLMENT_APPROVED,
  FULFILLMENT_METADATA_UPDATED,
  FULFILLMENT_TRACKING_NUMBER_UPDATED,
  DRAFT_ORDER_CREATED,
  DRAFT_ORDER_UPDATED,
  DRAFT_ORDER_DELETED,
  SALE_CREATED,
  SALE_UPDATED,
  SALE_DELETED,
  SALE_TOGGLE,
  PROMOTION_CREATED,
  PROMOTION_UPDATED,
  PROMOTION_DELETED,
  PROMOTION_STARTED,
  PROMOTION_ENDED,
  PROMOTION_RULE_CREATED,
  PROMOTION_RULE_UPDATED,
  PROMOTION_RULE_DELETED,
  INVOICE_REQUESTED,
  INVOICE_DELETED,
  INVOICE_SENT,
  CUSTOMER_CREATED,
  CUSTOMER_UPDATED,
  CUSTOMER_DELETED,
  CUSTOMER_METADATA_UPDATED,
  COLLECTION_CREATED,
  COLLECTION_UPDATED,
  COLLECTION_DELETED,
  COLLECTION_METADATA_UPDATED,
  PRODUCT_CREATED,
  PRODUCT_UPDATED,
  PRODUCT_DELETED,
  PRODUCT_METADATA_UPDATED,
  PRODUCT_EXPORT_COMPLETED,
  PRODUCT_MEDIA_CREATED,
  PRODUCT_MEDIA_UPDATED,
  PRODUCT_MEDIA_DELETED,
  PRODUCT_VARIANT_CREATED,
  PRODUCT_VARIANT_UPDATED,
  PRODUCT_VARIANT_DELETED,
  PRODUCT_VARIANT_METADATA_UPDATED,
  PRODUCT_VARIANT_OUT_OF_STOCK,
  PRODUCT_VARIANT_BACK_IN_STOCK,
  PRODUCT_VARIANT_STOCK_UPDATED,
  CHECKOUT_CREATED,
  CHECKOUT_UPDATED,
  CHECKOUT_FULLY_PAID,
  CHECKOUT_METADATA_UPDATED,
  NOTIFY_USER,
  PAGE_CREATED,
  PAGE_UPDATED,
  PAGE_DELETED,
  PAGE_TYPE_CREATED,
  PAGE_TYPE_UPDATED,
  PAGE_TYPE_DELETED,
  PERMISSION_GROUP_CREATED,
  PERMISSION_GROUP_UPDATED,
  PERMISSION_GROUP_DELETED,
  SHIPPING_PRICE_CREATED,
  SHIPPING_PRICE_UPDATED,
  SHIPPING_PRICE_DELETED,
  SHIPPING_ZONE_CREATED,
  SHIPPING_ZONE_UPDATED,
  SHIPPING_ZONE_DELETED,
  SHIPPING_ZONE_METADATA_UPDATED,
  STAFF_CREATED,
  STAFF_UPDATED,
  STAFF_DELETED,
  STAFF_SET_PASSWORD_REQUESTED,
  TRANSACTION_ITEM_METADATA_UPDATED,
  TRANSLATION_CREATED,
  TRANSLATION_UPDATED,
  WAREHOUSE_CREATED,
  WAREHOUSE_UPDATED,
  WAREHOUSE_DELETED,
  WAREHOUSE_METADATA_UPDATED,
  VOUCHER_CREATED,
  VOUCHER_UPDATED,
  VOUCHER_DELETED,
  VOUCHER_CODES_CREATED,
  VOUCHER_CODES_DELETED,
  VOUCHER_METADATA_UPDATED,
  VOUCHER_CODE_EXPORT_COMPLETED,
  OBSERVABILITY,
  THUMBNAIL_CREATED,
  SHOP_METADATA_UPDATED,
  $unknown;

  factory Enum$WebhookSampleEventTypeEnum.fromJson(String value) =>
      fromJson$Enum$WebhookSampleEventTypeEnum(value);

  String toJson() => toJson$Enum$WebhookSampleEventTypeEnum(this);
}

String toJson$Enum$WebhookSampleEventTypeEnum(
    Enum$WebhookSampleEventTypeEnum e) {
  switch (e) {
    case Enum$WebhookSampleEventTypeEnum.ACCOUNT_CONFIRMATION_REQUESTED:
      return r'ACCOUNT_CONFIRMATION_REQUESTED';
    case Enum$WebhookSampleEventTypeEnum.ACCOUNT_CHANGE_EMAIL_REQUESTED:
      return r'ACCOUNT_CHANGE_EMAIL_REQUESTED';
    case Enum$WebhookSampleEventTypeEnum.ACCOUNT_EMAIL_CHANGED:
      return r'ACCOUNT_EMAIL_CHANGED';
    case Enum$WebhookSampleEventTypeEnum.ACCOUNT_SET_PASSWORD_REQUESTED:
      return r'ACCOUNT_SET_PASSWORD_REQUESTED';
    case Enum$WebhookSampleEventTypeEnum.ACCOUNT_CONFIRMED:
      return r'ACCOUNT_CONFIRMED';
    case Enum$WebhookSampleEventTypeEnum.ACCOUNT_DELETE_REQUESTED:
      return r'ACCOUNT_DELETE_REQUESTED';
    case Enum$WebhookSampleEventTypeEnum.ACCOUNT_DELETED:
      return r'ACCOUNT_DELETED';
    case Enum$WebhookSampleEventTypeEnum.ADDRESS_CREATED:
      return r'ADDRESS_CREATED';
    case Enum$WebhookSampleEventTypeEnum.ADDRESS_UPDATED:
      return r'ADDRESS_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.ADDRESS_DELETED:
      return r'ADDRESS_DELETED';
    case Enum$WebhookSampleEventTypeEnum.APP_INSTALLED:
      return r'APP_INSTALLED';
    case Enum$WebhookSampleEventTypeEnum.APP_UPDATED:
      return r'APP_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.APP_DELETED:
      return r'APP_DELETED';
    case Enum$WebhookSampleEventTypeEnum.APP_STATUS_CHANGED:
      return r'APP_STATUS_CHANGED';
    case Enum$WebhookSampleEventTypeEnum.ATTRIBUTE_CREATED:
      return r'ATTRIBUTE_CREATED';
    case Enum$WebhookSampleEventTypeEnum.ATTRIBUTE_UPDATED:
      return r'ATTRIBUTE_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.ATTRIBUTE_DELETED:
      return r'ATTRIBUTE_DELETED';
    case Enum$WebhookSampleEventTypeEnum.ATTRIBUTE_VALUE_CREATED:
      return r'ATTRIBUTE_VALUE_CREATED';
    case Enum$WebhookSampleEventTypeEnum.ATTRIBUTE_VALUE_UPDATED:
      return r'ATTRIBUTE_VALUE_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.ATTRIBUTE_VALUE_DELETED:
      return r'ATTRIBUTE_VALUE_DELETED';
    case Enum$WebhookSampleEventTypeEnum.CATEGORY_CREATED:
      return r'CATEGORY_CREATED';
    case Enum$WebhookSampleEventTypeEnum.CATEGORY_UPDATED:
      return r'CATEGORY_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.CATEGORY_DELETED:
      return r'CATEGORY_DELETED';
    case Enum$WebhookSampleEventTypeEnum.CHANNEL_CREATED:
      return r'CHANNEL_CREATED';
    case Enum$WebhookSampleEventTypeEnum.CHANNEL_UPDATED:
      return r'CHANNEL_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.CHANNEL_DELETED:
      return r'CHANNEL_DELETED';
    case Enum$WebhookSampleEventTypeEnum.CHANNEL_STATUS_CHANGED:
      return r'CHANNEL_STATUS_CHANGED';
    case Enum$WebhookSampleEventTypeEnum.CHANNEL_METADATA_UPDATED:
      return r'CHANNEL_METADATA_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.GIFT_CARD_CREATED:
      return r'GIFT_CARD_CREATED';
    case Enum$WebhookSampleEventTypeEnum.GIFT_CARD_UPDATED:
      return r'GIFT_CARD_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.GIFT_CARD_DELETED:
      return r'GIFT_CARD_DELETED';
    case Enum$WebhookSampleEventTypeEnum.GIFT_CARD_SENT:
      return r'GIFT_CARD_SENT';
    case Enum$WebhookSampleEventTypeEnum.GIFT_CARD_STATUS_CHANGED:
      return r'GIFT_CARD_STATUS_CHANGED';
    case Enum$WebhookSampleEventTypeEnum.GIFT_CARD_METADATA_UPDATED:
      return r'GIFT_CARD_METADATA_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.GIFT_CARD_EXPORT_COMPLETED:
      return r'GIFT_CARD_EXPORT_COMPLETED';
    case Enum$WebhookSampleEventTypeEnum.MENU_CREATED:
      return r'MENU_CREATED';
    case Enum$WebhookSampleEventTypeEnum.MENU_UPDATED:
      return r'MENU_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.MENU_DELETED:
      return r'MENU_DELETED';
    case Enum$WebhookSampleEventTypeEnum.MENU_ITEM_CREATED:
      return r'MENU_ITEM_CREATED';
    case Enum$WebhookSampleEventTypeEnum.MENU_ITEM_UPDATED:
      return r'MENU_ITEM_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.MENU_ITEM_DELETED:
      return r'MENU_ITEM_DELETED';
    case Enum$WebhookSampleEventTypeEnum.ORDER_CREATED:
      return r'ORDER_CREATED';
    case Enum$WebhookSampleEventTypeEnum.ORDER_CONFIRMED:
      return r'ORDER_CONFIRMED';
    case Enum$WebhookSampleEventTypeEnum.ORDER_PAID:
      return r'ORDER_PAID';
    case Enum$WebhookSampleEventTypeEnum.ORDER_FULLY_PAID:
      return r'ORDER_FULLY_PAID';
    case Enum$WebhookSampleEventTypeEnum.ORDER_REFUNDED:
      return r'ORDER_REFUNDED';
    case Enum$WebhookSampleEventTypeEnum.ORDER_FULLY_REFUNDED:
      return r'ORDER_FULLY_REFUNDED';
    case Enum$WebhookSampleEventTypeEnum.ORDER_UPDATED:
      return r'ORDER_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.ORDER_CANCELLED:
      return r'ORDER_CANCELLED';
    case Enum$WebhookSampleEventTypeEnum.ORDER_EXPIRED:
      return r'ORDER_EXPIRED';
    case Enum$WebhookSampleEventTypeEnum.ORDER_FULFILLED:
      return r'ORDER_FULFILLED';
    case Enum$WebhookSampleEventTypeEnum.ORDER_METADATA_UPDATED:
      return r'ORDER_METADATA_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.ORDER_BULK_CREATED:
      return r'ORDER_BULK_CREATED';
    case Enum$WebhookSampleEventTypeEnum.FULFILLMENT_CREATED:
      return r'FULFILLMENT_CREATED';
    case Enum$WebhookSampleEventTypeEnum.FULFILLMENT_CANCELED:
      return r'FULFILLMENT_CANCELED';
    case Enum$WebhookSampleEventTypeEnum.FULFILLMENT_APPROVED:
      return r'FULFILLMENT_APPROVED';
    case Enum$WebhookSampleEventTypeEnum.FULFILLMENT_METADATA_UPDATED:
      return r'FULFILLMENT_METADATA_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.FULFILLMENT_TRACKING_NUMBER_UPDATED:
      return r'FULFILLMENT_TRACKING_NUMBER_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.DRAFT_ORDER_CREATED:
      return r'DRAFT_ORDER_CREATED';
    case Enum$WebhookSampleEventTypeEnum.DRAFT_ORDER_UPDATED:
      return r'DRAFT_ORDER_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.DRAFT_ORDER_DELETED:
      return r'DRAFT_ORDER_DELETED';
    case Enum$WebhookSampleEventTypeEnum.SALE_CREATED:
      return r'SALE_CREATED';
    case Enum$WebhookSampleEventTypeEnum.SALE_UPDATED:
      return r'SALE_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.SALE_DELETED:
      return r'SALE_DELETED';
    case Enum$WebhookSampleEventTypeEnum.SALE_TOGGLE:
      return r'SALE_TOGGLE';
    case Enum$WebhookSampleEventTypeEnum.PROMOTION_CREATED:
      return r'PROMOTION_CREATED';
    case Enum$WebhookSampleEventTypeEnum.PROMOTION_UPDATED:
      return r'PROMOTION_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.PROMOTION_DELETED:
      return r'PROMOTION_DELETED';
    case Enum$WebhookSampleEventTypeEnum.PROMOTION_STARTED:
      return r'PROMOTION_STARTED';
    case Enum$WebhookSampleEventTypeEnum.PROMOTION_ENDED:
      return r'PROMOTION_ENDED';
    case Enum$WebhookSampleEventTypeEnum.PROMOTION_RULE_CREATED:
      return r'PROMOTION_RULE_CREATED';
    case Enum$WebhookSampleEventTypeEnum.PROMOTION_RULE_UPDATED:
      return r'PROMOTION_RULE_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.PROMOTION_RULE_DELETED:
      return r'PROMOTION_RULE_DELETED';
    case Enum$WebhookSampleEventTypeEnum.INVOICE_REQUESTED:
      return r'INVOICE_REQUESTED';
    case Enum$WebhookSampleEventTypeEnum.INVOICE_DELETED:
      return r'INVOICE_DELETED';
    case Enum$WebhookSampleEventTypeEnum.INVOICE_SENT:
      return r'INVOICE_SENT';
    case Enum$WebhookSampleEventTypeEnum.CUSTOMER_CREATED:
      return r'CUSTOMER_CREATED';
    case Enum$WebhookSampleEventTypeEnum.CUSTOMER_UPDATED:
      return r'CUSTOMER_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.CUSTOMER_DELETED:
      return r'CUSTOMER_DELETED';
    case Enum$WebhookSampleEventTypeEnum.CUSTOMER_METADATA_UPDATED:
      return r'CUSTOMER_METADATA_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.COLLECTION_CREATED:
      return r'COLLECTION_CREATED';
    case Enum$WebhookSampleEventTypeEnum.COLLECTION_UPDATED:
      return r'COLLECTION_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.COLLECTION_DELETED:
      return r'COLLECTION_DELETED';
    case Enum$WebhookSampleEventTypeEnum.COLLECTION_METADATA_UPDATED:
      return r'COLLECTION_METADATA_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.PRODUCT_CREATED:
      return r'PRODUCT_CREATED';
    case Enum$WebhookSampleEventTypeEnum.PRODUCT_UPDATED:
      return r'PRODUCT_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.PRODUCT_DELETED:
      return r'PRODUCT_DELETED';
    case Enum$WebhookSampleEventTypeEnum.PRODUCT_METADATA_UPDATED:
      return r'PRODUCT_METADATA_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.PRODUCT_EXPORT_COMPLETED:
      return r'PRODUCT_EXPORT_COMPLETED';
    case Enum$WebhookSampleEventTypeEnum.PRODUCT_MEDIA_CREATED:
      return r'PRODUCT_MEDIA_CREATED';
    case Enum$WebhookSampleEventTypeEnum.PRODUCT_MEDIA_UPDATED:
      return r'PRODUCT_MEDIA_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.PRODUCT_MEDIA_DELETED:
      return r'PRODUCT_MEDIA_DELETED';
    case Enum$WebhookSampleEventTypeEnum.PRODUCT_VARIANT_CREATED:
      return r'PRODUCT_VARIANT_CREATED';
    case Enum$WebhookSampleEventTypeEnum.PRODUCT_VARIANT_UPDATED:
      return r'PRODUCT_VARIANT_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.PRODUCT_VARIANT_DELETED:
      return r'PRODUCT_VARIANT_DELETED';
    case Enum$WebhookSampleEventTypeEnum.PRODUCT_VARIANT_METADATA_UPDATED:
      return r'PRODUCT_VARIANT_METADATA_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.PRODUCT_VARIANT_OUT_OF_STOCK:
      return r'PRODUCT_VARIANT_OUT_OF_STOCK';
    case Enum$WebhookSampleEventTypeEnum.PRODUCT_VARIANT_BACK_IN_STOCK:
      return r'PRODUCT_VARIANT_BACK_IN_STOCK';
    case Enum$WebhookSampleEventTypeEnum.PRODUCT_VARIANT_STOCK_UPDATED:
      return r'PRODUCT_VARIANT_STOCK_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.CHECKOUT_CREATED:
      return r'CHECKOUT_CREATED';
    case Enum$WebhookSampleEventTypeEnum.CHECKOUT_UPDATED:
      return r'CHECKOUT_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.CHECKOUT_FULLY_PAID:
      return r'CHECKOUT_FULLY_PAID';
    case Enum$WebhookSampleEventTypeEnum.CHECKOUT_METADATA_UPDATED:
      return r'CHECKOUT_METADATA_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.NOTIFY_USER:
      return r'NOTIFY_USER';
    case Enum$WebhookSampleEventTypeEnum.PAGE_CREATED:
      return r'PAGE_CREATED';
    case Enum$WebhookSampleEventTypeEnum.PAGE_UPDATED:
      return r'PAGE_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.PAGE_DELETED:
      return r'PAGE_DELETED';
    case Enum$WebhookSampleEventTypeEnum.PAGE_TYPE_CREATED:
      return r'PAGE_TYPE_CREATED';
    case Enum$WebhookSampleEventTypeEnum.PAGE_TYPE_UPDATED:
      return r'PAGE_TYPE_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.PAGE_TYPE_DELETED:
      return r'PAGE_TYPE_DELETED';
    case Enum$WebhookSampleEventTypeEnum.PERMISSION_GROUP_CREATED:
      return r'PERMISSION_GROUP_CREATED';
    case Enum$WebhookSampleEventTypeEnum.PERMISSION_GROUP_UPDATED:
      return r'PERMISSION_GROUP_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.PERMISSION_GROUP_DELETED:
      return r'PERMISSION_GROUP_DELETED';
    case Enum$WebhookSampleEventTypeEnum.SHIPPING_PRICE_CREATED:
      return r'SHIPPING_PRICE_CREATED';
    case Enum$WebhookSampleEventTypeEnum.SHIPPING_PRICE_UPDATED:
      return r'SHIPPING_PRICE_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.SHIPPING_PRICE_DELETED:
      return r'SHIPPING_PRICE_DELETED';
    case Enum$WebhookSampleEventTypeEnum.SHIPPING_ZONE_CREATED:
      return r'SHIPPING_ZONE_CREATED';
    case Enum$WebhookSampleEventTypeEnum.SHIPPING_ZONE_UPDATED:
      return r'SHIPPING_ZONE_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.SHIPPING_ZONE_DELETED:
      return r'SHIPPING_ZONE_DELETED';
    case Enum$WebhookSampleEventTypeEnum.SHIPPING_ZONE_METADATA_UPDATED:
      return r'SHIPPING_ZONE_METADATA_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.STAFF_CREATED:
      return r'STAFF_CREATED';
    case Enum$WebhookSampleEventTypeEnum.STAFF_UPDATED:
      return r'STAFF_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.STAFF_DELETED:
      return r'STAFF_DELETED';
    case Enum$WebhookSampleEventTypeEnum.STAFF_SET_PASSWORD_REQUESTED:
      return r'STAFF_SET_PASSWORD_REQUESTED';
    case Enum$WebhookSampleEventTypeEnum.TRANSACTION_ITEM_METADATA_UPDATED:
      return r'TRANSACTION_ITEM_METADATA_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.TRANSLATION_CREATED:
      return r'TRANSLATION_CREATED';
    case Enum$WebhookSampleEventTypeEnum.TRANSLATION_UPDATED:
      return r'TRANSLATION_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.WAREHOUSE_CREATED:
      return r'WAREHOUSE_CREATED';
    case Enum$WebhookSampleEventTypeEnum.WAREHOUSE_UPDATED:
      return r'WAREHOUSE_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.WAREHOUSE_DELETED:
      return r'WAREHOUSE_DELETED';
    case Enum$WebhookSampleEventTypeEnum.WAREHOUSE_METADATA_UPDATED:
      return r'WAREHOUSE_METADATA_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.VOUCHER_CREATED:
      return r'VOUCHER_CREATED';
    case Enum$WebhookSampleEventTypeEnum.VOUCHER_UPDATED:
      return r'VOUCHER_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.VOUCHER_DELETED:
      return r'VOUCHER_DELETED';
    case Enum$WebhookSampleEventTypeEnum.VOUCHER_CODES_CREATED:
      return r'VOUCHER_CODES_CREATED';
    case Enum$WebhookSampleEventTypeEnum.VOUCHER_CODES_DELETED:
      return r'VOUCHER_CODES_DELETED';
    case Enum$WebhookSampleEventTypeEnum.VOUCHER_METADATA_UPDATED:
      return r'VOUCHER_METADATA_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.VOUCHER_CODE_EXPORT_COMPLETED:
      return r'VOUCHER_CODE_EXPORT_COMPLETED';
    case Enum$WebhookSampleEventTypeEnum.OBSERVABILITY:
      return r'OBSERVABILITY';
    case Enum$WebhookSampleEventTypeEnum.THUMBNAIL_CREATED:
      return r'THUMBNAIL_CREATED';
    case Enum$WebhookSampleEventTypeEnum.SHOP_METADATA_UPDATED:
      return r'SHOP_METADATA_UPDATED';
    case Enum$WebhookSampleEventTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$WebhookSampleEventTypeEnum fromJson$Enum$WebhookSampleEventTypeEnum(
    String value) {
  switch (value) {
    case r'ACCOUNT_CONFIRMATION_REQUESTED':
      return Enum$WebhookSampleEventTypeEnum.ACCOUNT_CONFIRMATION_REQUESTED;
    case r'ACCOUNT_CHANGE_EMAIL_REQUESTED':
      return Enum$WebhookSampleEventTypeEnum.ACCOUNT_CHANGE_EMAIL_REQUESTED;
    case r'ACCOUNT_EMAIL_CHANGED':
      return Enum$WebhookSampleEventTypeEnum.ACCOUNT_EMAIL_CHANGED;
    case r'ACCOUNT_SET_PASSWORD_REQUESTED':
      return Enum$WebhookSampleEventTypeEnum.ACCOUNT_SET_PASSWORD_REQUESTED;
    case r'ACCOUNT_CONFIRMED':
      return Enum$WebhookSampleEventTypeEnum.ACCOUNT_CONFIRMED;
    case r'ACCOUNT_DELETE_REQUESTED':
      return Enum$WebhookSampleEventTypeEnum.ACCOUNT_DELETE_REQUESTED;
    case r'ACCOUNT_DELETED':
      return Enum$WebhookSampleEventTypeEnum.ACCOUNT_DELETED;
    case r'ADDRESS_CREATED':
      return Enum$WebhookSampleEventTypeEnum.ADDRESS_CREATED;
    case r'ADDRESS_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.ADDRESS_UPDATED;
    case r'ADDRESS_DELETED':
      return Enum$WebhookSampleEventTypeEnum.ADDRESS_DELETED;
    case r'APP_INSTALLED':
      return Enum$WebhookSampleEventTypeEnum.APP_INSTALLED;
    case r'APP_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.APP_UPDATED;
    case r'APP_DELETED':
      return Enum$WebhookSampleEventTypeEnum.APP_DELETED;
    case r'APP_STATUS_CHANGED':
      return Enum$WebhookSampleEventTypeEnum.APP_STATUS_CHANGED;
    case r'ATTRIBUTE_CREATED':
      return Enum$WebhookSampleEventTypeEnum.ATTRIBUTE_CREATED;
    case r'ATTRIBUTE_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.ATTRIBUTE_UPDATED;
    case r'ATTRIBUTE_DELETED':
      return Enum$WebhookSampleEventTypeEnum.ATTRIBUTE_DELETED;
    case r'ATTRIBUTE_VALUE_CREATED':
      return Enum$WebhookSampleEventTypeEnum.ATTRIBUTE_VALUE_CREATED;
    case r'ATTRIBUTE_VALUE_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.ATTRIBUTE_VALUE_UPDATED;
    case r'ATTRIBUTE_VALUE_DELETED':
      return Enum$WebhookSampleEventTypeEnum.ATTRIBUTE_VALUE_DELETED;
    case r'CATEGORY_CREATED':
      return Enum$WebhookSampleEventTypeEnum.CATEGORY_CREATED;
    case r'CATEGORY_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.CATEGORY_UPDATED;
    case r'CATEGORY_DELETED':
      return Enum$WebhookSampleEventTypeEnum.CATEGORY_DELETED;
    case r'CHANNEL_CREATED':
      return Enum$WebhookSampleEventTypeEnum.CHANNEL_CREATED;
    case r'CHANNEL_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.CHANNEL_UPDATED;
    case r'CHANNEL_DELETED':
      return Enum$WebhookSampleEventTypeEnum.CHANNEL_DELETED;
    case r'CHANNEL_STATUS_CHANGED':
      return Enum$WebhookSampleEventTypeEnum.CHANNEL_STATUS_CHANGED;
    case r'CHANNEL_METADATA_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.CHANNEL_METADATA_UPDATED;
    case r'GIFT_CARD_CREATED':
      return Enum$WebhookSampleEventTypeEnum.GIFT_CARD_CREATED;
    case r'GIFT_CARD_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.GIFT_CARD_UPDATED;
    case r'GIFT_CARD_DELETED':
      return Enum$WebhookSampleEventTypeEnum.GIFT_CARD_DELETED;
    case r'GIFT_CARD_SENT':
      return Enum$WebhookSampleEventTypeEnum.GIFT_CARD_SENT;
    case r'GIFT_CARD_STATUS_CHANGED':
      return Enum$WebhookSampleEventTypeEnum.GIFT_CARD_STATUS_CHANGED;
    case r'GIFT_CARD_METADATA_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.GIFT_CARD_METADATA_UPDATED;
    case r'GIFT_CARD_EXPORT_COMPLETED':
      return Enum$WebhookSampleEventTypeEnum.GIFT_CARD_EXPORT_COMPLETED;
    case r'MENU_CREATED':
      return Enum$WebhookSampleEventTypeEnum.MENU_CREATED;
    case r'MENU_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.MENU_UPDATED;
    case r'MENU_DELETED':
      return Enum$WebhookSampleEventTypeEnum.MENU_DELETED;
    case r'MENU_ITEM_CREATED':
      return Enum$WebhookSampleEventTypeEnum.MENU_ITEM_CREATED;
    case r'MENU_ITEM_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.MENU_ITEM_UPDATED;
    case r'MENU_ITEM_DELETED':
      return Enum$WebhookSampleEventTypeEnum.MENU_ITEM_DELETED;
    case r'ORDER_CREATED':
      return Enum$WebhookSampleEventTypeEnum.ORDER_CREATED;
    case r'ORDER_CONFIRMED':
      return Enum$WebhookSampleEventTypeEnum.ORDER_CONFIRMED;
    case r'ORDER_PAID':
      return Enum$WebhookSampleEventTypeEnum.ORDER_PAID;
    case r'ORDER_FULLY_PAID':
      return Enum$WebhookSampleEventTypeEnum.ORDER_FULLY_PAID;
    case r'ORDER_REFUNDED':
      return Enum$WebhookSampleEventTypeEnum.ORDER_REFUNDED;
    case r'ORDER_FULLY_REFUNDED':
      return Enum$WebhookSampleEventTypeEnum.ORDER_FULLY_REFUNDED;
    case r'ORDER_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.ORDER_UPDATED;
    case r'ORDER_CANCELLED':
      return Enum$WebhookSampleEventTypeEnum.ORDER_CANCELLED;
    case r'ORDER_EXPIRED':
      return Enum$WebhookSampleEventTypeEnum.ORDER_EXPIRED;
    case r'ORDER_FULFILLED':
      return Enum$WebhookSampleEventTypeEnum.ORDER_FULFILLED;
    case r'ORDER_METADATA_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.ORDER_METADATA_UPDATED;
    case r'ORDER_BULK_CREATED':
      return Enum$WebhookSampleEventTypeEnum.ORDER_BULK_CREATED;
    case r'FULFILLMENT_CREATED':
      return Enum$WebhookSampleEventTypeEnum.FULFILLMENT_CREATED;
    case r'FULFILLMENT_CANCELED':
      return Enum$WebhookSampleEventTypeEnum.FULFILLMENT_CANCELED;
    case r'FULFILLMENT_APPROVED':
      return Enum$WebhookSampleEventTypeEnum.FULFILLMENT_APPROVED;
    case r'FULFILLMENT_METADATA_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.FULFILLMENT_METADATA_UPDATED;
    case r'FULFILLMENT_TRACKING_NUMBER_UPDATED':
      return Enum$WebhookSampleEventTypeEnum
          .FULFILLMENT_TRACKING_NUMBER_UPDATED;
    case r'DRAFT_ORDER_CREATED':
      return Enum$WebhookSampleEventTypeEnum.DRAFT_ORDER_CREATED;
    case r'DRAFT_ORDER_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.DRAFT_ORDER_UPDATED;
    case r'DRAFT_ORDER_DELETED':
      return Enum$WebhookSampleEventTypeEnum.DRAFT_ORDER_DELETED;
    case r'SALE_CREATED':
      return Enum$WebhookSampleEventTypeEnum.SALE_CREATED;
    case r'SALE_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.SALE_UPDATED;
    case r'SALE_DELETED':
      return Enum$WebhookSampleEventTypeEnum.SALE_DELETED;
    case r'SALE_TOGGLE':
      return Enum$WebhookSampleEventTypeEnum.SALE_TOGGLE;
    case r'PROMOTION_CREATED':
      return Enum$WebhookSampleEventTypeEnum.PROMOTION_CREATED;
    case r'PROMOTION_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.PROMOTION_UPDATED;
    case r'PROMOTION_DELETED':
      return Enum$WebhookSampleEventTypeEnum.PROMOTION_DELETED;
    case r'PROMOTION_STARTED':
      return Enum$WebhookSampleEventTypeEnum.PROMOTION_STARTED;
    case r'PROMOTION_ENDED':
      return Enum$WebhookSampleEventTypeEnum.PROMOTION_ENDED;
    case r'PROMOTION_RULE_CREATED':
      return Enum$WebhookSampleEventTypeEnum.PROMOTION_RULE_CREATED;
    case r'PROMOTION_RULE_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.PROMOTION_RULE_UPDATED;
    case r'PROMOTION_RULE_DELETED':
      return Enum$WebhookSampleEventTypeEnum.PROMOTION_RULE_DELETED;
    case r'INVOICE_REQUESTED':
      return Enum$WebhookSampleEventTypeEnum.INVOICE_REQUESTED;
    case r'INVOICE_DELETED':
      return Enum$WebhookSampleEventTypeEnum.INVOICE_DELETED;
    case r'INVOICE_SENT':
      return Enum$WebhookSampleEventTypeEnum.INVOICE_SENT;
    case r'CUSTOMER_CREATED':
      return Enum$WebhookSampleEventTypeEnum.CUSTOMER_CREATED;
    case r'CUSTOMER_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.CUSTOMER_UPDATED;
    case r'CUSTOMER_DELETED':
      return Enum$WebhookSampleEventTypeEnum.CUSTOMER_DELETED;
    case r'CUSTOMER_METADATA_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.CUSTOMER_METADATA_UPDATED;
    case r'COLLECTION_CREATED':
      return Enum$WebhookSampleEventTypeEnum.COLLECTION_CREATED;
    case r'COLLECTION_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.COLLECTION_UPDATED;
    case r'COLLECTION_DELETED':
      return Enum$WebhookSampleEventTypeEnum.COLLECTION_DELETED;
    case r'COLLECTION_METADATA_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.COLLECTION_METADATA_UPDATED;
    case r'PRODUCT_CREATED':
      return Enum$WebhookSampleEventTypeEnum.PRODUCT_CREATED;
    case r'PRODUCT_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.PRODUCT_UPDATED;
    case r'PRODUCT_DELETED':
      return Enum$WebhookSampleEventTypeEnum.PRODUCT_DELETED;
    case r'PRODUCT_METADATA_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.PRODUCT_METADATA_UPDATED;
    case r'PRODUCT_EXPORT_COMPLETED':
      return Enum$WebhookSampleEventTypeEnum.PRODUCT_EXPORT_COMPLETED;
    case r'PRODUCT_MEDIA_CREATED':
      return Enum$WebhookSampleEventTypeEnum.PRODUCT_MEDIA_CREATED;
    case r'PRODUCT_MEDIA_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.PRODUCT_MEDIA_UPDATED;
    case r'PRODUCT_MEDIA_DELETED':
      return Enum$WebhookSampleEventTypeEnum.PRODUCT_MEDIA_DELETED;
    case r'PRODUCT_VARIANT_CREATED':
      return Enum$WebhookSampleEventTypeEnum.PRODUCT_VARIANT_CREATED;
    case r'PRODUCT_VARIANT_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.PRODUCT_VARIANT_UPDATED;
    case r'PRODUCT_VARIANT_DELETED':
      return Enum$WebhookSampleEventTypeEnum.PRODUCT_VARIANT_DELETED;
    case r'PRODUCT_VARIANT_METADATA_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.PRODUCT_VARIANT_METADATA_UPDATED;
    case r'PRODUCT_VARIANT_OUT_OF_STOCK':
      return Enum$WebhookSampleEventTypeEnum.PRODUCT_VARIANT_OUT_OF_STOCK;
    case r'PRODUCT_VARIANT_BACK_IN_STOCK':
      return Enum$WebhookSampleEventTypeEnum.PRODUCT_VARIANT_BACK_IN_STOCK;
    case r'PRODUCT_VARIANT_STOCK_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.PRODUCT_VARIANT_STOCK_UPDATED;
    case r'CHECKOUT_CREATED':
      return Enum$WebhookSampleEventTypeEnum.CHECKOUT_CREATED;
    case r'CHECKOUT_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.CHECKOUT_UPDATED;
    case r'CHECKOUT_FULLY_PAID':
      return Enum$WebhookSampleEventTypeEnum.CHECKOUT_FULLY_PAID;
    case r'CHECKOUT_METADATA_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.CHECKOUT_METADATA_UPDATED;
    case r'NOTIFY_USER':
      return Enum$WebhookSampleEventTypeEnum.NOTIFY_USER;
    case r'PAGE_CREATED':
      return Enum$WebhookSampleEventTypeEnum.PAGE_CREATED;
    case r'PAGE_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.PAGE_UPDATED;
    case r'PAGE_DELETED':
      return Enum$WebhookSampleEventTypeEnum.PAGE_DELETED;
    case r'PAGE_TYPE_CREATED':
      return Enum$WebhookSampleEventTypeEnum.PAGE_TYPE_CREATED;
    case r'PAGE_TYPE_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.PAGE_TYPE_UPDATED;
    case r'PAGE_TYPE_DELETED':
      return Enum$WebhookSampleEventTypeEnum.PAGE_TYPE_DELETED;
    case r'PERMISSION_GROUP_CREATED':
      return Enum$WebhookSampleEventTypeEnum.PERMISSION_GROUP_CREATED;
    case r'PERMISSION_GROUP_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.PERMISSION_GROUP_UPDATED;
    case r'PERMISSION_GROUP_DELETED':
      return Enum$WebhookSampleEventTypeEnum.PERMISSION_GROUP_DELETED;
    case r'SHIPPING_PRICE_CREATED':
      return Enum$WebhookSampleEventTypeEnum.SHIPPING_PRICE_CREATED;
    case r'SHIPPING_PRICE_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.SHIPPING_PRICE_UPDATED;
    case r'SHIPPING_PRICE_DELETED':
      return Enum$WebhookSampleEventTypeEnum.SHIPPING_PRICE_DELETED;
    case r'SHIPPING_ZONE_CREATED':
      return Enum$WebhookSampleEventTypeEnum.SHIPPING_ZONE_CREATED;
    case r'SHIPPING_ZONE_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.SHIPPING_ZONE_UPDATED;
    case r'SHIPPING_ZONE_DELETED':
      return Enum$WebhookSampleEventTypeEnum.SHIPPING_ZONE_DELETED;
    case r'SHIPPING_ZONE_METADATA_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.SHIPPING_ZONE_METADATA_UPDATED;
    case r'STAFF_CREATED':
      return Enum$WebhookSampleEventTypeEnum.STAFF_CREATED;
    case r'STAFF_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.STAFF_UPDATED;
    case r'STAFF_DELETED':
      return Enum$WebhookSampleEventTypeEnum.STAFF_DELETED;
    case r'STAFF_SET_PASSWORD_REQUESTED':
      return Enum$WebhookSampleEventTypeEnum.STAFF_SET_PASSWORD_REQUESTED;
    case r'TRANSACTION_ITEM_METADATA_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.TRANSACTION_ITEM_METADATA_UPDATED;
    case r'TRANSLATION_CREATED':
      return Enum$WebhookSampleEventTypeEnum.TRANSLATION_CREATED;
    case r'TRANSLATION_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.TRANSLATION_UPDATED;
    case r'WAREHOUSE_CREATED':
      return Enum$WebhookSampleEventTypeEnum.WAREHOUSE_CREATED;
    case r'WAREHOUSE_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.WAREHOUSE_UPDATED;
    case r'WAREHOUSE_DELETED':
      return Enum$WebhookSampleEventTypeEnum.WAREHOUSE_DELETED;
    case r'WAREHOUSE_METADATA_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.WAREHOUSE_METADATA_UPDATED;
    case r'VOUCHER_CREATED':
      return Enum$WebhookSampleEventTypeEnum.VOUCHER_CREATED;
    case r'VOUCHER_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.VOUCHER_UPDATED;
    case r'VOUCHER_DELETED':
      return Enum$WebhookSampleEventTypeEnum.VOUCHER_DELETED;
    case r'VOUCHER_CODES_CREATED':
      return Enum$WebhookSampleEventTypeEnum.VOUCHER_CODES_CREATED;
    case r'VOUCHER_CODES_DELETED':
      return Enum$WebhookSampleEventTypeEnum.VOUCHER_CODES_DELETED;
    case r'VOUCHER_METADATA_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.VOUCHER_METADATA_UPDATED;
    case r'VOUCHER_CODE_EXPORT_COMPLETED':
      return Enum$WebhookSampleEventTypeEnum.VOUCHER_CODE_EXPORT_COMPLETED;
    case r'OBSERVABILITY':
      return Enum$WebhookSampleEventTypeEnum.OBSERVABILITY;
    case r'THUMBNAIL_CREATED':
      return Enum$WebhookSampleEventTypeEnum.THUMBNAIL_CREATED;
    case r'SHOP_METADATA_UPDATED':
      return Enum$WebhookSampleEventTypeEnum.SHOP_METADATA_UPDATED;
    default:
      return Enum$WebhookSampleEventTypeEnum.$unknown;
  }
}

enum Enum$WebhookTriggerErrorCode {
  GRAPHQL_ERROR,
  NOT_FOUND,
  INVALID_ID,
  MISSING_PERMISSION,
  TYPE_NOT_SUPPORTED,
  SYNTAX,
  MISSING_SUBSCRIPTION,
  UNABLE_TO_PARSE,
  MISSING_QUERY,
  MISSING_EVENT,
  $unknown;

  factory Enum$WebhookTriggerErrorCode.fromJson(String value) =>
      fromJson$Enum$WebhookTriggerErrorCode(value);

  String toJson() => toJson$Enum$WebhookTriggerErrorCode(this);
}

String toJson$Enum$WebhookTriggerErrorCode(Enum$WebhookTriggerErrorCode e) {
  switch (e) {
    case Enum$WebhookTriggerErrorCode.GRAPHQL_ERROR:
      return r'GRAPHQL_ERROR';
    case Enum$WebhookTriggerErrorCode.NOT_FOUND:
      return r'NOT_FOUND';
    case Enum$WebhookTriggerErrorCode.INVALID_ID:
      return r'INVALID_ID';
    case Enum$WebhookTriggerErrorCode.MISSING_PERMISSION:
      return r'MISSING_PERMISSION';
    case Enum$WebhookTriggerErrorCode.TYPE_NOT_SUPPORTED:
      return r'TYPE_NOT_SUPPORTED';
    case Enum$WebhookTriggerErrorCode.SYNTAX:
      return r'SYNTAX';
    case Enum$WebhookTriggerErrorCode.MISSING_SUBSCRIPTION:
      return r'MISSING_SUBSCRIPTION';
    case Enum$WebhookTriggerErrorCode.UNABLE_TO_PARSE:
      return r'UNABLE_TO_PARSE';
    case Enum$WebhookTriggerErrorCode.MISSING_QUERY:
      return r'MISSING_QUERY';
    case Enum$WebhookTriggerErrorCode.MISSING_EVENT:
      return r'MISSING_EVENT';
    case Enum$WebhookTriggerErrorCode.$unknown:
      return r'$unknown';
  }
}

Enum$WebhookTriggerErrorCode fromJson$Enum$WebhookTriggerErrorCode(
    String value) {
  switch (value) {
    case r'GRAPHQL_ERROR':
      return Enum$WebhookTriggerErrorCode.GRAPHQL_ERROR;
    case r'NOT_FOUND':
      return Enum$WebhookTriggerErrorCode.NOT_FOUND;
    case r'INVALID_ID':
      return Enum$WebhookTriggerErrorCode.INVALID_ID;
    case r'MISSING_PERMISSION':
      return Enum$WebhookTriggerErrorCode.MISSING_PERMISSION;
    case r'TYPE_NOT_SUPPORTED':
      return Enum$WebhookTriggerErrorCode.TYPE_NOT_SUPPORTED;
    case r'SYNTAX':
      return Enum$WebhookTriggerErrorCode.SYNTAX;
    case r'MISSING_SUBSCRIPTION':
      return Enum$WebhookTriggerErrorCode.MISSING_SUBSCRIPTION;
    case r'UNABLE_TO_PARSE':
      return Enum$WebhookTriggerErrorCode.UNABLE_TO_PARSE;
    case r'MISSING_QUERY':
      return Enum$WebhookTriggerErrorCode.MISSING_QUERY;
    case r'MISSING_EVENT':
      return Enum$WebhookTriggerErrorCode.MISSING_EVENT;
    default:
      return Enum$WebhookTriggerErrorCode.$unknown;
  }
}

enum Enum$WeightUnitsEnum {
  G,
  LB,
  OZ,
  KG,
  TONNE,
  $unknown;

  factory Enum$WeightUnitsEnum.fromJson(String value) =>
      fromJson$Enum$WeightUnitsEnum(value);

  String toJson() => toJson$Enum$WeightUnitsEnum(this);
}

String toJson$Enum$WeightUnitsEnum(Enum$WeightUnitsEnum e) {
  switch (e) {
    case Enum$WeightUnitsEnum.G:
      return r'G';
    case Enum$WeightUnitsEnum.LB:
      return r'LB';
    case Enum$WeightUnitsEnum.OZ:
      return r'OZ';
    case Enum$WeightUnitsEnum.KG:
      return r'KG';
    case Enum$WeightUnitsEnum.TONNE:
      return r'TONNE';
    case Enum$WeightUnitsEnum.$unknown:
      return r'$unknown';
  }
}

Enum$WeightUnitsEnum fromJson$Enum$WeightUnitsEnum(String value) {
  switch (value) {
    case r'G':
      return Enum$WeightUnitsEnum.G;
    case r'LB':
      return Enum$WeightUnitsEnum.LB;
    case r'OZ':
      return Enum$WeightUnitsEnum.OZ;
    case r'KG':
      return Enum$WeightUnitsEnum.KG;
    case r'TONNE':
      return Enum$WeightUnitsEnum.TONNE;
    default:
      return Enum$WeightUnitsEnum.$unknown;
  }
}

enum Enum$__TypeKind {
  SCALAR,
  OBJECT,
  INTERFACE,
  UNION,
  ENUM,
  INPUT_OBJECT,
  LIST,
  NON_NULL,
  $unknown;

  factory Enum$__TypeKind.fromJson(String value) =>
      fromJson$Enum$__TypeKind(value);

  String toJson() => toJson$Enum$__TypeKind(this);
}

String toJson$Enum$__TypeKind(Enum$__TypeKind e) {
  switch (e) {
    case Enum$__TypeKind.SCALAR:
      return r'SCALAR';
    case Enum$__TypeKind.OBJECT:
      return r'OBJECT';
    case Enum$__TypeKind.INTERFACE:
      return r'INTERFACE';
    case Enum$__TypeKind.UNION:
      return r'UNION';
    case Enum$__TypeKind.ENUM:
      return r'ENUM';
    case Enum$__TypeKind.INPUT_OBJECT:
      return r'INPUT_OBJECT';
    case Enum$__TypeKind.LIST:
      return r'LIST';
    case Enum$__TypeKind.NON_NULL:
      return r'NON_NULL';
    case Enum$__TypeKind.$unknown:
      return r'$unknown';
  }
}

Enum$__TypeKind fromJson$Enum$__TypeKind(String value) {
  switch (value) {
    case r'SCALAR':
      return Enum$__TypeKind.SCALAR;
    case r'OBJECT':
      return Enum$__TypeKind.OBJECT;
    case r'INTERFACE':
      return Enum$__TypeKind.INTERFACE;
    case r'UNION':
      return Enum$__TypeKind.UNION;
    case r'ENUM':
      return Enum$__TypeKind.ENUM;
    case r'INPUT_OBJECT':
      return Enum$__TypeKind.INPUT_OBJECT;
    case r'LIST':
      return Enum$__TypeKind.LIST;
    case r'NON_NULL':
      return Enum$__TypeKind.NON_NULL;
    default:
      return Enum$__TypeKind.$unknown;
  }
}

enum Enum$__DirectiveLocation {
  QUERY,
  MUTATION,
  SUBSCRIPTION,
  FIELD,
  FRAGMENT_DEFINITION,
  FRAGMENT_SPREAD,
  INLINE_FRAGMENT,
  VARIABLE_DEFINITION,
  SCHEMA,
  SCALAR,
  OBJECT,
  FIELD_DEFINITION,
  ARGUMENT_DEFINITION,
  INTERFACE,
  UNION,
  ENUM,
  ENUM_VALUE,
  INPUT_OBJECT,
  INPUT_FIELD_DEFINITION,
  $unknown;

  factory Enum$__DirectiveLocation.fromJson(String value) =>
      fromJson$Enum$__DirectiveLocation(value);

  String toJson() => toJson$Enum$__DirectiveLocation(this);
}

String toJson$Enum$__DirectiveLocation(Enum$__DirectiveLocation e) {
  switch (e) {
    case Enum$__DirectiveLocation.QUERY:
      return r'QUERY';
    case Enum$__DirectiveLocation.MUTATION:
      return r'MUTATION';
    case Enum$__DirectiveLocation.SUBSCRIPTION:
      return r'SUBSCRIPTION';
    case Enum$__DirectiveLocation.FIELD:
      return r'FIELD';
    case Enum$__DirectiveLocation.FRAGMENT_DEFINITION:
      return r'FRAGMENT_DEFINITION';
    case Enum$__DirectiveLocation.FRAGMENT_SPREAD:
      return r'FRAGMENT_SPREAD';
    case Enum$__DirectiveLocation.INLINE_FRAGMENT:
      return r'INLINE_FRAGMENT';
    case Enum$__DirectiveLocation.VARIABLE_DEFINITION:
      return r'VARIABLE_DEFINITION';
    case Enum$__DirectiveLocation.SCHEMA:
      return r'SCHEMA';
    case Enum$__DirectiveLocation.SCALAR:
      return r'SCALAR';
    case Enum$__DirectiveLocation.OBJECT:
      return r'OBJECT';
    case Enum$__DirectiveLocation.FIELD_DEFINITION:
      return r'FIELD_DEFINITION';
    case Enum$__DirectiveLocation.ARGUMENT_DEFINITION:
      return r'ARGUMENT_DEFINITION';
    case Enum$__DirectiveLocation.INTERFACE:
      return r'INTERFACE';
    case Enum$__DirectiveLocation.UNION:
      return r'UNION';
    case Enum$__DirectiveLocation.ENUM:
      return r'ENUM';
    case Enum$__DirectiveLocation.ENUM_VALUE:
      return r'ENUM_VALUE';
    case Enum$__DirectiveLocation.INPUT_OBJECT:
      return r'INPUT_OBJECT';
    case Enum$__DirectiveLocation.INPUT_FIELD_DEFINITION:
      return r'INPUT_FIELD_DEFINITION';
    case Enum$__DirectiveLocation.$unknown:
      return r'$unknown';
  }
}

Enum$__DirectiveLocation fromJson$Enum$__DirectiveLocation(String value) {
  switch (value) {
    case r'QUERY':
      return Enum$__DirectiveLocation.QUERY;
    case r'MUTATION':
      return Enum$__DirectiveLocation.MUTATION;
    case r'SUBSCRIPTION':
      return Enum$__DirectiveLocation.SUBSCRIPTION;
    case r'FIELD':
      return Enum$__DirectiveLocation.FIELD;
    case r'FRAGMENT_DEFINITION':
      return Enum$__DirectiveLocation.FRAGMENT_DEFINITION;
    case r'FRAGMENT_SPREAD':
      return Enum$__DirectiveLocation.FRAGMENT_SPREAD;
    case r'INLINE_FRAGMENT':
      return Enum$__DirectiveLocation.INLINE_FRAGMENT;
    case r'VARIABLE_DEFINITION':
      return Enum$__DirectiveLocation.VARIABLE_DEFINITION;
    case r'SCHEMA':
      return Enum$__DirectiveLocation.SCHEMA;
    case r'SCALAR':
      return Enum$__DirectiveLocation.SCALAR;
    case r'OBJECT':
      return Enum$__DirectiveLocation.OBJECT;
    case r'FIELD_DEFINITION':
      return Enum$__DirectiveLocation.FIELD_DEFINITION;
    case r'ARGUMENT_DEFINITION':
      return Enum$__DirectiveLocation.ARGUMENT_DEFINITION;
    case r'INTERFACE':
      return Enum$__DirectiveLocation.INTERFACE;
    case r'UNION':
      return Enum$__DirectiveLocation.UNION;
    case r'ENUM':
      return Enum$__DirectiveLocation.ENUM;
    case r'ENUM_VALUE':
      return Enum$__DirectiveLocation.ENUM_VALUE;
    case r'INPUT_OBJECT':
      return Enum$__DirectiveLocation.INPUT_OBJECT;
    case r'INPUT_FIELD_DEFINITION':
      return Enum$__DirectiveLocation.INPUT_FIELD_DEFINITION;
    default:
      return Enum$__DirectiveLocation.$unknown;
  }
}

const possibleTypesMap = <String, Set<String>>{
  '_Entity': {
    'App',
    'Address',
    'User',
    'Group',
    'ProductVariant',
    'Product',
    'ProductType',
    'ProductMedia',
    'Category',
    'Collection',
    'Order',
    'PageType',
  },
  'Event': {
    'AccountChangeEmailRequested',
    'AccountConfirmationRequested',
    'AccountConfirmed',
    'AccountDeleted',
    'AccountDeleteRequested',
    'AccountEmailChanged',
    'AccountSetPasswordRequested',
    'AddressCreated',
    'AddressDeleted',
    'AddressUpdated',
    'AppDeleted',
    'AppInstalled',
    'AppStatusChanged',
    'AppUpdated',
    'AttributeCreated',
    'AttributeDeleted',
    'AttributeUpdated',
    'AttributeValueCreated',
    'AttributeValueDeleted',
    'AttributeValueUpdated',
    'CalculateTaxes',
    'CategoryCreated',
    'CategoryDeleted',
    'CategoryUpdated',
    'ChannelCreated',
    'ChannelDeleted',
    'ChannelMetadataUpdated',
    'ChannelStatusChanged',
    'ChannelUpdated',
    'CheckoutCreated',
    'CheckoutFilterShippingMethods',
    'CheckoutFullyPaid',
    'CheckoutMetadataUpdated',
    'CheckoutUpdated',
    'CollectionCreated',
    'CollectionDeleted',
    'CollectionMetadataUpdated',
    'CollectionUpdated',
    'CustomerCreated',
    'CustomerMetadataUpdated',
    'CustomerUpdated',
    'DraftOrderCreated',
    'DraftOrderDeleted',
    'DraftOrderUpdated',
    'FulfillmentApproved',
    'FulfillmentCanceled',
    'FulfillmentCreated',
    'FulfillmentMetadataUpdated',
    'FulfillmentTrackingNumberUpdated',
    'GiftCardCreated',
    'GiftCardDeleted',
    'GiftCardExportCompleted',
    'GiftCardMetadataUpdated',
    'GiftCardSent',
    'GiftCardStatusChanged',
    'GiftCardUpdated',
    'InvoiceDeleted',
    'InvoiceRequested',
    'InvoiceSent',
    'ListStoredPaymentMethods',
    'MenuCreated',
    'MenuDeleted',
    'MenuItemCreated',
    'MenuItemDeleted',
    'MenuItemUpdated',
    'MenuUpdated',
    'OrderBulkCreated',
    'OrderCancelled',
    'OrderConfirmed',
    'OrderCreated',
    'OrderExpired',
    'OrderFilterShippingMethods',
    'OrderFulfilled',
    'OrderFullyPaid',
    'OrderFullyRefunded',
    'OrderMetadataUpdated',
    'OrderPaid',
    'OrderRefunded',
    'OrderUpdated',
    'PageCreated',
    'PageDeleted',
    'PageTypeCreated',
    'PageTypeDeleted',
    'PageTypeUpdated',
    'PageUpdated',
    'PaymentAuthorize',
    'PaymentCaptureEvent',
    'PaymentConfirmEvent',
    'PaymentGatewayInitializeSession',
    'PaymentGatewayInitializeTokenizationSession',
    'PaymentListGateways',
    'PaymentMethodInitializeTokenizationSession',
    'PaymentMethodProcessTokenizationSession',
    'PaymentProcessEvent',
    'PaymentRefundEvent',
    'PaymentVoidEvent',
    'PermissionGroupCreated',
    'PermissionGroupDeleted',
    'PermissionGroupUpdated',
    'ProductCreated',
    'ProductDeleted',
    'ProductExportCompleted',
    'ProductMediaCreated',
    'ProductMediaDeleted',
    'ProductMediaUpdated',
    'ProductMetadataUpdated',
    'ProductUpdated',
    'ProductVariantBackInStock',
    'ProductVariantCreated',
    'ProductVariantDeleted',
    'ProductVariantMetadataUpdated',
    'ProductVariantOutOfStock',
    'ProductVariantStockUpdated',
    'ProductVariantUpdated',
    'PromotionCreated',
    'PromotionDeleted',
    'PromotionEnded',
    'PromotionRuleCreated',
    'PromotionRuleDeleted',
    'PromotionRuleUpdated',
    'PromotionStarted',
    'PromotionUpdated',
    'SaleCreated',
    'SaleDeleted',
    'SaleToggle',
    'SaleUpdated',
    'ShippingListMethodsForCheckout',
    'ShippingPriceCreated',
    'ShippingPriceDeleted',
    'ShippingPriceUpdated',
    'ShippingZoneCreated',
    'ShippingZoneDeleted',
    'ShippingZoneMetadataUpdated',
    'ShippingZoneUpdated',
    'ShopMetadataUpdated',
    'StaffCreated',
    'StaffDeleted',
    'StaffSetPasswordRequested',
    'StaffUpdated',
    'StoredPaymentMethodDeleteRequested',
    'ThumbnailCreated',
    'TransactionCancelationRequested',
    'TransactionChargeRequested',
    'TransactionInitializeSession',
    'TransactionItemMetadataUpdated',
    'TransactionProcessSession',
    'TransactionRefundRequested',
    'TranslationCreated',
    'TranslationUpdated',
    'VoucherCodeExportCompleted',
    'VoucherCodesCreated',
    'VoucherCodesDeleted',
    'VoucherCreated',
    'VoucherDeleted',
    'VoucherMetadataUpdated',
    'VoucherUpdated',
    'WarehouseCreated',
    'WarehouseDeleted',
    'WarehouseMetadataUpdated',
    'WarehouseUpdated',
  },
  'Node': {
    'Address',
    'Allocation',
    'App',
    'AppExtension',
    'AppInstallation',
    'AppToken',
    'Attribute',
    'AttributeTranslatableContent',
    'AttributeTranslation',
    'AttributeValue',
    'AttributeValueTranslatableContent',
    'AttributeValueTranslation',
    'Category',
    'CategoryTranslatableContent',
    'CategoryTranslation',
    'Channel',
    'Checkout',
    'CheckoutLine',
    'Collection',
    'CollectionChannelListing',
    'CollectionTranslatableContent',
    'CollectionTranslation',
    'CustomerEvent',
    'DigitalContent',
    'DigitalContentUrl',
    'EventDelivery',
    'EventDeliveryAttempt',
    'ExportEvent',
    'ExportFile',
    'Fulfillment',
    'FulfillmentLine',
    'GiftCard',
    'GiftCardEvent',
    'GiftCardTag',
    'Group',
    'Invoice',
    'Menu',
    'MenuItem',
    'MenuItemTranslatableContent',
    'MenuItemTranslation',
    'Order',
    'OrderDiscount',
    'OrderEvent',
    'OrderLine',
    'Page',
    'PageTranslatableContent',
    'PageTranslation',
    'PageType',
    'Payment',
    'Product',
    'ProductChannelListing',
    'ProductMedia',
    'ProductTranslatableContent',
    'ProductTranslation',
    'ProductType',
    'ProductVariant',
    'ProductVariantChannelListing',
    'ProductVariantTranslatableContent',
    'ProductVariantTranslation',
    'Promotion',
    'PromotionCreatedEvent',
    'PromotionEndedEvent',
    'PromotionRule',
    'PromotionRuleCreatedEvent',
    'PromotionRuleDeletedEvent',
    'PromotionRuleTranslatableContent',
    'PromotionRuleTranslation',
    'PromotionRuleUpdatedEvent',
    'PromotionStartedEvent',
    'PromotionTranslatableContent',
    'PromotionTranslation',
    'PromotionUpdatedEvent',
    'Sale',
    'SaleChannelListing',
    'SaleTranslatableContent',
    'SaleTranslation',
    'ShippingMethod',
    'ShippingMethodChannelListing',
    'ShippingMethodPostalCodeRule',
    'ShippingMethodTranslatableContent',
    'ShippingMethodTranslation',
    'ShippingMethodType',
    'ShippingZone',
    'ShopTranslation',
    'StaffNotificationRecipient',
    'Stock',
    'TaxClass',
    'TaxConfiguration',
    'Transaction',
    'TransactionEvent',
    'TransactionItem',
    'User',
    'Voucher',
    'VoucherChannelListing',
    'VoucherTranslatableContent',
    'VoucherTranslation',
    'Warehouse',
    'Webhook',
  },
  'ObjectWithMetadata': {
    'Address',
    'App',
    'Attribute',
    'Category',
    'Channel',
    'Checkout',
    'CheckoutLine',
    'Collection',
    'DigitalContent',
    'Fulfillment',
    'GiftCard',
    'Invoice',
    'Menu',
    'MenuItem',
    'Order',
    'OrderLine',
    'Page',
    'PageType',
    'Payment',
    'Product',
    'ProductMedia',
    'ProductType',
    'ProductVariant',
    'Promotion',
    'Sale',
    'ShippingMethod',
    'ShippingMethodType',
    'ShippingZone',
    'Shop',
    'TaxClass',
    'TaxConfiguration',
    'TransactionItem',
    'User',
    'Voucher',
    'Warehouse',
  },
  'AppExtensionPossibleOptions': {
    'AppExtensionOptionsWidget',
    'AppExtensionOptionsNewTab',
  },
  'Job': {
    'AppInstallation',
    'ExportFile',
    'Invoice',
  },
  'CheckoutLineProblem': {
    'CheckoutLineProblemInsufficientStock',
    'CheckoutLineProblemVariantNotAvailable',
  },
  'CheckoutProblem': {
    'CheckoutLineProblemInsufficientStock',
    'CheckoutLineProblemVariantNotAvailable',
  },
  'DeliveryMethod': {
    'Warehouse',
    'ShippingMethod',
  },
  'IssuingPrincipal': {
    'App',
    'User',
  },
  'OrderOrCheckout': {
    'Checkout',
    'Order',
  },
  'PromotionEventInterface': {
    'PromotionCreatedEvent',
    'PromotionEndedEvent',
    'PromotionRuleCreatedEvent',
    'PromotionRuleDeletedEvent',
    'PromotionRuleUpdatedEvent',
    'PromotionStartedEvent',
    'PromotionUpdatedEvent',
  },
  'PromotionEvent': {
    'PromotionCreatedEvent',
    'PromotionUpdatedEvent',
    'PromotionStartedEvent',
    'PromotionEndedEvent',
    'PromotionRuleCreatedEvent',
    'PromotionRuleUpdatedEvent',
    'PromotionRuleDeletedEvent',
  },
  'PromotionRuleEventInterface': {
    'PromotionRuleCreatedEvent',
    'PromotionRuleDeletedEvent',
    'PromotionRuleUpdatedEvent',
  },
  'TaxSourceLine': {
    'CheckoutLine',
    'OrderLine',
  },
  'TaxSourceObject': {
    'Checkout',
    'Order',
  },
  'TranslatableItem': {
    'ProductTranslatableContent',
    'CollectionTranslatableContent',
    'CategoryTranslatableContent',
    'AttributeTranslatableContent',
    'AttributeValueTranslatableContent',
    'ProductVariantTranslatableContent',
    'PageTranslatableContent',
    'ShippingMethodTranslatableContent',
    'VoucherTranslatableContent',
    'MenuItemTranslatableContent',
    'PromotionTranslatableContent',
    'PromotionRuleTranslatableContent',
    'SaleTranslatableContent',
  },
  'TranslationTypes': {
    'ProductTranslation',
    'CollectionTranslation',
    'CategoryTranslation',
    'AttributeTranslation',
    'AttributeValueTranslation',
    'ProductVariantTranslation',
    'PageTranslation',
    'ShippingMethodTranslation',
    'VoucherTranslation',
    'MenuItemTranslation',
    'PromotionTranslation',
    'PromotionRuleTranslation',
    'SaleTranslation',
  },
  'UserOrApp': {
    'User',
    'App',
  },
};
